
6502/65C02 Turbo Assembler listing file of "sbc.asm"
done on Sat Jul 30 09:28:20 2011


>8002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>80f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>81f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>82f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>83f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>84f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>85f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>86f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>87f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>88f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>89f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8a92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8aa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8af2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8b92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8be2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8bf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8c92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8cf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8d92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8da2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8db2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8dc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8dd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8de2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8df2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8e92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8eb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8f92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8fe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>8ff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>90f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>91f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>92f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>93f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>94f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>95f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>96f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>97f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>98f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>99f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9a92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9aa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9af2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9b92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9be2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9bf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9c92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9cf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9d92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9da2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9db2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9dc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9dd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9de2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9df2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9e92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9eb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9f92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9fe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>9ff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>a9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aa92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aaa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aaf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ab92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>abf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ac92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ace2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>acf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ad92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ada2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>adb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>adc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>add2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ade2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>adf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ae92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aeb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>af92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>afe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>aff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>b9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ba92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>baa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>baf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bcf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bdf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>be92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>beb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bf92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bfe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>bff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>c9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ca92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>caa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>caf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ccf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cdf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ce92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ceb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ced2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cf92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cfe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>cff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>d9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>da92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>daa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>daf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>db92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dcf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ddf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>de92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>deb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ded2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>def2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>df92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dfe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>dff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>e9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ea92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eaa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ead2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eaf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ebf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ec92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ece2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ecf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ed92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ede2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>edf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ee92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eeb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ef92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>efe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>eff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f002  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f012  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f022  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f032  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f042  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f052  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f062  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f072  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f082  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f092  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f0f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f102  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f112  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f122  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f132  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f142  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f152  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f162  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f172  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f182  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f192  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f1f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f202  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f212  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f222  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f232  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f242  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f252  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f262  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f272  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f282  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f292  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f2f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f302  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f312  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f322  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f332  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f342  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f352  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f362  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f372  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f382  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f392  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f3f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f402  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f412  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f422  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f432  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f442  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f452  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f462  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f472  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f482  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f492  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f4f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f502  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f512  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f522  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f532  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f542  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f552  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f562  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f572  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f582  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f592  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f5f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f602  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f612  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f622  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f632  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f642  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f652  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f662  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f672  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f682  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f692  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f6f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f702  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f712  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f722  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f732  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f742  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f752  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f762  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f772  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f782  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f792  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f7f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f802  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f812  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f822  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f832  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f842  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f852  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f862  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f872  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f882  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f892  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f8f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f902  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f912  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f922  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f932  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f942  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f952  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f962  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f972  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f982  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f992  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9a2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9b2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9c2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9d2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9e2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>f9f2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fa92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>faa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fab2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fac2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fad2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fae2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>faf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fb92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fba2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fbf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fc92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fca2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fce2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fcf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fd92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fda2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fde2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fdf2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fe92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fea2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>feb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fec2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fed2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fee2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fef2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff02  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff12  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff22  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff32  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff42  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff52  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff62  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff72  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff82  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ff92  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffa2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffb2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffc2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffd2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>ffe2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff           .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff ;
>fff2  ff ff ff ff ff ff ff ff ff ff ff ff ff ff        .byte  $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff  ;
.bc00                              lab_cold

.bc00  a0 04      ldy #$04         	LDY	#PG2_TABE-PG2_TABS-1
.bc02                              lab_2d13
.bc02  b9 f6 dc   lda $dcf6,y      	LDA	PG2_TABS,Y		; get byte
.bc05  99 00 02   sta $0200,y      	STA	ccflag,Y		; store in page 2
.bc08  88         dey              	DEY				; decrement count
.bc09  10 f7      bpl $bc02        	BPL	LAB_2D13		; loop if not done
.bc0b  a2 ff      ldx #$ff         	LDX	#$FF			; set byte
.bc0d  86 88      stx $88          	STX	Clineh		; set current line high byte (set immediate mode)
.bc0f  9a         txs              	TXS				; reset stack pointer
.bc10  a9 4c      lda #$4c         	LDA	#$4C			; code for JMP
.bc12  85 a1      sta $a1          	STA	Fnxjmp		; save for jump vector for functions
.bc14  a2 1c      ldx #$1c         	LDX	#StrTab-LAB_2CEE	; set byte count
.bc16                              lab_2d4e
.bc16  bd fa dc   lda $dcfa,x      	LDA	LAB_2CEE-1,X	; get byte from table
.bc19  95 bb      sta $bb,x        	STA	LAB_IGBY-1,X	; save byte in page zero
.bc1b  ca         dex              	DEX				; decrement count
.bc1c  d0 f8      bne $bc16        	BNE	LAB_2D4E		; loop if not all done
.bc1e                              lab_gmem
.bc1e  a2 12      ldx #$12         	LDX	#EndTab-StrTab-1	; set byte count-1
.bc20                              tabloop
.bc20  bd 17 dd   lda $dd17,x      	LDA	StrTab,X		; get byte from table
.bc23  95 00      sta $00,x        	STA	PLUS_0,X		; save byte in page zero
.bc25  ca         dex              	DEX				; decrement count
.bc26  10 f8      bpl $bc20        	BPL	TabLoop		; loop if not all done
.bc28  a9 00      lda #$00         	LDA	#$00			; clear A
.bc2a  85 dc      sta $dc          	STA	NmiBase		; clear NMI handler enabled flag
.bc2c  85 df      sta $df          	STA	IrqBase		; clear IRQ handler enabled flag
.bc2e  85 b2      sta $b2          	STA	FAC1_o		; clear FAC1 overflow byte
.bc30  85 67      sta $67          	STA	last_sh		; clear descriptor stack top item pointer high byte
.bc32  a9 0e      lda #$0e         	LDA	#$0E			; set default tab size
.bc34  85 64      sta $64          	STA	TabSiz		; save it
.bc36  a9 03      lda #$03         	LDA	#$03			; set garbage collect step size for descriptor stack
.bc38  85 a0      sta $a0          	STA	g_step		; save it
.bc3a  a2 68      ldx #$68         	LDX	#des_sk		; descriptor stack start
.bc3c  86 65      stx $65          	STX	next_s		; set descriptor stack pointer
.bc3e  20 92 c4   jsr $c492        	JSR	LAB_CRLF		; print CR/LF
.bc41  a9 2a      lda #$2a         	LDA	#<LAB_MSZM		; point to memory size message (low addr)
.bc43  a0 dd      ldy #$dd         	LDY	#>LAB_MSZM		; point to memory size message (high addr)
.bc45  20 d3 c4   jsr $c4d3        	JSR	LAB_18C3		; print null terminated string from memory
.bc48  20 40 be   jsr $be40        	JSR	LAB_INLN		; print "? " and get BASIC input
.bc4b  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.bc4d  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.bc4f  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get last byte back
.bc52  d0 1f      bne $bc73        	BNE	LAB_2DAA		; branch if not null (user typed something)
.bc54  a0 00      ldy #$00         	LDY	#$00			; else clear Y
.bc56                              lab_2d93
.bc56  e6 11      inc $11          	INC	Itempl		; increment temporary integer low byte
.bc58  d0 08      bne $bc62        	BNE	LAB_2D99		; branch if no overflow
.bc5a  e6 12      inc $12          	INC	Itemph		; increment temporary integer high byte
.bc5c  a5 12      lda $12          	LDA	Itemph		; get high byte
.bc5e  c9 80      cmp #$80         	CMP	#>Ram_top		; compare with top of RAM+1
.bc60  f0 1d      beq $bc7f        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
.bc62                              lab_2d99
.bc62  a9 55      lda #$55         	LDA	#$55			; set test byte
.bc64  91 11      sta ($11),y      	STA	(Itempl),Y		; save via temporary integer
.bc66  d1 11      cmp ($11),y      	CMP	(Itempl),Y		; compare via temporary integer
.bc68  d0 15      bne $bc7f        	BNE	LAB_2DB6		; branch if fail
.bc6a  0a         asl              	ASL				; shift test byte left (now $AA)
.bc6b  91 11      sta ($11),y      	STA	(Itempl),Y		; save via temporary integer
.bc6d  d1 11      cmp ($11),y      	CMP	(Itempl),Y		; compare via temporary integer
.bc6f  f0 e5      beq $bc56        	BEQ	LAB_2D93		; if ok go do next byte
.bc71  d0 0c      bne $bc7f        	BNE	LAB_2DB6		; branch if fail
.bc73                              lab_2daa
.bc73  20 a6 d5   jsr $d5a6        	JSR	LAB_2887		; get FAC1 from string
.bc76  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.bc78  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.bc7a  b0 a2      bcs $bc1e        	BCS	LAB_GMEM		; if too large go try again
.bc7c  20 f7 d0   jsr $d0f7        	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
.bc7f                              lab_2db6
.bc7f  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.bc81  a4 12      ldy $12          	LDY	Itemph		; get temporary integer high byte
.bc83  c0 01      cpy #$01         	CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
.bc85  90 97      bcc $bc1e        	BCC	LAB_GMEM		; if too small go try again
.bc87  85 85      sta $85          	STA	Ememl			; set end of mem low byte
.bc89  84 86      sty $86          	STY	Ememh			; set end of mem high byte
.bc8b  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.bc8d  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.bc8f  a0 00      ldy #$00         	LDY	#<Ram_base		; set start addr low byte
.bc91  a2 04      ldx #$04         	LDX	#>Ram_base		; set start addr high byte
.bc93  84 79      sty $79          	STY	Smeml			; save start of mem low byte
.bc95  86 7a      stx $7a          	STX	Smemh			; save start of mem high byte
.bc97  98         tya              	TYA				; clear A
.bc98  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first byte
.bc9a  e6 79      inc $79          	INC	Smeml			; increment start of mem low byte
.bc9c                              lab_2e05
.bc9c  20 92 c4   jsr $c492        	JSR	LAB_CRLF		; print CR/LF
.bc9f  20 50 bf   jsr $bf50        	JSR	LAB_1463		; do "NEW" and "CLEAR"
.bca2  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.bca4  38         sec              	SEC				; set carry for subtract
.bca5  e5 79      sbc $79          	SBC	Smeml			; subtract start of mem low byte
.bca7  aa         tax              	TAX				; copy to X
.bca8  a5 86      lda $86          	LDA	Ememh			; get end of mem high byte
.bcaa  e5 7a      sbc $7a          	SBC	Smemh			; subtract start of mem high byte
.bcac  20 82 d6   jsr $d682        	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
.bcaf  a9 39      lda #$39         	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
.bcb1  a0 dd      ldy #$dd         	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
.bcb3  20 d3 c4   jsr $c4d3        	JSR	LAB_18C3		; print null terminated string from memory
.bcb6  a9 5a      lda #$5a         	LDA	#<LAB_1274		; warm start vector low byte
.bcb8  a0 bd      ldy #$bd         	LDY	#>LAB_1274		; warm start vector high byte
.bcba  85 01      sta $01          	STA	Wrmjpl		; save warm start vector low byte
.bcbc  84 02      sty $02          	STY	Wrmjph		; save warm start vector high byte
.bcbe  6c 01 00   jmp ($0001)      	JMP	(Wrmjpl)		; go do warm start
.bcc1                              lab_11cf
.bcc1  20 0b bd   jsr $bd0b        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.bcc4  85 7f      sta $7f          	STA	Earryl		; save new array mem end low byte
.bcc6  84 80      sty $80          	STY	Earryh		; save new array mem end high byte
.bcc8                              lab_11d6
.bcc8  38         sec              	SEC				; set carry for subtract
.bcc9  a5 a6      lda $a6          	LDA	Obendl		; get block end low byte
.bccb  e5 aa      sbc $aa          	SBC	Ostrtl		; subtract block start low byte
.bccd  a8         tay              	TAY				; copy MOD(block length/$100) byte to Y
.bcce  a5 a7      lda $a7          	LDA	Obendh		; get block end high byte
.bcd0  e5 ab      sbc $ab          	SBC	Ostrth		; subtract block start high byte
.bcd2  aa         tax              	TAX				; copy block length high byte to X
.bcd3  e8         inx              	INX				; +1 to allow for count=0 exit
.bcd4  98         tya              	TYA				; copy block length low byte to A
.bcd5  f0 24      beq $bcfb        	BEQ	LAB_120A		; branch if length low byte=0
.bcd7  38         sec              	SEC				; set carry for add + 1, two's complement
.bcd8  49 ff      eor #$ff         	EOR	#$FF			; invert low byte for subtract
.bcda  65 a6      adc $a6          	ADC	Obendl		; add block end low byte
.bcdc  85 a6      sta $a6          	STA	Obendl		; save corrected old block end low byte
.bcde  b0 03      bcs $bce3        	BCS	LAB_11F3		; branch if no underflow
.bce0  c6 a7      dec $a7          	DEC	Obendh		; else decrement block end high byte
.bce2  38         sec              	SEC				; set carry for add + 1, two's complement
.bce3                              lab_11f3
.bce3  98         tya              	TYA				; get MOD(block length/$100) byte
.bce4  49 ff      eor #$ff         	EOR	#$FF			; invert low byte for subtract
.bce6  65 a4      adc $a4          	ADC	Nbendl		; add destination end low byte
.bce8  85 a4      sta $a4          	STA	Nbendl		; save modified new block end low byte
.bcea  b0 08      bcs $bcf4        	BCS	LAB_1203		; branch if no underflow
.bcec  c6 a5      dec $a5          	DEC	Nbendh		; else decrement block end high byte
.bcee  90 04      bcc $bcf4        	BCC	LAB_1203		; branch always
.bcf0                              lab_11ff
.bcf0  b1 a6      lda ($a6),y      	LDA	(Obendl),Y		; get byte from source
.bcf2  91 a4      sta ($a4),y      	STA	(Nbendl),Y		; copy byte to destination
.bcf4                              lab_1203
.bcf4  88         dey              	DEY				; decrement index
.bcf5  d0 f9      bne $bcf0        	BNE	LAB_11FF		; loop until Y=0
.bcf7  b1 a6      lda ($a6),y      	LDA	(Obendl),Y		; get byte from source
.bcf9  91 a4      sta ($a4),y      	STA	(Nbendl),Y		; save byte to destination
.bcfb                              lab_120a
.bcfb  c6 a7      dec $a7          	DEC	Obendh		; decrement source pointer high byte
.bcfd  c6 a5      dec $a5          	DEC	Nbendh		; decrement destination pointer high byte
.bcff  ca         dex              	DEX				; decrement block count
.bd00  d0 f2      bne $bcf4        	BNE	LAB_1203		; loop until count = $0
.bd02  60         rts              	RTS
.bd03                              lab_1212
.bd03  85 78      sta $78          	STA	TempB			; save result in temp byte
.bd05  ba         tsx              	TSX				; copy stack
.bd06  e4 78      cpx $78          	CPX	TempB			; compare new "limit" with stack
.bd08  90 30      bcc $bd3a        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
.bd0a  60         rts              	RTS
.bd0b                              lab_121f
.bd0b  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string mem high byte
.bd0d  90 2a      bcc $bd39        	BCC	LAB_124B		; if less then exit (is ok)
.bd0f  d0 04      bne $bd15        	BNE	LAB_1229		; skip next test if greater (tested <)
.bd11  c5 81      cmp $81          	CMP	Sstorl		; compare with bottom of string mem low byte
.bd13  90 24      bcc $bd39        	BCC	LAB_124B		; if less then exit (is ok)
.bd15                              lab_1229
.bd15  48         pha              	PHA				; push addr low byte
.bd16  a2 08      ldx #$08         	LDX	#$08			; set index to save Adatal to expneg inclusive
.bd18  98         tya              	TYA				; copy addr high byte (to push on stack)
.bd19                              lab_122d
.bd19  48         pha              	PHA				; push byte
.bd1a  b5 a3      lda $a3,x        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
.bd1c  ca         dex              	DEX				; decrement index
.bd1d  10 fa      bpl $bd19        	BPL	LAB_122D		; loop until all done
.bd1f  20 df cd   jsr $cddf        	JSR	LAB_GARB		; garbage collection routine
.bd22  a2 00      ldx #$00         	LDX	#$00			; clear the index to restore bytes
.bd24                              lab_1238
.bd24  68         pla              	PLA				; pop byte
.bd25  95 a4      sta $a4,x        	STA	Adatal,X		; save byte to Adatal to expneg
.bd27  e8         inx              	INX				; increment index
.bd28  e0 08      cpx #$08         	CPX	#$08			; compare with end + 1
.bd2a  30 f8      bmi $bd24        	BMI	LAB_1238		; loop if more to do
.bd2c  68         pla              	PLA				; pop addr high byte
.bd2d  a8         tay              	TAY				; copy back to Y
.bd2e  68         pla              	PLA				; pop addr low byte
.bd2f  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string mem high byte
.bd31  90 06      bcc $bd39        	BCC	LAB_124B		; if less then exit (is ok)
.bd33  d0 05      bne $bd3a        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
.bd35  c5 81      cmp $81          	CMP	Sstorl		; compare with bottom of string mem low byte
.bd37  b0 01      bcs $bd3a        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
.bd39                              lab_124b
.bd39  60         rts              	RTS
.bd3a                              lab_omer
.bd3a  a2 0c      ldx #$0c         	LDX	#$0C			; error code $0C ("Out of memory" error)
.bd3c                              lab_xerr
.bd3c  20 92 c4   jsr $c492        	JSR	LAB_CRLF		; print CR/LF
.bd3f  bd b2 e2   lda $e2b2,x      	LDA	LAB_BAER,X		; get error message pointer low byte
.bd42  bc b3 e2   ldy $e2b3,x      	LDY	LAB_BAER+1,X	; get error message pointer high byte
.bd45  20 d3 c4   jsr $c4d3        	JSR	LAB_18C3		; print null terminated string from memory
.bd48  20 89 bf   jsr $bf89        	JSR	LAB_1491		; flush stack and clear continue flag
.bd4b  a9 ef      lda #$ef         	LDA	#<LAB_EMSG		; point to " Error" low addr
.bd4d  a0 e3      ldy #$e3         	LDY	#>LAB_EMSG		; point to " Error" high addr
.bd4f                              lab_1269
.bd4f  20 d3 c4   jsr $c4d3        	JSR	LAB_18C3		; print null terminated string from memory
.bd52  a4 88      ldy $88          	LDY	Clineh		; get current line high byte
.bd54  c8         iny              	INY				; increment it
.bd55  f0 03      beq $bd5a        	BEQ	LAB_1274		; go do warm start (was immediate mode)
.bd57  20 77 d6   jsr $d677        	JSR	LAB_2953		; print " in line [LINE #]"
.bd5a                              lab_1274
.bd5a  a9 00      lda #$00         	LDA	#$00			; clear A
.bd5c  85 df      sta $df          	STA	IrqBase		; clear enabled byte
.bd5e  85 dc      sta $dc          	STA	NmiBase		; clear enabled byte
.bd60  a9 00      lda #$00         	LDA	#<LAB_RMSG		; point to "Ready" message low byte
.bd62  a0 e4      ldy #$e4         	LDY	#>LAB_RMSG		; point to "Ready" message high byte
.bd64  20 d3 c4   jsr $c4d3        	JSR	LAB_18C3		; go do print string
.bd67                              lab_127d
.bd67  20 4d be   jsr $be4d        	JSR	LAB_1357		; call for BASIC input
.bd6a                              lab_1280
.bd6a  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.bd6c  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.bd6e  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.bd71  f0 f4      beq $bd67        	BEQ	LAB_127D		; loop while null
.bd73  a2 ff      ldx #$ff         	LDX	#$FF			; current line to null value
.bd75  86 88      stx $88          	STX	Clineh		; set current line high byte
.bd77  90 06      bcc $bd7f        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
.bd79  20 7e be   jsr $be7e        	JSR	LAB_13A6		; crunch keywords into Basic tokens
.bd7c  4c f3 c0   jmp $c0f3        	JMP	LAB_15F6		; go scan and interpret code
.bd7f                              lab_1295
.bd7f  20 55 c3   jsr $c355        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.bd82  20 7e be   jsr $be7e        	JSR	LAB_13A6		; crunch keywords into Basic tokens
.bd85  84 5d      sty $5d          	STY	Ibptr			; save index pointer to end of crunched line
.bd87  20 24 bf   jsr $bf24        	JSR	LAB_SSLN		; search BASIC for temp integer line number
.bd8a  90 44      bcc $bdd0        	BCC	LAB_12E6		; branch if not found
.bd8c  a0 01      ldy #$01         	LDY	#$01			; set index to next line pointer high byte
.bd8e  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.bd90  85 72      sta $72          	STA	ut1_ph		; save it
.bd92  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.bd94  85 71      sta $71          	STA	ut1_pl		; save it
.bd96  a5 ab      lda $ab          	LDA	Baslnh		; get found line pointer high byte
.bd98  85 74      sta $74          	STA	ut2_ph		; save it
.bd9a  a5 aa      lda $aa          	LDA	Baslnl		; get found line pointer low byte
.bd9c  88         dey              	DEY				; decrement index
.bd9d  f1 aa      sbc ($aa),y      	SBC	(Baslnl),Y		; subtract next line pointer low byte
.bd9f  18         clc              	CLC				; clear carry for add
.bda0  65 7b      adc $7b          	ADC	Svarl			; add start of vars low byte
.bda2  85 7b      sta $7b          	STA	Svarl			; save new start of vars low byte
.bda4  85 73      sta $73          	STA	ut2_pl		; save destination pointer low byte
.bda6  a5 7c      lda $7c          	LDA	Svarh			; get start of vars high byte
.bda8  69 ff      adc #$ff         	ADC	#$FF			; -1 + carry
.bdaa  85 7c      sta $7c          	STA	Svarh			; save start of vars high byte
.bdac  e5 ab      sbc $ab          	SBC	Baslnh		; subtract found line pointer high byte
.bdae  aa         tax              	TAX				; copy to block count
.bdaf  38         sec              	SEC				; set carry for subtract
.bdb0  a5 aa      lda $aa          	LDA	Baslnl		; get found line pointer low byte
.bdb2  e5 7b      sbc $7b          	SBC	Svarl			; subtract start of vars low byte
.bdb4  a8         tay              	TAY				; copy to bytes in first block count
.bdb5  b0 03      bcs $bdba        	BCS	LAB_12D0		; branch if overflow
.bdb7  e8         inx              	INX				; increment block count (correct for =0 loop exit)
.bdb8  c6 74      dec $74          	DEC	ut2_ph		; decrement destination high byte
.bdba                              lab_12d0
.bdba  18         clc              	CLC				; clear carry for add
.bdbb  65 71      adc $71          	ADC	ut1_pl		; add source pointer low byte
.bdbd  90 03      bcc $bdc2        	BCC	LAB_12D8		; branch if no overflow
.bdbf  c6 72      dec $72          	DEC	ut1_ph		; else decrement source pointer high byte
.bdc1  18         clc              	CLC				; clear carry
.bdc2                              lab_12d8
.bdc2  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from source
.bdc4  91 73      sta ($73),y      	STA	(ut2_pl),Y		; copy to destination
.bdc6  c8         iny              	INY				; increment index
.bdc7  d0 f9      bne $bdc2        	BNE	LAB_12D8		; while <> 0 do this block
.bdc9  e6 72      inc $72          	INC	ut1_ph		; increment source pointer high byte
.bdcb  e6 74      inc $74          	INC	ut2_ph		; increment destination pointer high byte
.bdcd  ca         dex              	DEX				; decrement block count
.bdce  d0 f2      bne $bdc2        	BNE	LAB_12D8		; loop until all done
.bdd0                              lab_12e6
.bdd0  ad 0d 02   lda $020d        	LDA	Ibuffs		; get byte from start of input buffer
.bdd3  f0 3f      beq $be14        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
.bdd5  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.bdd7  a4 86      ldy $86          	LDY	Ememh			; get end of mem high byte
.bdd9  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.bddb  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.bddd  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte	(end of BASIC)
.bddf  85 a6      sta $a6          	STA	Obendl		; save old block end low byte
.bde1  a4 7c      ldy $7c          	LDY	Svarh			; get start of vars high byte	(end of BASIC)
.bde3  84 a7      sty $a7          	STY	Obendh		; save old block end high byte
.bde5  65 5d      adc $5d          	ADC	Ibptr			; add input buffer pointer	(also buffer length)
.bde7  90 01      bcc $bdea        	BCC	LAB_1301		; branch if no overflow from add
.bde9  c8         iny              	INY				; else increment high byte
.bdea                              lab_1301
.bdea  85 a4      sta $a4          	STA	Nbendl		; save new block end low byte	(move to, low byte)
.bdec  84 a5      sty $a5          	STY	Nbendh		; save new block end high byte
.bdee  20 c1 bc   jsr $bcc1        	JSR	LAB_11CF		; open up space in memory
.bdf1  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.bdf3  a4 80      ldy $80          	LDY	Earryh		; get array mem end high byte
.bdf5  85 7b      sta $7b          	STA	Svarl			; save start of vars low byte
.bdf7  84 7c      sty $7c          	STY	Svarh			; save start of vars high byte
.bdf9  a4 5d      ldy $5d          	LDY	Ibptr			; get input buffer pointer	(also buffer length)
.bdfb  88         dey              	DEY				; adjust for loop type
.bdfc                              lab_1311
.bdfc  b9 09 02   lda $0209,y      	LDA	Ibuffs-4,Y		; get byte from crunched line
.bdff  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.be01  88         dey              	DEY				; decrement count
.be02  c0 03      cpy #$03         	CPY	#$03			; compare with first byte-1
.be04  d0 f6      bne $bdfc        	BNE	LAB_1311		; continue while count <> 3
.be06  a5 12      lda $12          	LDA	Itemph		; get line # high byte
.be08  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.be0a  88         dey              	DEY				; decrement count
.be0b  a5 11      lda $11          	LDA	Itempl		; get line # low byte
.be0d  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.be0f  88         dey              	DEY				; decrement count
.be10  a9 ff      lda #$ff         	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
.be12  91 aa      sta ($aa),y      	STA	(Baslnl),Y		; save it to program memory
.be14                              lab_1319
.be14  20 65 bf   jsr $bf65        	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
.be17  a6 79      ldx $79          	LDX	Smeml			; get start of mem low byte
.be19  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.be1b  a0 01      ldy #$01         	LDY	#$01			; index to high byte of next line pointer
.be1d                              lab_1325
.be1d  86 71      stx $71          	STX	ut1_pl		; set line start pointer low byte
.be1f  85 72      sta $72          	STA	ut1_ph		; set line start pointer high byte
.be21  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get it
.be23  f0 18      beq $be3d        	BEQ	LAB_133E		; exit if end of program
.be25  a0 04      ldy #$04         	LDY	#$04			; point to first code byte of line
.be27                              lab_1330
.be27  c8         iny              	INY				; next code byte
.be28  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte
.be2a  d0 fb      bne $be27        	BNE	LAB_1330		; loop if not [EOL]
.be2c  38         sec              	SEC				; set carry for add + 1
.be2d  98         tya              	TYA				; copy end index
.be2e  65 71      adc $71          	ADC	ut1_pl		; add to line start pointer low byte
.be30  aa         tax              	TAX				; copy to X
.be31  a0 00      ldy #$00         	LDY	#$00			; clear index, point to this line's next line pointer
.be33  91 71      sta ($71),y      	STA	(ut1_pl),Y		; set next line pointer low byte
.be35  98         tya              	TYA				; clear A
.be36  65 72      adc $72          	ADC	ut1_ph		; add line start pointer high byte + carry
.be38  c8         iny              	INY				; increment index to high byte
.be39  91 71      sta ($71),y      	STA	(ut1_pl),Y		; save next line pointer low byte
.be3b  90 e0      bcc $be1d        	BCC	LAB_1325		; go do next line, branch always, carry clear
.be3d                              lab_133e
.be3d  4c 67 bd   jmp $bd67        	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
.be40                              lab_inln
.be40  20 eb c4   jsr $c4eb        	JSR	LAB_18E3		; print "?" character
.be43  20 e8 c4   jsr $c4e8        	JSR	LAB_18E0		; print " "
.be46  d0 05      bne $be4d        	BNE	LAB_1357		; call for BASIC input and return
.be48                              lab_134b
.be48  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.be4b  ca         dex              	DEX				; decrement the buffer counter (delete)

>be4c  2c                          	.byte	$2C			; make LDX into BIT abs
.be4d                              lab_1357

.be4d  a2 00      ldx #$00         	LDX	#$00			; clear BASIC line buffer pointer
.be4f                              lab_1359
.be4f  20 ea dc   jsr $dcea        	JSR	V_INPT		; call scan input device
.be52  90 fb      bcc $be4f        	BCC	LAB_1359		; loop if no byte
.be54  f0 f9      beq $be4f        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
.be56  c9 07      cmp #$07         	CMP	#$07			; compare with [BELL]
.be58  f0 10      beq $be6a        	BEQ	LAB_1378		; branch if [BELL]
.be5a  c9 0d      cmp #$0d         	CMP	#$0D			; compare with [CR]
.be5c  f0 19      beq $be77        	BEQ	LAB_1384		; do CR/LF exit if [CR]
.be5e  e0 00      cpx #$00         	CPX	#$00			; compare pointer with $00
.be60  d0 04      bne $be66        	BNE	LAB_1374		; branch if not empty
.be62  c9 21      cmp #$21         	CMP	#$21			; compare with [SP]+1
.be64  90 e9      bcc $be4f        	BCC	LAB_1359		; if < ignore character
.be66                              lab_1374
.be66  c9 08      cmp #$08         	CMP	#$08			; compare with [BACKSPACE] (delete last character)
.be68  f0 de      beq $be48        	BEQ	LAB_134B		; go delete last character
.be6a                              lab_1378
.be6a  e0 47      cpx #$47         	CPX	#Ibuffe-Ibuffs	; compare character count with max
.be6c  b0 0c      bcs $be7a        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
.be6e  9d 0d 02   sta $020d,x      	STA	Ibuffs,X		; else store in buffer
.be71  e8         inx              	INX				; increment pointer
.be72                              lab_137f
.be72  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.be75  d0 d8      bne $be4f        	BNE	LAB_1359		; always loop for next character
.be77                              lab_1384
.be77  4c 89 c4   jmp $c489        	JMP	LAB_1866		; do CR/LF exit to BASIC
.be7a                              lab_138e
.be7a  a9 07      lda #$07         	LDA	#$07			; [BELL] character into A
.be7c  d0 f4      bne $be72        	BNE	LAB_137F		; go print the [BELL] but ignore input character
.be7e                              lab_13a6
.be7e  a0 ff      ldy #$ff         	LDY	#$FF			; set save index (makes for easy math later)
.be80  38         sec              	SEC				; set carry for subtract
.be81  a5 c3      lda $c3          	LDA	Bpntrl		; get basic execute pointer low byte
.be83  e9 0d      sbc #$0d         	SBC	#<Ibuffs		; subtract input buffer start pointer
.be85  aa         tax              	TAX				; copy result to X (index past line # if any)
.be86  86 60      stx $60          	STX	Oquote		; clear open quote/DATA flag
.be88                              lab_13ac
.be88  bd 0d 02   lda $020d,x      	LDA	Ibuffs,X		; get byte from input buffer
.be8b  f0 51      beq $bede        	BEQ	LAB_13EC		; if null save byte then exit
.be8d  c9 5f      cmp #$5f         	CMP	#"_"			; compare with "_"
.be8f  b0 4d      bcs $bede        	BCS	LAB_13EC		; if >= go save byte then continue crunching
.be91  c9 3c      cmp #$3c         	CMP	#"<"			; compare with "<"
.be93  b0 0e      bcs $bea3        	BCS	LAB_13CC		; if >= go crunch now
.be95  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.be97  b0 45      bcs $bede        	BCS	LAB_13EC		; if >= go save byte then continue crunching
.be99  85 5c      sta $5c          	STA	Scnquo		; save buffer byte as search character
.be9b  c9 22      cmp #$22         	CMP	#$22			; is it quote character?
.be9d  f0 61      beq $bf00        	BEQ	LAB_1410		; branch if so (copy quoted string)
.be9f  c9 2a      cmp #$2a         	CMP	#"*"			; compare with "*"
.bea1  90 3b      bcc $bede        	BCC	LAB_13EC		; if < go save byte then continue crunching
.bea3                              lab_13cc
.bea3  24 60      bit $60          	BIT	Oquote		; get open quote/DATA token flag
.bea5  70 37      bvs $bede        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
.bea7  86 78      stx $78          	STX	TempB			; save buffer read index
.bea9  84 ba      sty $ba          	STY	csidx			; copy buffer save index
.beab  a0 12      ldy #$12         	LDY	#<TAB_1STC		; get keyword first character table low address
.bead  84 73      sty $73          	STY	ut2_pl		; save pointer low byte
.beaf  a0 df      ldy #$df         	LDY	#>TAB_1STC		; get keyword first character table high address
.beb1  84 74      sty $74          	STY	ut2_ph		; save pointer high byte
.beb3  a0 00      ldy #$00         	LDY	#$00			; clear table pointer
.beb5                              lab_13d0
.beb5  d1 73      cmp ($73),y      	CMP	(ut2_pl),Y		; compare with keyword first character table byte
.beb7  f0 05      beq $bebe        	BEQ	LAB_13D1		; go do word_table_chr if match
.beb9  90 21      bcc $bedc        	BCC	LAB_13EA		; if < keyword first character table byte go restore
.bebb  c8         iny              	INY				; else increment pointer
.bebc  d0 f7      bne $beb5        	BNE	LAB_13D0		; and loop (branch always)
.bebe                              lab_13d1
.bebe  98         tya              	TYA				; copy matching index
.bebf  0a         asl              	ASL				; *2 (bytes per pointer)
.bec0  aa         tax              	TAX				; copy to new index
.bec1  bd 30 df   lda $df30,x      	LDA	TAB_CHRT,X		; get keyword table pointer low byte
.bec4  85 73      sta $73          	STA	ut2_pl		; save pointer low byte
.bec6  bd 31 df   lda $df31,x      	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
.bec9  85 74      sta $74          	STA	ut2_ph		; save pointer high byte
.becb  a0 ff      ldy #$ff         	LDY	#$FF			; clear table pointer (make -1 for start)
.becd  a6 78      ldx $78          	LDX	TempB			; restore buffer read index
.becf                              lab_13d6
.becf  c8         iny              	INY				; next table byte
.bed0  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get byte from table
.bed2                              lab_13d8
.bed2  30 08      bmi $bedc        	BMI	LAB_13EA		; all bytes matched so go save token
.bed4  e8         inx              	INX				; next buffer byte
.bed5  dd 0d 02   cmp $020d,x      	CMP	Ibuffs,X		; compare with byte from input buffer
.bed8  f0 f5      beq $becf        	BEQ	LAB_13D6		; go compare next if match
.beda  d0 2b      bne $bf07        	BNE	LAB_1417		; branch if >< (not found keyword)
.bedc                              lab_13ea
.bedc  a4 ba      ldy $ba          	LDY	csidx			; restore save index
.bede                              lab_13ec
.bede  e8         inx              	INX				; increment buffer index (to next input byte)
.bedf  c8         iny              	INY				; increment save index (to next output byte)
.bee0  99 0d 02   sta $020d,y      	STA	Ibuffs,Y		; save byte to output
.bee3  c9 00      cmp #$00         	CMP	#$00			; set the flags, set carry
.bee5  f0 32      beq $bf19        	BEQ	LAB_142A		; do exit if was null [EOL]
.bee7  e9 3a      sbc #$3a         	SBC	#":"			; subtract ":" (carry set by CMP #00)
.bee9  f0 04      beq $beef        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
.beeb  c9 49      cmp #$49         	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
.beed  d0 02      bne $bef1        	BNE	LAB_1401		; branch if not DATA
.beef                              lab_13ff
.beef  85 60      sta $60          	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
.bef1                              lab_1401
.bef1  49 57      eor #$57         	EOR	#TK_REM-$3A		; effectively subtract REM token offset
.bef3  d0 93      bne $be88        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
.bef5  85 5c      sta $5c          	STA	Asrch			; else was REM so set search for [EOL]
.bef7                              lab_1408
.bef7  bd 0d 02   lda $020d,x      	LDA	Ibuffs,X		; get byte from input buffer
.befa  f0 e2      beq $bede        	BEQ	LAB_13EC		; branch if null [EOL]
.befc  c5 5c      cmp $5c          	CMP	Asrch			; compare with stored character
.befe  f0 de      beq $bede        	BEQ	LAB_13EC		; branch if match (end quote)
.bf00                              lab_1410
.bf00  c8         iny              	INY				; increment buffer save index
.bf01  99 0d 02   sta $020d,y      	STA	Ibuffs,Y		; save byte to output
.bf04  e8         inx              	INX				; increment buffer read index
.bf05  d0 f0      bne $bef7        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
.bf07                              lab_1417
.bf07  a6 78      ldx $78          	LDX	TempB			; compare has failed, restore buffer index (start byte!)
.bf09                              lab_141b
.bf09  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get table byte
.bf0b  08         php              	PHP				; save status
.bf0c  c8         iny              	INY				; increment table index
.bf0d  28         plp              	PLP				; restore byte status
.bf0e  10 f9      bpl $bf09        	BPL	LAB_141B		; if not end of keyword go do next
.bf10  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get byte from keyword table
.bf12  d0 be      bne $bed2        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
.bf14  bd 0d 02   lda $020d,x      	LDA	Ibuffs,X		; restore byte from input buffer
.bf17  10 c3      bpl $bedc        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
.bf19                              lab_142a
.bf19  c8         iny              	INY				; increment pointer
.bf1a  c8         iny              	INY				; increment pointer (makes it next line pointer high byte)
.bf1b  99 0d 02   sta $020d,y      	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
.bf1e  c8         iny              	INY				; adjust for line copy
.bf1f  c8         iny              	INY				; adjust for line copy
.bf20  c8         iny              	INY				; adjust for line copy
.bf21  c6 c3      dec $c3          	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
.bf23  60         rts              	RTS
.bf24                              lab_ssln
.bf24  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.bf26  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.bf28                              lab_shln
.bf28  a0 01      ldy #$01         	LDY	#$01			; set index
.bf2a  85 aa      sta $aa          	STA	Baslnl		; save low byte as current
.bf2c  86 ab      stx $ab          	STX	Baslnh		; save high byte as current
.bf2e  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get pointer high byte from addr
.bf30  f0 1a      beq $bf4c        	BEQ	LAB_145F		; pointer was zero so we"re done, do "not found" exit
.bf32  a0 03      ldy #$03         	LDY	#$03			; set index to line # high byte
.bf34  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # high byte
.bf36  88         dey              	DEY				; decrement index (point to low byte)
.bf37  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.bf39  d0 04      bne $bf3f        	BNE	LAB_1455		; if <> skip low byte check
.bf3b  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # low byte
.bf3d  c5 11      cmp $11          	CMP	Itempl		; compare with temporary integer low byte
.bf3f                              lab_1455
.bf3f  b0 09      bcs $bf4a        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
.bf41                              lab_1456
.bf41  88         dey              	DEY				; decrement index to next line ptr high byte
.bf42  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.bf44  aa         tax              	TAX				; copy to X
.bf45  88         dey              	DEY				; decrement index to next line ptr low byte
.bf46  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer low byte
.bf48  90 de      bcc $bf28        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
.bf4a                              lab_145e
.bf4a  f0 01      beq $bf4d        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
.bf4c                              lab_145f
.bf4c  18         clc              	CLC				; clear found flag
.bf4d                              lab_1460
.bf4d  60         rts              	RTS
.bf4e                              lab_new
.bf4e  d0 fd      bne $bf4d        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
.bf50                              lab_1463
.bf50  a9 00      lda #$00         	LDA	#$00			; clear A
.bf52  a8         tay              	TAY				; clear Y
.bf53  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first line, next line pointer, low byte
.bf55  c8         iny              	INY				; increment index
.bf56  91 79      sta ($79),y      	STA	(Smeml),Y		; clear first line, next line pointer, high byte
.bf58  18         clc              	CLC				; clear carry
.bf59  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.bf5b  69 02      adc #$02         	ADC	#$02			; calculate end of BASIC low byte
.bf5d  85 7b      sta $7b          	STA	Svarl			; save start of vars low byte
.bf5f  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.bf61  69 00      adc #$00         	ADC	#$00			; add any carry
.bf63  85 7c      sta $7c          	STA	Svarh			; save start of vars high byte
.bf65                              lab_1477
.bf65  18         clc              	CLC				; clear carry
.bf66  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.bf68  69 ff      adc #$ff         	ADC	#$FF			; -1
.bf6a  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.bf6c  a5 7a      lda $7a          	LDA	Smemh			; get start of mem high byte
.bf6e  69 ff      adc #$ff         	ADC	#$FF			; -1+carry
.bf70  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.bf72                              lab_147a
.bf72  a5 85      lda $85          	LDA	Ememl			; get end of mem low byte
.bf74  a4 86      ldy $86          	LDY	Ememh			; get end of mem high byte
.bf76  85 81      sta $81          	STA	Sstorl		; set bottom of string space low byte
.bf78  84 82      sty $82          	STY	Sstorh		; set bottom of string space high byte
.bf7a  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.bf7c  a4 7c      ldy $7c          	LDY	Svarh			; get start of vars high byte
.bf7e  85 7d      sta $7d          	STA	Sarryl		; save var mem end low byte
.bf80  84 7e      sty $7e          	STY	Sarryh		; save var mem end high byte
.bf82  85 7f      sta $7f          	STA	Earryl		; save array mem end low byte
.bf84  84 80      sty $80          	STY	Earryh		; save array mem end high byte
.bf86  20 44 c1   jsr $c144        	JSR	LAB_161A		; perform RESTORE command
.bf89                              lab_1491
.bf89  a2 68      ldx #$68         	LDX	#des_sk		; set descriptor stack pointer
.bf8b  86 65      stx $65          	STX	next_s		; save descriptor stack pointer
.bf8d  68         pla              	PLA				; pull return address low byte
.bf8e  aa         tax              	TAX				; copy return address low byte
.bf8f  68         pla              	PLA				; pull return address high byte
.bf90  8e fe 01   stx $01fe        	STX	LAB_SKFE		; save to cleared stack
.bf93  8d ff 01   sta $01ff        	STA	LAB_SKFF		; save to cleared stack
.bf96  a2 fd      ldx #$fd         	LDX	#$FD			; new stack pointer
.bf98  9a         txs              	TXS				; reset stack
.bf99  a9 00      lda #$00         	LDA	#$00			; clear byte
.bf9b  85 8c      sta $8c          	STA	Cpntrh		; clear continue pointer high byte
.bf9d  85 61      sta $61          	STA	Sufnxf		; clear subscript/FNX flag
.bf9f                              lab_14a6
.bf9f  60         rts              	RTS
.bfa0                              lab_clear
.bfa0  f0 d0      beq $bf72        	BEQ	LAB_147A		; if no following token go do "CLEAR"
.bfa2  60         rts              	RTS
.bfa3                              lab_list
.bfa3  90 06      bcc $bfab        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
.bfa5  f0 04      beq $bfab        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
.bfa7  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; compare with token for -
.bfa9  d0 f4      bne $bf9f        	BNE	LAB_14A6		; exit if not - (LIST -m)
.bfab                              lab_14bd
.bfab  20 55 c3   jsr $c355        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.bfae  20 24 bf   jsr $bf24        	JSR	LAB_SSLN		; search BASIC for temp integer line number
.bfb1  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.bfb4  f0 0c      beq $bfc2        	BEQ	LAB_14D4		; branch if no more characters
.bfb6  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; compare with token for -
.bfb8  d0 93      bne $bf4d        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
.bfba  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.bfbd  20 55 c3   jsr $c355        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.bfc0  d0 8b      bne $bf4d        	BNE	LAB_1460		; exit if not ok
.bfc2                              lab_14d4
.bfc2  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.bfc4  05 12      ora $12          	ORA	Itemph		; OR temporary integer high byte
.bfc6  d0 06      bne $bfce        	BNE	LAB_14E2		; branch if start set
.bfc8  a9 ff      lda #$ff         	LDA	#$FF			; set for -1
.bfca  85 11      sta $11          	STA	Itempl		; set temporary integer low byte
.bfcc  85 12      sta $12          	STA	Itemph		; set temporary integer high byte
.bfce                              lab_14e2
.bfce  a0 01      ldy #$01         	LDY	#$01			; set index for line
.bfd0  84 60      sty $60          	STY	Oquote		; clear open quote flag
.bfd2  20 92 c4   jsr $c492        	JSR	LAB_CRLF		; print CR/LF
.bfd5  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.bfd7  f0 3e      beq $c017        	BEQ	LAB_152B		; if null all done so exit
.bfd9  20 14 c1   jsr $c114        	JSR	LAB_1629		; do CRTL-C check vector
.bfdc  c8         iny              	INY				; increment index for line
.bfdd  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # low byte
.bfdf  aa         tax              	TAX				; copy to X
.bfe0  c8         iny              	INY				; increment index
.bfe1  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get line # high byte
.bfe3  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.bfe5  d0 04      bne $bfeb        	BNE	LAB_14FF		; branch if no high byte match
.bfe7  e4 11      cpx $11          	CPX	Itempl		; compare with temporary integer low byte
.bfe9  f0 02      beq $bfed        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
.bfeb                              lab_14ff
.bfeb  b0 2a      bcs $c017        	BCS	LAB_152B		; if greater all done so exit
.bfed                              lab_1501
.bfed  84 97      sty $97          	STY	Tidx1			; save index for line
.bfef  20 82 d6   jsr $d682        	JSR	LAB_295E		; print XA as unsigned integer
.bff2  a9 20      lda #$20         	LDA	#$20			; space is the next character
.bff4                              lab_1508
.bff4  a4 97      ldy $97          	LDY	Tidx1			; get index for line
.bff6  29 7f      and #$7f         	AND	#$7F			; mask top out bit of character
.bff8                              lab_150c
.bff8  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.bffb  c9 22      cmp #$22         	CMP	#$22			; was it " character
.bffd  d0 06      bne $c005        	BNE	LAB_1519		; branch if not
.bfff  a5 60      lda $60          	LDA	Oquote		; get open quote flag
.c001  49 ff      eor #$ff         	EOR	#$FF			; toggle it
.c003  85 60      sta $60          	STA	Oquote		; save it back
.c005                              lab_1519
.c005  c8         iny              	INY				; increment index
.c006  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next byte
.c008  d0 0e      bne $c018        	BNE	LAB_152E		; branch if not [EOL] (go print character)
.c00a  a8         tay              	TAY				; else clear index
.c00b  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer low byte
.c00d  aa         tax              	TAX				; copy to X
.c00e  c8         iny              	INY				; increment index
.c00f  b1 aa      lda ($aa),y      	LDA	(Baslnl),Y		; get next line pointer high byte
.c011  86 aa      stx $aa          	STX	Baslnl		; set pointer to line low byte
.c013  85 ab      sta $ab          	STA	Baslnh		; set pointer to line high byte
.c015  d0 b7      bne $bfce        	BNE	LAB_14E2		; go do next line if not [EOT]
.c017                              lab_152b
.c017  60         rts              	RTS
.c018                              lab_152e
.c018  10 de      bpl $bff8        	BPL	LAB_150C		; just go print it if not token byte
.c01a  24 60      bit $60          	BIT	Oquote		; test the open quote flag
.c01c  30 da      bmi $bff8        	BMI	LAB_150C		; just go print character if open quote set
.c01e  a2 e1      ldx #$e1         	LDX	#>LAB_KEYT		; get table address high byte
.c020  0a         asl              	ASL				; *2
.c021  0a         asl              	ASL				; *4
.c022  90 02      bcc $c026        	BCC	LAB_152F		; branch if no carry
.c024  e8         inx              	INX				; else increment high byte
.c025  18         clc              	CLC				; clear carry for add
.c026                              lab_152f
.c026  69 16      adc #$16         	ADC	#<LAB_KEYT		; add low byte
.c028  90 01      bcc $c02b        	BCC	LAB_1530		; branch if no carry
.c02a  e8         inx              	INX				; else increment high byte
.c02b                              lab_1530
.c02b  85 73      sta $73          	STA	ut2_pl		; save table pointer low byte
.c02d  86 74      stx $74          	STX	ut2_ph		; save table pointer high byte
.c02f  84 97      sty $97          	STY	Tidx1			; save index for line
.c031  a0 00      ldy #$00         	LDY	#$00			; clear index
.c033  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get length
.c035  aa         tax              	TAX				; copy length
.c036  c8         iny              	INY				; increment index
.c037  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get 1st character
.c039  ca         dex              	DEX				; decrement length
.c03a  f0 b8      beq $bff4        	BEQ	LAB_1508		; if no more characters exit and print
.c03c  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.c03f  c8         iny              	INY				; increment index
.c040  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get keyword address low byte
.c042  48         pha              	PHA				; save it for now
.c043  c8         iny              	INY				; increment index
.c044  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get keyword address high byte
.c046  a0 00      ldy #$00         	LDY	#$00
.c048  85 74      sta $74          	STA	ut2_ph		; save keyword pointer high byte
.c04a  68         pla              	PLA				; pull low byte
.c04b  85 73      sta $73          	STA	ut2_pl		; save keyword pointer low byte
.c04d                              lab_1540
.c04d  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get character
.c04f  ca         dex              	DEX				; decrement character count
.c050  f0 a2      beq $bff4        	BEQ	LAB_1508		; if last character exit and print
.c052  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.c055  c8         iny              	INY				; increment index
.c056  d0 f5      bne $c04d        	BNE	LAB_1540		; loop for next character
.c058                              lab_for
.c058  a9 80      lda #$80         	LDA	#$80			; set FNX
.c05a  85 61      sta $61          	STA	Sufnxf		; set subscript/FNX flag
.c05c  20 b4 c3   jsr $c3b4        	JSR	LAB_LET		; go do LET
.c05f  68         pla              	PLA				; pull return address
.c060  68         pla              	PLA				; pull return address
.c061  a9 10      lda #$10         	LDA	#$10			; we need 16d bytes !
.c063  20 03 bd   jsr $bd03        	JSR	LAB_1212		; check room on stack for A bytes
.c066  20 9d c2   jsr $c29d        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.c069  18         clc              	CLC				; clear carry for add
.c06a  98         tya              	TYA				; copy index to A
.c06b  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.c06d  48         pha              	PHA				; push onto stack
.c06e  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.c070  69 00      adc #$00         	ADC	#$00			; add carry
.c072  48         pha              	PHA				; push onto stack
.c073  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.c075  48         pha              	PHA				; push onto stack
.c076  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.c078  48         pha              	PHA				; push onto stack
.c079  a9 ae      lda #$ae         	LDA	#TK_TO		; get "TO" token
.c07b  20 f1 c7   jsr $c7f1        	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
.c07e  20 d0 c6   jsr $c6d0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.c081  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c084  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.c086  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.c088  25 ad      and $ad          	AND	FAC1_1		; and FAC1 mantissa1
.c08a  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.c08c  a9 97      lda #$97         	LDA	#<LAB_159F		; set return address low byte
.c08e  a0 c0      ldy #$c0         	LDY	#>LAB_159F		; set return address high byte
.c090  85 71      sta $71          	STA	ut1_pl		; save return address low byte
.c092  84 72      sty $72          	STY	ut1_ph		; save return address high byte
.c094  4c 84 c7   jmp $c784        	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
.c097                              lab_159f
.c097  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
.c099  a0 dd      ldy #$dd         	LDY	#>LAB_259C		; set 1 pointer high addr
.c09b  20 7d d4   jsr $d47d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.c09e  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c0a1  c9 b3      cmp #$b3         	CMP	#TK_STEP		; compare with STEP token
.c0a3  d0 06      bne $c0ab        	BNE	LAB_15B3		; jump if not "STEP"
.c0a5  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c0a8  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.c0ab                              lab_15b3
.c0ab  20 e9 d4   jsr $d4e9        	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
.c0ae  85 b0      sta $b0          	STA	FAC1_s		; set FAC1 sign (b7)
.c0b0  20 79 c7   jsr $c779        	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
.c0b3  a5 98      lda $98          	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.c0b5  48         pha              	PHA				; push on stack
.c0b6  a5 97      lda $97          	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.c0b8  48         pha              	PHA				; push on stack
.c0b9  a9 81      lda #$81         	LDA	#TK_FOR		; get FOR token
.c0bb  48         pha              	PHA				; push on stack
.c0bc                              lab_15c2
.c0bc  20 14 c1   jsr $c114        	JSR	LAB_1629		; do CRTL-C check vector
.c0bf  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.c0c1  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.c0c3  a6 88      ldx $88          	LDX	Clineh		; continue line is $FFxx for immediate mode
.c0c5  e8         inx              	INX				; increment it (now $00 if immediate mode)
.c0c6  f0 04      beq $c0cc        	BEQ	LAB_15D1		; branch if null (immediate mode)
.c0c8  85 8b      sta $8b          	STA	Cpntrl		; save continue pointer low byte
.c0ca  84 8c      sty $8c          	STY	Cpntrh		; save continue pointer high byte
.c0cc                              lab_15d1
.c0cc  a0 00      ldy #$00         	LDY	#$00			; clear index
.c0ce  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next byte
.c0d0  f0 07      beq $c0d9        	BEQ	LAB_15DC		; branch if null [EOL]
.c0d2  c9 3a      cmp #$3a         	CMP	#":"			; compare with ":"
.c0d4  f0 1d      beq $c0f3        	BEQ	LAB_15F6		; branch if = (statement separator)
.c0d6                              lab_15d9
.c0d6  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; else syntax error then warm start
.c0d9                              lab_15dc
.c0d9  a0 02      ldy #$02         	LDY	#$02			; set index
.c0db  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line pointer high byte
.c0dd  18         clc              	CLC				; clear carry for no "BREAK" message
.c0de  f0 56      beq $c136        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
.c0e0  c8         iny              	INY				; increment index
.c0e1  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get line # low byte
.c0e3  85 87      sta $87          	STA	Clinel		; save current line low byte
.c0e5  c8         iny              	INY				; increment index
.c0e6  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get line # high byte
.c0e8  85 88      sta $88          	STA	Clineh		; save current line high byte
.c0ea  98         tya              	TYA				; A now = 4
.c0eb  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.c0ed  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c0ef  90 02      bcc $c0f3        	BCC	LAB_15F6		; branch if no overflow
.c0f1  e6 c4      inc $c4          	INC	Bpntrh		; else increment BASIC execute pointer high byte
.c0f3                              lab_15f6
.c0f3  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c0f6                              lab_15f9
.c0f6  20 fc c0   jsr $c0fc        	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
.c0f9                              lab_15fc
.c0f9  4c bc c0   jmp $c0bc        	JMP	LAB_15C2		; loop
.c0fc                              lab_15ff
.c0fc  f0 54      beq $c152        	BEQ	LAB_1628		; exit if zero [EOL]
.c0fe                              lab_1602
.c0fe  0a         asl              	ASL				; *2 bytes per vector and normalise token
.c0ff  b0 03      bcs $c104        	BCS	LAB_1609		; branch if was token
.c101  4c b4 c3   jmp $c3b4        	JMP	LAB_LET		; else go do implied LET
.c104                              lab_1609
.c104  c9 58      cmp #$58         	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
.c106  b0 ce      bcs $c0d6        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
.c108  a8         tay              	TAY				; copy to index
.c109  b9 08 de   lda $de08,y      	LDA	LAB_CTBL+1,Y	; get vector high byte
.c10c  48         pha              	PHA				; onto stack
.c10d  b9 07 de   lda $de07,y      	LDA	LAB_CTBL,Y		; get vector low byte
.c110  48         pha              	PHA				; onto stack
.c111  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; jump to increment and scan memory
.c114                              lab_1629
.c114  6c 03 02   jmp ($0203)      	JMP	(VEC_CC)		; ctrl c check vector
.c117                              lab_1636
.c117  c9 03      cmp #$03         	CMP	#$03			; compare with CTRL-C
.c119                              lab_stop
.c119  b0 01      bcs $c11c        	BCS	LAB_163B		; branch if token follows STOP
.c11b                              lab_end
.c11b  18         clc              	CLC				; clear the carry, indicate a normal program end
.c11c                              lab_163b
.c11c  d0 67      bne $c185        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
.c11e  a5 c4      lda $c4          	LDA	Bpntrh		; get the BASIC execute pointer high byte
.c120  49 02      eor #$02         	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
.c122  f0 10      beq $c134        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
.c124  49 02      eor #$02         	EOR	#>Ibuffs		; correct the bits
.c126  a4 c3      ldy $c3          	LDY	Bpntrl		; get BASIC execute pointer low byte
.c128  84 8b      sty $8b          	STY	Cpntrl		; save continue pointer low byte
.c12a  85 8c      sta $8c          	STA	Cpntrh		; save continue pointer high byte
.c12c                              lab_1647
.c12c  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.c12e  a4 88      ldy $88          	LDY	Clineh		; get current line high byte
.c130  85 89      sta $89          	STA	Blinel		; save break line low byte
.c132  84 8a      sty $8a          	STY	Blineh		; save break line high byte
.c134                              lab_164f
.c134  68         pla              	PLA				; pull return address low
.c135  68         pla              	PLA				; pull return address high
.c136                              lab_1651
.c136  90 07      bcc $c13f        	BCC	LAB_165E		; if was program end just do warm start
.c138  a9 e7      lda #$e7         	LDA	#<LAB_BMSG		; point to "Break" low byte
.c13a  a0 e3      ldy #$e3         	LDY	#>LAB_BMSG		; point to "Break" high byte
.c13c  4c 4f bd   jmp $bd4f        	JMP	LAB_1269		; print "Break" and do warm start
.c13f                              lab_165e
.c13f  4c 5a bd   jmp $bd5a        	JMP	LAB_1274		; go do warm start
.c142                              lab_restore
.c142  d0 0f      bne $c153        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
.c144                              lab_161a
.c144  38         sec              	SEC				; set carry for subtract
.c145  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.c147  e9 01      sbc #$01         	SBC	#$01			; -1
.c149  a4 7a      ldy $7a          	LDY	Smemh			; get start of mem high byte
.c14b  b0 01      bcs $c14e        	BCS	LAB_1624		; branch if no underflow
.c14d                              lab_uflow
.c14d  88         dey              	DEY				; else decrement high byte
.c14e                              lab_1624
.c14e  85 8f      sta $8f          	STA	Dptrl			; save DATA pointer low byte
.c150  84 90      sty $90          	STY	Dptrh			; save DATA pointer high byte
.c152                              lab_1628
.c152  60         rts              	RTS
.c153                              lab_restoren
.c153  20 55 c3   jsr $c355        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.c156  20 a0 c2   jsr $c2a0        	JSR	LAB_SNBL		; scan for next BASIC line
.c159  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.c15b  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.c15d  b0 0b      bcs $c16a        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
.c15f  98         tya              	TYA				; else copy line index to A
.c160  38         sec              	SEC				; set carry (+1)
.c161  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.c163  a6 c4      ldx $c4          	LDX	Bpntrh		; get BASIC execute pointer high byte
.c165  90 07      bcc $c16e        	BCC	LAB_go_search	; branch if no overflow to high byte
.c167  e8         inx              	INX				; increment high byte
.c168  b0 04      bcs $c16e        	BCS	LAB_go_search	; branch always (can never be carry clear)
.c16a                              lab_reset_search
.c16a  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.c16c  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.c16e                              lab_go_search
.c16e  20 28 bf   jsr $bf28        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.c171  b0 03      bcs $c176        	BCS	LAB_line_found	; if carry set go set pointer
.c173  4c 72 c2   jmp $c272        	JMP	LAB_16F7		; else go do "Undefined statement" error
.c176                              lab_line_found
.c176  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.c178  e9 01      sbc #$01         	SBC	#$01			; -1
.c17a  a4 ab      ldy $ab          	LDY	Baslnh		; get pointer high byte
.c17c  b0 d0      bcs $c14e        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
.c17e  90 cd      bcc $c14d        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
.c180                              lab_null
.c180  20 8c d0   jsr $d08c        	JSR	LAB_GTBY		; get byte parameter
.c183  86 0d      stx $0d          	STX	Nullct		; save new NULL count
.c185                              lab_167a
.c185  60         rts              	RTS
.c186                              lab_cont
.c186  d0 fd      bne $c185        	BNE	LAB_167A		; if following byte exit to do syntax error
.c188  a4 8c      ldy $8c          	LDY	Cpntrh		; get continue pointer high byte
.c18a  d0 05      bne $c191        	BNE	LAB_166C		; go do continue if we can
.c18c  a2 1e      ldx #$1e         	LDX	#$1E			; error code $1E ("Can't continue" error)
.c18e  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.c191                              lab_166c
.c191  a9 93      lda #$93         	LDA	#TK_ON		; set token for ON
.c193  20 14 db   jsr $db14        	JSR	LAB_IRQ		; set IRQ flags
.c196  a9 93      lda #$93         	LDA	#TK_ON		; set token for ON
.c198  20 17 db   jsr $db17        	JSR	LAB_NMI		; set NMI flags
.c19b  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.c19d  a5 8b      lda $8b          	LDA	Cpntrl		; get continue pointer low byte
.c19f  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c1a1  a5 89      lda $89          	LDA	Blinel		; get break line low byte
.c1a3  a4 8a      ldy $8a          	LDY	Blineh		; get break line high byte
.c1a5  85 87      sta $87          	STA	Clinel		; set current line low byte
.c1a7  84 88      sty $88          	STY	Clineh		; set current line high byte
.c1a9  60         rts              	RTS
.c1aa                              lab_run
.c1aa  d0 03      bne $c1af        	BNE	LAB_1696		; branch if RUN n
.c1ac  4c 65 bf   jmp $bf65        	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
.c1af                              lab_1696
.c1af  20 72 bf   jsr $bf72        	JSR	LAB_147A		; go do "CLEAR"
.c1b2  f0 2e      beq $c1e2        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
.c1b4                              lab_do
.c1b4  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for DO
.c1b6  20 03 bd   jsr $bd03        	JSR	LAB_1212		; check room on stack for A bytes
.c1b9  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.c1bb  48         pha              	PHA				; push on stack
.c1bc  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.c1be  48         pha              	PHA				; push on stack
.c1bf  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.c1c1  48         pha              	PHA				; push on stack
.c1c2  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.c1c4  48         pha              	PHA				; push on stack
.c1c5  a9 9d      lda #$9d         	LDA	#TK_DO		; token for DO
.c1c7  48         pha              	PHA				; push on stack
.c1c8  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c1cb  4c bc c0   jmp $c0bc        	JMP	LAB_15C2		; go do interpreter inner loop
.c1ce                              lab_gosub
.c1ce  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for GOSUB
.c1d0  20 03 bd   jsr $bd03        	JSR	LAB_1212		; check room on stack for A bytes
.c1d3  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.c1d5  48         pha              	PHA				; push on stack
.c1d6  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.c1d8  48         pha              	PHA				; push on stack
.c1d9  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.c1db  48         pha              	PHA				; push on stack
.c1dc  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.c1de  48         pha              	PHA				; push on stack
.c1df  a9 8d      lda #$8d         	LDA	#TK_GOSUB		; token for GOSUB
.c1e1  48         pha              	PHA				; push on stack
.c1e2                              lab_16b0
.c1e2  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c1e5  20 eb c1   jsr $c1eb        	JSR	LAB_GOTO		; perform GOTO n
.c1e8  4c bc c0   jmp $c0bc        	JMP	LAB_15C2		; go do interpreter inner loop
.c1eb                              lab_goto
.c1eb  20 55 c3   jsr $c355        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.c1ee  20 a0 c2   jsr $c2a0        	JSR	LAB_SNBL		; scan for next BASIC line
.c1f1  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.c1f3  c5 12      cmp $12          	CMP	Itemph		; compare with temporary integer high byte
.c1f5  b0 0b      bcs $c202        	BCS	LAB_16D0		; branch if >= (start search from beginning)
.c1f7  98         tya              	TYA				; else copy line index to A
.c1f8  38         sec              	SEC				; set carry (+1)
.c1f9  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.c1fb  a6 c4      ldx $c4          	LDX	Bpntrh		; get BASIC execute pointer high byte
.c1fd  90 07      bcc $c206        	BCC	LAB_16D4		; branch if no overflow to high byte
.c1ff  e8         inx              	INX				; increment high byte
.c200  b0 04      bcs $c206        	BCS	LAB_16D4		; branch always (can never be carry)
.c202                              lab_16d0
.c202  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.c204  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.c206                              lab_16d4
.c206  20 28 bf   jsr $bf28        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.c209  90 67      bcc $c272        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
.c20b  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.c20d  e9 01      sbc #$01         	SBC	#$01			; -1
.c20f  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c211  a5 ab      lda $ab          	LDA	Baslnh		; get pointer high byte
.c213  e9 00      sbc #$00         	SBC	#$00			; subtract carry
.c215  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.c217                              lab_16e5
.c217  60         rts              	RTS
.c218                              lab_donok
.c218  a2 22      ldx #$22         	LDX	#$22			; error code $22 ("LOOP without DO" error)
.c21a  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.c21d                              lab_loop
.c21d  a8         tay              	TAY				; save following token
.c21e  ba         tsx              	TSX				; copy stack pointer
.c21f  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get token byte from stack
.c222  c9 9d      cmp #$9d         	CMP	#TK_DO		; compare with DO token
.c224  d0 f2      bne $c218        	BNE	LAB_DONOK		; branch if no matching DO
.c226  e8         inx              	INX				; dump calling routine return address
.c227  e8         inx              	INX				; dump calling routine return address
.c228  9a         txs              	TXS				; correct stack
.c229  98         tya              	TYA				; get saved following token back
.c22a  f0 20      beq $c24c        	BEQ	LoopAlways		; if no following token loop forever
.c22c  c9 3a      cmp #$3a         	CMP	#":"			; could be ":"
.c22e  f0 1c      beq $c24c        	BEQ	LoopAlways		; if :... loop forever
.c230  e9 b4      sbc #$b4         	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
.c232  aa         tax              	TAX				; copy to X (if it was UNTIL then Y will be correct)
.c233  f0 04      beq $c239        	BEQ	DoRest		; branch if was UNTIL
.c235  ca         dex              	DEX				; decrement result
.c236  d0 62      bne $c29a        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
.c238  ca         dex              	DEX				; set invert result byte
.c239                              dorest
.c239  86 98      stx $98          	STX	Frnxth		; save invert result byte
.c23b  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c23e  20 e1 c6   jsr $c6e1        	JSR	LAB_EVEX		; evaluate expression
.c241  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c243  f0 02      beq $c247        	BEQ	DoCmp			; if =0 go do straight compare
.c245  a9 ff      lda #$ff         	LDA	#$FF			; else set all bits
.c247                              docmp
.c247  ba         tsx              	TSX				; copy stack pointer
.c248  45 98      eor $98          	EOR	Frnxth		; EOR with invert byte
.c24a  d0 1a      bne $c266        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
.c24c                              loopalways
.c24c  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get current line low byte
.c24f  85 87      sta $87          	STA	Clinel		; save current line low byte
.c251  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get current line high byte
.c254  85 88      sta $88          	STA	Clineh		; save current line high byte
.c256  bd 04 01   lda $0104,x      	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
.c259  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c25b  bd 05 01   lda $0105,x      	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
.c25e  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.c260  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c263  4c bc c0   jmp $c0bc        	JMP	LAB_15C2		; go do interpreter inner loop
.c266                              loopdone
.c266  e8         inx              	INX				; dump DO token
.c267  e8         inx              	INX				; dump current line low byte
.c268  e8         inx              	INX				; dump current line high byte
.c269  e8         inx              	INX				; dump BASIC execute pointer low byte
.c26a  e8         inx              	INX				; dump BASIC execute pointer high byte
.c26b  9a         txs              	TXS				; correct stack
.c26c  4c 8c c2   jmp $c28c        	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
.c26f                              lab_16f4
.c26f  a2 04      ldx #$04         	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)

>c271  2c                          	.byte	$2C			; makes next line BIT LAB_0EA2
.c272                              lab_16f7

.c272  a2 0e      ldx #$0e         	LDX	#$0E			; error code $0E ("Undefined statement" error)
.c274  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.c277                              lab_return
.c277  d0 9e      bne $c217        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
.c279                              lab_16e8
.c279  68         pla              	PLA				; dump calling routine return address
.c27a  68         pla              	PLA				; dump calling routine return address
.c27b  68         pla              	PLA				; pull token
.c27c  c9 8d      cmp #$8d         	CMP	#TK_GOSUB		; compare with GOSUB token
.c27e  d0 ef      bne $c26f        	BNE	LAB_16F4		; branch if no matching GOSUB
.c280                              lab_16ff
.c280  68         pla              	PLA				; pull current line low byte
.c281  85 87      sta $87          	STA	Clinel		; save current line low byte
.c283  68         pla              	PLA				; pull current line high byte
.c284  85 88      sta $88          	STA	Clineh		; save current line high byte
.c286  68         pla              	PLA				; pull BASIC execute pointer low byte
.c287  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c289  68         pla              	PLA				; pull BASIC execute pointer high byte
.c28a  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.c28c                              lab_data
.c28c  20 9d c2   jsr $c29d        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.c28f                              lab_170f
.c28f  98         tya              	TYA				; copy index to A
.c290  18         clc              	CLC				; clear carry for add
.c291  65 c3      adc $c3          	ADC	Bpntrl		; add BASIC execute pointer low byte
.c293  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c295  90 02      bcc $c299        	BCC	LAB_1719		; skip next if no carry
.c297  e6 c4      inc $c4          	INC	Bpntrh		; else increment BASIC execute pointer high byte
.c299                              lab_1719
.c299  60         rts              	RTS
.c29a                              lab_16fc
.c29a  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; do syntax error then warm start
.c29d                              lab_snbs
.c29d  a2 3a      ldx #$3a         	LDX	#":"			; set look for character = ":"

>c29f  2c                          	.byte	$2C			; makes next line BIT $00A2
.c2a0                              lab_snbl

.c2a0  a2 00      ldx #$00         	LDX	#$00			; set alt search character = [EOL]
.c2a2  a0 00      ldy #$00         	LDY	#$00			; set search character = [EOL]
.c2a4  84 5c      sty $5c          	STY	Asrch			; store search character
.c2a6                              lab_1725
.c2a6  8a         txa              	TXA				; get alt search character
.c2a7  45 5c      eor $5c          	EOR	Asrch			; toggle search character, effectively swap with $00
.c2a9  85 5c      sta $5c          	STA	Asrch			; save swapped search character
.c2ab                              lab_172d
.c2ab  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next byte
.c2ad  f0 ea      beq $c299        	BEQ	LAB_1719		; exit if null [EOL]
.c2af  c5 5c      cmp $5c          	CMP	Asrch			; compare with search character
.c2b1  f0 e6      beq $c299        	BEQ	LAB_1719		; exit if found
.c2b3  c8         iny              	INY				; increment index
.c2b4  c9 22      cmp #$22         	CMP	#$22			; compare current character with open quote
.c2b6  d0 f3      bne $c2ab        	BNE	LAB_172D		; if not open quote go get next character
.c2b8  f0 ec      beq $c2a6        	BEQ	LAB_1725		; if found go swap search character for alt search character
.c2ba                              lab_if
.c2ba  20 e1 c6   jsr $c6e1        	JSR	LAB_EVEX		; evaluate the expression
.c2bd  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c2c0  c9 b1      cmp #$b1         	CMP	#TK_THEN		; compare with THEN token
.c2c2  f0 11      beq $c2d5        	BEQ	LAB_174B		; if it was THEN go do IF
.c2c4  c9 89      cmp #$89         	CMP	#TK_GOTO		; compare with GOTO token
.c2c6  d0 d2      bne $c29a        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
.c2c8  a6 c3      ldx $c3          	LDX	Bpntrl		; save the basic pointer low byte
.c2ca  a4 c4      ldy $c4          	LDY	Bpntrh		; save the basic pointer high byte
.c2cc  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c2cf  b0 c9      bcs $c29a        	BCS	LAB_16FC		; if not numeric go do syntax error
.c2d1  86 c3      stx $c3          	STX	Bpntrl		; restore the basic pointer low byte
.c2d3  84 c4      sty $c4          	STY	Bpntrh		; restore the basic pointer high byte
.c2d5                              lab_174b
.c2d5  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c2d7  f0 1b      beq $c2f4        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
.c2d9  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; else increment and scan memory
.c2dc  b0 03      bcs $c2e1        	BCS	LAB_174D		; if not numeric go do var or keyword
.c2de                              lab_174c
.c2de  4c eb c1   jmp $c1eb        	JMP	LAB_GOTO		; else was numeric so do GOTO n
.c2e1                              lab_174d
.c2e1  c9 90      cmp #$90         	CMP	#TK_RETURN		; compare the byte with the token for RETURN
.c2e3  d0 03      bne $c2e8        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
.c2e5  4c fe c0   jmp $c0fe        	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
.c2e8                              lab_174g
.c2e8  20 fc c0   jsr $c0fc        	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
.c2eb  a0 00      ldy #$00         	LDY	#$00			; clear the index
.c2ed  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get the next BASIC byte
.c2ef  c9 ad      cmp #$ad         	CMP	#TK_ELSE		; compare it with the token for ELSE
.c2f1  f0 99      beq $c28c        	BEQ	LAB_DATA		; if ELSE ignore the following statement
.c2f3  60         rts              	RTS				; else return to the interpreter inner loop
.c2f4                              lab_174e
.c2f4  a0 00      ldy #$00         	LDY	#$00			; clear the BASIC byte index
.c2f6  a2 01      ldx #$01         	LDX	#$01			; clear the nesting depth
.c2f8                              lab_1750
.c2f8  c8         iny              	INY				; increment the BASIC byte index
.c2f9  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get the next BASIC byte
.c2fb  f0 0f      beq $c30c        	BEQ	LAB_1753		; if EOL go add the pointer and return
.c2fd  c9 8b      cmp #$8b         	CMP	#TK_IF		; compare the byte with the token for IF
.c2ff  d0 03      bne $c304        	BNE	LAB_1752		; if not IF token skip the depth increment
.c301  e8         inx              	INX				; else increment the nesting depth ..
.c302  d0 f4      bne $c2f8        	BNE	LAB_1750		; .. and continue looking
.c304                              lab_1752
.c304  c9 ad      cmp #$ad         	CMP	#TK_ELSE		; compare the byte with the token for ELSE
.c306  d0 f0      bne $c2f8        	BNE	LAB_1750		; if not ELSE token continue looking
.c308  ca         dex              	DEX				; was ELSE so decrement the nesting depth
.c309  d0 ed      bne $c2f8        	BNE	LAB_1750		; loop if still nested
.c30b  c8         iny              	INY				; increment the BASIC byte index past the ELSE
.c30c                              lab_1753
.c30c  98         tya              	TYA				; else copy line index to A
.c30d  18         clc              	CLC				; clear carry for add
.c30e  65 c3      adc $c3          	ADC	Bpntrl		; add the BASIC execute pointer low byte
.c310  85 c3      sta $c3          	STA	Bpntrl		; save the BASIC execute pointer low byte
.c312  90 02      bcc $c316        	BCC	LAB_1754		; branch if no overflow to high byte
.c314  e6 c4      inc $c4          	INC	Bpntrh		; else increment the BASIC execute pointer high byte
.c316                              lab_1754
.c316  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c319  90 c3      bcc $c2de        	BCC	LAB_174C		; if numeric do GOTO n
.c31b  4c fc c0   jmp $c0fc        	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
.c31e                              lab_rem
.c31e  20 a0 c2   jsr $c2a0        	JSR	LAB_SNBL		; scan for next BASIC line
.c321  4c 8f c2   jmp $c28f        	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
.c324                              lab_16fd
.c324  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; do syntax error then warm start
.c327                              lab_on
.c327  c9 a9      cmp #$a9         	CMP	#TK_IRQ		; was it IRQ token ?
.c329  d0 03      bne $c32e        	BNE	LAB_NOIN		; if not go check NMI
.c32b  4c 38 db   jmp $db38        	JMP	LAB_SIRQ		; else go set-up IRQ
.c32e                              lab_noin
.c32e  c9 aa      cmp #$aa         	CMP	#TK_NMI		; was it NMI token ?
.c330  d0 03      bne $c335        	BNE	LAB_NONM		; if not go do normal ON command
.c332  4c 3c db   jmp $db3c        	JMP	LAB_SNMI		; else go set-up NMI
.c335                              lab_nonm
.c335  20 8c d0   jsr $d08c        	JSR	LAB_GTBY		; get byte parameter
.c338  48         pha              	PHA				; push GOTO/GOSUB token
.c339  c9 8d      cmp #$8d         	CMP	#TK_GOSUB		; compare with GOSUB token
.c33b  f0 04      beq $c341        	BEQ	LAB_176B		; branch if GOSUB
.c33d  c9 89      cmp #$89         	CMP	#TK_GOTO		; compare with GOTO token
.c33f                              lab_1767
.c33f  d0 e3      bne $c324        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
.c341                              lab_176b
.c341  c6 af      dec $af          	DEC	FAC1_3		; decrement index (byte value)
.c343  d0 04      bne $c349        	BNE	LAB_1773		; branch if not zero
.c345  68         pla              	PLA				; pull GOTO/GOSUB token
.c346  4c fe c0   jmp $c0fe        	JMP	LAB_1602		; go execute it
.c349                              lab_1773
.c349  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c34c  20 55 c3   jsr $c355        	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
.c34f  c9 2c      cmp #$2c         	CMP	#$2C			; compare next character with ","
.c351  f0 ee      beq $c341        	BEQ	LAB_176B		; loop if ","
.c353                              lab_177e
.c353  68         pla              	PLA				; else pull keyword token (run out of options)
.c354                              lab_177f
.c354  60         rts              	RTS
.c355                              lab_gfpn
.c355  a2 00      ldx #$00         	LDX	#$00			; clear reg
.c357  86 11      stx $11          	STX	Itempl		; clear temporary integer low byte
.c359                              lab_1785
.c359  86 12      stx $12          	STX	Itemph		; save temporary integer high byte
.c35b  b0 f7      bcs $c354        	BCS	LAB_177F		; return if carry set, end of scan, character was
.c35d  e0 19      cpx #$19         	CPX	#$19			; compare high byte with $19
.c35f  a8         tay              	TAY				; ensure Zb = 0 if the branch is taken
.c360  b0 dd      bcs $c33f        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
.c362  e9 2f      sbc #$2f         	SBC	#"0"-1		; subtract "0", $2F + carry, from byte
.c364  a8         tay              	TAY				; copy binary digit
.c365  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte
.c367  0a         asl              	ASL				; *2 low byte
.c368  26 12      rol $12          	ROL	Itemph		; *2 high byte
.c36a  0a         asl              	ASL				; *2 low byte
.c36b  26 12      rol $12          	ROL	Itemph		; *2 high byte, *4
.c36d  65 11      adc $11          	ADC	Itempl		; + low byte, *5
.c36f  85 11      sta $11          	STA	Itempl		; save it
.c371  8a         txa              	TXA				; get high byte copy to A
.c372  65 12      adc $12          	ADC	Itemph		; + high byte, *5
.c374  06 11      asl $11          	ASL	Itempl		; *2 low byte, *10d
.c376  2a         rol              	ROL				; *2 high byte, *10d
.c377  aa         tax              	TAX				; copy high byte back to X
.c378  98         tya              	TYA				; get binary digit back
.c379  65 11      adc $11          	ADC	Itempl		; add number low byte
.c37b  85 11      sta $11          	STA	Itempl		; save number low byte
.c37d  90 01      bcc $c380        	BCC	LAB_17B3		; if no overflow to high byte get next character
.c37f  e8         inx              	INX				; else increment high byte
.c380                              lab_17b3
.c380  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c383  4c 59 c3   jmp $c359        	JMP	LAB_1785		; loop for next character
.c386                              lab_dec
.c386  a9 e4      lda #$e4         	LDA	#<LAB_2AFD		; set -1 pointer low byte

>c388  2c                          	.byte	$2C			; BIT abs to skip the LDA below
.c389                              lab_inc

.c389  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low byte
.c38b                              lab_17b5
.c38b  48         pha              	PHA				; save +/-1 pointer low byte
.c38c                              lab_17b7
.c38c  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get var address
.c38f  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.c391  30 1e      bmi $c3b1        	BMI	IncrErr		; exit if string
.c393  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.c395  84 98      sty $98          	STY	Lvarph		; save var address high byte
.c397  20 7d d4   jsr $d47d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.c39a  68         pla              	PLA				; get +/-1 pointer low byte
.c39b  48         pha              	PHA				; save +/-1 pointer low byte
.c39c  a0 dd      ldy #$dd         	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
.c39e  20 be d1   jsr $d1be        	JSR	LAB_246C		; add (AY) to FAC1
.c3a1  20 a3 d4   jsr $d4a3        	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
.c3a4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c3a7  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.c3a9  d0 a8      bne $c353        	BNE	LAB_177E		; exit if not "," (either end or error)
.c3ab  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c3ae  4c 8c c3   jmp $c38c        	JMP	LAB_17B7		; go do next var
.c3b1                              increrr
.c3b1  4c dc c6   jmp $c6dc        	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.c3b4                              lab_let
.c3b4  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get var address
.c3b7  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.c3b9  84 98      sty $98          	STY	Lvarph		; save var address high byte
.c3bb  a9 c2      lda #$c2         	LDA	#TK_EQUAL		; get = token
.c3bd  20 f1 c7   jsr $c7f1        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.c3c0  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.c3c2  48         pha              	PHA				; push data type flag
.c3c3  20 e1 c6   jsr $c6e1        	JSR	LAB_EVEX		; evaluate expression
.c3c6  68         pla              	PLA				; pop data type flag
.c3c7  2a         rol              	ROL				; set carry if type = string
.c3c8  20 d3 c6   jsr $c6d3        	JSR	LAB_CKTM		; type match check, set C for string
.c3cb  d0 03      bne $c3d0        	BNE	LAB_17D5		; branch if string
.c3cd  4c a3 d4   jmp $d4a3        	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
.c3d0                              lab_17d5
.c3d0  a0 02      ldy #$02         	LDY	#$02			; set index to pointer high byte
.c3d2  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get string pointer high byte
.c3d4  c5 82      cmp $82          	CMP	Sstorh		; compare bottom of string space high byte
.c3d6  90 17      bcc $c3ef        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
.c3d8  d0 07      bne $c3e1        	BNE	LAB_17E6		; branch if >
.c3da  88         dey              	DEY				; decrement index
.c3db  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get pointer low byte
.c3dd  c5 81      cmp $81          	CMP	Sstorl		; compare bottom of string space low byte
.c3df  90 0e      bcc $c3ef        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
.c3e1                              lab_17e6
.c3e1  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.c3e3  c4 7c      cpy $7c          	CPY	Svarh			; compare start of vars high byte
.c3e5  90 08      bcc $c3ef        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
.c3e7  d0 0d      bne $c3f6        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
.c3e9  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.c3eb  c5 7b      cmp $7b          	CMP	Svarl			; compare start of vars low byte
.c3ed  b0 07      bcs $c3f6        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
.c3ef                              lab_17f4
.c3ef  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.c3f1  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.c3f3  4c 0c c4   jmp $c40c        	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
.c3f6                              lab_17fb
.c3f6  a0 00      ldy #$00         	LDY	#$00			; index to length
.c3f8  b1 ae      lda ($ae),y      	LDA	(des_pl),Y		; get string length
.c3fa  20 32 cd   jsr $cd32        	JSR	LAB_209C		; copy string
.c3fd  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.c3ff  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.c401  85 b8      sta $b8          	STA	ssptr_l		; save descriptor pointer low byte
.c403  84 b9      sty $b9          	STY	ssptr_h		; save descriptor pointer high byte
.c405  20 11 cf   jsr $cf11        	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.c408  a9 ac      lda #$ac         	LDA	#<FAC1_e		; set descriptor pointer low byte
.c40a  a0 00      ldy #$00         	LDY	#>FAC1_e		; get descriptor pointer high byte
.c40c                              lab_1811
.c40c  85 9e      sta $9e          	STA	des_2l		; save descriptor_2 pointer low byte
.c40e  84 9f      sty $9f          	STY	des_2h		; save descriptor_2 pointer high byte
.c410  20 73 cf   jsr $cf73        	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.c413  a0 00      ldy #$00         	LDY	#$00			; index to length
.c415  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string length
.c417  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.c419  c8         iny              	INY				; index to string pointer low byte
.c41a  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string pointer low byte
.c41c  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.c41e  c8         iny              	INY				; index to string pointer high byte
.c41f  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; get string pointer high byte
.c421  91 97      sta ($97),y      	STA	(Lvarpl),Y		; copy to let string variable
.c423  60         rts              	RTS
.c424                              lab_get
.c424  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get var address
.c427  85 97      sta $97          	STA	Lvarpl		; save var address low byte
.c429  84 98      sty $98          	STY	Lvarph		; save var address high byte
.c42b  20 00 db   jsr $db00        	JSR	INGET			; get input byte
.c42e  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.c430  30 07      bmi $c439        	BMI	LAB_GETS		; go get string character
.c432  a8         tay              	TAY				; copy character to Y
.c433  20 66 cc   jsr $cc66        	JSR	LAB_1FD0		; convert Y to byte in FAC1
.c436  4c a3 d4   jmp $d4a3        	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
.c439                              lab_gets
.c439  48         pha              	PHA				; save character
.c43a  a9 01      lda #$01         	LDA	#$01			; string is single byte
.c43c  b0 01      bcs $c43f        	BCS	LAB_IsByte		; branch if byte received
.c43e  68         pla              	PLA				; string is null
.c43f                              lab_isbyte
.c43f  20 3a cd   jsr $cd3a        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.c442  f0 05      beq $c449        	BEQ	LAB_NoSt		; skip store if null string
.c444  68         pla              	PLA				; get character back
.c445  a0 00      ldy #$00         	LDY	#$00			; clear index
.c447  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save byte in string (byte IS string!)
.c449                              lab_nost
.c449  20 85 cd   jsr $cd85        	JSR	LAB_RTST		; check for space on descriptor stack then put address
.c44c  4c d0 c3   jmp $c3d0        	JMP	LAB_17D5		; do string LET and return
.c44f                              lab_1829
.c44f  20 d6 c4   jsr $c4d6        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.c452                              lab_182c
.c452  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c455                              lab_print
.c455  f0 3b      beq $c492        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
.c457                              lab_1831
.c457  c9 ac      cmp #$ac         	CMP	#TK_TAB		; compare with TAB( token
.c459  f0 56      beq $c4b1        	BEQ	LAB_18A2		; go do TAB/SPC
.c45b  c9 b0      cmp #$b0         	CMP	#TK_SPC		; compare with SPC( token
.c45d  f0 52      beq $c4b1        	BEQ	LAB_18A2		; go do TAB/SPC
.c45f  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.c461  f0 38      beq $c49b        	BEQ	LAB_188B		; go do move to next TAB mark
.c463  c9 3b      cmp #$3b         	CMP	#";"			; compare with ";"
.c465  f0 66      beq $c4cd        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
.c467  20 e1 c6   jsr $c6e1        	JSR	LAB_EVEX		; evaluate expression
.c46a  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.c46c  30 e1      bmi $c44f        	BMI	LAB_1829		; branch if string
.c46e  20 95 d6   jsr $d695        	JSR	LAB_296E		; convert FAC1 to string
.c471  20 44 cd   jsr $cd44        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.c474  a0 00      ldy #$00         	LDY	#$00			; clear index
.c476  a5 0f      lda $0f          	LDA	TWidth		; get terminal width byte
.c478  f0 0a      beq $c484        	BEQ	LAB_185E		; skip check if zero
.c47a  38         sec              	SEC				; set carry for subtract
.c47b  e5 0e      sbc $0e          	SBC	TPos			; subtract terminal position
.c47d  f1 ae      sbc ($ae),y      	SBC	(des_pl),Y		; subtract string length
.c47f  b0 03      bcs $c484        	BCS	LAB_185E		; branch if less than terminal width
.c481  20 92 c4   jsr $c492        	JSR	LAB_CRLF		; else print CR/LF
.c484                              lab_185e
.c484  20 d6 c4   jsr $c4d6        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.c487  f0 c9      beq $c452        	BEQ	LAB_182C		; always go continue processing line
.c489                              lab_1866
.c489  a9 00      lda #$00         	LDA	#$00			; clear byte
.c48b  9d 0d 02   sta $020d,x      	STA	Ibuffs,X		; null terminate input
.c48e  a2 0d      ldx #$0d         	LDX	#<Ibuffs		; set X to buffer start-1 low byte
.c490  a0 02      ldy #$02         	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
.c492                              lab_crlf
.c492  a9 0d      lda #$0d         	LDA	#$0D			; load [CR]
.c494  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.c497  a9 0a      lda #$0a         	LDA	#$0A			; load [LF]
.c499  d0 52      bne $c4ed        	BNE	LAB_PRNA		; go print the character and return, branch always
.c49b                              lab_188b
.c49b  a5 0e      lda $0e          	LDA	TPos			; get terminal position
.c49d  c5 10      cmp $10          	CMP	Iclim			; compare with input column limit
.c49f  90 05      bcc $c4a6        	BCC	LAB_1897		; branch if less
.c4a1  20 92 c4   jsr $c492        	JSR	LAB_CRLF		; else print CR/LF (next line)
.c4a4  d0 27      bne $c4cd        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
.c4a6                              lab_1897
.c4a6  38         sec              	SEC				; set carry for subtract
.c4a7                              lab_1898
.c4a7  e5 64      sbc $64          	SBC	TabSiz		; subtract TAB size
.c4a9  b0 fc      bcs $c4a7        	BCS	LAB_1898		; loop if result was +ve
.c4ab  49 ff      eor #$ff         	EOR	#$FF			; complement it
.c4ad  69 01      adc #$01         	ADC	#$01			; +1 (twos complement)
.c4af  d0 12      bne $c4c3        	BNE	LAB_18B6		; always print A spaces (result is never $00)
.c4b1                              lab_18a2
.c4b1  48         pha              	PHA				; save token
.c4b2  20 89 d0   jsr $d089        	JSR	LAB_SGBY		; scan and get byte parameter
.c4b5  c9 29      cmp #$29         	CMP	#$29			; is next character )
.c4b7  d0 7b      bne $c534        	BNE	LAB_1910		; if not do syntax error then warm start
.c4b9  68         pla              	PLA				; get token back
.c4ba  c9 ac      cmp #$ac         	CMP	#TK_TAB		; was it TAB ?
.c4bc  d0 06      bne $c4c4        	BNE	LAB_18B7		; if not go do SPC
.c4be  8a         txa              	TXA				; copy integer value to A
.c4bf  e5 0e      sbc $0e          	SBC	TPos			; subtract terminal position
.c4c1  90 0a      bcc $c4cd        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
.c4c3                              lab_18b6
.c4c3  aa         tax              	TAX				; copy result to X
.c4c4                              lab_18b7
.c4c4  8a         txa              	TXA				; set flags on size for SPC
.c4c5  f0 06      beq $c4cd        	BEQ	LAB_18BD		; branch if result was = $0, already here
.c4c7                              lab_18ba
.c4c7  20 e8 c4   jsr $c4e8        	JSR	LAB_18E0		; print " "
.c4ca  ca         dex              	DEX				; decrement count
.c4cb  d0 fa      bne $c4c7        	BNE	LAB_18BA		; loop if not all done
.c4cd                              lab_18bd
.c4cd  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c4d0  d0 85      bne $c457        	BNE	LAB_1831		; if more to print go do it
.c4d2  60         rts              	RTS
.c4d3                              lab_18c3
.c4d3  20 44 cd   jsr $cd44        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.c4d6                              lab_18c6
.c4d6  20 3e cf   jsr $cf3e        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.c4d9  a0 00      ldy #$00         	LDY	#$00			; reset index
.c4db  aa         tax              	TAX				; copy length to X
.c4dc  f0 49      beq $c527        	BEQ	LAB_188C		; exit (RTS) if null string
.c4de                              lab_18cd
.c4de  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get next byte
.c4e0  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.c4e3  c8         iny              	INY				; increment index
.c4e4  ca         dex              	DEX				; decrement count
.c4e5  d0 f7      bne $c4de        	BNE	LAB_18CD		; loop if not done yet
.c4e7  60         rts              	RTS
.c4e8                              lab_18e0
.c4e8  a9 20      lda #$20         	LDA	#$20			; load " "

>c4ea  2c                          	.byte	$2C			; change next line to BIT LAB_3FA9
.c4eb                              lab_18e3

.c4eb  a9 3f      lda #$3f         	LDA	#$3F			; load "?" character
.c4ed                              lab_prna
.c4ed  c9 20      cmp #$20         	CMP	#" "			; compare with " "
.c4ef  90 19      bcc $c50a        	BCC	LAB_18F9		; branch if less (non printing)
.c4f1  48         pha              	PHA				; save the character
.c4f2  a5 0f      lda $0f          	LDA	TWidth		; get terminal width
.c4f4  d0 0a      bne $c500        	BNE	LAB_18F0		; branch if not zero (not infinite length)
.c4f6  a5 0e      lda $0e          	LDA	TPos			; get position
.c4f8  e5 64      sbc $64          	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
.c4fa  d0 0b      bne $c507        	BNE	LAB_18F7		; skip reset if different
.c4fc  85 0e      sta $0e          	STA	TPos			; else reset position
.c4fe  f0 07      beq $c507        	BEQ	LAB_18F7		; go print character
.c500                              lab_18f0
.c500  c5 0e      cmp $0e          	CMP	TPos			; compare with terminal character position
.c502  d0 03      bne $c507        	BNE	LAB_18F7		; branch if not at end of line
.c504  20 92 c4   jsr $c492        	JSR	LAB_CRLF		; else print CR/LF
.c507                              lab_18f7
.c507  e6 0e      inc $0e          	INC	TPos			; increment terminal position
.c509  68         pla              	PLA				; get character back
.c50a                              lab_18f9
.c50a  20 ed dc   jsr $dced        	JSR	V_OUTP		; output byte via output vector
.c50d  c9 0d      cmp #$0d         	CMP	#$0D			; compare with [CR]
.c50f  d0 14      bne $c525        	BNE	LAB_188A		; branch if not [CR]
.c511  86 78      stx $78          	STX	TempB			; save buffer index
.c513  a6 0d      ldx $0d          	LDX	Nullct		; get null count
.c515  f0 0a      beq $c521        	BEQ	LAB_1886		; branch if no nulls
.c517  a9 00      lda #$00         	LDA	#$00			; load [NULL]
.c519                              lab_1880
.c519  20 ed c4   jsr $c4ed        	JSR	LAB_PRNA		; go print the character
.c51c  ca         dex              	DEX				; decrement count
.c51d  d0 fa      bne $c519        	BNE	LAB_1880		; loop if not all done
.c51f  a9 0d      lda #$0d         	LDA	#$0D			; restore the character (and set the flags)
.c521                              lab_1886
.c521  86 0e      stx $0e          	STX	TPos			; clear terminal position (X always = zero when we get here)
.c523  a6 78      ldx $78          	LDX	TempB			; restore buffer index
.c525                              lab_188a
.c525  29 ff      and #$ff         	AND	#$FF			; set the flags
.c527                              lab_188c
.c527  60         rts              	RTS
.c528                              lab_1904
.c528  a5 62      lda $62          	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
.c52a  10 0b      bpl $c537        	BPL	LAB_1913		; branch if INPUT (go do redo)
.c52c  a5 8d      lda $8d          	LDA	Dlinel		; get current DATA line low byte
.c52e  a4 8e      ldy $8e          	LDY	Dlineh		; get current DATA line high byte
.c530  85 87      sta $87          	STA	Clinel		; save current line low byte
.c532  84 88      sty $88          	STY	Clineh		; save current line high byte
.c534                              lab_1910
.c534  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; do syntax error then warm start
.c537                              lab_1913
.c537  a9 1b      lda #$1b         	LDA	#<LAB_REDO		; point to redo message (low addr)
.c539  a0 e4      ldy #$e4         	LDY	#>LAB_REDO		; point to redo message (high addr)
.c53b  20 d3 c4   jsr $c4d3        	JSR	LAB_18C3		; print null terminated string from memory
.c53e  a5 8b      lda $8b          	LDA	Cpntrl		; get continue pointer low byte
.c540  a4 8c      ldy $8c          	LDY	Cpntrh		; get continue pointer high byte
.c542  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c544  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.c546  60         rts              	RTS
.c547                              lab_input
.c547  c9 22      cmp #$22         	CMP	#$22			; compare next byte with open quote
.c549  d0 0b      bne $c556        	BNE	LAB_1934		; branch if no prompt string
.c54b  20 be c7   jsr $c7be        	JSR	LAB_1BC1		; print "..." string
.c54e  a9 3b      lda #$3b         	LDA	#$3B			; load A with ";"
.c550  20 f1 c7   jsr $c7f1        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.c553  20 d6 c4   jsr $c4d6        	JSR	LAB_18C6		; print string from Sutill/Sutilh
.c556                              lab_1934
.c556  20 6a cc   jsr $cc6a        	JSR	LAB_CKRN		; check not Direct, back here if ok
.c559  20 40 be   jsr $be40        	JSR	LAB_INLN		; print "? " and get BASIC input
.c55c  a9 00      lda #$00         	LDA	#$00			; set mode = INPUT
.c55e  cd 0d 02   cmp $020d        	CMP	Ibuffs		; test first byte in buffer
.c561  d0 0a      bne $c56d        	BNE	LAB_1953		; branch if not null input
.c563  18         clc              	CLC				; was null input so clear carry to exit program
.c564  4c 2c c1   jmp $c12c        	JMP	LAB_1647		; go do BREAK exit
.c567                              lab_read
.c567  a6 8f      ldx $8f          	LDX	Dptrl			; get DATA pointer low byte
.c569  a4 90      ldy $90          	LDY	Dptrh			; get DATA pointer high byte
.c56b  a9 80      lda #$80         	LDA	#$80			; set mode = READ
.c56d                              lab_1953
.c56d  85 62      sta $62          	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
.c56f  86 91      stx $91          	STX	Rdptrl		; save READ pointer low byte
.c571  84 92      sty $92          	STY	Rdptrh		; save READ pointer high byte
.c573                              lab_195b
.c573  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get (var) address
.c576  85 97      sta $97          	STA	Lvarpl		; save address low byte
.c578  84 98      sty $98          	STY	Lvarph		; save address high byte
.c57a  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.c57c  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.c57e  85 11      sta $11          	STA	Itempl		; save as temporary integer low byte
.c580  84 12      sty $12          	STY	Itemph		; save as temporary integer high byte
.c582  a6 91      ldx $91          	LDX	Rdptrl		; get READ pointer low byte
.c584  a4 92      ldy $92          	LDY	Rdptrh		; get READ pointer high byte
.c586  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.c588  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.c58a  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c58d  d0 11      bne $c5a0        	BNE	LAB_1988		; branch if not null
.c58f  24 62      bit $62          	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
.c591  30 65      bmi $c5f8        	BMI	LAB_19DD		; branch if READ
.c593  20 eb c4   jsr $c4eb        	JSR	LAB_18E3		; print "?" character (double ? for extended input)
.c596  20 40 be   jsr $be40        	JSR	LAB_INLN		; print "? " and get BASIC input
.c599  86 c3      stx $c3          	STX	Bpntrl		; set BASIC execute pointer low byte
.c59b  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.c59d                              lab_1985
.c59d  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c5a0                              lab_1988
.c5a0  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.c5a2  10 24      bpl $c5c8        	BPL	LAB_19B0		; branch if numeric
.c5a4  85 5b      sta $5b          	STA	Srchc			; save search character
.c5a6  c9 22      cmp #$22         	CMP	#$22			; was it " ?
.c5a8  f0 07      beq $c5b1        	BEQ	LAB_1999		; branch if so
.c5aa  a9 3a      lda #$3a         	LDA	#":"			; else search character is ":"
.c5ac  85 5b      sta $5b          	STA	Srchc			; set new search character
.c5ae  a9 2c      lda #$2c         	LDA	#","			; other search character is ","
.c5b0  18         clc              	CLC				; clear carry for add
.c5b1                              lab_1999
.c5b1  85 5c      sta $5c          	STA	Asrch			; set second search character
.c5b3  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.c5b5  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.c5b7  69 00      adc #$00         	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
.c5b9  90 01      bcc $c5bc        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
.c5bb  c8         iny              	INY				; else increment high byte
.c5bc                              lab_19a4
.c5bc  20 4a cd   jsr $cd4a        	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
.c5bf  20 cf d0   jsr $d0cf        	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
.c5c2  20 d0 c3   jsr $c3d0        	JSR	LAB_17D5		; go do string LET
.c5c5  4c ce c5   jmp $c5ce        	JMP	LAB_19B6		; go check string terminator
.c5c8                              lab_19b0
.c5c8  20 a6 d5   jsr $d5a6        	JSR	LAB_2887		; get FAC1 from string
.c5cb  20 a3 d4   jsr $d4a3        	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
.c5ce                              lab_19b6
.c5ce  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c5d1  f0 0a      beq $c5dd        	BEQ	LAB_19C5		; branch if null (last entry)
.c5d3  c9 2c      cmp #$2c         	CMP	#","			; else compare with ","
.c5d5  f0 03      beq $c5da        	BEQ	LAB_19C2		; branch if ","
.c5d7  4c 28 c5   jmp $c528        	JMP	LAB_1904		; else go handle bad input data
.c5da                              lab_19c2
.c5da  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c5dd                              lab_19c5
.c5dd  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
.c5df  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
.c5e1  85 91      sta $91          	STA	Rdptrl		; save for now
.c5e3  84 92      sty $92          	STY	Rdptrh		; save for now
.c5e5  a5 11      lda $11          	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
.c5e7  a4 12      ldy $12          	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
.c5e9  85 c3      sta $c3          	STA	Bpntrl		; set BASIC execute pointer low byte
.c5eb  84 c4      sty $c4          	STY	Bpntrh		; set BASIC execute pointer high byte
.c5ed  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c5f0  f0 2c      beq $c61e        	BEQ	LAB_1A03		; if null go do extra ignored message
.c5f2  20 fe c7   jsr $c7fe        	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
.c5f5  4c 73 c5   jmp $c573        	JMP	LAB_195B		; go INPUT next variable from list
.c5f8                              lab_19dd
.c5f8  20 9d c2   jsr $c29d        	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
.c5fb  c8         iny              	INY				; increment index
.c5fc  aa         tax              	TAX				; copy character ([:] or [EOL])
.c5fd  d0 12      bne $c611        	BNE	LAB_19F6		; branch if [:]
.c5ff  a2 06      ldx #$06         	LDX	#$06			; set for "Out of DATA" error
.c601  c8         iny              	INY				; increment index, now points to next line pointer high byte
.c602  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line pointer high byte
.c604  f0 73      beq $c679        	BEQ	LAB_1A54		; branch if end (eventually does error X)
.c606  c8         iny              	INY				; increment index
.c607  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line # low byte
.c609  85 8d      sta $8d          	STA	Dlinel		; save current DATA line low byte
.c60b  c8         iny              	INY				; increment index
.c60c  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get next line # high byte
.c60e  c8         iny              	INY				; increment index
.c60f  85 8e      sta $8e          	STA	Dlineh		; save current DATA line high byte
.c611                              lab_19f6
.c611  b1 c3      lda ($c3),y      	LDA	(Bpntrl),Y		; get byte
.c613  c8         iny              	INY				; increment index
.c614  aa         tax              	TAX				; copy to X
.c615  20 8f c2   jsr $c28f        	JSR	LAB_170F		; set BASIC execute pointer
.c618  e0 83      cpx #$83         	CPX	#TK_DATA		; compare with "DATA" token
.c61a  f0 81      beq $c59d        	BEQ	LAB_1985		; was "DATA" so go do next READ
.c61c  d0 da      bne $c5f8        	BNE	LAB_19DD		; go find next statement if not "DATA"
.c61e                              lab_1a03
.c61e  a5 91      lda $91          	LDA	Rdptrl		; get temp READ pointer low byte
.c620  a4 92      ldy $92          	LDY	Rdptrh		; get temp READ pointer high byte
.c622  a6 62      ldx $62          	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
.c624  10 03      bpl $c629        	BPL	LAB_1A0E		; branch if INPUT
.c626  4c 4e c1   jmp $c14e        	JMP	LAB_1624		; save AY as DATA pointer and return
.c629                              lab_1a0e
.c629  a0 00      ldy #$00         	LDY	#$00			; clear index
.c62b  b1 91      lda ($91),y      	LDA	(Rdptrl),Y		; get next byte
.c62d  d0 01      bne $c630        	BNE	LAB_1A1B		; error if not end of INPUT
.c62f  60         rts              	RTS
.c630                              lab_1a1b
.c630  a9 0a      lda #$0a         	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
.c632  a0 e4      ldy #$e4         	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
.c634  4c d3 c4   jmp $c4d3        	JMP	LAB_18C3		; print null terminated string from memory and return
.c637                              lab_11a1
.c637  ba         tsx              	TSX				; copy stack pointer
.c638  e8         inx              	INX				; +1 pass return address
.c639  e8         inx              	INX				; +2 pass return address
.c63a  e8         inx              	INX				; +3 pass calling routine return address
.c63b  e8         inx              	INX				; +4 pass calling routine return address
.c63c                              lab_11a6
.c63c  bd 01 01   lda $0101,x      	LDA	LAB_STAK+1,X	; get token byte from stack
.c63f  c9 81      cmp #$81         	CMP	#TK_FOR		; is it FOR token
.c641  d0 21      bne $c664        	BNE	LAB_11CE		; exit if not FOR token
.c643  a5 98      lda $98          	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
.c645  d0 0a      bne $c651        	BNE	LAB_11BB		; branch if not null
.c647  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
.c64a  85 97      sta $97          	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
.c64c  bd 03 01   lda $0103,x      	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
.c64f  85 98      sta $98          	STA	Frnxth		; save var pointer for FOR/NEXT high byte
.c651                              lab_11bb
.c651  dd 03 01   cmp $0103,x      	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
.c654  d0 07      bne $c65d        	BNE	LAB_11C7		; branch if no match
.c656  a5 97      lda $97          	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
.c658  dd 02 01   cmp $0102,x      	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
.c65b  f0 07      beq $c664        	BEQ	LAB_11CE		; exit if match found
.c65d                              lab_11c7
.c65d  8a         txa              	TXA				; copy index
.c65e  18         clc              	CLC				; clear carry for add
.c65f  69 10      adc #$10         	ADC	#$10			; add FOR stack use size
.c661  aa         tax              	TAX				; copy back to index
.c662  d0 d8      bne $c63c        	BNE	LAB_11A6		; loop if not at start of stack
.c664                              lab_11ce
.c664  60         rts              	RTS
.c665                              lab_next
.c665  d0 04      bne $c66b        	BNE	LAB_1A46		; branch if NEXT var
.c667  a0 00      ldy #$00         	LDY	#$00			; else clear Y
.c669  f0 03      beq $c66e        	BEQ	LAB_1A49		; branch always (no variable to search for)
.c66b                              lab_1a46
.c66b  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get variable address
.c66e                              lab_1a49
.c66e  85 97      sta $97          	STA	Frnxtl		; store variable pointer low byte
.c670  84 98      sty $98          	STY	Frnxth		; store variable pointer high byte
.c672  20 37 c6   jsr $c637        	JSR	LAB_11A1		; search the stack for FOR activity
.c675  f0 04      beq $c67b        	BEQ	LAB_1A56		; branch if found
.c677  a2 00      ldx #$00         	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
.c679                              lab_1a54
.c679  f0 63      beq $c6de        	BEQ	LAB_1ABE		; do error #X, then warm start
.c67b                              lab_1a56
.c67b  9a         txs              	TXS				; set stack pointer, X set by search, dumps return addresses
.c67c  8a         txa              	TXA				; copy stack pointer
.c67d  38         sec              	SEC				; set carry for subtract
.c67e  e9 f7      sbc #$f7         	SBC	#$F7			; point to TO var
.c680  85 73      sta $73          	STA	ut2_pl		; save pointer to TO var for compare
.c682  69 fb      adc #$fb         	ADC	#$FB			; point to STEP var
.c684  a0 01      ldy #$01         	LDY	#>LAB_STAK		; point to stack page high byte
.c686  20 7d d4   jsr $d47d        	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
.c689  ba         tsx              	TSX				; get stack pointer back
.c68a  bd 08 01   lda $0108,x      	LDA	LAB_STAK+8,X	; get step sign
.c68d  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.c68f  a5 97      lda $97          	LDA	Frnxtl		; get FOR variable pointer low byte
.c691  a4 98      ldy $98          	LDY	Frnxth		; get FOR variable pointer high byte
.c693  20 be d1   jsr $d1be        	JSR	LAB_246C		; add (FOR variable) to FAC1
.c696  20 a3 d4   jsr $d4a3        	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
.c699  a0 01      ldy #$01         	LDY	#>LAB_STAK		; point to stack page high byte
.c69b  20 19 d5   jsr $d519        	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
.c69e  ba         tsx              	TSX				; get stack pointer back
.c69f  dd 08 01   cmp $0108,x      	CMP	LAB_STAK+8,X	; compare step sign
.c6a2  f0 17      beq $c6bb        	BEQ	LAB_1A9B		; branch if = (loop complete)
.c6a4  bd 0d 01   lda $010d,x      	LDA	LAB_STAK+$0D,X	; get FOR line low byte
.c6a7  85 87      sta $87          	STA	Clinel		; save current line low byte
.c6a9  bd 0e 01   lda $010e,x      	LDA	LAB_STAK+$0E,X	; get FOR line high byte
.c6ac  85 88      sta $88          	STA	Clineh		; save current line high byte
.c6ae  bd 10 01   lda $0110,x      	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
.c6b1  85 c3      sta $c3          	STA	Bpntrl		; save BASIC execute pointer low byte
.c6b3  bd 0f 01   lda $010f,x      	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
.c6b6  85 c4      sta $c4          	STA	Bpntrh		; save BASIC execute pointer high byte
.c6b8                              lab_1a98
.c6b8  4c bc c0   jmp $c0bc        	JMP	LAB_15C2		; go do interpreter inner loop
.c6bb                              lab_1a9b
.c6bb  8a         txa              	TXA				; stack copy to A
.c6bc  69 0f      adc #$0f         	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
.c6be  aa         tax              	TAX				; copy back to index
.c6bf  9a         txs              	TXS				; copy to stack pointer
.c6c0  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c6c3  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.c6c5  d0 f1      bne $c6b8        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
.c6c7  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; else increment and scan memory
.c6ca  20 6b c6   jsr $c66b        	JSR	LAB_1A46		; do NEXT (var)
.c6cd                              lab_evnm
.c6cd  20 e1 c6   jsr $c6e1        	JSR	LAB_EVEX		; evaluate expression
.c6d0                              lab_ctnm
.c6d0  18         clc              	CLC				; destination is numeric

>c6d1  24                          	.byte	$24			; makes next line BIT $38
.c6d2                              lab_ctst

.c6d2  38         sec              	SEC				; required type is string
.c6d3                              lab_cktm
.c6d3  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.c6d5  30 03      bmi $c6da        	BMI	LAB_1ABA		; branch if data type is string
.c6d7  b0 03      bcs $c6dc        	BCS	LAB_1ABC		; if required type is string do type mismatch error
.c6d9                              lab_1ab9
.c6d9  60         rts              	RTS
.c6da                              lab_1aba
.c6da  b0 fd      bcs $c6d9        	BCS	LAB_1AB9		; exit if required type is string
.c6dc                              lab_1abc
.c6dc  a2 18      ldx #$18         	LDX	#$18			; error code $18 ("Type mismatch" error)
.c6de                              lab_1abe
.c6de  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.c6e1                              lab_evex
.c6e1  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.c6e3  d0 02      bne $c6e7        	BNE	LAB_1AC7		; skip next if not zero
.c6e5  c6 c4      dec $c4          	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.c6e7                              lab_1ac7
.c6e7  c6 c3      dec $c3          	DEC	Bpntrl		; decrement BASIC execute pointer low byte
.c6e9                              lab_evez
.c6e9  a9 00      lda #$00         	LDA	#$00			; set null precedence (flag done)
.c6eb                              lab_1acc
.c6eb  48         pha              	PHA				; push precedence byte
.c6ec  a9 02      lda #$02         	LDA	#$02			; 2 bytes
.c6ee  20 03 bd   jsr $bd03        	JSR	LAB_1212		; check room on stack for A bytes
.c6f1  20 cd c7   jsr $c7cd        	JSR	LAB_GVAL		; get value from line
.c6f4  a9 00      lda #$00         	LDA	#$00			; clear A
.c6f6  85 9b      sta $9b          	STA	comp_f		; clear compare function flag
.c6f8                              lab_1adb
.c6f8  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c6fb                              lab_1ade
.c6fb  38         sec              	SEC				; set carry for subtract
.c6fc  e9 c1      sbc #$c1         	SBC	#TK_GT		; subtract token for > (lowest comparison function)
.c6fe  90 17      bcc $c717        	BCC	LAB_1AFA		; branch if < TK_GT
.c700  c9 03      cmp #$03         	CMP	#$03			; compare with ">" to "<" tokens
.c702  b0 13      bcs $c717        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
.c704  c9 01      cmp #$01         	CMP	#$01			; compare with token for =
.c706  2a         rol              	ROL				; *2, b0 = carry (=1 if token was = or <)
.c707  49 01      eor #$01         	EOR	#$01			; toggle b0
.c709  45 9b      eor $9b          	EOR	comp_f		; EOR with compare function flag bits
.c70b  c5 9b      cmp $9b          	CMP	comp_f		; compare with compare function flag
.c70d  90 67      bcc $c776        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
.c70f  85 9b      sta $9b          	STA	comp_f		; save new compare function flag
.c711  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c714  4c fb c6   jmp $c6fb        	JMP	LAB_1ADE		; go do next character
.c717                              lab_1afa
.c717  a6 9b      ldx $9b          	LDX	comp_f		; get compare function flag
.c719  d0 2c      bne $c747        	BNE	LAB_1B2A		; branch if compare function
.c71b  b0 79      bcs $c796        	BCS	LAB_1B78		; go do functions
.c71d  69 0a      adc #$0a         	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
.c71f  90 75      bcc $c796        	BCC	LAB_1B78		; branch if < + operator
.c721  d0 07      bne $c72a        	BNE	LAB_1B0B		; branch if not + token
.c723  24 5f      bit $5f          	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
.c725  10 03      bpl $c72a        	BPL	LAB_1B0B		; branch if not string
.c727  4c d4 ce   jmp $ced4        	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
.c72a                              lab_1b0b
.c72a  85 71      sta $71          	STA	ut1_pl		; save it
.c72c  0a         asl              	ASL				; *2
.c72d  65 71      adc $71          	ADC	ut1_pl		; *3
.c72f  a8         tay              	TAY				; copy to index
.c730                              lab_1b13
.c730  68         pla              	PLA				; pull previous precedence
.c731  d9 eb de   cmp $deeb,y      	CMP	LAB_OPPT,Y		; compare with precedence byte
.c734  b0 65      bcs $c79b        	BCS	LAB_1B7D		; branch if A >=
.c736  20 d0 c6   jsr $c6d0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.c739                              lab_1b1c
.c739  48         pha              	PHA				; save precedence
.c73a                              lab_1b1d
.c73a  20 62 c7   jsr $c762        	JSR	LAB_1B43		; get vector, execute function then continue evaluation
.c73d  68         pla              	PLA				; restore precedence
.c73e  a4 99      ldy $99          	LDY	prstk			; get precedence stacked flag
.c740  10 19      bpl $c75b        	BPL	LAB_1B3C		; branch if stacked values
.c742  aa         tax              	TAX				; copy precedence (set flags)
.c743  f0 76      beq $c7bb        	BEQ	LAB_1B9D		; exit if done
.c745  d0 5d      bne $c7a4        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
.c747                              lab_1b2a
.c747  26 5f      rol $5f          	ROL	Dtypef		; shift data type flag into Cb
.c749  8a         txa              	TXA				; copy compare function flag
.c74a  85 5f      sta $5f          	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
.c74c  2a         rol              	ROL				; shift data type into compare function byte b0
.c74d  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.c74f  d0 02      bne $c753        	BNE	LAB_1B34		; branch if no underflow
.c751  c6 c4      dec $c4          	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
.c753                              lab_1b34
.c753  c6 c3      dec $c3          	DEC	Bpntrl		; decrement BASIC execute pointer low byte
.c755  a0 24      ldy #$24         	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
.c757  85 9b      sta $9b          	STA	comp_f		; save new compare function flag
.c759  d0 d5      bne $c730        	BNE	LAB_1B13		; branch always
.c75b                              lab_1b3c
.c75b  d9 eb de   cmp $deeb,y      	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
.c75e  b0 44      bcs $c7a4        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
.c760  90 d7      bcc $c739        	BCC	LAB_1B1C		; branch always
.c762                              lab_1b43
.c762  b9 ed de   lda $deed,y      	LDA	LAB_OPPT+2,Y	; get function vector high byte
.c765  48         pha              	PHA				; onto stack
.c766  b9 ec de   lda $deec,y      	LDA	LAB_OPPT+1,Y	; get function vector low byte
.c769  48         pha              	PHA				; onto stack
.c76a  20 79 c7   jsr $c779        	JSR	LAB_1B5B		; function will return here, then the next RTS will call
.c76d  a5 9b      lda $9b          	LDA	comp_f		; get compare function flag
.c76f  48         pha              	PHA				; push compare evaluation byte
.c770  b9 eb de   lda $deeb,y      	LDA	LAB_OPPT,Y		; get precedence byte
.c773  4c eb c6   jmp $c6eb        	JMP	LAB_1ACC		; continue evaluating expression
.c776                              lab_1b53
.c776  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; do syntax error then warm start
.c779                              lab_1b5b
.c779  68         pla              	PLA				; get return addr low byte
.c77a  85 71      sta $71          	STA	ut1_pl		; save it
.c77c  e6 71      inc $71          	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
.c77e  68         pla              	PLA				; get return addr high byte
.c77f  85 72      sta $72          	STA	ut1_ph		; save it
.c781  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.c783  48         pha              	PHA				; push sign
.c784                              lab_1b66
.c784  20 d9 d4   jsr $d4d9        	JSR	LAB_27BA		; round FAC1
.c787  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.c789  48         pha              	PHA				; push on stack
.c78a  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.c78c  48         pha              	PHA				; push on stack
.c78d  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.c78f  48         pha              	PHA				; push on stack
.c790  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c792  48         pha              	PHA				; push on stack
.c793  6c 71 00   jmp ($0071)      	JMP	(ut1_pl)		; return, sort of
.c796                              lab_1b78
.c796  a0 ff      ldy #$ff         	LDY	#$FF			; flag function
.c798  68         pla              	PLA				; pull precedence byte
.c799                              lab_1b7b
.c799  f0 20      beq $c7bb        	BEQ	LAB_1B9D		; exit if done
.c79b                              lab_1b7d
.c79b  c9 64      cmp #$64         	CMP	#$64			; compare previous precedence with $64
.c79d  f0 03      beq $c7a2        	BEQ	LAB_1B84		; branch if was $64 (< function)
.c79f  20 d0 c6   jsr $c6d0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.c7a2                              lab_1b84
.c7a2  84 99      sty $99          	STY	prstk			; save precedence stacked flag
.c7a4                              lab_1b86
.c7a4  68         pla              	PLA				; pop byte
.c7a5  4a         lsr              	LSR				; shift out comparison evaluation lowest bit
.c7a6  85 63      sta $63          	STA	Cflag			; save comparison evaluation flag
.c7a8  68         pla              	PLA				; pop exponent
.c7a9  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.c7ab  68         pla              	PLA				; pop mantissa1
.c7ac  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.c7ae  68         pla              	PLA				; pop mantissa2
.c7af  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.c7b1  68         pla              	PLA				; pop mantissa3
.c7b2  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.c7b4  68         pla              	PLA				; pop sign
.c7b5  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign (b7)
.c7b7  45 b0      eor $b0          	EOR	FAC1_s		; EOR FAC1 sign (b7)
.c7b9  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.c7bb                              lab_1b9d
.c7bb  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c7bd  60         rts              	RTS
.c7be                              lab_1bc1
.c7be  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.c7c0  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.c7c2  69 00      adc #$00         	ADC	#$00			; add carry to low byte
.c7c4  90 01      bcc $c7c7        	BCC	LAB_1BCA		; branch if no overflow
.c7c6  c8         iny              	INY				; increment high byte
.c7c7                              lab_1bca
.c7c7  20 44 cd   jsr $cd44        	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
.c7ca  4c cf d0   jmp $d0cf        	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
.c7cd                              lab_gval
.c7cd  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c7d0  b0 03      bcs $c7d5        	BCS	LAB_1BAC		; branch if not numeric character
.c7d2                              lab_1ba9
.c7d2  4c a6 d5   jmp $d5a6        	JMP	LAB_2887		; get FAC1 from string and return
.c7d5                              lab_1bac
.c7d5  aa         tax              	TAX				; set the flags
.c7d6  30 2f      bmi $c807        	BMI	LAB_1BD0		; if -ve go test token values
.c7d8  c9 24      cmp #$24         	CMP	#"$"			; compare with "$"
.c7da  f0 f6      beq $c7d2        	BEQ	LAB_1BA9		; branch if "$", hex number
.c7dc  c9 25      cmp #$25         	CMP	#"%"			; else compare with "%"
.c7de  f0 f2      beq $c7d2        	BEQ	LAB_1BA9		; branch if "%", binary number
.c7e0  c9 2e      cmp #$2e         	CMP	#"."			; compare with "."
.c7e2  f0 ee      beq $c7d2        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
.c7e4  c9 22      cmp #$22         	CMP	#$22			; compare with "
.c7e6  f0 d6      beq $c7be        	BEQ	LAB_1BC1		; branch if open quote
.c7e8  c9 28      cmp #$28         	CMP	#"("			; compare with "("
.c7ea  d0 4f      bne $c83b        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
.c7ec                              lab_1bf7
.c7ec  20 e9 c6   jsr $c6e9        	JSR	LAB_EVEZ		; evaluate expression, no decrement
.c7ef                              lab_1bfb
.c7ef  a9 29      lda #$29         	LDA	#$29			; load A with ")"
.c7f1                              lab_scca
.c7f1  a0 00      ldy #$00         	LDY	#$00			; clear index
.c7f3  d1 c3      cmp ($c3),y      	CMP	(Bpntrl),Y		; check next byte is = A
.c7f5  d0 0b      bne $c802        	BNE	LAB_SNER		; if not do syntax error then warm start
.c7f7  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; increment and scan memory then return
.c7fa                              lab_1bfe
.c7fa  a9 28      lda #$28         	LDA	#$28			; load A with "("
.c7fc  d0 f3      bne $c7f1        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.c7fe                              lab_1c01
.c7fe  a9 2c      lda #$2c         	LDA	#$2C			; load A with ","
.c800  d0 ef      bne $c7f1        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.c802                              lab_sner
.c802  a2 02      ldx #$02         	LDX	#$02			; error code $02 ("Syntax" error)
.c804  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.c807                              lab_1bd0
.c807  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; compare with token for -
.c809  f0 29      beq $c834        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
.c80b  c9 b7      cmp #$b7         	CMP	#TK_PLUS		; compare with token for +
.c80d  f0 be      beq $c7cd        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
.c80f  c9 b2      cmp #$b2         	CMP	#TK_NOT		; compare with token for NOT
.c811  d0 13      bne $c826        	BNE	LAB_1BE7		; branch if not token for NOT
.c813  a0 21      ldy #$21         	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
.c815  d0 1f      bne $c836        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
.c817                              lab_equal
.c817  20 a6 ca   jsr $caa6        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.c81a  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.c81c  49 ff      eor #$ff         	EOR	#$FF			; invert it
.c81e  a8         tay              	TAY				; copy it
.c81f  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.c821  49 ff      eor #$ff         	EOR	#$FF			; invert it
.c823  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c826                              lab_1be7
.c826  c9 af      cmp #$af         	CMP	#TK_FN		; compare with token for FN
.c828  d0 03      bne $c82d        	BNE	LAB_1BEE		; branch if not token for FN
.c82a  4c b4 cc   jmp $ccb4        	JMP	LAB_201E		; go evaluate FNx
.c82d                              lab_1bee
.c82d  e9 c4      sbc #$c4         	SBC	#TK_SGN		; subtract with token for SGN
.c82f  b0 19      bcs $c84a        	BCS	LAB_1C27		; if a function token go do it
.c831  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; else do syntax error
.c834                              lab_1c11
.c834  a0 1e      ldy #$1e         	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
.c836                              lab_1c13
.c836  68         pla              	PLA				; dump return address low byte
.c837  68         pla              	PLA				; dump return address high byte
.c838  4c 3a c7   jmp $c73a        	JMP	LAB_1B1D		; execute function then continue evaluation
.c83b                              lab_1c18
.c83b  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get (var) address
.c83e  85 ae      sta $ae          	STA	FAC1_2		; save address low byte in FAC1 mantissa2
.c840  84 af      sty $af          	STY	FAC1_3		; save address high byte in FAC1 mantissa3
.c842  a6 5f      ldx $5f          	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
.c844  30 03      bmi $c849        	BMI	LAB_1C25		; if string then return (does RTS)
.c846                              lab_1c24
.c846  4c 7d d4   jmp $d47d        	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
.c849                              lab_1c25
.c849  60         rts              	RTS
.c84a                              lab_1c27
.c84a  0a         asl              	ASL				; *2 (2 bytes per function address)
.c84b  a8         tay              	TAY				; copy to index
.c84c  b9 a6 de   lda $dea6,y      	LDA	LAB_FTBM,Y		; get function jump vector high byte
.c84f  48         pha              	PHA				; push functions jump vector high byte
.c850  b9 a5 de   lda $dea5,y      	LDA	LAB_FTBL,Y		; get function jump vector low byte
.c853  48         pha              	PHA				; push functions jump vector low byte
.c854  b9 60 de   lda $de60,y      	LDA	LAB_FTPM,Y		; get function pre process vector high byte
.c857  f0 05      beq $c85e        	BEQ	LAB_1C56		; skip pre process if null vector
.c859  48         pha              	PHA				; push functions pre process vector high byte
.c85a  b9 5f de   lda $de5f,y      	LDA	LAB_FTPL,Y		; get function pre process vector low byte
.c85d  48         pha              	PHA				; push functions pre process vector low byte
.c85e                              lab_1c56
.c85e  60         rts              	RTS				; do function, or pre process, call
.c85f                              lab_ppfs
.c85f  20 ec c7   jsr $c7ec        	JSR	LAB_1BF7		; process expression in parenthesis
.c862  4c d2 c6   jmp $c6d2        	JMP	LAB_CTST		; check if source is string then do function,
.c865                              lab_ppfn
.c865  20 ec c7   jsr $c7ec        	JSR	LAB_1BF7		; process expression in parenthesis
.c868  4c d0 c6   jmp $c6d0        	JMP	LAB_CTNM		; check if source is numeric then do function,
.c86b                              lab_ppbi
.c86b  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.c86d  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; increment and scan memory then do function
.c870                              lab_lrms
.c870  20 e9 c6   jsr $c6e9        	JSR	LAB_EVEZ		; evaluate (should be string) expression
.c873  20 fe c7   jsr $c7fe        	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
.c876  20 d2 c6   jsr $c6d2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.c879  68         pla              	PLA				; get function jump vector low byte
.c87a  aa         tax              	TAX				; save functions jump vector low byte
.c87b  68         pla              	PLA				; get function jump vector high byte
.c87c  a8         tay              	TAY				; save functions jump vector high byte
.c87d  a5 af      lda $af          	LDA	des_ph		; get descriptor pointer high byte
.c87f  48         pha              	PHA				; push string pointer high byte
.c880  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.c882  48         pha              	PHA				; push string pointer low byte
.c883  98         tya              	TYA				; get function jump vector high byte back
.c884  48         pha              	PHA				; save functions jump vector high byte
.c885  8a         txa              	TXA				; get function jump vector low byte back
.c886  48         pha              	PHA				; save functions jump vector low byte
.c887  20 8c d0   jsr $d08c        	JSR	LAB_GTBY		; get byte parameter
.c88a  8a         txa              	TXA				; copy byte parameter to A
.c88b  60         rts              	RTS				; go do function
.c88c                              lab_bhss
.c88c  20 e9 c6   jsr $c6e9        	JSR	LAB_EVEZ		; process expression
.c88f  20 d0 c6   jsr $c6d0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.c892  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.c894  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.c896  b0 20      bcs $c8b8        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
.c898  20 50 d5   jsr $d550        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.c89b  a2 02      ldx #$02         	LDX	#$02			; 3 bytes to do
.c89d                              lab_cfac
.c89d  b5 ad      lda $ad,x        	LDA	FAC1_1,X		; get byte from FAC1
.c89f  95 11      sta $11,x        	STA	nums_1,X		; save byte to temp
.c8a1  ca         dex              	DEX				; decrement index
.c8a2  10 f9      bpl $c89d        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
.c8a4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.c8a7  a2 00      ldx #$00         	LDX	#$00			; set default to no leading "0"s
.c8a9  c9 29      cmp #$29         	CMP	#")"			; compare with close bracket
.c8ab  f0 0a      beq $c8b7        	BEQ	LAB_1C54		; if ")" go do rest of function
.c8ad  20 de d0   jsr $d0de        	JSR	LAB_SCGB		; scan for "," and get byte
.c8b0  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get last byte back
.c8b3  c9 29      cmp #$29         	CMP	#")"			; is next character )
.c8b5  d0 01      bne $c8b8        	BNE	LAB_BHER		; if not ")" go do error
.c8b7                              lab_1c54
.c8b7  60         rts              	RTS				; else do function
.c8b8                              lab_bher
.c8b8  4c 29 cb   jmp $cb29        	JMP	LAB_FCER		; do function call error then warm start
.c8bb                              lab_eor
.c8bb  20 e2 c8   jsr $c8e2        	JSR	GetFirst		; get first integer expression (no sign check)
.c8be  45 5b      eor $5b          	EOR	XOAw_l		; EOR with expression 1 low byte
.c8c0  a8         tay              	TAY				; save in Y
.c8c1  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.c8c3  45 5c      eor $5c          	EOR	XOAw_h		; EOR with expression 1 high byte
.c8c5  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c8c8                              lab_or
.c8c8  20 e2 c8   jsr $c8e2        	JSR	GetFirst		; get first integer expression (no sign check)
.c8cb  05 5b      ora $5b          	ORA	XOAw_l		; OR with expression 1 low byte
.c8cd  a8         tay              	TAY				; save in Y
.c8ce  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.c8d0  05 5c      ora $5c          	ORA	XOAw_h		; OR with expression 1 high byte
.c8d2  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c8d5                              lab_and
.c8d5  20 e2 c8   jsr $c8e2        	JSR	GetFirst		; get first integer expression (no sign check)
.c8d8  25 5b      and $5b          	AND	XOAw_l		; AND with expression 1 low byte
.c8da  a8         tay              	TAY				; save in Y
.c8db  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.c8dd  25 5c      and $5c          	AND	XOAw_h		; AND with expression 1 high byte
.c8df  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c8e2                              getfirst
.c8e2  20 a6 ca   jsr $caa6        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.c8e5  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.c8e7  85 5c      sta $5c          	STA	XOAw_h		; save it
.c8e9  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.c8eb  85 5b      sta $5b          	STA	XOAw_l		; save it
.c8ed  20 c3 d1   jsr $d1c3        	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.c8f0  20 a6 ca   jsr $caa6        	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
.c8f3  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.c8f5                              lab_1c95
.c8f5  60         rts              	RTS
.c8f6                              lab_lthan
.c8f6  20 d3 c6   jsr $c6d3        	JSR	LAB_CKTM		; type match check, set C for string
.c8f9  b0 13      bcs $c90e        	BCS	LAB_1CAE		; branch if string
.c8fb  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.c8fd  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.c8ff  25 b4      and $b4          	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
.c901  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.c903  a9 b3      lda #$b3         	LDA	#<FAC2_e		; set pointer low byte to FAC2
.c905  a0 00      ldy #$00         	LDY	#>FAC2_e		; set pointer high byte to FAC2
.c907  20 17 d5   jsr $d517        	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
.c90a  aa         tax              	TAX				; copy result
.c90b  4c 3f c9   jmp $c93f        	JMP	LAB_1CE1		; go evaluate result
.c90e                              lab_1cae
.c90e  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.c910  c6 9b      dec $9b          	DEC	comp_f		; clear < bit in compare function flag
.c912  20 3e cf   jsr $cf3e        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.c915  85 ac      sta $ac          	STA	str_ln		; save length
.c917  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.c919  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.c91b  a5 b5      lda $b5          	LDA	FAC2_2		; get descriptor pointer low byte
.c91d  a4 b6      ldy $b6          	LDY	FAC2_3		; get descriptor pointer high byte
.c91f  20 42 cf   jsr $cf42        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.c922  86 b5      stx $b5          	STX	FAC2_2		; save string pointer low byte
.c924  84 b6      sty $b6          	STY	FAC2_3		; save string pointer high byte
.c926  aa         tax              	TAX				; copy length
.c927  38         sec              	SEC				; set carry for subtract
.c928  e5 ac      sbc $ac          	SBC	str_ln		; subtract string 1 length
.c92a  f0 08      beq $c934        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
.c92c  a9 01      lda #$01         	LDA	#$01			; set str 1 length > string 2 length
.c92e  90 04      bcc $c934        	BCC	LAB_1CD6		; branch if so
.c930  a6 ac      ldx $ac          	LDX	str_ln		; get string 1 length
.c932  a9 ff      lda #$ff         	LDA	#$FF			; set str 1 length < string 2 length
.c934                              lab_1cd6
.c934  85 b0      sta $b0          	STA	FAC1_s		; save length compare
.c936  a0 ff      ldy #$ff         	LDY	#$FF			; set index
.c938  e8         inx              	INX				; adjust for loop
.c939                              lab_1cdb
.c939  c8         iny              	INY				; increment index
.c93a  ca         dex              	DEX				; decrement count
.c93b  d0 07      bne $c944        	BNE	LAB_1CE6		; branch if still bytes to do
.c93d  a6 b0      ldx $b0          	LDX	FAC1_s		; get length compare back
.c93f                              lab_1ce1
.c93f  30 0f      bmi $c950        	BMI	LAB_1CF2		; branch if str 1 < str 2
.c941  18         clc              	CLC				; flag str 1 <= str 2
.c942  90 0c      bcc $c950        	BCC	LAB_1CF2		; go evaluate result
.c944                              lab_1ce6
.c944  b1 b5      lda ($b5),y      	LDA	(FAC2_2),Y		; get string 2 byte
.c946  d1 ad      cmp ($ad),y      	CMP	(FAC1_1),Y		; compare with string 1 byte
.c948  f0 ef      beq $c939        	BEQ	LAB_1CDB		; loop if bytes =
.c94a  a2 ff      ldx #$ff         	LDX	#$FF			; set str 1 < string 2
.c94c  b0 02      bcs $c950        	BCS	LAB_1CF2		; branch if so
.c94e  a2 01      ldx #$01         	LDX	#$01			;  set str 1 > string 2
.c950                              lab_1cf2
.c950  e8         inx              	INX				; x = 0, 1 or 2
.c951  8a         txa              	TXA				; copy to A
.c952  2a         rol              	ROL				; *2 (1, 2 or 4)
.c953  25 63      and $63          	AND	Cflag			; AND with comparison evaluation flag
.c955  f0 02      beq $c959        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
.c957  a9 ff      lda #$ff         	LDA	#$FF			; else set result true
.c959                              lab_1cfb
.c959  4c fa d4   jmp $d4fa        	JMP	LAB_27DB		; save A as integer byte and return
.c95c                              lab_1cfe
.c95c  20 fe c7   jsr $c7fe        	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
.c95f                              lab_dim
.c95f  aa         tax              	TAX				; copy "DIM" flag to X
.c960  20 af c9   jsr $c9af        	JSR	LAB_1D10		; search for variable
.c963  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.c966  d0 f4      bne $c95c        	BNE	LAB_1CFE		; scan for "," and loop if not null
.c968  60         rts              	RTS
.c969                              lab_lshift
.c969  20 9f c9   jsr $c99f        	JSR	GetPair		; get integer expression and byte (no sign check)
.c96c  a5 ae      lda $ae          	LDA	FAC1_2		; get expression high byte
.c96e  a6 78      ldx $78          	LDX	TempB			; get shift count
.c970  f0 22      beq $c994        	BEQ	NoShift		; branch if zero
.c972  e0 10      cpx #$10         	CPX	#$10			; compare bit count with 16d
.c974  b0 23      bcs $c999        	BCS	TooBig		; branch if >=
.c976                              ls_loop
.c976  06 af      asl $af          	ASL	FAC1_3		; shift low byte
.c978  2a         rol              	ROL				; shift high byte
.c979  ca         dex              	DEX				; decrement bit count
.c97a  d0 fa      bne $c976        	BNE	Ls_loop		; loop if shift not complete
.c97c  a4 af      ldy $af          	LDY	FAC1_3		; get expression low byte
.c97e  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c981                              lab_rshift
.c981  20 9f c9   jsr $c99f        	JSR	GetPair		; get integer expression and byte (no sign check)
.c984  a5 ae      lda $ae          	LDA	FAC1_2		; get expression high byte
.c986  a6 78      ldx $78          	LDX	TempB			; get shift count
.c988  f0 0a      beq $c994        	BEQ	NoShift		; branch if zero
.c98a  e0 10      cpx #$10         	CPX	#$10			; compare bit count with 16d
.c98c  b0 0b      bcs $c999        	BCS	TooBig		; branch if >=
.c98e                              rs_loop
.c98e  4a         lsr              	LSR				; shift high byte
.c98f  66 af      ror $af          	ROR	FAC1_3		; shift low byte
.c991  ca         dex              	DEX				; decrement bit count
.c992  d0 fa      bne $c98e        	BNE	Rs_loop		; loop if shift not complete
.c994                              noshift
.c994  a4 af      ldy $af          	LDY	FAC1_3		; get expression low byte
.c996  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c999                              toobig
.c999  a9 00      lda #$00         	LDA	#$00			; clear high byte
.c99b  a8         tay              	TAY				; copy to low byte
.c99c  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.c99f                              getpair
.c99f  20 8f d0   jsr $d08f        	JSR	LAB_EVBY		; evaluate byte expression, result in X
.c9a2  86 78      stx $78          	STX	TempB			; save it
.c9a4  20 c3 d1   jsr $d1c3        	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
.c9a7  4c a6 ca   jmp $caa6        	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
.c9aa                              lab_gvar
.c9aa  a2 00      ldx #$00         	LDX	#$00			; set DIM flag = $00
.c9ac  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory (1st character)
.c9af                              lab_1d10
.c9af  86 5e      stx $5e          	STX	Defdim		; save DIM flag
.c9b1                              lab_1d12
.c9b1  85 93      sta $93          	STA	Varnm1		; save 1st character
.c9b3  29 7f      and #$7f         	AND	#$7F			; clear FN flag bit
.c9b5  20 1e ca   jsr $ca1e        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.c9b8  b0 03      bcs $c9bd        	BCS	LAB_1D1F		; branch if ok
.c9ba  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; else syntax error then warm start
.c9bd                              lab_1d1f
.c9bd  a2 00      ldx #$00         	LDX	#$00			; clear 2nd character temp
.c9bf  86 5f      stx $5f          	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
.c9c1  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (2nd character)
.c9c4  90 05      bcc $c9cb        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
.c9c6  20 1e ca   jsr $ca1e        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.c9c9  90 0b      bcc $c9d6        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
.c9cb                              lab_1d2d
.c9cb  aa         tax              	TAX				; copy 2nd character
.c9cc                              lab_1d2e
.c9cc  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (3rd character)
.c9cf  90 fb      bcc $c9cc        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
.c9d1  20 1e ca   jsr $ca1e        	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
.c9d4  b0 f6      bcs $c9cc        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
.c9d6                              lab_1d38
.c9d6  c9 24      cmp #$24         	CMP	#"$"			; compare with "$"
.c9d8  d0 0b      bne $c9e5        	BNE	LAB_1D47		; branch if not string
.c9da  a9 ff      lda #$ff         	LDA	#$FF			; set data type = string
.c9dc  85 5f      sta $5f          	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
.c9de  8a         txa              	TXA				; get 2nd character back
.c9df  09 80      ora #$80         	ORA	#$80			; set top bit (indicate string var)
.c9e1  aa         tax              	TAX				; copy back to 2nd character temp
.c9e2  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.c9e5                              lab_1d47
.c9e5  86 94      stx $94          	STX	Varnm2		; save 2nd character
.c9e7  05 61      ora $61          	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
.c9e9  c9 28      cmp #$28         	CMP	#"("			; compare with "("
.c9eb  d0 03      bne $c9f0        	BNE	LAB_1D53		; branch if not "("
.c9ed  4c b8 ca   jmp $cab8        	JMP	LAB_1E17		; go find, or make, array
.c9f0                              lab_1d53
.c9f0  a9 00      lda #$00         	LDA	#$00			; clear A
.c9f2  85 61      sta $61          	STA	Sufnxf		; clear subscript/FNX flag
.c9f4  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.c9f6  a6 7c      ldx $7c          	LDX	Svarh			; get start of vars high byte
.c9f8  a0 00      ldy #$00         	LDY	#$00			; clear index
.c9fa                              lab_1d5d
.c9fa  86 ab      stx $ab          	STX	Vrschh		; save search address high byte
.c9fc                              lab_1d5f
.c9fc  85 aa      sta $aa          	STA	Vrschl		; save search address low byte
.c9fe  e4 7e      cpx $7e          	CPX	Sarryh		; compare high address with var space end
.ca00  d0 04      bne $ca06        	BNE	LAB_1D69		; skip next compare if <>
.ca02  c5 7d      cmp $7d          	CMP	Sarryl		; compare low address with var space end
.ca04  f0 2c      beq $ca32        	BEQ	LAB_1D8B		; if not found go make new var
.ca06                              lab_1d69
.ca06  a5 93      lda $93          	LDA	Varnm1		; get 1st character of var to find
.ca08  d1 aa      cmp ($aa),y      	CMP	(Vrschl),Y		; compare with variable name 1st character
.ca0a  d0 08      bne $ca14        	BNE	LAB_1D77		; branch if no match
.ca0c  a5 94      lda $94          	LDA	Varnm2		; get 2nd character of var to find
.ca0e  c8         iny              	INY				; index to point to variable name 2nd character
.ca0f  d1 aa      cmp ($aa),y      	CMP	(Vrschl),Y		; compare with variable name 2nd character
.ca11  f0 69      beq $ca7c        	BEQ	LAB_1DD7		; branch if match (found var)
.ca13  88         dey              	DEY				; else decrement index (now = $00)
.ca14                              lab_1d77
.ca14  18         clc              	CLC				; clear carry for add
.ca15  a5 aa      lda $aa          	LDA	Vrschl		; get search address low byte
.ca17  69 06      adc #$06         	ADC	#$06			; +6 (offset to next var name)
.ca19  90 e1      bcc $c9fc        	BCC	LAB_1D5F		; loop if no overflow to high byte
.ca1b  e8         inx              	INX				; else increment high byte
.ca1c  d0 dc      bne $c9fa        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
.ca1e                              lab_casc
.ca1e  c9 61      cmp #$61         	CMP	#"a"			; compare with "a"
.ca20  b0 0a      bcs $ca2c        	BCS	LAB_1D83		; go check <"z"+1
.ca22                              lab_1d82
.ca22  c9 41      cmp #$41         	CMP	#"A"			; compare with "A"
.ca24  90 05      bcc $ca2b        	BCC	LAB_1D8A		; exit if less
.ca26  e9 5b      sbc #$5b         	SBC	#$5B			; subtract "Z"+1
.ca28  38         sec              	SEC				; set carry
.ca29  e9 a5      sbc #$a5         	SBC	#$A5			; subtract $A5 (restore byte)
.ca2b                              lab_1d8a
.ca2b  60         rts              	RTS
.ca2c                              lab_1d83
.ca2c  e9 7b      sbc #$7b         	SBC	#$7B			; subtract "z"+1
.ca2e  38         sec              	SEC				; set carry
.ca2f  e9 85      sbc #$85         	SBC	#$85			; subtract $85 (restore byte)
.ca31  60         rts              	RTS
.ca32                              lab_1d8b
.ca32  68         pla              	PLA				; pop return address low byte
.ca33  48         pha              	PHA				; push return address low byte
.ca34  c9 3d      cmp #$3d         	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
.ca36  d0 05      bne $ca3d        	BNE	LAB_1D98		; if not get (var) go create new var
.ca38  a9 e1      lda #$e1         	LDA	#<LAB_1D96		; low byte point to $00,$00
.ca3a  a0 dd      ldy #$dd         	LDY	#>LAB_1D96		; high byte point to $00,$00
.ca3c  60         rts              	RTS
.ca3d                              lab_1d98
.ca3d  a5 7d      lda $7d          	LDA	Sarryl		; get var mem end low byte
.ca3f  a4 7e      ldy $7e          	LDY	Sarryh		; get var mem end high byte
.ca41  85 aa      sta $aa          	STA	Ostrtl		; save old block start low byte
.ca43  84 ab      sty $ab          	STY	Ostrth		; save old block start high byte
.ca45  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.ca47  a4 80      ldy $80          	LDY	Earryh		; get array mem end high byte
.ca49  85 a6      sta $a6          	STA	Obendl		; save old block end low byte
.ca4b  84 a7      sty $a7          	STY	Obendh		; save old block end high byte
.ca4d  18         clc              	CLC				; clear carry for add
.ca4e  69 06      adc #$06         	ADC	#$06			; +6 (space for one var)
.ca50  90 01      bcc $ca53        	BCC	LAB_1DAE		; branch if no overflow to high byte
.ca52  c8         iny              	INY				; else increment high byte
.ca53                              lab_1dae
.ca53  85 a4      sta $a4          	STA	Nbendl		; set new block end low byte
.ca55  84 a5      sty $a5          	STY	Nbendh		; set new block end high byte
.ca57  20 c1 bc   jsr $bcc1        	JSR	LAB_11CF		; open up space in memory
.ca5a  a5 a4      lda $a4          	LDA	Nbendl		; get new start low byte
.ca5c  a4 a5      ldy $a5          	LDY	Nbendh		; get new start high byte (-$100)
.ca5e  c8         iny              	INY				; correct high byte
.ca5f  85 7d      sta $7d          	STA	Sarryl		; save new var mem end low byte
.ca61  84 7e      sty $7e          	STY	Sarryh		; save new var mem end high byte
.ca63  a0 00      ldy #$00         	LDY	#$00			; clear index
.ca65  a5 93      lda $93          	LDA	Varnm1		; get var name 1st character
.ca67  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; save var name 1st character
.ca69  c8         iny              	INY				; increment index
.ca6a  a5 94      lda $94          	LDA	Varnm2		; get var name 2nd character
.ca6c  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; save var name 2nd character
.ca6e  a9 00      lda #$00         	LDA	#$00			; clear A
.ca70  c8         iny              	INY				; increment index
.ca71  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.ca73  c8         iny              	INY				; increment index
.ca74  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.ca76  c8         iny              	INY				; increment index
.ca77  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.ca79  c8         iny              	INY				; increment index
.ca7a  91 aa      sta ($aa),y      	STA	(Vrschl),Y		; initialise var byte
.ca7c                              lab_1dd7
.ca7c  a5 aa      lda $aa          	LDA	Vrschl		; get var address low byte
.ca7e  18         clc              	CLC				; clear carry for add
.ca7f  69 02      adc #$02         	ADC	#$02			; +2 (offset past var name bytes)
.ca81  a4 ab      ldy $ab          	LDY	Vrschh		; get var address high byte
.ca83  90 01      bcc $ca86        	BCC	LAB_1DE1		; branch if no overflow from add
.ca85  c8         iny              	INY				; else increment high byte
.ca86                              lab_1de1
.ca86  85 95      sta $95          	STA	Cvaral		; save current var address low byte
.ca88  84 96      sty $96          	STY	Cvarah		; save current var address high byte
.ca8a  60         rts              	RTS
.ca8b                              lab_1de6
.ca8b  a5 5d      lda $5d          	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
.ca8d  0a         asl              	ASL				; *2 (also clears the carry !)
.ca8e  69 05      adc #$05         	ADC	#$05			; +5 (result is 7, 9 or 11 here)
.ca90  65 aa      adc $aa          	ADC	Astrtl		; add array start pointer low byte
.ca92  a4 ab      ldy $ab          	LDY	Astrth		; get array pointer high byte
.ca94  90 01      bcc $ca97        	BCC	LAB_1DF2		; branch if no overflow
.ca96  c8         iny              	INY				; else increment high byte
.ca97                              lab_1df2
.ca97  85 a4      sta $a4          	STA	Adatal		; save array data pointer low byte
.ca99  84 a5      sty $a5          	STY	Adatah		; save array data pointer high byte
.ca9b  60         rts              	RTS
.ca9c                              lab_evin
.ca9c  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.ca9f  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.caa2                              lab_evpi
.caa2  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.caa4  30 0d      bmi $cab3        	BMI	LAB_1E12		; do function call error if -ve
.caa6                              lab_evir
.caa6  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.caa8  c9 90      cmp #$90         	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
.caaa  90 09      bcc $cab5        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
.caac  a9 e8      lda #$e8         	LDA	#<LAB_1DF7		; set pointer low byte to -32768
.caae  a0 dd      ldy #$dd         	LDY	#>LAB_1DF7		; set pointer high byte to -32768
.cab0  20 17 d5   jsr $d517        	JSR	LAB_27F8		; compare FAC1 with (AY)
.cab3                              lab_1e12
.cab3  d0 74      bne $cb29        	BNE	LAB_FCER		; if <> do function call error then warm start
.cab5                              lab_1e14
.cab5  4c 50 d5   jmp $d550        	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
.cab8                              lab_1e17
.cab8  a5 5e      lda $5e          	LDA	Defdim		; get DIM flag
.caba  48         pha              	PHA				; push it
.cabb  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.cabd  48         pha              	PHA				; push it
.cabe  a0 00      ldy #$00         	LDY	#$00			; clear dimensions count
.cac0                              lab_1e1f
.cac0  98         tya              	TYA				; copy dimensions count
.cac1  48         pha              	PHA				; save it
.cac2  a5 94      lda $94          	LDA	Varnm2		; get array name 2nd byte
.cac4  48         pha              	PHA				; save it
.cac5  a5 93      lda $93          	LDA	Varnm1		; get array name 1st byte
.cac7  48         pha              	PHA				; save it
.cac8  20 9c ca   jsr $ca9c        	JSR	LAB_EVIN		; evaluate integer expression
.cacb  68         pla              	PLA				; pull array name 1st byte
.cacc  85 93      sta $93          	STA	Varnm1		; restore array name 1st byte
.cace  68         pla              	PLA				; pull array name 2nd byte
.cacf  85 94      sta $94          	STA	Varnm2		; restore array name 2nd byte
.cad1  68         pla              	PLA				; pull dimensions count
.cad2  a8         tay              	TAY				; restore it
.cad3  ba         tsx              	TSX				; copy stack pointer
.cad4  bd 02 01   lda $0102,x      	LDA	LAB_STAK+2,X	; get DIM flag
.cad7  48         pha              	PHA				; push it
.cad8  bd 01 01   lda $0101,x      	LDA	LAB_STAK+1,X	; get data type flag
.cadb  48         pha              	PHA				; push it
.cadc  a5 ae      lda $ae          	LDA	FAC1_2		; get this dimension size high byte
.cade  9d 02 01   sta $0102,x      	STA	LAB_STAK+2,X	; stack before flag bytes
.cae1  a5 af      lda $af          	LDA	FAC1_3		; get this dimension size low byte
.cae3  9d 01 01   sta $0101,x      	STA	LAB_STAK+1,X	; stack before flag bytes
.cae6  c8         iny              	INY				; increment dimensions count
.cae7  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.caea  c9 2c      cmp #$2c         	CMP	#","			; compare with ","
.caec  f0 d2      beq $cac0        	BEQ	LAB_1E1F		; if found go do next dimension
.caee  84 5d      sty $5d          	STY	Dimcnt		; store dimensions count
.caf0  20 ef c7   jsr $c7ef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.caf3  68         pla              	PLA				; pull data type flag
.caf4  85 5f      sta $5f          	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
.caf6  68         pla              	PLA				; pull DIM flag
.caf7  85 5e      sta $5e          	STA	Defdim		; restore DIM flag
.caf9  a6 7d      ldx $7d          	LDX	Sarryl		; get array mem start low byte
.cafb  a5 7e      lda $7e          	LDA	Sarryh		; get array mem start high byte
.cafd                              lab_1e5c
.cafd  86 aa      stx $aa          	STX	Astrtl		; save as array start pointer low byte
.caff  85 ab      sta $ab          	STA	Astrth		; save as array start pointer high byte
.cb01  c5 80      cmp $80          	CMP	Earryh		; compare with array mem end high byte
.cb03  d0 04      bne $cb09        	BNE	LAB_1E68		; branch if not reached array mem end
.cb05  e4 7f      cpx $7f          	CPX	Earryl		; else compare with array mem end low byte
.cb07  f0 39      beq $cb42        	BEQ	LAB_1EA1		; go build array if not found
.cb09                              lab_1e68
.cb09  a0 00      ldy #$00         	LDY	#$00			; clear index
.cb0b  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array name first byte
.cb0d  c8         iny              	INY				; increment index to second name byte
.cb0e  c5 93      cmp $93          	CMP	Varnm1		; compare with this array name first byte
.cb10  d0 06      bne $cb18        	BNE	LAB_1E77		; branch if no match
.cb12  a5 94      lda $94          	LDA	Varnm2		; else get this array name second byte
.cb14  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array name second byte
.cb16  f0 16      beq $cb2e        	BEQ	LAB_1E8D		; array found so branch
.cb18                              lab_1e77
.cb18  c8         iny              	INY				; increment index
.cb19  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array size low byte
.cb1b  18         clc              	CLC				; clear carry for add
.cb1c  65 aa      adc $aa          	ADC	Astrtl		; add array start pointer low byte
.cb1e  aa         tax              	TAX				; copy low byte to X
.cb1f  c8         iny              	INY				; increment index
.cb20  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array size high byte
.cb22  65 ab      adc $ab          	ADC	Astrth		; add array mem pointer high byte
.cb24  90 d7      bcc $cafd        	BCC	LAB_1E5C		; if no overflow go check next array
.cb26                              lab_1e85
.cb26  a2 10      ldx #$10         	LDX	#$10			; error code $10 ("Array bounds" error)

>cb28  2c                          	.byte	$2C			; makes next bit BIT LAB_08A2
.cb29                              lab_fcer

.cb29  a2 08      ldx #$08         	LDX	#$08			; error code $08 ("Function call" error)
.cb2b                              lab_1e8a
.cb2b  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.cb2e                              lab_1e8d
.cb2e  a2 12      ldx #$12         	LDX	#$12			; set error $12 ("Double dimension" error)
.cb30  a5 5e      lda $5e          	LDA	Defdim		; get DIM flag
.cb32  d0 f7      bne $cb2b        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
.cb34  20 8b ca   jsr $ca8b        	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.cb37  a5 5d      lda $5d          	LDA	Dimcnt		; get dimensions count
.cb39  a0 04      ldy #$04         	LDY	#$04			; set index to array's # of dimensions
.cb3b  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with no of dimensions
.cb3d  d0 e7      bne $cb26        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
.cb3f  4c c5 cb   jmp $cbc5        	JMP	LAB_1F28		; found array so go get element
.cb42                              lab_1ea1
.cb42  20 8b ca   jsr $ca8b        	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
.cb45  20 0b bd   jsr $bd0b        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.cb48  a0 00      ldy #$00         	LDY	#$00			; clear Y (don't need to clear A)
.cb4a  84 bb      sty $bb          	STY	Aspth			; clear array data size high byte
.cb4c  a5 93      lda $93          	LDA	Varnm1		; get variable name 1st byte
.cb4e  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array name 1st byte
.cb50  c8         iny              	INY				; increment index
.cb51  a5 94      lda $94          	LDA	Varnm2		; get variable name 2nd byte
.cb53  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array name 2nd byte
.cb55  a5 5d      lda $5d          	LDA	Dimcnt		; get dimensions count
.cb57  a0 04      ldy #$04         	LDY	#$04			; index to dimension count
.cb59  84 ba      sty $ba          	STY	Asptl			; set array data size low byte (four bytes per element)
.cb5b  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; set array's dimensions count
.cb5d  18         clc              	CLC				; clear carry for add (clear on subsequent loops)
.cb5e                              lab_1ec0
.cb5e  a2 0b      ldx #$0b         	LDX	#$0B			; set default dimension value low byte
.cb60  a9 00      lda #$00         	LDA	#$00			; set default dimension value high byte
.cb62  24 5e      bit $5e          	BIT	Defdim		; test default DIM flag
.cb64  50 07      bvc $cb6d        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
.cb66  68         pla              	PLA				; else pull dimension value low byte
.cb67  69 01      adc #$01         	ADC	#$01			; +1 (allow for zeroeth element)
.cb69  aa         tax              	TAX				; copy low byte to X
.cb6a  68         pla              	PLA				; pull dimension value high byte
.cb6b  69 00      adc #$00         	ADC	#$00			; add carry from low byte
.cb6d                              lab_1ed0
.cb6d  c8         iny              	INY				; index to dimension value high byte
.cb6e  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save dimension value high byte
.cb70  c8         iny              	INY				; index to dimension value high byte
.cb71  8a         txa              	TXA				; get dimension value low byte
.cb72  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save dimension value low byte
.cb74  20 14 cc   jsr $cc14        	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.cb77  86 ba      stx $ba          	STX	Asptl			; save array data size low byte
.cb79  85 bb      sta $bb          	STA	Aspth			; save array data size high byte
.cb7b  a4 71      ldy $71          	LDY	ut1_pl		; restore index (saved by subroutine)
.cb7d  c6 5d      dec $5d          	DEC	Dimcnt		; decrement dimensions count
.cb7f  d0 dd      bne $cb5e        	BNE	LAB_1EC0		; loop while not = 0
.cb81  65 a5      adc $a5          	ADC	Adatah		; add size high byte to first element high byte
.cb83  b0 5d      bcs $cbe2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.cb85  85 a5      sta $a5          	STA	Adatah		; save end of array high byte
.cb87  a8         tay              	TAY				; copy end high byte to Y
.cb88  8a         txa              	TXA				; get array size low byte
.cb89  65 a4      adc $a4          	ADC	Adatal		; add array start low byte
.cb8b  90 03      bcc $cb90        	BCC	LAB_1EF3		; branch if no carry
.cb8d  c8         iny              	INY				; else increment end of array high byte
.cb8e  f0 52      beq $cbe2        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
.cb90                              lab_1ef3
.cb90  20 0b bd   jsr $bd0b        	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
.cb93  85 7f      sta $7f          	STA	Earryl		; save array mem end low byte
.cb95  84 80      sty $80          	STY	Earryh		; save array mem end high byte
.cb97  a9 00      lda #$00         	LDA	#$00			; clear byte for array clear
.cb99  e6 bb      inc $bb          	INC	Aspth			; increment array size high byte (now block count)
.cb9b  a4 ba      ldy $ba          	LDY	Asptl			; get array size low byte (now index to block)
.cb9d  f0 05      beq $cba4        	BEQ	LAB_1F07		; branch if low byte = $00
.cb9f                              lab_1f02
.cb9f  88         dey              	DEY				; decrement index (do 0 to n-1)
.cba0  91 a4      sta ($a4),y      	STA	(Adatal),Y		; zero byte
.cba2  d0 fb      bne $cb9f        	BNE	LAB_1F02		; loop until this block done
.cba4                              lab_1f07
.cba4  c6 a5      dec $a5          	DEC	Adatah		; decrement array pointer high byte
.cba6  c6 bb      dec $bb          	DEC	Aspth			; decrement block count high byte
.cba8  d0 f5      bne $cb9f        	BNE	LAB_1F02		; loop until all blocks done
.cbaa  e6 a5      inc $a5          	INC	Adatah		; correct for last loop
.cbac  38         sec              	SEC				; set carry for subtract
.cbad  a0 02      ldy #$02         	LDY	#$02			; index to array size low byte
.cbaf  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.cbb1  e5 aa      sbc $aa          	SBC	Astrtl		; subtract array start low byte
.cbb3  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array size low byte
.cbb5  c8         iny              	INY				; index to array size high byte
.cbb6  a5 80      lda $80          	LDA	Earryh		; get array mem end high byte
.cbb8  e5 ab      sbc $ab          	SBC	Astrth		; subtract array start high byte
.cbba  91 aa      sta ($aa),y      	STA	(Astrtl),Y		; save array size high byte
.cbbc  a5 5e      lda $5e          	LDA	Defdim		; get default DIM flag
.cbbe  d0 53      bne $cc13        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
.cbc0  c8         iny              	INY				; index to # of dimensions
.cbc1                              lab_1f24
.cbc1  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get array's dimension count
.cbc3  85 5d      sta $5d          	STA	Dimcnt		; save it
.cbc5                              lab_1f28
.cbc5  a9 00      lda #$00         	LDA	#$00			; clear byte
.cbc7  85 ba      sta $ba          	STA	Asptl			; clear array data pointer low byte
.cbc9                              lab_1f2c
.cbc9  85 bb      sta $bb          	STA	Aspth			; save array data pointer high byte
.cbcb  c8         iny              	INY				; increment index (point to array bound high byte)
.cbcc  68         pla              	PLA				; pull array index low byte
.cbcd  aa         tax              	TAX				; copy to X
.cbce  85 ae      sta $ae          	STA	FAC1_2		; save index low byte to FAC1 mantissa2
.cbd0  68         pla              	PLA				; pull array index high byte
.cbd1  85 af      sta $af          	STA	FAC1_3		; save index high byte to FAC1 mantissa3
.cbd3  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array bound high byte
.cbd5  90 0e      bcc $cbe5        	BCC	LAB_1F48		; branch if within bounds
.cbd7  d0 06      bne $cbdf        	BNE	LAB_1F42		; if outside bounds do array bounds error
.cbd9  c8         iny              	INY				; index to array bound low byte
.cbda  8a         txa              	TXA				; get array index low byte
.cbdb  d1 aa      cmp ($aa),y      	CMP	(Astrtl),Y		; compare with array bound low byte
.cbdd  90 07      bcc $cbe6        	BCC	LAB_1F49		; branch if within bounds
.cbdf                              lab_1f42
.cbdf  4c 26 cb   jmp $cb26        	JMP	LAB_1E85		; else do array bounds error
.cbe2                              lab_1f45
.cbe2  4c 3a bd   jmp $bd3a        	JMP	LAB_OMER		; do "Out of memory" error then warm start
.cbe5                              lab_1f48
.cbe5  c8         iny              	INY				; index to array bound low byte
.cbe6                              lab_1f49
.cbe6  a5 bb      lda $bb          	LDA	Aspth			; get array data pointer high byte
.cbe8  05 ba      ora $ba          	ORA	Asptl			; OR with array data pointer low byte
.cbea  f0 0a      beq $cbf6        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
.cbec  20 14 cc   jsr $cc14        	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
.cbef  8a         txa              	TXA				; get result low byte
.cbf0  65 ae      adc $ae          	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
.cbf2  aa         tax              	TAX				; save result low byte
.cbf3  98         tya              	TYA				; get result high byte
.cbf4  a4 71      ldy $71          	LDY	ut1_pl		; restore index
.cbf6                              lab_1f5a
.cbf6  65 af      adc $af          	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
.cbf8  86 ba      stx $ba          	STX	Asptl			; save array data pointer low byte
.cbfa  c6 5d      dec $5d          	DEC	Dimcnt		; decrement dimensions count
.cbfc  d0 cb      bne $cbc9        	BNE	LAB_1F2C		; loop if dimensions still to do
.cbfe  06 ba      asl $ba          	ASL	Asptl			; array data pointer low byte * 2
.cc00  2a         rol              	ROL				; array data pointer high byte * 2
.cc01  06 ba      asl $ba          	ASL	Asptl			; array data pointer low byte * 4
.cc03  2a         rol              	ROL				; array data pointer high byte * 4
.cc04  a8         tay              	TAY				; copy high byte
.cc05  a5 ba      lda $ba          	LDA	Asptl			; get low byte
.cc07  65 a4      adc $a4          	ADC	Adatal		; add array data start pointer low byte
.cc09  85 95      sta $95          	STA	Cvaral		; save as current var address low byte
.cc0b  98         tya              	TYA				; get high byte back
.cc0c  65 a5      adc $a5          	ADC	Adatah		; add array data start pointer high byte
.cc0e  85 96      sta $96          	STA	Cvarah		; save as current var address high byte
.cc10  a8         tay              	TAY				; copy high byte to Y
.cc11  a5 95      lda $95          	LDA	Cvaral		; get current var address low byte
.cc13                              lab_1f7b
.cc13  60         rts              	RTS
.cc14                              lab_1f7c
.cc14  84 71      sty $71          	STY	ut1_pl		; save index
.cc16  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get dimension size low byte
.cc18  85 76      sta $76          	STA	dims_l		; save dimension size low byte
.cc1a  88         dey              	DEY				; decrement index
.cc1b  b1 aa      lda ($aa),y      	LDA	(Astrtl),Y		; get dimension size high byte
.cc1d  85 77      sta $77          	STA	dims_h		; save dimension size high byte
.cc1f  a9 10      lda #$10         	LDA	#$10			; count = $10 (16 bit multiply)
.cc21  85 a8      sta $a8          	STA	numbit		; save bit count
.cc23  a2 00      ldx #$00         	LDX	#$00			; clear result low byte
.cc25  a0 00      ldy #$00         	LDY	#$00			; clear result high byte
.cc27                              lab_1f8f
.cc27  8a         txa              	TXA				; get result low byte
.cc28  0a         asl              	ASL				; *2
.cc29  aa         tax              	TAX				; save result low byte
.cc2a  98         tya              	TYA				; get result high byte
.cc2b  2a         rol              	ROL				; *2
.cc2c  a8         tay              	TAY				; save result high byte
.cc2d  b0 b3      bcs $cbe2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.cc2f  06 ba      asl $ba          	ASL	Asptl			; shift multiplier low byte
.cc31  26 bb      rol $bb          	ROL	Aspth			; shift multiplier high byte
.cc33  90 0b      bcc $cc40        	BCC	LAB_1FA8		; skip add if no carry
.cc35  18         clc              	CLC				; else clear carry for add
.cc36  8a         txa              	TXA				; get result low byte
.cc37  65 76      adc $76          	ADC	dims_l		; add dimension size low byte
.cc39  aa         tax              	TAX				; save result low byte
.cc3a  98         tya              	TYA				; get result high byte
.cc3b  65 77      adc $77          	ADC	dims_h		; add dimension size high byte
.cc3d  a8         tay              	TAY				; save result high byte
.cc3e  b0 a2      bcs $cbe2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
.cc40                              lab_1fa8
.cc40  c6 a8      dec $a8          	DEC	numbit		; decrement bit count
.cc42  d0 e3      bne $cc27        	BNE	LAB_1F8F		; loop until all done
.cc44  60         rts              	RTS
.cc45                              lab_fre
.cc45  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.cc47  10 03      bpl $cc4c        	BPL	LAB_1FB4		; branch if numeric
.cc49  20 3e cf   jsr $cf3e        	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
.cc4c                              lab_1fb4
.cc4c  20 df cd   jsr $cddf        	JSR	LAB_GARB		; go do garbage collection
.cc4f  38         sec              	SEC				; set carry for subtract
.cc50  a5 81      lda $81          	LDA	Sstorl		; get bottom of string space low byte
.cc52  e5 7f      sbc $7f          	SBC	Earryl		; subtract array mem end low byte
.cc54  a8         tay              	TAY				; copy result to Y
.cc55  a5 82      lda $82          	LDA	Sstorh		; get bottom of string space high byte
.cc57  e5 80      sbc $80          	SBC	Earryh		; subtract array mem end high byte
.cc59                              lab_ayfc
.cc59  46 5f      lsr $5f          	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
.cc5b  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.cc5d  84 ae      sty $ae          	STY	FAC1_2		; save FAC1 mantissa2
.cc5f  a2 90      ldx #$90         	LDX	#$90			; set exponent=2^16 (integer)
.cc61  4c 02 d5   jmp $d502        	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
.cc64                              lab_pos
.cc64  a4 0e      ldy $0e          	LDY	TPos			; get terminal position
.cc66                              lab_1fd0
.cc66  a9 00      lda #$00         	LDA	#$00			; clear high byte
.cc68  f0 ef      beq $cc59        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
.cc6a                              lab_ckrn
.cc6a  a6 88      ldx $88          	LDX	Clineh		; get current line high byte
.cc6c  e8         inx              	INX				; increment it
.cc6d  d0 a4      bne $cc13        	BNE	LAB_1F7B		; return if can continue not direct mode
.cc6f                              lab_1fd9
.cc6f  a2 16      ldx #$16         	LDX	#$16			; error code $16 ("Illegal direct" error)
.cc71                              lab_1fdb
.cc71  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; go do error #X, then warm start
.cc74                              lab_def
.cc74  20 a5 cc   jsr $cca5        	JSR	LAB_200B		; check FNx syntax
.cc77  85 9c      sta $9c          	STA	func_l		; save function pointer low byte
.cc79  84 9d      sty $9d          	STY	func_h		; save function pointer high byte
.cc7b  20 6a cc   jsr $cc6a        	JSR	LAB_CKRN		; check not Direct (back here if ok)
.cc7e  20 fa c7   jsr $c7fa        	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
.cc81  a9 80      lda #$80         	LDA	#$80			; set flag for FNx
.cc83  85 61      sta $61          	STA	Sufnxf		; save subscript/FNx flag
.cc85  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get (var) address
.cc88  20 d0 c6   jsr $c6d0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.cc8b  20 ef c7   jsr $c7ef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.cc8e  a9 c2      lda #$c2         	LDA	#TK_EQUAL		; get = token
.cc90  20 f1 c7   jsr $c7f1        	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
.cc93  a5 96      lda $96          	LDA	Cvarah		; get current var address high byte
.cc95  48         pha              	PHA				; push it
.cc96  a5 95      lda $95          	LDA	Cvaral		; get current var address low byte
.cc98  48         pha              	PHA				; push it
.cc99  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.cc9b  48         pha              	PHA				; push it
.cc9c  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.cc9e  48         pha              	PHA				; push it
.cc9f  20 8c c2   jsr $c28c        	JSR	LAB_DATA		; go perform DATA
.cca2  4c 14 cd   jmp $cd14        	JMP	LAB_207A		; put execute pointer and variable pointer into function
.cca5                              lab_200b
.cca5  a9 af      lda #$af         	LDA	#TK_FN		; get FN" token
.cca7  20 f1 c7   jsr $c7f1        	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
.ccaa  09 80      ora #$80         	ORA	#$80			; set FN flag bit
.ccac  85 61      sta $61          	STA	Sufnxf		; save FN flag so array variable test fails
.ccae  20 b1 c9   jsr $c9b1        	JSR	LAB_1D12		; search for FN variable
.ccb1  4c d0 c6   jmp $c6d0        	JMP	LAB_CTNM		; check if source is numeric and return, else do type
.ccb4                              lab_201e
.ccb4  20 a5 cc   jsr $cca5        	JSR	LAB_200B		; check FNx syntax
.ccb7  48         pha              	PHA				; push function pointer low byte
.ccb8  98         tya              	TYA				; copy function pointer high byte
.ccb9  48         pha              	PHA				; push function pointer high byte
.ccba  20 fa c7   jsr $c7fa        	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
.ccbd  20 e1 c6   jsr $c6e1        	JSR	LAB_EVEX		; evaluate expression
.ccc0  20 ef c7   jsr $c7ef        	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
.ccc3  20 d0 c6   jsr $c6d0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.ccc6  68         pla              	PLA				; pop function pointer high byte
.ccc7  85 9d      sta $9d          	STA	func_h		; restore it
.ccc9  68         pla              	PLA				; pop function pointer low byte
.ccca  85 9c      sta $9c          	STA	func_l		; restore it
.cccc  a2 20      ldx #$20         	LDX	#$20			; error code $20 ("Undefined function" error)
.ccce  a0 03      ldy #$03         	LDY	#$03			; index to variable pointer high byte
.ccd0  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get variable pointer high byte
.ccd2  f0 9d      beq $cc71        	BEQ	LAB_1FDB		; if zero go do undefined function error
.ccd4  85 96      sta $96          	STA	Cvarah		; save variable address high byte
.ccd6  88         dey              	DEY				; index to variable address low byte
.ccd7  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get variable address low byte
.ccd9  85 95      sta $95          	STA	Cvaral		; save variable address low byte
.ccdb  aa         tax              	TAX				; copy address low byte
.ccdc  c8         iny              	INY				; index to mantissa_3
.ccdd                              lab_2043
.ccdd  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get byte from variable
.ccdf  48         pha              	PHA				; stack it
.cce0  88         dey              	DEY				; decrement index
.cce1  10 fa      bpl $ccdd        	BPL	LAB_2043		; loop until variable stacked
.cce3  a4 96      ldy $96          	LDY	Cvarah		; get variable address high byte
.cce5  20 a7 d4   jsr $d4a7        	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
.cce8  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.ccea  48         pha              	PHA				; push it
.cceb  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.cced  48         pha              	PHA				; push it
.ccee  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get function execute pointer low byte
.ccf0  85 c3      sta $c3          	STA	Bpntrl		; save as BASIC execute pointer low byte
.ccf2  c8         iny              	INY				; index to high byte
.ccf3  b1 9c      lda ($9c),y      	LDA	(func_l),Y		; get function execute pointer high byte
.ccf5  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.ccf7  a5 96      lda $96          	LDA	Cvarah		; get variable address high byte
.ccf9  48         pha              	PHA				; push it
.ccfa  a5 95      lda $95          	LDA	Cvaral		; get variable address low byte
.ccfc  48         pha              	PHA				; push it
.ccfd  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.cd00  68         pla              	PLA				; pull variable address low byte
.cd01  85 9c      sta $9c          	STA	func_l		; save variable address low byte
.cd03  68         pla              	PLA				; pull variable address high byte
.cd04  85 9d      sta $9d          	STA	func_h		; save variable address high byte
.cd06  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.cd09  f0 03      beq $cd0e        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
.cd0b  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; else syntax error then warm start
.cd0e                              lab_2074
.cd0e  68         pla              	PLA				; pull BASIC execute pointer low byte
.cd0f  85 c3      sta $c3          	STA	Bpntrl		; restore BASIC execute pointer low byte
.cd11  68         pla              	PLA				; pull BASIC execute pointer high byte
.cd12  85 c4      sta $c4          	STA	Bpntrh		; restore BASIC execute pointer high byte
.cd14                              lab_207a
.cd14  a0 00      ldy #$00         	LDY	#$00			; clear index
.cd16  68         pla              	PLA				; pull BASIC execute pointer low byte
.cd17  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.cd19  c8         iny              	INY				; increment index
.cd1a  68         pla              	PLA				; pull BASIC execute pointer high byte
.cd1b  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.cd1d  c8         iny              	INY				; increment index
.cd1e  68         pla              	PLA				; pull current var address low byte
.cd1f  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.cd21  c8         iny              	INY				; increment index
.cd22  68         pla              	PLA				; pull current var address high byte
.cd23  91 9c      sta ($9c),y      	STA	(func_l),Y		; save to function
.cd25  60         rts              	RTS
.cd26                              lab_strs
.cd26  20 d0 c6   jsr $c6d0        	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
.cd29  20 95 d6   jsr $d695        	JSR	LAB_296E		; convert FAC1 to string
.cd2c  a9 f0      lda #$f0         	LDA	#<Decssp1		; set result string low pointer
.cd2e  a0 00      ldy #$00         	LDY	#>Decssp1		; set result string high pointer
.cd30  f0 12      beq $cd44        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
.cd32                              lab_209c
.cd32  a6 ae      ldx $ae          	LDX	des_pl		; get descriptor pointer low byte
.cd34  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.cd36  86 9e      stx $9e          	STX	des_2l		; save descriptor pointer low byte
.cd38  84 9f      sty $9f          	STY	des_2h		; save descriptor pointer high byte
.cd3a                              lab_mssp
.cd3a  20 ad cd   jsr $cdad        	JSR	LAB_2115		; make space in string memory for string A long
.cd3d  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.cd3f  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.cd41  85 ac      sta $ac          	STA	str_ln		; save length
.cd43  60         rts              	RTS
.cd44                              lab_20ae
.cd44  a2 22      ldx #$22         	LDX	#$22			; set terminator to "
.cd46  86 5b      stx $5b          	STX	Srchc			; set search character (terminator 1)
.cd48  86 5c      stx $5c          	STX	Asrch			; set terminator 2
.cd4a                              lab_20b4
.cd4a  85 b8      sta $b8          	STA	ssptr_l		; store string start low byte
.cd4c  84 b9      sty $b9          	STY	ssptr_h		; store string start high byte
.cd4e  85 ad      sta $ad          	STA	str_pl		; save string pointer low byte
.cd50  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.cd52  a0 ff      ldy #$ff         	LDY	#$FF			; set length to -1
.cd54                              lab_20be
.cd54  c8         iny              	INY				; increment length
.cd55  b1 b8      lda ($b8),y      	LDA	(ssptr_l),Y		; get byte from string
.cd57  f0 0c      beq $cd65        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
.cd59  c5 5b      cmp $5b          	CMP	Srchc			; compare with search character (terminator 1)
.cd5b  f0 04      beq $cd61        	BEQ	LAB_20CB		; branch if terminator
.cd5d  c5 5c      cmp $5c          	CMP	Asrch			; compare with terminator 2
.cd5f  d0 f3      bne $cd54        	BNE	LAB_20BE		; loop if not terminator 2
.cd61                              lab_20cb
.cd61  c9 22      cmp #$22         	CMP	#$22			; compare with "
.cd63  f0 01      beq $cd66        	BEQ	LAB_20D0		; branch if " (carry set if = !)
.cd65                              lab_20cf
.cd65  18         clc              	CLC				; clear carry for add (only if [EOL] terminated string)
.cd66                              lab_20d0
.cd66  84 ac      sty $ac          	STY	str_ln		; save length in FAC1 exponent
.cd68  98         tya              	TYA				; copy length to A
.cd69  65 b8      adc $b8          	ADC	ssptr_l		; add string start low byte
.cd6b  85 ba      sta $ba          	STA	Sendl			; save string end low byte
.cd6d  a6 b9      ldx $b9          	LDX	ssptr_h		; get string start high byte
.cd6f  90 01      bcc $cd72        	BCC	LAB_20DC		; branch if no low byte overflow
.cd71  e8         inx              	INX				; else increment high byte
.cd72                              lab_20dc
.cd72  86 bb      stx $bb          	STX	Sendh			; save string end high byte
.cd74  a5 b9      lda $b9          	LDA	ssptr_h		; get string start high byte
.cd76  c9 04      cmp #$04         	CMP	#>Ram_base		; compare with start of program memory
.cd78  b0 0b      bcs $cd85        	BCS	LAB_RTST		; branch if not in utility area
.cd7a  98         tya              	TYA				; copy length to A
.cd7b  20 32 cd   jsr $cd32        	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
.cd7e  a6 b8      ldx $b8          	LDX	ssptr_l		; get string start low byte
.cd80  a4 b9      ldy $b9          	LDY	ssptr_h		; get string start high byte
.cd82  20 1f cf   jsr $cf1f        	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
.cd85                              lab_rtst
.cd85  a6 65      ldx $65          	LDX	next_s		; get string stack pointer
.cd87  e0 71      cpx #$71         	CPX	#des_sk+$09		; compare with max+1
.cd89  d0 05      bne $cd90        	BNE	LAB_20F8		; branch if space on string stack
.cd8b  a2 1c      ldx #$1c         	LDX	#$1C			; error code $1C ("String too complex" error)
.cd8d                              lab_20f5
.cd8d  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.cd90                              lab_20f8
.cd90  a5 ac      lda $ac          	LDA	str_ln		; get string length
.cd92  95 00      sta $00,x        	STA	PLUS_0,X		; put on string stack
.cd94  a5 ad      lda $ad          	LDA	str_pl		; get string pointer low byte
.cd96  95 01      sta $01,x        	STA	PLUS_1,X		; put on string stack
.cd98  a5 ae      lda $ae          	LDA	str_ph		; get string pointer high byte
.cd9a  95 02      sta $02,x        	STA	PLUS_2,X		; put on string stack
.cd9c  a0 00      ldy #$00         	LDY	#$00			; clear Y
.cd9e  86 ae      stx $ae          	STX	des_pl		; save string descriptor pointer low byte
.cda0  84 af      sty $af          	STY	des_ph		; save string descriptor pointer high byte (always $00)
.cda2  88         dey              	DEY				; Y = $FF
.cda3  84 5f      sty $5f          	STY	Dtypef		; save data type flag, $FF=string
.cda5  86 66      stx $66          	STX	last_sl		; save old stack pointer (current top item)
.cda7  e8         inx              	INX				; update stack pointer
.cda8  e8         inx              	INX				; update stack pointer
.cda9  e8         inx              	INX				; update stack pointer
.cdaa  86 65      stx $65          	STX	next_s		; save new top item value
.cdac  60         rts              	RTS
.cdad                              lab_2115
.cdad  46 60      lsr $60          	LSR	Gclctd		; clear garbage collected flag (b7)
.cdaf                              lab_2117
.cdaf  48         pha              	PHA				; save string length
.cdb0  49 ff      eor #$ff         	EOR	#$FF			; complement it
.cdb2  38         sec              	SEC				; set carry for subtract (twos comp add)
.cdb3  65 81      adc $81          	ADC	Sstorl		; add bottom of string space low byte (subtract length)
.cdb5  a4 82      ldy $82          	LDY	Sstorh		; get bottom of string space high byte
.cdb7  b0 01      bcs $cdba        	BCS	LAB_2122		; skip decrement if no underflow
.cdb9  88         dey              	DEY				; decrement bottom of string space high byte
.cdba                              lab_2122
.cdba  c4 80      cpy $80          	CPY	Earryh		; compare with array mem end high byte
.cdbc  90 11      bcc $cdcf        	BCC	LAB_2137		; do out of memory error if less
.cdbe  d0 04      bne $cdc4        	BNE	LAB_212C		; if not = skip next test
.cdc0  c5 7f      cmp $7f          	CMP	Earryl		; compare with array mem end low byte
.cdc2  90 0b      bcc $cdcf        	BCC	LAB_2137		; do out of memory error if less
.cdc4                              lab_212c
.cdc4  85 81      sta $81          	STA	Sstorl		; save bottom of string space low byte
.cdc6  84 82      sty $82          	STY	Sstorh		; save bottom of string space high byte
.cdc8  85 83      sta $83          	STA	Sutill		; save string utility ptr low byte
.cdca  84 84      sty $84          	STY	Sutilh		; save string utility ptr high byte
.cdcc  aa         tax              	TAX				; copy low byte to X
.cdcd  68         pla              	PLA				; get string length back
.cdce  60         rts              	RTS
.cdcf                              lab_2137
.cdcf  a2 0c      ldx #$0c         	LDX	#$0C			; error code $0C ("Out of memory" error)
.cdd1  a5 60      lda $60          	LDA	Gclctd		; get garbage collected flag
.cdd3  30 b8      bmi $cd8d        	BMI	LAB_20F5		; if set then do error code X
.cdd5  20 df cd   jsr $cddf        	JSR	LAB_GARB		; else go do garbage collection
.cdd8  a9 80      lda #$80         	LDA	#$80			; flag for garbage collected
.cdda  85 60      sta $60          	STA	Gclctd		; set garbage collected flag
.cddc  68         pla              	PLA				; pull length
.cddd  d0 d0      bne $cdaf        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
.cddf                              lab_garb
.cddf  a6 85      ldx $85          	LDX	Ememl			; get end of mem low byte
.cde1  a5 86      lda $86          	LDA	Ememh			; get end of mem high byte
.cde3                              lab_214b
.cde3  86 81      stx $81          	STX	Sstorl		; set string storage low byte
.cde5  85 82      sta $82          	STA	Sstorh		; set string storage high byte
.cde7  a0 00      ldy #$00         	LDY	#$00			; clear index
.cde9  84 9d      sty $9d          	STY	garb_h		; clear working pointer high byte (flag no strings to move)
.cdeb  a5 7f      lda $7f          	LDA	Earryl		; get array mem end low byte
.cded  a6 80      ldx $80          	LDX	Earryh		; get array mem end high byte
.cdef  85 aa      sta $aa          	STA	Histrl		; save as highest string low byte
.cdf1  86 ab      stx $ab          	STX	Histrh		; save as highest string high byte
.cdf3  a9 68      lda #$68         	LDA	#des_sk		; set descriptor stack pointer
.cdf5  85 71      sta $71          	STA	ut1_pl		; save descriptor stack pointer low byte
.cdf7  84 72      sty $72          	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
.cdf9                              lab_2161
.cdf9  c5 65      cmp $65          	CMP	next_s		; compare with descriptor stack pointer
.cdfb  f0 05      beq $ce02        	BEQ	LAB_216A		; branch if =
.cdfd  20 63 ce   jsr $ce63        	JSR	LAB_21D7		; go garbage collect descriptor stack
.ce00  f0 f7      beq $cdf9        	BEQ	LAB_2161		; loop always
.ce02                              lab_216a
.ce02  06 a0      asl $a0          	ASL	g_step		; set step size = $06
.ce04  a5 7b      lda $7b          	LDA	Svarl			; get start of vars low byte
.ce06  a6 7c      ldx $7c          	LDX	Svarh			; get start of vars high byte
.ce08  85 71      sta $71          	STA	ut1_pl		; save as pointer low byte
.ce0a  86 72      stx $72          	STX	ut1_ph		; save as pointer high byte
.ce0c                              lab_2176
.ce0c  e4 7e      cpx $7e          	CPX	Sarryh		; compare start of arrays high byte
.ce0e  d0 04      bne $ce14        	BNE	LAB_217E		; branch if no high byte match
.ce10  c5 7d      cmp $7d          	CMP	Sarryl		; else compare start of arrays low byte
.ce12  f0 05      beq $ce19        	BEQ	LAB_2183		; branch if = var mem end
.ce14                              lab_217e
.ce14  20 5d ce   jsr $ce5d        	JSR	LAB_21D1		; go garbage collect strings
.ce17  f0 f3      beq $ce0c        	BEQ	LAB_2176		; loop always
.ce19                              lab_2183
.ce19  85 a4      sta $a4          	STA	Nbendl		; save start of arrays low byte as working pointer
.ce1b  86 a5      stx $a5          	STX	Nbendh		; save start of arrays high byte as working pointer
.ce1d  a9 04      lda #$04         	LDA	#$04			; set step size
.ce1f  85 a0      sta $a0          	STA	g_step		; save step size
.ce21                              lab_218b
.ce21  a5 a4      lda $a4          	LDA	Nbendl		; get pointer low byte
.ce23  a6 a5      ldx $a5          	LDX	Nbendh		; get pointer high byte
.ce25                              lab_218f
.ce25  e4 80      cpx $80          	CPX	Earryh		; compare with array mem end high byte
.ce27  d0 04      bne $ce2d        	BNE	LAB_219A		; branch if not at end
.ce29  c5 7f      cmp $7f          	CMP	Earryl		; else compare with array mem end low byte
.ce2b  f0 75      beq $cea2        	BEQ	LAB_2216		; tidy up and exit if at end
.ce2d                              lab_219a
.ce2d  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.ce2f  86 72      stx $72          	STX	ut1_ph		; save pointer high byte
.ce31  a0 02      ldy #$02         	LDY	#$02			; set index
.ce33  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get array size low byte
.ce35  65 a4      adc $a4          	ADC	Nbendl		; add start of this array low byte
.ce37  85 a4      sta $a4          	STA	Nbendl		; save start of next array low byte
.ce39  c8         iny              	INY				; increment index
.ce3a  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get array size high byte
.ce3c  65 a5      adc $a5          	ADC	Nbendh		; add start of this array high byte
.ce3e  85 a5      sta $a5          	STA	Nbendh		; save start of next array high byte
.ce40  a0 01      ldy #$01         	LDY	#$01			; set index
.ce42  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get name second byte
.ce44  10 db      bpl $ce21        	BPL	LAB_218B		; skip if not string array
.ce46  a0 04      ldy #$04         	LDY	#$04			; set index
.ce48  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get # of dimensions
.ce4a  0a         asl              	ASL				; *2
.ce4b  69 05      adc #$05         	ADC	#$05			; +5 (array header size)
.ce4d  20 95 ce   jsr $ce95        	JSR	LAB_2208		; go set up for first element
.ce50                              lab_21c4
.ce50  e4 a5      cpx $a5          	CPX	Nbendh		; compare with start of next array high byte
.ce52  d0 04      bne $ce58        	BNE	LAB_21CC		; branch if <> (go do this array)
.ce54  c5 a4      cmp $a4          	CMP	Nbendl		; else compare element pointer low byte with next array
.ce56  f0 cd      beq $ce25        	BEQ	LAB_218F		; if equal then go do next array
.ce58                              lab_21cc
.ce58  20 63 ce   jsr $ce63        	JSR	LAB_21D7		; go defrag array strings
.ce5b  f0 f3      beq $ce50        	BEQ	LAB_21C4		; go do next array string (loop always)
.ce5d                              lab_21d1
.ce5d  c8         iny              	INY				; increment index (Y was $00)
.ce5e  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get var name byte 2
.ce60  10 30      bpl $ce92        	BPL	LAB_2206		; if not string, step pointer to next var and return
.ce62  c8         iny              	INY				; else increment index
.ce63                              lab_21d7
.ce63  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string length
.ce65  f0 2b      beq $ce92        	BEQ	LAB_2206		; if null, step pointer to next string and return
.ce67  c8         iny              	INY				; else increment index
.ce68  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer low byte
.ce6a  aa         tax              	TAX				; copy to X
.ce6b  c8         iny              	INY				; increment index
.ce6c  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer high byte
.ce6e  c5 82      cmp $82          	CMP	Sstorh		; compare bottom of string space high byte
.ce70  90 06      bcc $ce78        	BCC	LAB_21EC		; branch if less
.ce72  d0 1e      bne $ce92        	BNE	LAB_2206		; if greater, step pointer to next string and return
.ce74  e4 81      cpx $81          	CPX	Sstorl		; compare bottom of string space low byte
.ce76  b0 1a      bcs $ce92        	BCS	LAB_2206		; if >=, step pointer to next string and return
.ce78                              lab_21ec
.ce78  c5 ab      cmp $ab          	CMP	Histrh		; compare to highest string high byte
.ce7a  90 17      bcc $ce93        	BCC	LAB_2207		; if <, step pointer to next string and return
.ce7c  d0 04      bne $ce82        	BNE	LAB_21F6		; if > update pointers, step to next and return
.ce7e  e4 aa      cpx $aa          	CPX	Histrl		; compare to highest string low byte
.ce80  90 11      bcc $ce93        	BCC	LAB_2207		; if <, step pointer to next string and return
.ce82                              lab_21f6
.ce82  86 aa      stx $aa          	STX	Histrl		; save as new highest string low byte
.ce84  85 ab      sta $ab          	STA	Histrh		; save as new highest string high byte
.ce86  a5 71      lda $71          	LDA	ut1_pl		; get start of vars(descriptors) low byte
.ce88  a6 72      ldx $72          	LDX	ut1_ph		; get start of vars(descriptors) high byte
.ce8a  85 9c      sta $9c          	STA	garb_l		; save as working pointer low byte
.ce8c  86 9d      stx $9d          	STX	garb_h		; save as working pointer high byte
.ce8e  88         dey              	DEY				; decrement index DIFFERS
.ce8f  88         dey              	DEY				; decrement index (should point to descriptor start)
.ce90  84 a2      sty $a2          	STY	g_indx		; save index pointer
.ce92                              lab_2206
.ce92  18         clc              	CLC				; clear carry for add
.ce93                              lab_2207
.ce93  a5 a0      lda $a0          	LDA	g_step		; get step size
.ce95                              lab_2208
.ce95  65 71      adc $71          	ADC	ut1_pl		; add pointer low byte
.ce97  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.ce99  90 02      bcc $ce9d        	BCC	LAB_2211		; branch if no overflow
.ce9b  e6 72      inc $72          	INC	ut1_ph		; else increment high byte
.ce9d                              lab_2211
.ce9d  a6 72      ldx $72          	LDX	ut1_ph		; get pointer high byte
.ce9f  a0 00      ldy #$00         	LDY	#$00			; clear Y
.cea1  60         rts              	RTS
.cea2                              lab_2216
.cea2  c6 a0      dec $a0          	DEC	g_step		; decrement step size (now $03 for descriptor stack)
.cea4  a6 9d      ldx $9d          	LDX	garb_h		; get string to move high byte
.cea6  f0 f5      beq $ce9d        	BEQ	LAB_2211		; exit if nothing to move
.cea8  a4 a2      ldy $a2          	LDY	g_indx		; get index byte back (points to descriptor)
.ceaa  18         clc              	CLC				; clear carry for add
.ceab  b1 9c      lda ($9c),y      	LDA	(garb_l),Y		; get string length
.cead  65 aa      adc $aa          	ADC	Histrl		; add highest string low byte
.ceaf  85 a6      sta $a6          	STA	Obendl		; save old block end low pointer
.ceb1  a5 ab      lda $ab          	LDA	Histrh		; get highest string high byte
.ceb3  69 00      adc #$00         	ADC	#$00			; add any carry
.ceb5  85 a7      sta $a7          	STA	Obendh		; save old block end high byte
.ceb7  a5 81      lda $81          	LDA	Sstorl		; get bottom of string space low byte
.ceb9  a6 82      ldx $82          	LDX	Sstorh		; get bottom of string space high byte
.cebb  85 a4      sta $a4          	STA	Nbendl		; save new block end low byte
.cebd  86 a5      stx $a5          	STX	Nbendh		; save new block end high byte
.cebf  20 c8 bc   jsr $bcc8        	JSR	LAB_11D6		; open up space in memory, don't set array end
.cec2  a4 a2      ldy $a2          	LDY	g_indx		; get index byte
.cec4  c8         iny              	INY				; point to descriptor low byte
.cec5  a5 a4      lda $a4          	LDA	Nbendl		; get string pointer low byte
.cec7  91 9c      sta ($9c),y      	STA	(garb_l),Y		; save new string pointer low byte
.cec9  aa         tax              	TAX				; copy string pointer low byte
.ceca  e6 a5      inc $a5          	INC	Nbendh		; correct high byte (move sets high byte -1)
.cecc  a5 a5      lda $a5          	LDA	Nbendh		; get new string pointer high byte
.cece  c8         iny              	INY				; point to descriptor high byte
.cecf  91 9c      sta ($9c),y      	STA	(garb_l),Y		; save new string pointer high byte
.ced1  4c e3 cd   jmp $cde3        	JMP	LAB_214B		; re-run routine from last ending
.ced4                              lab_224d
.ced4  a5 af      lda $af          	LDA	des_ph		; get descriptor pointer high byte
.ced6  48         pha              	PHA				; put on stack
.ced7  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.ced9  48         pha              	PHA				; put on stack
.ceda  20 cd c7   jsr $c7cd        	JSR	LAB_GVAL		; get value from line
.cedd  20 d2 c6   jsr $c6d2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.cee0  68         pla              	PLA				; get descriptor pointer low byte back
.cee1  85 b8      sta $b8          	STA	ssptr_l		; set pointer low byte
.cee3  68         pla              	PLA				; get descriptor pointer high byte back
.cee4  85 b9      sta $b9          	STA	ssptr_h		; set pointer high byte
.cee6  a0 00      ldy #$00         	LDY	#$00			; clear index
.cee8  b1 b8      lda ($b8),y      	LDA	(ssptr_l),Y		; get length_1 from descriptor
.ceea  18         clc              	CLC				; clear carry for add
.ceeb  71 ae      adc ($ae),y      	ADC	(des_pl),Y		; add length_2
.ceed  90 05      bcc $cef4        	BCC	LAB_226D		; branch if no overflow
.ceef  a2 1a      ldx #$1a         	LDX	#$1A			; else set error code $1A ("String too long" error)
.cef1  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.cef4                              lab_226d
.cef4  20 32 cd   jsr $cd32        	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
.cef7  20 11 cf   jsr $cf11        	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
.cefa  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.cefc  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.cefe  20 42 cf   jsr $cf42        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.cf01  20 23 cf   jsr $cf23        	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.cf04  a5 b8      lda $b8          	LDA	ssptr_l		;.set descriptor pointer low byte
.cf06  a4 b9      ldy $b9          	LDY	ssptr_h		;.set descriptor pointer high byte
.cf08  20 42 cf   jsr $cf42        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.cf0b  20 85 cd   jsr $cd85        	JSR	LAB_RTST		; check for space on descriptor stack then put string
.cf0e  4c f8 c6   jmp $c6f8        	JMP	LAB_1ADB		;.continue evaluation
.cf11                              lab_228a
.cf11  a0 00      ldy #$00         	LDY	#$00			; clear index
.cf13  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get string length
.cf15  48         pha              	PHA				; save on stack
.cf16  c8         iny              	INY				; increment index
.cf17  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get source string pointer low byte
.cf19  aa         tax              	TAX				; copy to X
.cf1a  c8         iny              	INY				; increment index
.cf1b  b1 b8      lda ($b8),y      	LDA	(sdescr),Y		; get source string pointer high byte
.cf1d  a8         tay              	TAY				; copy to Y
.cf1e  68         pla              	PLA				; get length back
.cf1f                              lab_2298
.cf1f  86 71      stx $71          	STX	ut1_pl		; save source string pointer low byte
.cf21  84 72      sty $72          	STY	ut1_ph		; save source string pointer high byte
.cf23                              lab_229c
.cf23  aa         tax              	TAX				; copy length to index (don't count with Y)
.cf24  f0 14      beq $cf3a        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
.cf26  a0 00      ldy #$00         	LDY	#$00			; zero pointer (copy forward)
.cf28                              lab_22a0
.cf28  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get source byte
.cf2a  91 83      sta ($83),y      	STA	(Sutill),Y		; save destination byte
.cf2c  c8         iny              	INY				; increment index
.cf2d  ca         dex              	DEX				; decrement counter
.cf2e  d0 f8      bne $cf28        	BNE	LAB_22A0		; loop while <> 0
.cf30  98         tya              	TYA				; restore length from Y
.cf31                              lab_22a9
.cf31  18         clc              	CLC				; clear carry for add
.cf32  65 83      adc $83          	ADC	Sutill		; add string utility ptr low byte
.cf34  85 83      sta $83          	STA	Sutill		; save string utility ptr low byte
.cf36  90 02      bcc $cf3a        	BCC	LAB_22B2		; branch if no carry
.cf38  e6 84      inc $84          	INC	Sutilh		; else increment string utility ptr high byte
.cf3a                              lab_22b2
.cf3a  60         rts              	RTS
.cf3b                              lab_evst
.cf3b  20 d2 c6   jsr $c6d2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.cf3e                              lab_22b6
.cf3e  a5 ae      lda $ae          	LDA	des_pl		; get descriptor pointer low byte
.cf40  a4 af      ldy $af          	LDY	des_ph		; get descriptor pointer high byte
.cf42                              lab_22ba
.cf42  85 71      sta $71          	STA	ut1_pl		; save descriptor pointer low byte
.cf44  84 72      sty $72          	STY	ut1_ph		; save descriptor pointer high byte
.cf46  20 73 cf   jsr $cf73        	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
.cf49  08         php              	PHP				; save status flags
.cf4a  a0 00      ldy #$00         	LDY	#$00			; clear index
.cf4c  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get length from string descriptor
.cf4e  48         pha              	PHA				; put on stack
.cf4f  c8         iny              	INY				; increment index
.cf50  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
.cf52  aa         tax              	TAX				; copy to X
.cf53  c8         iny              	INY				; increment index
.cf54  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
.cf56  a8         tay              	TAY				; copy to Y
.cf57  68         pla              	PLA				; get string length back
.cf58  28         plp              	PLP				; restore status
.cf59  d0 13      bne $cf6e        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
.cf5b  c4 82      cpy $82          	CPY	Sstorh		; compare bottom of string space high byte
.cf5d  d0 0f      bne $cf6e        	BNE	LAB_22E6		; branch if <>
.cf5f  e4 81      cpx $81          	CPX	Sstorl		; else compare bottom of string space low byte
.cf61  d0 0b      bne $cf6e        	BNE	LAB_22E6		; branch if <>
.cf63  48         pha              	PHA				; save string length
.cf64  18         clc              	CLC				; clear carry for add
.cf65  65 81      adc $81          	ADC	Sstorl		; add bottom of string space low byte
.cf67  85 81      sta $81          	STA	Sstorl		; save bottom of string space low byte
.cf69  90 02      bcc $cf6d        	BCC	LAB_22E5		; skip increment if no overflow
.cf6b  e6 82      inc $82          	INC	Sstorh		; increment bottom of string space high byte
.cf6d                              lab_22e5
.cf6d  68         pla              	PLA				; restore string length
.cf6e                              lab_22e6
.cf6e  86 71      stx $71          	STX	ut1_pl		; save string pointer low byte
.cf70  84 72      sty $72          	STY	ut1_ph		; save string pointer high byte
.cf72  60         rts              	RTS
.cf73                              lab_22eb
.cf73  c4 67      cpy $67          	CPY	last_sh		; compare pointer high byte
.cf75  d0 0c      bne $cf83        	BNE	LAB_22FB		; exit if <>
.cf77  c5 66      cmp $66          	CMP	last_sl		; compare pointer low byte
.cf79  d0 08      bne $cf83        	BNE	LAB_22FB		; exit if <>
.cf7b  85 65      sta $65          	STA	next_s		; save descriptor stack pointer
.cf7d  e9 03      sbc #$03         	SBC	#$03			; -3
.cf7f  85 66      sta $66          	STA	last_sl		; save low byte -3
.cf81  a0 00      ldy #$00         	LDY	#$00			; clear high byte
.cf83                              lab_22fb
.cf83  60         rts              	RTS
.cf84                              lab_chrs
.cf84  20 8f d0   jsr $d08f        	JSR	LAB_EVBY		; evaluate byte expression, result in X
.cf87  8a         txa              	TXA				; copy to A
.cf88  48         pha              	PHA				; save character
.cf89  a9 01      lda #$01         	LDA	#$01			; string is single byte
.cf8b  20 3a cd   jsr $cd3a        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.cf8e  68         pla              	PLA				; get character back
.cf8f  a0 00      ldy #$00         	LDY	#$00			; clear index
.cf91  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save byte in string (byte IS string!)
.cf93  4c 85 cd   jmp $cd85        	JMP	LAB_RTST		; check for space on descriptor stack then put string
.cf96                              lab_left
.cf96  48         pha              	PHA				; push byte parameter
.cf97  20 f7 cf   jsr $cff7        	JSR	LAB_236F		; pull string data and byte parameter from stack
.cf9a  d1 9e      cmp ($9e),y      	CMP	(des_2l),Y		; compare byte parameter with string length
.cf9c  98         tya              	TYA				; clear A
.cf9d  f0 09      beq $cfa8        	BEQ	LAB_2316		; go do string copy (branch always)
.cf9f                              lab_right
.cf9f  48         pha              	PHA				; push byte parameter
.cfa0  20 f7 cf   jsr $cff7        	JSR	LAB_236F		; pull string data and byte parameter from stack
.cfa3  18         clc              	CLC				; clear carry for add-1
.cfa4  f1 9e      sbc ($9e),y      	SBC	(des_2l),Y		; subtract string length
.cfa6  49 ff      eor #$ff         	EOR	#$FF			; invert it (A=LEN(expression$)-l)
.cfa8                              lab_2316
.cfa8  90 04      bcc $cfae        	BCC	LAB_231C		; branch if string length > byte parameter
.cfaa  b1 9e      lda ($9e),y      	LDA	(des_2l),Y		; else make parameter = length
.cfac  aa         tax              	TAX				; copy to byte parameter copy
.cfad  98         tya              	TYA				; clear string start offset
.cfae                              lab_231c
.cfae  48         pha              	PHA				; save string start offset
.cfaf                              lab_231d
.cfaf  8a         txa              	TXA				; copy byte parameter (or string length if <)
.cfb0                              lab_231e
.cfb0  48         pha              	PHA				; save string length
.cfb1  20 3a cd   jsr $cd3a        	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
.cfb4  a5 9e      lda $9e          	LDA	des_2l		; get descriptor pointer low byte
.cfb6  a4 9f      ldy $9f          	LDY	des_2h		; get descriptor pointer high byte
.cfb8  20 42 cf   jsr $cf42        	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
.cfbb  68         pla              	PLA				; get string length back
.cfbc  a8         tay              	TAY				; copy length to Y
.cfbd  68         pla              	PLA				; get string start offset back
.cfbe  18         clc              	CLC				; clear carry for add
.cfbf  65 71      adc $71          	ADC	ut1_pl		; add start offset to string start pointer low byte
.cfc1  85 71      sta $71          	STA	ut1_pl		; save string start pointer low byte
.cfc3  90 02      bcc $cfc7        	BCC	LAB_2335		; branch if no overflow
.cfc5  e6 72      inc $72          	INC	ut1_ph		; else increment string start pointer high byte
.cfc7                              lab_2335
.cfc7  98         tya              	TYA				; copy length to A
.cfc8  20 23 cf   jsr $cf23        	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
.cfcb  4c 85 cd   jmp $cd85        	JMP	LAB_RTST		; check for space on descriptor stack then put string
.cfce                              lab_mids
.cfce  48         pha              	PHA				; push byte parameter
.cfcf  a9 ff      lda #$ff         	LDA	#$FF			; set default length = 255
.cfd1  85 af      sta $af          	STA	mids_l		; save default length
.cfd3  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.cfd6  c9 29      cmp #$29         	CMP	#")"			; compare with ")"
.cfd8  f0 06      beq $cfe0        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
.cfda  20 fe c7   jsr $c7fe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.cfdd  20 8c d0   jsr $d08c        	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
.cfe0                              lab_2358
.cfe0  20 f7 cf   jsr $cff7        	JSR	LAB_236F		; pull string data and byte parameter from stack
.cfe3  ca         dex              	DEX				; decrement start index
.cfe4  8a         txa              	TXA				; copy to A
.cfe5  48         pha              	PHA				; save string start offset
.cfe6  18         clc              	CLC				; clear carry for sub-1
.cfe7  a2 00      ldx #$00         	LDX	#$00			; clear output string length
.cfe9  f1 9e      sbc ($9e),y      	SBC	(des_2l),Y		; subtract string length
.cfeb  b0 c2      bcs $cfaf        	BCS	LAB_231D		; if start>string length go do null string
.cfed  49 ff      eor #$ff         	EOR	#$FF			; complement -length
.cfef  c5 af      cmp $af          	CMP	mids_l		; compare byte parameter
.cff1  90 bd      bcc $cfb0        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
.cff3  a5 af      lda $af          	LDA	mids_l		; get length byte
.cff5  b0 b9      bcs $cfb0        	BCS	LAB_231E		; go do string copy (branch always)
.cff7                              lab_236f
.cff7  20 ef c7   jsr $c7ef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.cffa  68         pla              	PLA				; pull return address low byte (return address)
.cffb  85 a2      sta $a2          	STA	Fnxjpl		; save functions jump vector low byte
.cffd  68         pla              	PLA				; pull return address high byte (return address)
.cffe  85 a3      sta $a3          	STA	Fnxjph		; save functions jump vector high byte
.d000  68         pla              	PLA				; pull byte parameter
.d001  aa         tax              	TAX				; copy byte parameter to X
.d002  68         pla              	PLA				; pull string pointer low byte
.d003  85 9e      sta $9e          	STA	des_2l		; save it
.d005  68         pla              	PLA				; pull string pointer high byte
.d006  85 9f      sta $9f          	STA	des_2h		; save it
.d008  a0 00      ldy #$00         	LDY	#$00			; clear index
.d00a  8a         txa              	TXA				; copy byte parameter
.d00b  f0 79      beq $d086        	BEQ	LAB_23A8		; if null do function call error then warm start
.d00d  e6 a2      inc $a2          	INC	Fnxjpl		; increment function jump vector low byte
.d00f  6c a2 00   jmp ($00a2)      	JMP	(Fnxjpl)		; in effect, RTS
.d012                              lab_lcase
.d012  20 3b cf   jsr $cf3b        	JSR	LAB_EVST		; evaluate string
.d015  85 ac      sta $ac          	STA	str_ln		; set string length
.d017  a8         tay              	TAY				; copy length to Y
.d018  f0 38      beq $d052        	BEQ	NoString		; branch if null string
.d01a  20 3a cd   jsr $cd3a        	JSR	LAB_MSSP		; make string space A bytes long A=length,
.d01d  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.d01f  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.d021  a8         tay              	TAY				; get string length back
.d022                              lc_loop
.d022  88         dey              	DEY				; decrement index
.d023  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from string
.d025  20 22 ca   jsr $ca22        	JSR	LAB_1D82		; is character "A" to "Z"
.d028  90 02      bcc $d02c        	BCC	NoUcase		; branch if not upper case alpha
.d02a  09 20      ora #$20         	ORA	#$20			; convert upper to lower case
.d02c                              noucase
.d02c  91 83      sta ($83),y      	STA	(Sutill),Y		; save byte back to string
.d02e  98         tya              	TYA				; test index
.d02f  d0 f1      bne $d022        	BNE	LC_loop		; loop if not all done
.d031  f0 1f      beq $d052        	BEQ	NoString		; tidy up and exit, branch always
.d033                              lab_ucase
.d033  20 3b cf   jsr $cf3b        	JSR	LAB_EVST		; evaluate string
.d036  85 ac      sta $ac          	STA	str_ln		; set string length
.d038  a8         tay              	TAY				; copy length to Y
.d039  f0 17      beq $d052        	BEQ	NoString		; branch if null string
.d03b  20 3a cd   jsr $cd3a        	JSR	LAB_MSSP		; make string space A bytes long A=length,
.d03e  86 ad      stx $ad          	STX	str_pl		; save string pointer low byte
.d040  84 ae      sty $ae          	STY	str_ph		; save string pointer high byte
.d042  a8         tay              	TAY				; get string length back
.d043                              uc_loop
.d043  88         dey              	DEY				; decrement index
.d044  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte from string
.d046  20 1e ca   jsr $ca1e        	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
.d049  90 02      bcc $d04d        	BCC	NoLcase		; branch if not alpha
.d04b  29 df      and #$df         	AND	#$DF			; convert lower to upper case
.d04d                              nolcase
.d04d  91 83      sta ($83),y      	STA	(Sutill),Y		; save byte back to string
.d04f  98         tya              	TYA				; test index
.d050  d0 f1      bne $d043        	BNE	UC_loop		; loop if not all done
.d052                              nostring
.d052  4c 85 cd   jmp $cd85        	JMP	LAB_RTST		; check for space on descriptor stack then put string
.d055                              lab_sadd
.d055  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.d058  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get var address
.d05b  20 ef c7   jsr $c7ef        	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
.d05e  20 d2 c6   jsr $c6d2        	JSR	LAB_CTST		; check if source is string, else do type mismatch
.d061  a0 02      ldy #$02         	LDY	#$02			; index to string pointer high byte
.d063  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get string pointer high byte
.d065  aa         tax              	TAX				; copy string pointer high byte to X
.d066  88         dey              	DEY				; index to string pointer low byte
.d067  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get string pointer low byte
.d069  a8         tay              	TAY				; copy string pointer low byte to Y
.d06a  8a         txa              	TXA				; copy string pointer high byte to A
.d06b  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.d06e                              lab_lens
.d06e  20 74 d0   jsr $d074        	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.d071  4c 66 cc   jmp $cc66        	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.d074                              lab_esgl
.d074  20 3b cf   jsr $cf3b        	JSR	LAB_EVST		; evaluate string
.d077  a8         tay              	TAY				; copy length to Y
.d078  60         rts              	RTS
.d079                              lab_asc
.d079  20 74 d0   jsr $d074        	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.d07c  f0 08      beq $d086        	BEQ	LAB_23A8		; if null do function call error then warm start
.d07e  a0 00      ldy #$00         	LDY	#$00			; set index to first character
.d080  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get byte
.d082  a8         tay              	TAY				; copy to Y
.d083  4c 66 cc   jmp $cc66        	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.d086                              lab_23a8
.d086  4c 29 cb   jmp $cb29        	JMP	LAB_FCER		; do function call error then warm start
.d089                              lab_sgby
.d089  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.d08c                              lab_gtby
.d08c  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.d08f                              lab_evby
.d08f  20 a2 ca   jsr $caa2        	JSR	LAB_EVPI		; evaluate integer expression (no check)
.d092  a4 ae      ldy $ae          	LDY	FAC1_2		; get FAC1 mantissa2
.d094  d0 f0      bne $d086        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
.d096  a6 af      ldx $af          	LDX	FAC1_3		; get FAC1 mantissa3
.d098  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory and return
.d09b                              lab_val
.d09b  20 74 d0   jsr $d074        	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
.d09e  d0 03      bne $d0a3        	BNE	LAB_23C5		; branch if not null string
.d0a0  4c 50 d2   jmp $d250        	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
.d0a3                              lab_23c5
.d0a3  a6 c3      ldx $c3          	LDX	Bpntrl		; get BASIC execute pointer low byte
.d0a5  a4 c4      ldy $c4          	LDY	Bpntrh		; get BASIC execute pointer high byte
.d0a7  86 ba      stx $ba          	STX	Btmpl			; save BASIC execute pointer low byte
.d0a9  84 bb      sty $bb          	STY	Btmph			; save BASIC execute pointer high byte
.d0ab  a6 71      ldx $71          	LDX	ut1_pl		; get string pointer low byte
.d0ad  86 c3      stx $c3          	STX	Bpntrl		; save as BASIC execute pointer low byte
.d0af  18         clc              	CLC				; clear carry
.d0b0  65 71      adc $71          	ADC	ut1_pl		; add string length
.d0b2  85 73      sta $73          	STA	ut2_pl		; save string end low byte
.d0b4  a5 72      lda $72          	LDA	ut1_ph		; get string pointer high byte
.d0b6  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.d0b8  69 00      adc #$00         	ADC	#$00			; add carry to high byte
.d0ba  85 74      sta $74          	STA	ut2_ph		; save string end high byte
.d0bc  a0 00      ldy #$00         	LDY	#$00			; set index to $00
.d0be  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get string end +1 byte
.d0c0  48         pha              	PHA				; push it
.d0c1  98         tya              	TYA				; clear A
.d0c2  91 73      sta ($73),y      	STA	(ut2_pl),Y		; terminate string with $00
.d0c4  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.d0c7  20 a6 d5   jsr $d5a6        	JSR	LAB_2887		; get FAC1 from string
.d0ca  68         pla              	PLA				; restore string end +1 byte
.d0cb  a0 00      ldy #$00         	LDY	#$00			; set index to zero
.d0cd  91 73      sta ($73),y      	STA	(ut2_pl),Y		; put string end byte back
.d0cf                              lab_23f3
.d0cf  a6 ba      ldx $ba          	LDX	Btmpl			; get BASIC execute pointer low byte back
.d0d1  a4 bb      ldy $bb          	LDY	Btmph			; get BASIC execute pointer high byte back
.d0d3  86 c3      stx $c3          	STX	Bpntrl		; save BASIC execute pointer low byte
.d0d5  84 c4      sty $c4          	STY	Bpntrh		; save BASIC execute pointer high byte
.d0d7  60         rts              	RTS
.d0d8                              lab_gadb
.d0d8  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.d0db  20 f1 d0   jsr $d0f1        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.d0de                              lab_scgb
.d0de  20 fe c7   jsr $c7fe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.d0e1  a5 12      lda $12          	LDA	Itemph		; save temporary integer high byte
.d0e3  48         pha              	PHA				; on stack
.d0e4  a5 11      lda $11          	LDA	Itempl		; save temporary integer low byte
.d0e6  48         pha              	PHA				; on stack
.d0e7  20 8c d0   jsr $d08c        	JSR	LAB_GTBY		; get byte parameter
.d0ea  68         pla              	PLA				; pull low byte
.d0eb  85 11      sta $11          	STA	Itempl		; restore temporary integer low byte
.d0ed  68         pla              	PLA				; pull high byte
.d0ee  85 12      sta $12          	STA	Itemph		; restore temporary integer high byte
.d0f0  60         rts              	RTS
.d0f1                              lab_f2fx
.d0f1  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d0f3  c9 98      cmp #$98         	CMP	#$98			; compare with exponent = 2^24
.d0f5  b0 8f      bcs $d086        	BCS	LAB_23A8		; if >= do function call error then warm start
.d0f7                              lab_f2fu
.d0f7  20 50 d5   jsr $d550        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.d0fa  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.d0fc  a4 af      ldy $af          	LDY	FAC1_3		; get FAC1 mantissa3
.d0fe  84 11      sty $11          	STY	Itempl		; save temporary integer low byte
.d100  85 12      sta $12          	STA	Itemph		; save temporary integer high byte
.d102  60         rts              	RTS
.d103                              lab_peek
.d103  20 f1 d0   jsr $d0f1        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.d106  a2 00      ldx #$00         	LDX	#$00			; clear index
.d108  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; get byte via temporary integer (addr)
.d10a  a8         tay              	TAY				; copy byte to Y
.d10b  4c 66 cc   jmp $cc66        	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
.d10e                              lab_poke
.d10e  20 d8 d0   jsr $d0d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.d111  8a         txa              	TXA				; copy byte argument to A
.d112  a2 00      ldx #$00         	LDX	#$00			; clear index
.d114  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.d116  60         rts              	RTS
.d117                              lab_deek
.d117  20 f1 d0   jsr $d0f1        	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
.d11a  a2 00      ldx #$00         	LDX	#$00			; clear index
.d11c  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; PEEK low byte
.d11e  a8         tay              	TAY				; copy to Y
.d11f  e6 11      inc $11          	INC	Itempl		; increment pointer low byte
.d121  d0 02      bne $d125        	BNE	Deekh			; skip high increment if no rollover
.d123  e6 12      inc $12          	INC	Itemph		; increment pointer high byte
.d125                              deekh
.d125  a1 11      lda ($11,x)      	LDA	(Itempl,X)		; PEEK high byte
.d127  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.d12a                              lab_doke
.d12a  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.d12d  20 f1 d0   jsr $d0f1        	JSR	LAB_F2FX		; convert floating-to-fixed
.d130  84 97      sty $97          	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
.d132  85 98      sta $98          	STA	Frnxth		; save pointer high byte
.d134  20 fe c7   jsr $c7fe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.d137  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.d13a  20 f1 d0   jsr $d0f1        	JSR	LAB_F2FX		; convert floating-to-fixed
.d13d  98         tya              	TYA				; copy value low byte (float to fixed returns word in AY)
.d13e  a2 00      ldx #$00         	LDX	#$00			; clear index
.d140  81 97      sta ($97,x)      	STA	(Frnxtl,X)		; POKE low byte
.d142  e6 97      inc $97          	INC	Frnxtl		; increment pointer low byte
.d144  d0 02      bne $d148        	BNE	Dokeh			; skip high increment if no rollover
.d146  e6 98      inc $98          	INC	Frnxth		; increment pointer high byte
.d148                              dokeh
.d148  a5 12      lda $12          	LDA	Itemph		; get value high byte
.d14a  81 97      sta ($97,x)      	STA	(Frnxtl,X)		; POKE high byte
.d14c  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory and return
.d14f                              lab_swap
.d14f  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get var1 address
.d152  85 97      sta $97          	STA	Lvarpl		; save var1 address low byte
.d154  84 98      sty $98          	STY	Lvarph		; save var1 address high byte
.d156  a5 5f      lda $5f          	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
.d158  48         pha              	PHA				; save data type flag
.d159  20 fe c7   jsr $c7fe        	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
.d15c  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
.d15f  68         pla              	PLA				; pull var1 data type flag
.d160  45 5f      eor $5f          	EOR	Dtypef		; compare with var2 data type
.d162  10 10      bpl $d174        	BPL	SwapErr		; exit if not both the same type
.d164  a0 03      ldy #$03         	LDY	#$03			; four bytes to swap (either value or descriptor+1)
.d166                              swaplp
.d166  b1 97      lda ($97),y      	LDA	(Lvarpl),Y		; get byte from var1
.d168  aa         tax              	TAX				; save var1 byte
.d169  b1 95      lda ($95),y      	LDA	(Cvaral),Y		; get byte from var2
.d16b  91 97      sta ($97),y      	STA	(Lvarpl),Y		; save byte to var1
.d16d  8a         txa              	TXA				; restore var1 byte
.d16e  91 95      sta ($95),y      	STA	(Cvaral),Y		; save byte to var2
.d170  88         dey              	DEY				; decrement index
.d171  10 f3      bpl $d166        	BPL	SwapLp		; loop until done
.d173  60         rts              	RTS
.d174                              swaperr
.d174  4c dc c6   jmp $c6dc        	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
.d177                              lab_call
.d177  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.d17a  20 f1 d0   jsr $d0f1        	JSR	LAB_F2FX		; convert floating-to-fixed
.d17d  a9 d1      lda #$d1         	LDA	#>CallExit		; set return address high byte
.d17f  48         pha              	PHA				; put on stack
.d180  a9 85      lda #$85         	LDA	#<CallExit-1	; set return address low byte
.d182  48         pha              	PHA				; put on stack
.d183  6c 11 00   jmp ($0011)      	JMP	(Itempl)		; do indirect jump to user routine
.d186                              callexit
.d186  4c c2 00   jmp $00c2        	JMP	LAB_GBYT		; scan memory and return
.d189                              lab_wait
.d189  20 d8 d0   jsr $d0d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.d18c  86 97      stx $97          	STX	Frnxtl		; save byte
.d18e  a2 00      ldx #$00         	LDX	#$00			; clear mask
.d190  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; scan memory
.d193  f0 03      beq $d198        	BEQ	LAB_2441		; skip if no third argument
.d195  20 de d0   jsr $d0de        	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
.d198                              lab_2441
.d198  86 98      stx $98          	STX	Frnxth		; save EOR argument
.d19a                              lab_2445
.d19a  b1 11      lda ($11),y      	LDA	(Itempl),Y		; get byte via temporary integer (addr)
.d19c  45 98      eor $98          	EOR	Frnxth		; EOR with second argument (mask)
.d19e  25 97      and $97          	AND	Frnxtl		; AND with first argument (byte)
.d1a0  f0 f8      beq $d19a        	BEQ	LAB_2445		; loop if result is zero
.d1a2                              lab_244d
.d1a2  60         rts              	RTS
.d1a3                              lab_2455
.d1a3  20 8b d3   jsr $d38b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.d1a6                              lab_subtract
.d1a6  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d1a8  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d1aa  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.d1ac  45 b7      eor $b7          	EOR	FAC2_s		; EOR with FAC2 sign (b7)
.d1ae  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.d1b0  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d1b2  4c c1 d1   jmp $d1c1        	JMP	LAB_ADD		; go add FAC2 to FAC1
.d1b5                              lab_2467
.d1b5  20 da d2   jsr $d2da        	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
.d1b8  90 4d      bcc $d207        	BCC	LAB_24A8		;.go subtract mantissas
.d1ba                              lab_244e
.d1ba  a9 e9      lda #$e9         	LDA	#<LAB_2A96		; set 0.5 pointer low byte
.d1bc  a0 dd      ldy #$dd         	LDY	#>LAB_2A96		; set 0.5 pointer high byte
.d1be                              lab_246c
.d1be  20 8b d3   jsr $d38b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.d1c1                              lab_add
.d1c1  d0 10      bne $d1d3        	BNE	LAB_2474		; branch if FAC1 was not zero
.d1c3                              lab_279b
.d1c3  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.d1c5                              lab_279d
.d1c5  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.d1c7  a2 04      ldx #$04         	LDX	#$04			; 4 bytes to copy
.d1c9                              lab_27a1
.d1c9  b5 b2      lda $b2,x        	LDA	FAC1_o,X		; get byte from FAC2,X
.d1cb  95 ab      sta $ab,x        	STA	FAC1_e-1,X		; save byte at FAC1,X
.d1cd  ca         dex              	DEX				; decrement count
.d1ce  d0 f9      bne $d1c9        	BNE	LAB_27A1		; loop if not all done
.d1d0  86 b9      stx $b9          	STX	FAC1_r		; clear FAC1 rounding byte
.d1d2  60         rts              	RTS
.d1d3                              lab_2474
.d1d3  a6 b9      ldx $b9          	LDX	FAC1_r		; get FAC1 rounding byte
.d1d5  86 a3      stx $a3          	STX	FAC2_r		; save as FAC2 rounding byte
.d1d7  a2 b3      ldx #$b3         	LDX	#FAC2_e		; set index to FAC2 exponent addr
.d1d9  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.d1db                              lab_247c
.d1db  a8         tay              	TAY				; copy exponent
.d1dc  f0 c4      beq $d1a2        	BEQ	LAB_244D		; exit if zero
.d1de  38         sec              	SEC				; set carry for subtract
.d1df  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent
.d1e1  f0 24      beq $d207        	BEQ	LAB_24A8		; branch if = (go add mantissa)
.d1e3  90 12      bcc $d1f7        	BCC	LAB_2498		; branch if <
.d1e5  84 ac      sty $ac          	STY	FAC1_e		; save FAC1 exponent
.d1e7  a4 b7      ldy $b7          	LDY	FAC2_s		; get FAC2 sign (b7)
.d1e9  84 b0      sty $b0          	STY	FAC1_s		; save FAC1 sign (b7)
.d1eb  49 ff      eor #$ff         	EOR	#$FF			; complement A
.d1ed  69 00      adc #$00         	ADC	#$00			; +1 (twos complement, carry is set)
.d1ef  a0 00      ldy #$00         	LDY	#$00			; clear Y
.d1f1  84 a3      sty $a3          	STY	FAC2_r		; clear FAC2 rounding byte
.d1f3  a2 ac      ldx #$ac         	LDX	#FAC1_e		; set index to FAC1 exponent addr
.d1f5  d0 04      bne $d1fb        	BNE	LAB_249C		; branch always
.d1f7                              lab_2498
.d1f7  a0 00      ldy #$00         	LDY	#$00			; clear Y
.d1f9  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.d1fb                              lab_249c
.d1fb  c9 f9      cmp #$f9         	CMP	#$F9			; compare exponent diff with $F9
.d1fd  30 b6      bmi $d1b5        	BMI	LAB_2467		; branch if range $79-$F8
.d1ff  a8         tay              	TAY				; copy exponent difference to Y
.d200  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.d202  56 01      lsr $01,x        	LSR	PLUS_1,X		; shift FAC? mantissa1
.d204  20 f1 d2   jsr $d2f1        	JSR	LAB_2592		; shift FACX Y times right
.d207                              lab_24a8
.d207  24 b8      bit $b8          	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
.d209  10 4c      bpl $d257        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
.d20b  a0 ac      ldy #$ac         	LDY	#FAC1_e		; set index to FAC1 exponent addr
.d20d  e0 b3      cpx #$b3         	CPX	#FAC2_e		; compare X to FAC2 exponent addr
.d20f  f0 02      beq $d213        	BEQ	LAB_24B4		; branch if =
.d211  a0 b3      ldy #$b3         	LDY	#FAC2_e		; else set index to FAC2 exponent addr
.d213                              lab_24b4
.d213  38         sec              	SEC				; set carry for subtract
.d214  49 ff      eor #$ff         	EOR	#$FF			; ones complement A
.d216  65 a3      adc $a3          	ADC	FAC2_r		; add FAC2 rounding byte
.d218  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.d21a  b9 03 00   lda $0003,y      	LDA	PLUS_3,Y		; get FACY mantissa3
.d21d  f5 03      sbc $03,x        	SBC	PLUS_3,X		; subtract FACX mantissa3
.d21f  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.d221  b9 02 00   lda $0002,y      	LDA	PLUS_2,Y		; get FACY mantissa2
.d224  f5 02      sbc $02,x        	SBC	PLUS_2,X		; subtract FACX mantissa2
.d226  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.d228  b9 01 00   lda $0001,y      	LDA	PLUS_1,Y		; get FACY mantissa1
.d22b  f5 01      sbc $01,x        	SBC	PLUS_1,X		; subtract FACX mantissa1
.d22d  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d22f                              lab_24d0
.d22f  b0 03      bcs $d234        	BCS	LAB_24D5		; branch if number is +ve
.d231  20 96 d2   jsr $d296        	JSR	LAB_2537		; negate FAC1
.d234                              lab_24d5
.d234  a0 00      ldy #$00         	LDY	#$00			; clear Y
.d236  98         tya              	TYA				; clear A
.d237  18         clc              	CLC				; clear carry for add
.d238                              lab_24d9
.d238  a6 ad      ldx $ad          	LDX	FAC1_1		; get FAC1 mantissa1
.d23a  d0 3e      bne $d27a        	BNE	LAB_251B		; if not zero normalise FAC1
.d23c  a6 ae      ldx $ae          	LDX	FAC1_2		; get FAC1 mantissa2
.d23e  86 ad      stx $ad          	STX	FAC1_1		; save FAC1 mantissa1
.d240  a6 af      ldx $af          	LDX	FAC1_3		; get FAC1 mantissa3
.d242  86 ae      stx $ae          	STX	FAC1_2		; save FAC1 mantissa2
.d244  a6 b9      ldx $b9          	LDX	FAC1_r		; get FAC1 rounding byte
.d246  86 af      stx $af          	STX	FAC1_3		; save FAC1 mantissa3
.d248  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.d24a  69 08      adc #$08         	ADC	#$08			; add x to exponent offset
.d24c  c9 18      cmp #$18         	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
.d24e  d0 e8      bne $d238        	BNE	LAB_24D9		; loop if not max
.d250                              lab_24f1
.d250  a9 00      lda #$00         	LDA	#$00			; clear A
.d252                              lab_24f3
.d252  85 ac      sta $ac          	STA	FAC1_e		; set FAC1 exponent
.d254                              lab_24f5
.d254  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.d256  60         rts              	RTS
.d257                              lab_24f8
.d257  65 a3      adc $a3          	ADC	FAC2_r		; add FAC2 rounding byte
.d259  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.d25b  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.d25d  65 b6      adc $b6          	ADC	FAC2_3		; add FAC2 mantissa3
.d25f  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.d261  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.d263  65 b5      adc $b5          	ADC	FAC2_2		; add FAC2 mantissa2
.d265  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.d267  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.d269  65 b4      adc $b4          	ADC	FAC2_1		; add FAC2 mantissa1
.d26b  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d26d  b0 1a      bcs $d289        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
.d26f  60         rts              	RTS				; else just exit
.d270                              lab_2511
.d270  69 01      adc #$01         	ADC	#$01			; add 1 to exponent offset
.d272  06 b9      asl $b9          	ASL	FAC1_r		; shift FAC1 rounding byte
.d274  26 af      rol $af          	ROL	FAC1_3		; shift FAC1 mantissa3
.d276  26 ae      rol $ae          	ROL	FAC1_2		; shift FAC1 mantissa2
.d278  26 ad      rol $ad          	ROL	FAC1_1		; shift FAC1 mantissa1
.d27a                              lab_251b
.d27a  10 f4      bpl $d270        	BPL	LAB_2511		; loop if not normalised
.d27c  38         sec              	SEC				; set carry for subtract
.d27d  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent
.d27f  b0 cf      bcs $d250        	BCS	LAB_24F1		; branch if underflow (set result = $0)
.d281  49 ff      eor #$ff         	EOR	#$FF			; complement exponent
.d283  69 01      adc #$01         	ADC	#$01			; +1 (twos complement)
.d285  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.d287                              lab_2528
.d287  90 0c      bcc $d295        	BCC	LAB_2536		; exit if no overflow
.d289                              lab_252a
.d289  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent
.d28b  f0 36      beq $d2c3        	BEQ	LAB_2564		; if zero do overflow error and warm start
.d28d  66 ad      ror $ad          	ROR	FAC1_1		; shift FAC1 mantissa1
.d28f  66 ae      ror $ae          	ROR	FAC1_2		; shift FAC1 mantissa2
.d291  66 af      ror $af          	ROR	FAC1_3		; shift FAC1 mantissa3
.d293  66 b9      ror $b9          	ROR	FAC1_r		; shift FAC1 rounding byte
.d295                              lab_2536
.d295  60         rts              	RTS
.d296                              lab_2537
.d296  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d298  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d29a  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.d29c                              lab_253d
.d29c  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.d29e  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d2a0  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d2a2  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.d2a4  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d2a6  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.d2a8  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.d2aa  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d2ac  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.d2ae  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.d2b0  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d2b2  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.d2b4  e6 b9      inc $b9          	INC	FAC1_r		; increment FAC1 rounding byte
.d2b6  d0 0a      bne $d2c2        	BNE	LAB_2563		; exit if no overflow
.d2b8                              lab_2559
.d2b8  e6 af      inc $af          	INC	FAC1_3		; increment FAC1 mantissa3
.d2ba  d0 06      bne $d2c2        	BNE	LAB_2563		; finished if no rollover
.d2bc  e6 ae      inc $ae          	INC	FAC1_2		; increment FAC1 mantissa2
.d2be  d0 02      bne $d2c2        	BNE	LAB_2563		; finished if no rollover
.d2c0  e6 ad      inc $ad          	INC	FAC1_1		; increment FAC1 mantissa1
.d2c2                              lab_2563
.d2c2  60         rts              	RTS
.d2c3                              lab_2564
.d2c3  a2 0a      ldx #$0a         	LDX	#$0A			; error code $0A ("Overflow" error)
.d2c5  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.d2c8                              lab_2569
.d2c8  a2 74      ldx #$74         	LDX	#FACt_1-1		; set offset to FACtemp
.d2ca                              lab_256b
.d2ca  b4 03      ldy $03,x        	LDY	PLUS_3,X		; get FACX mantissa3
.d2cc  84 b9      sty $b9          	STY	FAC1_r		; save as FAC1 rounding byte
.d2ce  b4 02      ldy $02,x        	LDY	PLUS_2,X		; get FACX mantissa2
.d2d0  94 03      sty $03,x        	STY	PLUS_3,X		; save FACX mantissa3
.d2d2  b4 01      ldy $01,x        	LDY	PLUS_1,X		; get FACX mantissa1
.d2d4  94 02      sty $02,x        	STY	PLUS_2,X		; save FACX mantissa2
.d2d6  a4 b2      ldy $b2          	LDY	FAC1_o		; get FAC1 overflow byte
.d2d8  94 01      sty $01,x        	STY	PLUS_1,X		; save FACX mantissa1
.d2da                              lab_257b
.d2da  69 08      adc #$08         	ADC	#$08			; add 8 to shift count
.d2dc  30 ec      bmi $d2ca        	BMI	LAB_256B		; go do 8 shift if still -ve
.d2de  f0 ea      beq $d2ca        	BEQ	LAB_256B		; go do 8 shift if zero
.d2e0  e9 08      sbc #$08         	SBC	#$08			; else subtract 8 again
.d2e2  a8         tay              	TAY				; save count to Y
.d2e3  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.d2e5  b0 12      bcs $d2f9        	BCS	LAB_259A		;.
.d2e7                              lab_2588
.d2e7  16 01      asl $01,x        	ASL	PLUS_1,X		; shift FACX mantissa1
.d2e9  90 02      bcc $d2ed        	BCC	LAB_258E		; branch if +ve
.d2eb  f6 01      inc $01,x        	INC	PLUS_1,X		; this sets b7 eventually
.d2ed                              lab_258e
.d2ed  76 01      ror $01,x        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
.d2ef  76 01      ror $01,x        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
.d2f1                              lab_2592
.d2f1  76 02      ror $02,x        	ROR	PLUS_2,X		; shift FACX mantissa2
.d2f3  76 03      ror $03,x        	ROR	PLUS_3,X		; shift FACX mantissa3
.d2f5  6a         ror              	ROR				; shift FACX rounding byte
.d2f6  c8         iny              	INY				; increment exponent diff
.d2f7  d0 ee      bne $d2e7        	BNE	LAB_2588		; branch if range adjust not complete
.d2f9                              lab_259a
.d2f9  18         clc              	CLC				; just clear it
.d2fa  60         rts              	RTS
.d2fb                              lab_log
.d2fb  20 e9 d4   jsr $d4e9        	JSR	LAB_27CA		; test sign and zero
.d2fe  f0 02      beq $d302        	BEQ	LAB_25C4		; if zero do function call error then warm start
.d300  10 03      bpl $d305        	BPL	LAB_25C7		; skip error if +ve
.d302                              lab_25c4
.d302  4c 29 cb   jmp $cb29        	JMP	LAB_FCER		; do function call error then warm start (-ve)
.d305                              lab_25c7
.d305  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d307  e9 7f      sbc #$7f         	SBC	#$7F			; normalise it
.d309  48         pha              	PHA				; save it
.d30a  a9 80      lda #$80         	LDA	#$80			; set exponent to zero
.d30c  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.d30e  a9 69      lda #$69         	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
.d310  a0 dd      ldy #$dd         	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
.d312  20 be d1   jsr $d1be        	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
.d315  a9 6d      lda #$6d         	LDA	#<LAB_25B1		; set root2 pointer low byte
.d317  a0 dd      ldy #$dd         	LDY	#>LAB_25B1		; set root2 pointer high byte
.d319  20 01 d4   jsr $d401        	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
.d31c  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low byte
.d31e  a0 dd      ldy #$dd         	LDY	#>LAB_259C		; set 1 pointer high byte
.d320  20 a3 d1   jsr $d1a3        	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
.d323  a9 5c      lda #$5c         	LDA	#<LAB_25A0		; set pointer low byte to counter
.d325  a0 dd      ldy #$dd         	LDY	#>LAB_25A0		; set pointer high byte to counter
.d327  20 51 d8   jsr $d851        	JSR	LAB_2B6E		; ^2 then series evaluation
.d32a  a9 71      lda #$71         	LDA	#<LAB_25B5		; set -0.5 pointer low byte
.d32c  a0 dd      ldy #$dd         	LDY	#>LAB_25B5		; set -0.5 pointer high byte
.d32e  20 be d1   jsr $d1be        	JSR	LAB_246C		; add (AY) to FAC1
.d331  68         pla              	PLA				; restore FAC1 exponent
.d332  20 45 d6   jsr $d645        	JSR	LAB_2912		; evaluate new ASCII digit
.d335  a9 75      lda #$75         	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
.d337  a0 dd      ldy #$dd         	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
.d339                              lab_25fb
.d339  20 8b d3   jsr $d38b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.d33c                              lab_multiply
.d33c  f0 4c      beq $d38a        	BEQ	LAB_264C		; exit if zero
.d33e  20 b1 d3   jsr $d3b1        	JSR	LAB_2673		; test and adjust accumulators
.d341  a9 00      lda #$00         	LDA	#$00			; clear A
.d343  85 75      sta $75          	STA	FACt_1		; clear temp mantissa1
.d345  85 76      sta $76          	STA	FACt_2		; clear temp mantissa2
.d347  85 77      sta $77          	STA	FACt_3		; clear temp mantissa3
.d349  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.d34b  20 60 d3   jsr $d360        	JSR	LAB_2622		; go do shift/add FAC2
.d34e  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.d350  20 60 d3   jsr $d360        	JSR	LAB_2622		; go do shift/add FAC2
.d353  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.d355  20 60 d3   jsr $d360        	JSR	LAB_2622		; go do shift/add FAC2
.d358  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.d35a  20 65 d3   jsr $d365        	JSR	LAB_2627		; go do shift/add FAC2
.d35d  4c 6e d4   jmp $d46e        	JMP	LAB_273C		; copy temp to FAC1, normalise and return
.d360                              lab_2622
.d360  d0 03      bne $d365        	BNE	LAB_2627		; branch if byte <> zero
.d362  4c c8 d2   jmp $d2c8        	JMP	LAB_2569		; shift FCAtemp << A+8 times
.d365                              lab_2627
.d365  4a         lsr              	LSR				; shift byte
.d366  09 80      ora #$80         	ORA	#$80			; set top bit (mark for 8 times)
.d368                              lab_262a
.d368  a8         tay              	TAY				; copy result
.d369  90 13      bcc $d37e        	BCC	LAB_2640		; skip next if bit was zero
.d36b  18         clc              	CLC				; clear carry for add
.d36c  a5 77      lda $77          	LDA	FACt_3		; get temp mantissa3
.d36e  65 b6      adc $b6          	ADC	FAC2_3		; add FAC2 mantissa3
.d370  85 77      sta $77          	STA	FACt_3		; save temp mantissa3
.d372  a5 76      lda $76          	LDA	FACt_2		; get temp mantissa2
.d374  65 b5      adc $b5          	ADC	FAC2_2		; add FAC2 mantissa2
.d376  85 76      sta $76          	STA	FACt_2		; save temp mantissa2
.d378  a5 75      lda $75          	LDA	FACt_1		; get temp mantissa1
.d37a  65 b4      adc $b4          	ADC	FAC2_1		; add FAC2 mantissa1
.d37c  85 75      sta $75          	STA	FACt_1		; save temp mantissa1
.d37e                              lab_2640
.d37e  66 75      ror $75          	ROR	FACt_1		; shift temp mantissa1
.d380  66 76      ror $76          	ROR	FACt_2		; shift temp mantissa2
.d382  66 77      ror $77          	ROR	FACt_3		; shift temp mantissa3
.d384  66 b9      ror $b9          	ROR	FAC1_r		; shift temp rounding byte
.d386  98         tya              	TYA				; get byte back
.d387  4a         lsr              	LSR				; shift byte
.d388  d0 de      bne $d368        	BNE	LAB_262A		; loop if all bits not done
.d38a                              lab_264c
.d38a  60         rts              	RTS
.d38b                              lab_264d
.d38b  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.d38d  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.d38f  a0 03      ldy #$03         	LDY	#$03			; 4 bytes to get (0-3)
.d391  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa3
.d393  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.d395  88         dey              	DEY				; decrement index
.d396  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa2
.d398  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.d39a  88         dey              	DEY				; decrement index
.d39b  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get mantissa1+sign
.d39d  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign (b7)
.d39f  45 b0      eor $b0          	EOR	FAC1_s		; EOR with FAC1 sign (b7)
.d3a1  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.d3a3  a5 b7      lda $b7          	LDA	FAC2_s		; recover FAC2 sign (b7)
.d3a5  09 80      ora #$80         	ORA	#$80			; set 1xxx xxx (set normal bit)
.d3a7  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.d3a9  88         dey              	DEY				; decrement index
.d3aa  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get exponent byte
.d3ac  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.d3ae  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d3b0  60         rts              	RTS
.d3b1                              lab_2673
.d3b1  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.d3b3                              lab_2675
.d3b3  f0 1d      beq $d3d2        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
.d3b5  18         clc              	CLC				; clear carry for add
.d3b6  65 ac      adc $ac          	ADC	FAC1_e		; add FAC1 exponent
.d3b8  90 04      bcc $d3be        	BCC	LAB_2680		; branch if sum of exponents <$0100
.d3ba  30 31      bmi $d3ed        	BMI	LAB_269B		; do overflow error
.d3bc  18         clc              	CLC				; clear carry for the add

>d3bd  2c                          	.byte	$2C			; makes next line BIT $1410
.d3be                              lab_2680

.d3be  10 12      bpl $d3d2        	BPL	LAB_2696		; if +ve go handle underflow
.d3c0  69 80      adc #$80         	ADC	#$80			; adjust exponent
.d3c2  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.d3c4  d0 03      bne $d3c9        	BNE	LAB_268B		; branch if not zero
.d3c6  4c 54 d2   jmp $d254        	JMP	LAB_24F5		; save FAC1 sign and return
.d3c9                              lab_268b
.d3c9  a5 b8      lda $b8          	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
.d3cb  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.d3cd                              lab_268f
.d3cd  60         rts              	RTS
.d3ce                              lab_2690
.d3ce  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d3d0  10 1b      bpl $d3ed        	BPL	LAB_269B		; do overflow error
.d3d2                              lab_2696
.d3d2  68         pla              	PLA				; pop return address low byte
.d3d3  68         pla              	PLA				; pop return address high byte
.d3d4  4c 50 d2   jmp $d250        	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
.d3d7                              lab_269e
.d3d7  20 ca d4   jsr $d4ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.d3da  aa         tax              	TAX				; copy exponent (set the flags)
.d3db  f0 f0      beq $d3cd        	BEQ	LAB_268F		; exit if zero
.d3dd  18         clc              	CLC				; clear carry for add
.d3de  69 02      adc #$02         	ADC	#$02			; add two to exponent (*4)
.d3e0  b0 0b      bcs $d3ed        	BCS	LAB_269B		; do overflow error if > $FF
.d3e2  a2 00      ldx #$00         	LDX	#$00			; clear byte
.d3e4  86 b8      stx $b8          	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.d3e6  20 db d1   jsr $d1db        	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
.d3e9  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent (*10)
.d3eb  d0 e0      bne $d3cd        	BNE	LAB_268F		; if non zero just do RTS
.d3ed                              lab_269b
.d3ed  4c c3 d2   jmp $d2c3        	JMP	LAB_2564		; do overflow error and warm start
.d3f0                              lab_26b9
.d3f0  20 ca d4   jsr $d4ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.d3f3  a9 f1      lda #$f1         	LDA	#<LAB_26B5		; set pointer to 10d low addr
.d3f5  a0 dd      ldy #$dd         	LDY	#>LAB_26B5		; set pointer to 10d high addr
.d3f7  a2 00      ldx #$00         	LDX	#$00			; clear sign
.d3f9                              lab_26c2
.d3f9  86 b8      stx $b8          	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.d3fb  20 7d d4   jsr $d47d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.d3fe  4c 04 d4   jmp $d404        	JMP	LAB_DIVIDE		; do FAC2/FAC1
.d401                              lab_26ca
.d401  20 8b d3   jsr $d38b        	JSR	LAB_264D		; unpack memory (AY) into FAC2
.d404                              lab_divide
.d404  f0 63      beq $d469        	BEQ	LAB_2737		; if zero go do /0 error
.d406  20 d9 d4   jsr $d4d9        	JSR	LAB_27BA		; round FAC1
.d409  a9 00      lda #$00         	LDA	#$00			; clear A
.d40b  38         sec              	SEC				; set carry for subtract
.d40c  e5 ac      sbc $ac          	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
.d40e  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.d410  20 b1 d3   jsr $d3b1        	JSR	LAB_2673		; test and adjust accumulators
.d413  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent
.d415  f0 d6      beq $d3ed        	BEQ	LAB_269B		; if zero do overflow error
.d417  a2 ff      ldx #$ff         	LDX	#$FF			; set index for pre increment
.d419  a9 01      lda #$01         	LDA	#$01			; set bit to flag byte save
.d41b                              lab_26e4
.d41b  a4 b4      ldy $b4          	LDY	FAC2_1		; get FAC2 mantissa1
.d41d  c4 ad      cpy $ad          	CPY	FAC1_1		; compare FAC1 mantissa1
.d41f  d0 0a      bne $d42b        	BNE	LAB_26F4		; branch if <>
.d421  a4 b5      ldy $b5          	LDY	FAC2_2		; get FAC2 mantissa2
.d423  c4 ae      cpy $ae          	CPY	FAC1_2		; compare FAC1 mantissa2
.d425  d0 04      bne $d42b        	BNE	LAB_26F4		; branch if <>
.d427  a4 b6      ldy $b6          	LDY	FAC2_3		; get FAC2 mantissa3
.d429  c4 af      cpy $af          	CPY	FAC1_3		; compare FAC1 mantissa3
.d42b                              lab_26f4
.d42b  08         php              	PHP				; save FAC2-FAC1 compare status
.d42c  2a         rol              	ROL				; shift the result byte
.d42d  90 0e      bcc $d43d        	BCC	LAB_2702		; if no carry skip the byte save
.d42f  a0 01      ldy #$01         	LDY	#$01			; set bit to flag byte save
.d431  e8         inx              	INX				; else increment the index to FACt
.d432  e0 02      cpx #$02         	CPX	#$02			; compare with the index to FACt_3
.d434  30 04      bmi $d43a        	BMI	LAB_2701		; if not last byte just go save it
.d436  d0 28      bne $d460        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
.d438  a0 40      ldy #$40         	LDY	#$40			; set bit to flag byte save for the rounding byte
.d43a                              lab_2701
.d43a  95 75      sta $75,x        	STA	FACt_1,X		; write result byte to FACt_1 + index
.d43c  98         tya              	TYA				; copy the next save byte flag
.d43d                              lab_2702
.d43d  28         plp              	PLP				; restore FAC2-FAC1 compare status
.d43e  90 14      bcc $d454        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
.d440  a8         tay              	TAY				; save FAC2-FAC1 compare status
.d441  a5 b6      lda $b6          	LDA	FAC2_3		; get FAC2 mantissa3
.d443  e5 af      sbc $af          	SBC	FAC1_3		; subtract FAC1 mantissa3
.d445  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.d447  a5 b5      lda $b5          	LDA	FAC2_2		; get FAC2 mantissa2
.d449  e5 ae      sbc $ae          	SBC	FAC1_2		; subtract FAC1 mantissa2
.d44b  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.d44d  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.d44f  e5 ad      sbc $ad          	SBC	FAC1_1		; subtract FAC1 mantissa1
.d451  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.d453  98         tya              	TYA				; restore FAC2-FAC1 compare status
.d454                              lab_2704
.d454  06 b6      asl $b6          	ASL	FAC2_3		; shift FAC2 mantissa3
.d456  26 b5      rol $b5          	ROL	FAC2_2		; shift FAC2 mantissa2
.d458  26 b4      rol $b4          	ROL	FAC2_1		; shift FAC2 mantissa1
.d45a  b0 cf      bcs $d42b        	BCS	LAB_26F4		; loop with no compare
.d45c  30 bd      bmi $d41b        	BMI	LAB_26E4		; loop with compare
.d45e  10 cb      bpl $d42b        	BPL	LAB_26F4		; loop always with no compare
.d460                              lab_272b
.d460  4a         lsr              	LSR				; shift b1 - b0 ..
.d461  6a         ror              	ROR				; ..
.d462  6a         ror              	ROR				; .. to b7 - b6
.d463  85 b9      sta $b9          	STA	FAC1_r		; save FAC1 rounding byte
.d465  28         plp              	PLP				; dump FAC2-FAC1 compare status
.d466  4c 6e d4   jmp $d46e        	JMP	LAB_273C		; copy temp to FAC1, normalise and return
.d469                              lab_2737
.d469  a2 14      ldx #$14         	LDX	#$14			; error code $14 ("Divide by zero" error)
.d46b  4c 3c bd   jmp $bd3c        	JMP	LAB_XERR		; do error #X, then warm start
.d46e                              lab_273c
.d46e  a5 75      lda $75          	LDA	FACt_1		; get temp mantissa1
.d470  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d472  a5 76      lda $76          	LDA	FACt_2		; get temp mantissa2
.d474  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.d476  a5 77      lda $77          	LDA	FACt_3		; get temp mantissa3
.d478  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.d47a  4c 34 d2   jmp $d234        	JMP	LAB_24D5		; normalise FAC1 and return
.d47d                              lab_ufac
.d47d  85 71      sta $71          	STA	ut1_pl		; save pointer low byte
.d47f  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.d481  a0 03      ldy #$03         	LDY	#$03			; 4 bytes to do
.d483  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get last byte
.d485  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.d487  88         dey              	DEY				; decrement index
.d488  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get last-1 byte
.d48a  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.d48c  88         dey              	DEY				; decrement index
.d48d  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get second byte
.d48f  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.d491  09 80      ora #$80         	ORA	#$80			; set 1xxx xxxx (add normal bit)
.d493  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d495  88         dey              	DEY				; decrement index
.d496  b1 71      lda ($71),y      	LDA	(ut1_pl),Y		; get first byte (exponent)
.d498  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.d49a  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.d49c  60         rts              	RTS
.d49d                              lab_276e
.d49d  a2 a4      ldx #$a4         	LDX	#<Adatal		; set pointer low byte
.d49f                              lab_2770
.d49f  a0 00      ldy #$00         	LDY	#>Adatal		; set pointer high byte
.d4a1  f0 04      beq $d4a7        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
.d4a3                              lab_pfac
.d4a3  a6 97      ldx $97          	LDX	Lvarpl		; get destination pointer low byte
.d4a5  a4 98      ldy $98          	LDY	Lvarph		; get destination pointer high byte
.d4a7                              lab_2778
.d4a7  20 d9 d4   jsr $d4d9        	JSR	LAB_27BA		; round FAC1
.d4aa  86 71      stx $71          	STX	ut1_pl		; save pointer low byte
.d4ac  84 72      sty $72          	STY	ut1_ph		; save pointer high byte
.d4ae  a0 03      ldy #$03         	LDY	#$03			; set index
.d4b0  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.d4b2  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.d4b4  88         dey              	DEY				; decrement index
.d4b5  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.d4b7  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.d4b9  88         dey              	DEY				; decrement index
.d4ba  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d4bc  09 7f      ora #$7f         	ORA	#$7F			; set bits x111 1111
.d4be  25 ad      and $ad          	AND	FAC1_1		; AND in FAC1 mantissa1
.d4c0  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.d4c2  88         dey              	DEY				; decrement index
.d4c3  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d4c5  91 71      sta ($71),y      	STA	(ut1_pl),Y		; store in destination
.d4c7  84 b9      sty $b9          	STY	FAC1_r		; clear FAC1 rounding byte
.d4c9  60         rts              	RTS
.d4ca                              lab_27ab
.d4ca  20 d9 d4   jsr $d4d9        	JSR	LAB_27BA		; round FAC1
.d4cd                              lab_27ae
.d4cd  a2 05      ldx #$05         	LDX	#$05			; 5 bytes to copy
.d4cf                              lab_27b0
.d4cf  b5 ab      lda $ab,x        	LDA	FAC1_e-1,X		; get byte from FAC1,X
.d4d1  95 b2      sta $b2,x        	STA	FAC1_o,X		; save byte at FAC2,X
.d4d3  ca         dex              	DEX				; decrement count
.d4d4  d0 f9      bne $d4cf        	BNE	LAB_27B0		; loop if not all done
.d4d6  86 b9      stx $b9          	STX	FAC1_r		; clear FAC1 rounding byte
.d4d8                              lab_27b9
.d4d8  60         rts              	RTS
.d4d9                              lab_27ba
.d4d9  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d4db  f0 fb      beq $d4d8        	BEQ	LAB_27B9		; exit if zero
.d4dd  06 b9      asl $b9          	ASL	FAC1_r		; shift FAC1 rounding byte
.d4df  90 f7      bcc $d4d8        	BCC	LAB_27B9		; exit if no overflow
.d4e1                              lab_27c2
.d4e1  20 b8 d2   jsr $d2b8        	JSR	LAB_2559		; increment FAC1 mantissa
.d4e4  d0 f2      bne $d4d8        	BNE	LAB_27B9		; branch if no overflow
.d4e6  4c 89 d2   jmp $d289        	JMP	LAB_252A		; normalise FAC1 for C=1 and return
.d4e9                              lab_27ca
.d4e9  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d4eb  f0 09      beq $d4f6        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
.d4ed                              lab_27ce
.d4ed  a5 b0      lda $b0          	LDA	FAC1_s		; else get FAC1 sign (b7)
.d4ef                              lab_27d0
.d4ef  2a         rol              	ROL				; move sign bit to carry
.d4f0  a9 ff      lda #$ff         	LDA	#$FF			; set byte for -ve result
.d4f2  b0 02      bcs $d4f6        	BCS	LAB_27D7		; return if sign was set (-ve)
.d4f4  a9 01      lda #$01         	LDA	#$01			; else set byte for +ve result
.d4f6                              lab_27d7
.d4f6  60         rts              	RTS
.d4f7                              lab_sgn
.d4f7  20 e9 d4   jsr $d4e9        	JSR	LAB_27CA		; get FAC1 sign
.d4fa                              lab_27db
.d4fa  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d4fc  a9 00      lda #$00         	LDA	#$00			; clear A
.d4fe  85 ae      sta $ae          	STA	FAC1_2		; clear FAC1 mantissa2
.d500  a2 88      ldx #$88         	LDX	#$88			; set exponent
.d502                              lab_27e3
.d502  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.d504  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d506  2a         rol              	ROL				; sign bit into carry
.d507                              lab_stfa
.d507  a9 00      lda #$00         	LDA	#$00			; clear A
.d509  85 af      sta $af          	STA	FAC1_3		; clear FAC1 mantissa3
.d50b  86 ac      stx $ac          	STX	FAC1_e		; set FAC1 exponent
.d50d  85 b9      sta $b9          	STA	FAC1_r		; clear FAC1 rounding byte
.d50f  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.d511  4c 2f d2   jmp $d22f        	JMP	LAB_24D0		; do ABS and normalise FAC1
.d514                              lab_abs
.d514  46 b0      lsr $b0          	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
.d516  60         rts              	RTS
.d517                              lab_27f8
.d517  85 73      sta $73          	STA	ut2_pl		; save pointer low byte
.d519                              lab_27fa
.d519  84 74      sty $74          	STY	ut2_ph		; save pointer high byte
.d51b  a0 00      ldy #$00         	LDY	#$00			; clear index
.d51d  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get exponent
.d51f  c8         iny              	INY				; increment index
.d520  aa         tax              	TAX				; copy (AY) exponent to X
.d521  f0 c6      beq $d4e9        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
.d523  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.d525  45 b0      eor $b0          	EOR	FAC1_s		; EOR FAC1 sign (b7)
.d527  30 c4      bmi $d4ed        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
.d529  e4 ac      cpx $ac          	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
.d52b  d0 1a      bne $d547        	BNE	LAB_2828		; branch if different
.d52d  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
.d52f  09 80      ora #$80         	ORA	#$80			; normalise top bit
.d531  c5 ad      cmp $ad          	CMP	FAC1_1		; compare with FAC1 mantissa1
.d533  d0 12      bne $d547        	BNE	LAB_2828		; branch if different
.d535  c8         iny              	INY				; increment index
.d536  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get mantissa2
.d538  c5 ae      cmp $ae          	CMP	FAC1_2		; compare with FAC1 mantissa2
.d53a  d0 0b      bne $d547        	BNE	LAB_2828		; branch if different
.d53c  c8         iny              	INY				; increment index
.d53d  a9 7f      lda #$7f         	LDA	#$7F			; set for 1/2 value rounding byte
.d53f  c5 b9      cmp $b9          	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
.d541  b1 73      lda ($73),y      	LDA	(ut2_pl),Y		; get mantissa3
.d543  e5 af      sbc $af          	SBC	FAC1_3		; subtract FAC1 mantissa3
.d545  f0 28      beq $d56f        	BEQ	LAB_2850		; exit if mantissa3 equal
.d547                              lab_2828
.d547  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d549  90 02      bcc $d54d        	BCC	LAB_282E		; branch if FAC1 > (AY)
.d54b  49 ff      eor #$ff         	EOR	#$FF			; else toggle FAC1 sign
.d54d                              lab_282e
.d54d  4c ef d4   jmp $d4ef        	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
.d550                              lab_2831
.d550  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d552  f0 4a      beq $d59e        	BEQ	LAB_287F		; if zero go clear FAC1 and return
.d554  38         sec              	SEC				; set carry for subtract
.d555  e9 98      sbc #$98         	SBC	#$98			; subtract maximum integer range exponent
.d557  24 b0      bit $b0          	BIT	FAC1_s		; test FAC1 sign (b7)
.d559  10 09      bpl $d564        	BPL	LAB_2845		; branch if FAC1 +ve
.d55b  aa         tax              	TAX				; copy subtracted exponent
.d55c  a9 ff      lda #$ff         	LDA	#$FF			; overflow for -ve number
.d55e  85 b2      sta $b2          	STA	FAC1_o		; set FAC1 overflow byte
.d560  20 9c d2   jsr $d29c        	JSR	LAB_253D		; twos complement FAC1 mantissa
.d563  8a         txa              	TXA				; restore subtracted exponent
.d564                              lab_2845
.d564  a2 ac      ldx #$ac         	LDX	#FAC1_e		; set index to FAC1
.d566  c9 f9      cmp #$f9         	CMP	#$F9			; compare exponent result
.d568  10 06      bpl $d570        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
.d56a  20 da d2   jsr $d2da        	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
.d56d  84 b2      sty $b2          	STY	FAC1_o		; clear FAC1 overflow byte
.d56f                              lab_2850
.d56f  60         rts              	RTS
.d570                              lab_2851
.d570  a8         tay              	TAY				; copy shift count
.d571  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d573  29 80      and #$80         	AND	#$80			; mask sign bit only (x000 0000)
.d575  46 ad      lsr $ad          	LSR	FAC1_1		; shift FAC1 mantissa1
.d577  05 ad      ora $ad          	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
.d579  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d57b  20 f1 d2   jsr $d2f1        	JSR	LAB_2592		; shift FAC1 Y times right
.d57e  84 b2      sty $b2          	STY	FAC1_o		; clear FAC1 overflow byte
.d580  60         rts              	RTS
.d581                              lab_int
.d581  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d583  c9 98      cmp #$98         	CMP	#$98			; compare with max int
.d585  b0 1e      bcs $d5a5        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
.d587  20 50 d5   jsr $d550        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.d58a  84 b9      sty $b9          	STY	FAC1_r		; save FAC1 rounding byte
.d58c  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d58e  84 b0      sty $b0          	STY	FAC1_s		; save FAC1 sign (b7)
.d590  49 80      eor #$80         	EOR	#$80			; toggle FAC1 sign
.d592  2a         rol              	ROL				; shift into carry
.d593  a9 98      lda #$98         	LDA	#$98			; set new exponent
.d595  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.d597  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.d599  85 5b      sta $5b          	STA	Temp3			; save for EXP() function
.d59b  4c 2f d2   jmp $d22f        	JMP	LAB_24D0		; do ABS and normalise FAC1
.d59e                              lab_287f
.d59e  85 ad      sta $ad          	STA	FAC1_1		; clear FAC1 mantissa1
.d5a0  85 ae      sta $ae          	STA	FAC1_2		; clear FAC1 mantissa2
.d5a2  85 af      sta $af          	STA	FAC1_3		; clear FAC1 mantissa3
.d5a4  a8         tay              	TAY				; clear Y
.d5a5                              lab_2886
.d5a5  60         rts              	RTS
.d5a6                              lab_2887
.d5a6  a0 00      ldy #$00         	LDY	#$00			; clear Y
.d5a8  84 5f      sty $5f          	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
.d5aa  a2 09      ldx #$09         	LDX	#$09			; set index
.d5ac                              lab_288b
.d5ac  94 a8      sty $a8,x        	STY	numexp,X		; clear byte
.d5ae  ca         dex              	DEX				; decrement index
.d5af  10 fb      bpl $d5ac        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
.d5b1  90 7f      bcc $d632        	BCC	LAB_28FE		; branch if 1st character numeric
.d5b3  c9 2d      cmp #$2d         	CMP	#"-"			; else compare with "-"
.d5b5  d0 04      bne $d5bb        	BNE	LAB_289A		; branch if not "-"
.d5b7  86 b1      stx $b1          	STX	negnum		; set flag for -ve number (X = $FF)
.d5b9  f0 04      beq $d5bf        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
.d5bb                              lab_289a
.d5bb  c9 2b      cmp #$2b         	CMP	#"+"			; else compare with "+"
.d5bd  d0 05      bne $d5c4        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
.d5bf                              lab_289c
.d5bf  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.d5c2  90 6e      bcc $d632        	BCC	LAB_28FE		; branch if numeric character
.d5c4                              lab_289d
.d5c4  c9 24      cmp #$24         	CMP	#"$"			; else compare with "$"
.d5c6  d0 03      bne $d5cb        	BNE	LAB_NHEX		; branch if not "$"
.d5c8  4c 6e da   jmp $da6e        	JMP	LAB_CHEX		; branch if "$"
.d5cb                              lab_nhex
.d5cb  c9 25      cmp #$25         	CMP	#"%"			; else compare with "%"
.d5cd  d0 08      bne $d5d7        	BNE	LAB_28A3		; branch if not "%" (continue original code)
.d5cf  4c 9c da   jmp $da9c        	JMP	LAB_CBIN		; branch if "%"
.d5d2                              lab_289e
.d5d2  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
.d5d5                              lab_28a1
.d5d5  90 5b      bcc $d632        	BCC	LAB_28FE		; branch if numeric character
.d5d7                              lab_28a3
.d5d7  c9 2e      cmp #$2e         	CMP	#"."			; else compare with "."
.d5d9  f0 2e      beq $d609        	BEQ	LAB_28D5		; branch if "."
.d5db  c9 45      cmp #$45         	CMP	#"E"			; else compare with "E"
.d5dd  d0 30      bne $d60f        	BNE	LAB_28DB		; branch if not "E"
.d5df  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.d5e2  90 17      bcc $d5fb        	BCC	LAB_28C7		; branch if numeric character
.d5e4  c9 b8      cmp #$b8         	CMP	#TK_MINUS		; else compare with token for -
.d5e6  f0 0e      beq $d5f6        	BEQ	LAB_28C2		; branch if token for -
.d5e8  c9 2d      cmp #$2d         	CMP	#"-"			; else compare with "-"
.d5ea  f0 0a      beq $d5f6        	BEQ	LAB_28C2		; branch if "-"
.d5ec  c9 b7      cmp #$b7         	CMP	#TK_PLUS		; else compare with token for +
.d5ee  f0 08      beq $d5f8        	BEQ	LAB_28C4		; branch if token for +
.d5f0  c9 2b      cmp #$2b         	CMP	#"+"			; else compare with "+"
.d5f2  f0 04      beq $d5f8        	BEQ	LAB_28C4		; branch if "+"
.d5f4  d0 07      bne $d5fd        	BNE	LAB_28C9		; branch always
.d5f6                              lab_28c2
.d5f6  66 ab      ror $ab          	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
.d5f8                              lab_28c4
.d5f8  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.d5fb                              lab_28c7
.d5fb  90 5b      bcc $d658        	BCC	LAB_2925		; branch if numeric character
.d5fd                              lab_28c9
.d5fd  24 ab      bit $ab          	BIT	expneg		; test exponent -ve flag
.d5ff  10 0e      bpl $d60f        	BPL	LAB_28DB		; if +ve go evaluate exponent
.d601  a9 00      lda #$00         	LDA	#$00			; clear result
.d603  38         sec              	SEC				; set carry for subtract
.d604  e5 a9      sbc $a9          	SBC	expcnt		; subtract exponent byte
.d606  4c 11 d6   jmp $d611        	JMP	LAB_28DD		; go evaluate exponent
.d609                              lab_28d5
.d609  66 aa      ror $aa          	ROR	numdpf		; set decimal point flag
.d60b  24 aa      bit $aa          	BIT	numdpf		; test decimal point flag
.d60d  50 c3      bvc $d5d2        	BVC	LAB_289E		; branch if only one decimal point so far
.d60f                              lab_28db
.d60f  a5 a9      lda $a9          	LDA	expcnt		; get exponent count byte
.d611                              lab_28dd
.d611  38         sec              	SEC				; set carry for subtract
.d612  e5 a8      sbc $a8          	SBC	numexp		; subtract numerator exponent
.d614  85 a9      sta $a9          	STA	expcnt		; save exponent count byte
.d616  f0 12      beq $d62a        	BEQ	LAB_28F6		; branch if no adjustment
.d618  10 09      bpl $d623        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
.d61a                              lab_28e6
.d61a  20 f0 d3   jsr $d3f0        	JSR	LAB_26B9		; divide by 10
.d61d  e6 a9      inc $a9          	INC	expcnt		; increment exponent count byte
.d61f  d0 f9      bne $d61a        	BNE	LAB_28E6		; loop until all done
.d621  f0 07      beq $d62a        	BEQ	LAB_28F6		; branch always
.d623                              lab_28ef
.d623  20 d7 d3   jsr $d3d7        	JSR	LAB_269E		; multiply by 10
.d626  c6 a9      dec $a9          	DEC	expcnt		; decrement exponent count byte
.d628  d0 f9      bne $d623        	BNE	LAB_28EF		; loop until all done
.d62a                              lab_28f6
.d62a  a5 b1      lda $b1          	LDA	negnum		; get -ve flag
.d62c  30 01      bmi $d62f        	BMI	LAB_28FB		; if -ve do - FAC1 and return
.d62e  60         rts              	RTS
.d62f                              lab_28fb
.d62f  4c f4 d7   jmp $d7f4        	JMP	LAB_GTHAN		; do - FAC1 and return
.d632                              lab_28fe
.d632  48         pha              	PHA				; save character
.d633  24 aa      bit $aa          	BIT	numdpf		; test decimal point flag
.d635  10 02      bpl $d639        	BPL	LAB_2905		; skip exponent increment if not set
.d637  e6 a8      inc $a8          	INC	numexp		; else increment number exponent
.d639                              lab_2905
.d639  20 d7 d3   jsr $d3d7        	JSR	LAB_269E		; multiply FAC1 by 10
.d63c  68         pla              	PLA				; restore character
.d63d  29 0f      and #$0f         	AND	#$0F			; convert to binary
.d63f  20 45 d6   jsr $d645        	JSR	LAB_2912		; evaluate new ASCII digit
.d642  4c d2 d5   jmp $d5d2        	JMP	LAB_289E		; go do next character
.d645                              lab_2912
.d645  48         pha              	PHA				; save digit
.d646  20 ca d4   jsr $d4ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.d649  68         pla              	PLA				; restore digit
.d64a  20 fa d4   jsr $d4fa        	JSR	LAB_27DB		; save A as integer byte
.d64d  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.d64f  45 b0      eor $b0          	EOR	FAC1_s		; toggle with FAC1 sign (b7)
.d651  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.d653  a6 ac      ldx $ac          	LDX	FAC1_e		; get FAC1 exponent
.d655  4c c1 d1   jmp $d1c1        	JMP	LAB_ADD		; add FAC2 to FAC1 and return
.d658                              lab_2925
.d658  a5 a9      lda $a9          	LDA	expcnt		; get exponent count byte
.d65a  c9 0a      cmp #$0a         	CMP	#$0A			; compare with 10 decimal
.d65c  90 09      bcc $d667        	BCC	LAB_2934		; branch if less
.d65e  a9 64      lda #$64         	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
.d660  24 ab      bit $ab          	BIT	expneg		; test exponent -ve flag
.d662  30 0e      bmi $d672        	BMI	LAB_2942		; branch if -ve
.d664  4c c3 d2   jmp $d2c3        	JMP	LAB_2564		; else do overflow error
.d667                              lab_2934
.d667  0a         asl              	ASL				; * 2
.d668  0a         asl              	ASL				; * 4
.d669  65 a9      adc $a9          	ADC	expcnt		; * 5
.d66b  0a         asl              	ASL				; * 10
.d66c  a0 00      ldy #$00         	LDY	#$00			; set index
.d66e  71 c3      adc ($c3),y      	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
.d670  e9 2f      sbc #$2f         	SBC	#"0"-1		; convert character to binary
.d672                              lab_2942
.d672  85 a9      sta $a9          	STA	expcnt		; save exponent count byte
.d674  4c f8 d5   jmp $d5f8        	JMP	LAB_28C4		; go get next character
.d677                              lab_2953
.d677  a9 f6      lda #$f6         	LDA	#<LAB_LMSG		; point to " in line " message low byte
.d679  a0 e3      ldy #$e3         	LDY	#>LAB_LMSG		; point to " in line " message high byte
.d67b  20 d3 c4   jsr $c4d3        	JSR	LAB_18C3		; print null terminated string from memory
.d67e  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.d680  a6 87      ldx $87          	LDX	Clinel		; get current line low byte
.d682                              lab_295e
.d682  85 ad      sta $ad          	STA	FAC1_1		; save low byte as FAC1 mantissa1
.d684  86 ae      stx $ae          	STX	FAC1_2		; save high byte as FAC1 mantissa2
.d686  a2 90      ldx #$90         	LDX	#$90			; set exponent to 16d bits
.d688  38         sec              	SEC				; set integer is +ve flag
.d689  20 07 d5   jsr $d507        	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
.d68c  a0 00      ldy #$00         	LDY	#$00			; clear index
.d68e  98         tya              	TYA				; clear A
.d68f  20 a2 d6   jsr $d6a2        	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
.d692  4c d3 c4   jmp $c4d3        	JMP	LAB_18C3		; print null terminated string from memory and return
.d695                              lab_296e
.d695  a0 01      ldy #$01         	LDY	#$01			; set index = 1
.d697  a9 20      lda #$20         	LDA	#$20			; character = " " (assume +ve)
.d699  24 b0      bit $b0          	BIT	FAC1_s		; test FAC1 sign (b7)
.d69b  10 02      bpl $d69f        	BPL	LAB_2978		; branch if +ve
.d69d  a9 2d      lda #$2d         	LDA	#$2D			; else character = "-"
.d69f                              lab_2978
.d69f  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save leading character (" " or "-")
.d6a2                              lab_297b
.d6a2  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.d6a4  84 ba      sty $ba          	STY	Sendl			; save index
.d6a6  c8         iny              	INY				; increment index
.d6a7  a6 ac      ldx $ac          	LDX	FAC1_e		; get FAC1 exponent
.d6a9  d0 05      bne $d6b0        	BNE	LAB_2989		; branch if FAC1<>0
.d6ab  a9 30      lda #$30         	LDA	#"0"			; set character = "0"
.d6ad  4c ae d7   jmp $d7ae        	JMP	LAB_2A89		; save last character, [EOT] and exit
.d6b0                              lab_2989
.d6b0  a9 00      lda #$00         	LDA	#$00			; clear (number exponent count)
.d6b2  e0 81      cpx #$81         	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
.d6b4  b0 09      bcs $d6bf        	BCS	LAB_299A		; branch if FAC1=>1
.d6b6  a9 81      lda #$81         	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
.d6b8  a0 dd      ldy #$dd         	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
.d6ba  20 39 d3   jsr $d339        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.d6bd  a9 fa      lda #$fa         	LDA	#$FA			; set number exponent count (-6)
.d6bf                              lab_299a
.d6bf  85 a8      sta $a8          	STA	numexp		; save number exponent count
.d6c1                              lab_299c
.d6c1  a9 7d      lda #$7d         	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
.d6c3  a0 dd      ldy #$dd         	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
.d6c5  20 17 d5   jsr $d517        	JSR	LAB_27F8		; compare FAC1 with (AY)
.d6c8  f0 1e      beq $d6e8        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
.d6ca  10 12      bpl $d6de        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
.d6cc                              lab_29a7
.d6cc  a9 79      lda #$79         	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
.d6ce  a0 dd      ldy #$dd         	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
.d6d0  20 17 d5   jsr $d517        	JSR	LAB_27F8		; compare FAC1 with (AY)
.d6d3  f0 02      beq $d6d7        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
.d6d5  10 0e      bpl $d6e5        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
.d6d7                              lab_29b2
.d6d7  20 d7 d3   jsr $d3d7        	JSR	LAB_269E		; multiply by 10
.d6da  c6 a8      dec $a8          	DEC	numexp		; decrement number exponent count
.d6dc  d0 ee      bne $d6cc        	BNE	LAB_29A7		; go test again (branch always)
.d6de                              lab_29b9
.d6de  20 f0 d3   jsr $d3f0        	JSR	LAB_26B9		; divide by 10
.d6e1  e6 a8      inc $a8          	INC	numexp		; increment number exponent count
.d6e3  d0 dc      bne $d6c1        	BNE	LAB_299C		; go test again (branch always)
.d6e5                              lab_29c0
.d6e5  20 ba d1   jsr $d1ba        	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
.d6e8                              lab_29c3
.d6e8  20 50 d5   jsr $d550        	JSR	LAB_2831		; convert FAC1 floating-to-fixed
.d6eb  a2 01      ldx #$01         	LDX	#$01			; set default digits before dp = 1
.d6ed  a5 a8      lda $a8          	LDA	numexp		; get number exponent count
.d6ef  18         clc              	CLC				; clear carry for add
.d6f0  69 07      adc #$07         	ADC	#$07			; up to 6 digits before point
.d6f2  30 09      bmi $d6fd        	BMI	LAB_29D8		; if -ve then 1 digit before dp
.d6f4  c9 08      cmp #$08         	CMP	#$08			; A>=8 if n>=1E6
.d6f6  b0 06      bcs $d6fe        	BCS	LAB_29D9		; branch if >= $08
.d6f8  69 ff      adc #$ff         	ADC	#$FF			; take 1 from digit count
.d6fa  aa         tax              	TAX				; copy to A
.d6fb  a9 02      lda #$02         	LDA	#$02			;.set exponent adjust
.d6fd                              lab_29d8
.d6fd  38         sec              	SEC				; set carry for subtract
.d6fe                              lab_29d9
.d6fe  e9 02      sbc #$02         	SBC	#$02			; -2
.d700  85 a9      sta $a9          	STA	expcnt		;.save exponent adjust
.d702  86 a8      stx $a8          	STX	numexp		; save digits before dp count
.d704  8a         txa              	TXA				; copy to A
.d705  f0 02      beq $d709        	BEQ	LAB_29E4		; branch if no digits before dp
.d707  10 13      bpl $d71c        	BPL	LAB_29F7		; branch if digits before dp
.d709                              lab_29e4
.d709  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.d70b  a9 2e      lda #$2e         	LDA	#$2E			; character "."
.d70d  c8         iny              	INY				; increment index
.d70e  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.d711  8a         txa              	TXA				;.
.d712  f0 06      beq $d71a        	BEQ	LAB_29F5		;.
.d714  a9 30      lda #$30         	LDA	#"0"			; character "0"
.d716  c8         iny              	INY				; increment index
.d717  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.d71a                              lab_29f5
.d71a  84 ba      sty $ba          	STY	Sendl			; save output string index
.d71c                              lab_29f7
.d71c  a0 00      ldy #$00         	LDY	#$00			; clear index (point to 100,000)
.d71e  a2 80      ldx #$80         	LDX	#$80			; 
.d720                              lab_29fb
.d720  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.d722  18         clc              	CLC				; clear carry for add
.d723  79 f7 dd   adc $ddf7,y      	ADC	LAB_2A9C,Y		; add -ve LSB
.d726  85 af      sta $af          	STA	FAC1_3		; save FAC1 mantissa3
.d728  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.d72a  79 f6 dd   adc $ddf6,y      	ADC	LAB_2A9B,Y		; add -ve NMSB
.d72d  85 ae      sta $ae          	STA	FAC1_2		; save FAC1 mantissa2
.d72f  a5 ad      lda $ad          	LDA	FAC1_1		; get FAC1 mantissa1
.d731  79 f5 dd   adc $ddf5,y      	ADC	LAB_2A9A,Y		; add -ve MSB
.d734  85 ad      sta $ad          	STA	FAC1_1		; save FAC1 mantissa1
.d736  e8         inx              	INX				; 
.d737  b0 04      bcs $d73d        	BCS	LAB_2A18		; 
.d739  10 e5      bpl $d720        	BPL	LAB_29FB		; not -ve so try again
.d73b  30 02      bmi $d73f        	BMI	LAB_2A1A		; 
.d73d                              lab_2a18
.d73d  30 e1      bmi $d720        	BMI	LAB_29FB		; 
.d73f                              lab_2a1a
.d73f  8a         txa              	TXA				; 
.d740  90 04      bcc $d746        	BCC	LAB_2A21		; 
.d742  49 ff      eor #$ff         	EOR	#$FF			; 
.d744  69 0a      adc #$0a         	ADC	#$0A			; 
.d746                              lab_2a21
.d746  69 2f      adc #$2f         	ADC	#"0"-1		; add "0"-1 to result
.d748  c8         iny              	INY				; increment index ..
.d749  c8         iny              	INY				; .. to next less ..
.d74a  c8         iny              	INY				; .. power of ten
.d74b  84 95      sty $95          	STY	Cvaral		; save as current var address low byte
.d74d  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.d74f  c8         iny              	INY				; increment output string index
.d750  aa         tax              	TAX				; copy character to X
.d751  29 7f      and #$7f         	AND	#$7F			; mask out top bit
.d753  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.d756  c6 a8      dec $a8          	DEC	numexp		; decrement # of characters before the dp
.d758  d0 06      bne $d760        	BNE	LAB_2A3B		; branch if still characters to do
.d75a  a9 2e      lda #$2e         	LDA	#$2E			; character "."
.d75c  c8         iny              	INY				; increment output string index
.d75d  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save to output string
.d760                              lab_2a3b
.d760  84 ba      sty $ba          	STY	Sendl			; save output string index
.d762  a4 95      ldy $95          	LDY	Cvaral		; get current var address low byte
.d764  8a         txa              	TXA				; get character back
.d765  49 ff      eor #$ff         	EOR	#$FF			; 
.d767  29 80      and #$80         	AND	#$80			; 
.d769  aa         tax              	TAX				; 
.d76a  c0 12      cpy #$12         	CPY	#$12			; compare index with max
.d76c  d0 b2      bne $d720        	BNE	LAB_29FB		; loop if not max
.d76e  a4 ba      ldy $ba          	LDY	Sendl			; get output string index
.d770                              lab_2a4b
.d770  b9 ef 00   lda $00ef,y      	LDA	Decss,Y		; get character from output string
.d773  88         dey              	DEY				; decrement output string index
.d774  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.d776  f0 f8      beq $d770        	BEQ	LAB_2A4B		; loop until non "0" character found
.d778  c9 2e      cmp #$2e         	CMP	#"."			; compare with "."
.d77a  f0 01      beq $d77d        	BEQ	LAB_2A58		; branch if was dp
.d77c  c8         iny              	INY				; increment output string index
.d77d                              lab_2a58
.d77d  a9 2b      lda #$2b         	LDA	#$2B			; character "+"
.d77f  a6 a9      ldx $a9          	LDX	expcnt		; get exponent count
.d781  f0 2e      beq $d7b1        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
.d783  10 08      bpl $d78d        	BPL	LAB_2A68		; branch if exponent count +ve
.d785  a9 00      lda #$00         	LDA	#$00			; clear A
.d787  38         sec              	SEC				; set carry for subtract
.d788  e5 a9      sbc $a9          	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
.d78a  aa         tax              	TAX				; copy exponent count to X
.d78b  a9 2d      lda #$2d         	LDA	#"-"			; character "-"
.d78d                              lab_2a68
.d78d  99 f1 00   sta $00f1,y      	STA	Decss+2,Y		; save to output string
.d790  a9 45      lda #$45         	LDA	#$45			; character "E"
.d792  99 f0 00   sta $00f0,y      	STA	Decss+1,Y		; save exponent sign to output string
.d795  8a         txa              	TXA				; get exponent count back
.d796  a2 2f      ldx #$2f         	LDX	#"0"-1		; one less than "0" character
.d798  38         sec              	SEC				; set carry for subtract
.d799                              lab_2a74
.d799  e8         inx              	INX				; increment 10's character
.d79a  e9 0a      sbc #$0a         	SBC	#$0A			;.subtract 10 from exponent count
.d79c  b0 fb      bcs $d799        	BCS	LAB_2A74		; loop while still >= 0
.d79e  69 3a      adc #$3a         	ADC	#":"			; add character ":" ($30+$0A, result is 10 less that value)
.d7a0  99 f3 00   sta $00f3,y      	STA	Decss+4,Y		; save to output string
.d7a3  8a         txa              	TXA				; copy 10's character
.d7a4  99 f2 00   sta $00f2,y      	STA	Decss+3,Y		; save to output string
.d7a7  a9 00      lda #$00         	LDA	#$00			; set null terminator
.d7a9  99 f4 00   sta $00f4,y      	STA	Decss+5,Y		; save to output string
.d7ac  f0 08      beq $d7b6        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
.d7ae                              lab_2a89
.d7ae  99 ef 00   sta $00ef,y      	STA	Decss,Y		; save last character to output string
.d7b1                              lab_2a8c
.d7b1  a9 00      lda #$00         	LDA	#$00			; set null terminator
.d7b3  99 f0 00   sta $00f0,y      	STA	Decss+1,Y		; save after last character
.d7b6                              lab_2a91
.d7b6  a9 f0      lda #$f0         	LDA	#<Decssp1		; set result string low pointer
.d7b8  a0 00      ldy #$00         	LDY	#>Decssp1		; set result string high pointer
.d7ba  60         rts              	RTS
.d7bb                              lab_power
.d7bb  f0 42      beq $d7ff        	BEQ	LAB_EXP		; go do  EXP()
.d7bd  a5 b3      lda $b3          	LDA	FAC2_e		; get FAC2 exponent
.d7bf  d0 03      bne $d7c4        	BNE	LAB_2ABF		; branch if FAC2<>0
.d7c1  4c 52 d2   jmp $d252        	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
.d7c4                              lab_2abf
.d7c4  a2 9c      ldx #$9c         	LDX	#<func_l		; set destination pointer low byte
.d7c6  a0 00      ldy #$00         	LDY	#>func_l		; set destination pointer high byte
.d7c8  20 a7 d4   jsr $d4a7        	JSR	LAB_2778		; pack FAC1 into (XY)
.d7cb  a5 b7      lda $b7          	LDA	FAC2_s		; get FAC2 sign (b7)
.d7cd  10 0f      bpl $d7de        	BPL	LAB_2AD9		; branch if FAC2>0
.d7cf  20 81 d5   jsr $d581        	JSR	LAB_INT		; perform INT
.d7d2  a9 9c      lda #$9c         	LDA	#<func_l		; set source pointer low byte
.d7d4  a0 00      ldy #$00         	LDY	#>func_l		; set source pointer high byte
.d7d6  20 17 d5   jsr $d517        	JSR	LAB_27F8		; compare FAC1 with (AY)
.d7d9  d0 03      bne $d7de        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
.d7db  98         tya              	TYA				; clear sign b7
.d7dc  a4 5b      ldy $5b          	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
.d7de                              lab_2ad9
.d7de  20 c5 d1   jsr $d1c5        	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
.d7e1  98         tya              	TYA				; copy sign back ..
.d7e2  48         pha              	PHA				; .. and save it
.d7e3  20 fb d2   jsr $d2fb        	JSR	LAB_LOG		; do LOG(n)
.d7e6  a9 9c      lda #$9c         	LDA	#<garb_l		; set pointer low byte
.d7e8  a0 00      ldy #$00         	LDY	#>garb_l		; set pointer high byte
.d7ea  20 39 d3   jsr $d339        	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
.d7ed  20 ff d7   jsr $d7ff        	JSR	LAB_EXP		; go do EXP(n)
.d7f0  68         pla              	PLA				; pull sign from stack
.d7f1  4a         lsr              	LSR				; b0 is to be tested, shift to Cb
.d7f2  90 0a      bcc $d7fe        	BCC	LAB_2AF9		; if no bit then exit
.d7f4                              lab_gthan
.d7f4  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d7f6  f0 06      beq $d7fe        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
.d7f8  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d7fa  49 ff      eor #$ff         	EOR	#$FF			; complement it
.d7fc  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign (b7)
.d7fe                              lab_2af9
.d7fe  60         rts              	RTS
.d7ff                              lab_exp
.d7ff  a9 85      lda #$85         	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
.d801  a0 dd      ldy #$dd         	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
.d803  20 39 d3   jsr $d339        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.d806  a5 b9      lda $b9          	LDA	FAC1_r		; get FAC1 rounding byte
.d808  69 50      adc #$50         	ADC	#$50			; +$50/$100
.d80a  90 03      bcc $d80f        	BCC	LAB_2B2B		; skip rounding if no carry
.d80c  20 e1 d4   jsr $d4e1        	JSR	LAB_27C2		; round FAC1 (no check)
.d80f                              lab_2b2b
.d80f  85 a3      sta $a3          	STA	FAC2_r		; save FAC2 rounding byte
.d811  20 cd d4   jsr $d4cd        	JSR	LAB_27AE		; copy FAC1 to FAC2
.d814  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d816  c9 88      cmp #$88         	CMP	#$88			; compare with EXP limit (256d)
.d818  90 03      bcc $d81d        	BCC	LAB_2B39		; branch if less
.d81a                              lab_2b36
.d81a  20 ce d3   jsr $d3ce        	JSR	LAB_2690		; handle overflow and underflow
.d81d                              lab_2b39
.d81d  20 81 d5   jsr $d581        	JSR	LAB_INT		; perform INT
.d820  a5 5b      lda $5b          	LDA	Temp3			; get mantissa 3 from INT() function
.d822  18         clc              	CLC				; clear carry for add
.d823  69 81      adc #$81         	ADC	#$81			; normalise +1
.d825  f0 f3      beq $d81a        	BEQ	LAB_2B36		; if $00 go handle overflow
.d827  38         sec              	SEC				; set carry for subtract
.d828  e9 01      sbc #$01         	SBC	#$01			; now correct for exponent
.d82a  48         pha              	PHA				; save FAC2 exponent
.d82b  a2 04      ldx #$04         	LDX	#$04			; 4 bytes to do
.d82d                              lab_2b49
.d82d  b5 b3      lda $b3,x        	LDA	FAC2_e,X		; get FAC2,X
.d82f  b4 ac      ldy $ac,x        	LDY	FAC1_e,X		; get FAC1,X
.d831  95 ac      sta $ac,x        	STA	FAC1_e,X		; save FAC1,X
.d833  94 b3      sty $b3,x        	STY	FAC2_e,X		; save FAC2,X
.d835  ca         dex              	DEX				; decrement count/index
.d836  10 f5      bpl $d82d        	BPL	LAB_2B49		; loop if not all done
.d838  a5 a3      lda $a3          	LDA	FAC2_r		; get FAC2 rounding byte
.d83a  85 b9      sta $b9          	STA	FAC1_r		; save as FAC1 rounding byte
.d83c  20 a6 d1   jsr $d1a6        	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.d83f  20 f4 d7   jsr $d7f4        	JSR	LAB_GTHAN		; do - FAC1
.d842  a9 89      lda #$89         	LDA	#<LAB_2AFE		; set counter pointer low byte
.d844  a0 dd      ldy #$dd         	LDY	#>LAB_2AFE		; set counter pointer high byte
.d846  20 67 d8   jsr $d867        	JSR	LAB_2B84		; go do series evaluation
.d849  a9 00      lda #$00         	LDA	#$00			; clear A
.d84b  85 b8      sta $b8          	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.d84d  68         pla              	PLA				;.get saved FAC2 exponent
.d84e  4c b3 d3   jmp $d3b3        	JMP	LAB_2675		; test and adjust accumulators and return
.d851                              lab_2b6e
.d851  85 ba      sta $ba          	STA	Cptrl			; save count pointer low byte
.d853  84 bb      sty $bb          	STY	Cptrh			; save count pointer high byte
.d855  20 9d d4   jsr $d49d        	JSR	LAB_276E		; pack FAC1 into Adatal
.d858  a9 a4      lda #$a4         	LDA	#<Adatal		; set pointer low byte (Y already $00)
.d85a  20 39 d3   jsr $d339        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.d85d  20 6b d8   jsr $d86b        	JSR	LAB_2B88		; go do series evaluation
.d860  a9 a4      lda #$a4         	LDA	#<Adatal		; pointer to original # low byte
.d862  a0 00      ldy #$00         	LDY	#>Adatal		; pointer to original # high byte
.d864  4c 39 d3   jmp $d339        	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
.d867                              lab_2b84
.d867  85 ba      sta $ba          	STA	Cptrl			; save count pointer low byte
.d869  84 bb      sty $bb          	STY	Cptrh			; save count pointer high byte
.d86b                              lab_2b88
.d86b  a2 a8      ldx #$a8         	LDX	#<numexp		; set pointer low byte
.d86d  20 9f d4   jsr $d49f        	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
.d870  b1 ba      lda ($ba),y      	LDA	(Cptrl),Y		; get constants count
.d872  85 b1      sta $b1          	STA	numcon		; save constants count
.d874  a4 ba      ldy $ba          	LDY	Cptrl			; get count pointer low byte
.d876  c8         iny              	INY				; increment it (now constants pointer)
.d877  98         tya              	TYA				; copy it
.d878  d0 02      bne $d87c        	BNE	LAB_2B97		; skip next if no overflow
.d87a  e6 bb      inc $bb          	INC	Cptrh			; else increment high byte
.d87c                              lab_2b97
.d87c  85 ba      sta $ba          	STA	Cptrl			; save low byte
.d87e  a4 bb      ldy $bb          	LDY	Cptrh			; get high byte
.d880                              lab_2b9b
.d880  20 39 d3   jsr $d339        	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
.d883  a5 ba      lda $ba          	LDA	Cptrl			; get constants pointer low byte
.d885  a4 bb      ldy $bb          	LDY	Cptrh			; get constants pointer high byte
.d887  18         clc              	CLC				; clear carry for add
.d888  69 04      adc #$04         	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
.d88a  90 01      bcc $d88d        	BCC	LAB_2BA8		; skip next if no overflow
.d88c  c8         iny              	INY				; increment high byte
.d88d                              lab_2ba8
.d88d  85 ba      sta $ba          	STA	Cptrl			; save pointer low byte
.d88f  84 bb      sty $bb          	STY	Cptrh			; save pointer high byte
.d891  20 be d1   jsr $d1be        	JSR	LAB_246C		; add (AY) to FAC1
.d894  a9 a8      lda #$a8         	LDA	#<numexp		; set pointer low byte to partial @ numexp
.d896  a0 00      ldy #$00         	LDY	#>numexp		; set pointer high byte to partial @ numexp
.d898  c6 b1      dec $b1          	DEC	numcon		; decrement constants count
.d89a  d0 e4      bne $d880        	BNE	LAB_2B9B		; loop until all done
.d89c  60         rts              	RTS
.d89d                              lab_rnd
.d89d  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d89f  f0 07      beq $d8a8        	BEQ	NextPRN		; do next random # if zero
.d8a1  a2 d8      ldx #$d8         	LDX	#Rbyte4		; set PRNG pointer low byte
.d8a3  a0 00      ldy #$00         	LDY	#$00			; set PRNG pointer high byte
.d8a5  20 a7 d4   jsr $d4a7        	JSR	LAB_2778		; pack FAC1 into (XY)
.d8a8                              nextprn
.d8a8  a2 af      ldx #$af         	LDX	#$AF			; set EOR byte
.d8aa  a0 13      ldy #$13         	LDY	#$13			; do this nineteen times
.d8ac                              loopprn
.d8ac  06 d9      asl $d9          	ASL	Rbyte1		; shift PRNG most significant byte
.d8ae  26 da      rol $da          	ROL	Rbyte2		; shift PRNG middle byte
.d8b0  26 db      rol $db          	ROL	Rbyte3		; shift PRNG least significant byte
.d8b2  26 d8      rol $d8          	ROL	Rbyte4		; shift PRNG extra byte
.d8b4  90 05      bcc $d8bb        	BCC	Ninc1			; branch if bit 32 clear
.d8b6  8a         txa              	TXA				; set EOR byte
.d8b7  45 d9      eor $d9          	EOR	Rbyte1		; EOR PRNG extra byte
.d8b9  85 d9      sta $d9          	STA	Rbyte1		; save new PRNG extra byte
.d8bb                              ninc1
.d8bb  88         dey              	DEY				; decrement loop count
.d8bc  d0 ee      bne $d8ac        	BNE	LoopPRN		; loop if not all done
.d8be  a2 02      ldx #$02         	LDX	#$02			; three bytes to copy
.d8c0                              copyprng
.d8c0  b5 d9      lda $d9,x        	LDA	Rbyte1,X		; get PRNG byte
.d8c2  95 ad      sta $ad,x        	STA	FAC1_1,X		; save FAC1 byte
.d8c4  ca         dex              	DEX
.d8c5  10 f9      bpl $d8c0        	BPL	CopyPRNG		; loop if not complete
.d8c7  a9 80      lda #$80         	LDA	#$80			; set the exponent
.d8c9  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.d8cb  0a         asl              	ASL				; clear A
.d8cc  85 b0      sta $b0          	STA	FAC1_s		; save FAC1 sign
.d8ce  4c 34 d2   jmp $d234        	JMP	LAB_24D5		; normalise FAC1 and return
.d8d1                              lab_cos
.d8d1  a9 a6      lda #$a6         	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.d8d3  a0 dd      ldy #$dd         	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.d8d5  20 be d1   jsr $d1be        	JSR	LAB_246C		; add (AY) to FAC1
.d8d8                              lab_sin
.d8d8  20 ca d4   jsr $d4ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.d8db  a9 bb      lda #$bb         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.d8dd  a0 dd      ldy #$dd         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.d8df  a6 b7      ldx $b7          	LDX	FAC2_s		; get FAC2 sign (b7)
.d8e1  20 f9 d3   jsr $d3f9        	JSR	LAB_26C2		; divide by (AY) (X=sign)
.d8e4  20 ca d4   jsr $d4ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.d8e7  20 81 d5   jsr $d581        	JSR	LAB_INT		; perform INT
.d8ea  a9 00      lda #$00         	LDA	#$00			; clear byte
.d8ec  85 b8      sta $b8          	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
.d8ee  20 a6 d1   jsr $d1a6        	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
.d8f1  a9 ed      lda #$ed         	LDA	#<LAB_2C80		; set 0.25 pointer low byte
.d8f3  a0 dd      ldy #$dd         	LDY	#>LAB_2C80		; set 0.25 pointer high byte
.d8f5  20 a3 d1   jsr $d1a3        	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.d8f8  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d8fa  48         pha              	PHA				; save FAC1 sign
.d8fb  10 0d      bpl $d90a        	BPL	LAB_2C35		; branch if +ve
.d8fd  20 ba d1   jsr $d1ba        	JSR	LAB_244E		; add 0.5 to FAC1
.d900  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d902  30 09      bmi $d90d        	BMI	LAB_2C38		; branch if -ve
.d904  a5 63      lda $63          	LDA	Cflag			; get comparison evaluation flag
.d906  49 ff      eor #$ff         	EOR	#$FF			; toggle flag
.d908  85 63      sta $63          	STA	Cflag			; save comparison evaluation flag
.d90a                              lab_2c35
.d90a  20 f4 d7   jsr $d7f4        	JSR	LAB_GTHAN		; do - FAC1
.d90d                              lab_2c38
.d90d  a9 ed      lda #$ed         	LDA	#<LAB_2C80		; set 0.25 pointer low byte
.d90f  a0 dd      ldy #$dd         	LDY	#>LAB_2C80		; set 0.25 pointer high byte
.d911  20 be d1   jsr $d1be        	JSR	LAB_246C		; add (AY) to FAC1
.d914  68         pla              	PLA				; restore FAC1 sign
.d915  10 03      bpl $d91a        	BPL	LAB_2C45		; branch if was +ve
.d917  20 f4 d7   jsr $d7f4        	JSR	LAB_GTHAN		; do - FAC1
.d91a                              lab_2c45
.d91a  a9 aa      lda #$aa         	LDA	#<LAB_2C84		; set pointer low byte to counter
.d91c  a0 dd      ldy #$dd         	LDY	#>LAB_2C84		; set pointer high byte to counter
.d91e  4c 51 d8   jmp $d851        	JMP	LAB_2B6E		; ^2 then series evaluation and return
.d921                              lab_tan
.d921  20 9d d4   jsr $d49d        	JSR	LAB_276E		; pack FAC1 into Adatal
.d924  a9 00      lda #$00         	LDA	#$00			; clear byte
.d926  85 63      sta $63          	STA	Cflag			; clear comparison evaluation flag
.d928  20 d8 d8   jsr $d8d8        	JSR	LAB_SIN		; go do SIN(n)
.d92b  a2 9c      ldx #$9c         	LDX	#<func_l		; set sin(n) pointer low byte
.d92d  a0 00      ldy #$00         	LDY	#>func_l		; set sin(n) pointer high byte
.d92f  20 a7 d4   jsr $d4a7        	JSR	LAB_2778		; pack FAC1 into (XY)
.d932  a9 a4      lda #$a4         	LDA	#<Adatal		; set n pointer low addr
.d934  a0 00      ldy #$00         	LDY	#>Adatal		; set n pointer high addr
.d936  20 7d d4   jsr $d47d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.d939  a9 00      lda #$00         	LDA	#$00			; clear byte
.d93b  85 b0      sta $b0          	STA	FAC1_s		; clear FAC1 sign (b7)
.d93d  a5 63      lda $63          	LDA	Cflag			; get comparison evaluation flag
.d93f  20 49 d9   jsr $d949        	JSR	LAB_2C74		; save flag and go do series evaluation
.d942  a9 9c      lda #$9c         	LDA	#<func_l		; set sin(n) pointer low byte
.d944  a0 00      ldy #$00         	LDY	#>func_l		; set sin(n) pointer high byte
.d946  4c 01 d4   jmp $d401        	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
.d949                              lab_2c74
.d949  48         pha              	PHA				; save comparison evaluation flag
.d94a  4c 0a d9   jmp $d90a        	JMP	LAB_2C35		; go do series evaluation
.d94d                              lab_usr
.d94d  20 0a 00   jsr $000a        	JSR	Usrjmp		; call user code
.d950  4c ef c7   jmp $c7ef        	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
.d953                              lab_atn
.d953  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign (b7)
.d955  48         pha              	PHA				; save sign
.d956  10 03      bpl $d95b        	BPL	LAB_2CA1		; branch if +ve
.d958  20 f4 d7   jsr $d7f4        	JSR	LAB_GTHAN		; else do - FAC1
.d95b                              lab_2ca1
.d95b  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.d95d  48         pha              	PHA				; push exponent
.d95e  c9 81      cmp #$81         	CMP	#$81			; compare with 1
.d960  90 07      bcc $d969        	BCC	LAB_2CAF		; branch if FAC1<1
.d962  a9 e0      lda #$e0         	LDA	#<LAB_259C		; set 1 pointer low byte
.d964  a0 dd      ldy #$dd         	LDY	#>LAB_259C		; set 1 pointer high byte
.d966  20 01 d4   jsr $d401        	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
.d969                              lab_2caf
.d969  a9 bf      lda #$bf         	LDA	#<LAB_2CC9		; set pointer low byte to counter
.d96b  a0 dd      ldy #$dd         	LDY	#>LAB_2CC9		; set pointer high byte to counter
.d96d  20 51 d8   jsr $d851        	JSR	LAB_2B6E		; ^2 then series evaluation
.d970  68         pla              	PLA				; restore old FAC1 exponent
.d971  c9 81      cmp #$81         	CMP	#$81			; compare with 1
.d973  90 07      bcc $d97c        	BCC	LAB_2CC2		; branch if FAC1<1
.d975  a9 a6      lda #$a6         	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
.d977  a0 dd      ldy #$dd         	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
.d979  20 a3 d1   jsr $d1a3        	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
.d97c                              lab_2cc2
.d97c  68         pla              	PLA				; restore FAC1 sign
.d97d  10 16      bpl $d995        	BPL	LAB_2D04		; exit if was +ve
.d97f  4c f4 d7   jmp $d7f4        	JMP	LAB_GTHAN		; else do - FAC1 and return
.d982                              lab_bitset
.d982  20 d8 d0   jsr $d0d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.d985  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.d987  b0 20      bcs $d9a9        	BCS	FCError		; branch if > 7
.d989  a9 00      lda #$00         	LDA	#$00			; clear A
.d98b  38         sec              	SEC				; set the carry
.d98c                              s_bits
.d98c  2a         rol              	ROL				; shift bit
.d98d  ca         dex              	DEX				; decrement bit number
.d98e  10 fc      bpl $d98c        	BPL	S_Bits		; loop if still +ve
.d990  e8         inx              	INX				; make X = $00
.d991  01 11      ora ($11,x)      	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
.d993  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.d995                              lab_2d04
.d995  60         rts              	RTS
.d996                              lab_bitclr
.d996  20 d8 d0   jsr $d0d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.d999  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.d99b  b0 0c      bcs $d9a9        	BCS	FCError		; branch if > 7
.d99d  a9 ff      lda #$ff         	LDA	#$FF			; set A
.d99f                              s_bitc
.d99f  2a         rol              	ROL				; shift bit
.d9a0  ca         dex              	DEX				; decrement bit number
.d9a1  10 fc      bpl $d99f        	BPL	S_Bitc		; loop if still +ve
.d9a3  e8         inx              	INX				; make X = $00
.d9a4  21 11      and ($11,x)      	AND	(Itempl,X)		; and with byte via temporary integer (addr)
.d9a6  81 11      sta ($11,x)      	STA	(Itempl,X)		; save byte via temporary integer (addr)
.d9a8  60         rts              	RTS
.d9a9                              fcerror
.d9a9  4c 29 cb   jmp $cb29        	JMP	LAB_FCER		; do function call error then warm start
.d9ac                              lab_btst
.d9ac  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment BASIC pointer
.d9af  20 d8 d0   jsr $d0d8        	JSR	LAB_GADB		; get two parameters for POKE or WAIT
.d9b2  e0 08      cpx #$08         	CPX	#$08			; only 0 to 7 are allowed
.d9b4  b0 f3      bcs $d9a9        	BCS	FCError		; branch if > 7
.d9b6  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.d9b9  c9 29      cmp #$29         	CMP	#")"			; is next character ")"
.d9bb  f0 03      beq $d9c0        	BEQ	TST_OK		; if ")" go do rest of function
.d9bd  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; do syntax error then warm start
.d9c0                              tst_ok
.d9c0  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.d9c3  a9 00      lda #$00         	LDA	#$00			; clear A
.d9c5  38         sec              	SEC				; set the carry
.d9c6                              t_bits
.d9c6  2a         rol              	ROL				; shift bit
.d9c7  ca         dex              	DEX				; decrement bit number
.d9c8  10 fc      bpl $d9c6        	BPL	T_Bits		; loop if still +ve
.d9ca  e8         inx              	INX				; make X = $00
.d9cb  21 11      and ($11,x)      	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
.d9cd  f0 02      beq $d9d1        	BEQ	LAB_NOTT		; branch if zero (already correct)
.d9cf  a9 ff      lda #$ff         	LDA	#$FF			; set for -1 result
.d9d1                              lab_nott
.d9d1  4c fa d4   jmp $d4fa        	JMP	LAB_27DB		; go do SGN tail
.d9d4                              lab_bins
.d9d4  e0 19      cpx #$19         	CPX	#$19			; max + 1
.d9d6  b0 48      bcs $da20        	BCS	BinFErr		; exit if too big ( > or = )
.d9d8  86 78      stx $78          	STX	TempB			; save # of characters ($00 = leading zero remove)
.d9da  a9 18      lda #$18         	LDA	#$18			; need A byte long space
.d9dc  20 3a cd   jsr $cd3a        	JSR	LAB_MSSP		; make string space A bytes long
.d9df  a0 17      ldy #$17         	LDY	#$17			; set index
.d9e1  a2 18      ldx #$18         	LDX	#$18			; character count
.d9e3                              nextb1
.d9e3  46 11      lsr $11          	LSR	nums_1		; shift highest byte
.d9e5  66 12      ror $12          	ROR	nums_2		; shift middle byte
.d9e7  66 13      ror $13          	ROR	nums_3		; shift lowest byte bit 0 to carry
.d9e9  8a         txa              	TXA				; load with "0"/2
.d9ea  2a         rol              	ROL				; shift in carry
.d9eb  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save to temp string + index
.d9ed  88         dey              	DEY				; decrement index
.d9ee  10 f3      bpl $d9e3        	BPL	NextB1		; loop if not done
.d9f0  a5 78      lda $78          	LDA	TempB			; get # of characters
.d9f2  f0 0a      beq $d9fe        	BEQ	EndBHS		; branch if truncate
.d9f4  aa         tax              	TAX				; copy length to X
.d9f5  38         sec              	SEC				; set carry for add !
.d9f6  49 ff      eor #$ff         	EOR	#$FF			; 1's complement
.d9f8  69 18      adc #$18         	ADC	#$18			; add 24d
.d9fa  f0 1c      beq $da18        	BEQ	GoPr2			; if zero print whole string
.d9fc  d0 0f      bne $da0d        	BNE	GoPr1			; else go make output string
.d9fe                              endbhs
.d9fe  a8         tay              	TAY				; clear index (A=0, X=length here)
.d9ff                              nextb2
.d9ff  b1 ad      lda ($ad),y      	LDA	(str_pl),Y		; get character from string
.da01  c9 30      cmp #$30         	CMP	#"0"			; compare with "0"
.da03  d0 07      bne $da0c        	BNE	GoPr			; if not "0" then go print string from here
.da05  ca         dex              	DEX				; decrement character count
.da06  f0 03      beq $da0b        	BEQ	GoPr3			; if zero then end of string so go print it
.da08  c8         iny              	INY				; else increment index
.da09  10 f4      bpl $d9ff        	BPL	NextB2		; loop always
.da0b                              gopr3
.da0b  e8         inx              	INX				; need at least 1 character
.da0c                              gopr
.da0c  98         tya              	TYA				; copy result
.da0d                              gopr1
.da0d  18         clc              	CLC				; clear carry for add
.da0e  65 ad      adc $ad          	ADC	str_pl		; add low address
.da10  85 ad      sta $ad          	STA	str_pl		; save low address
.da12  a9 00      lda #$00         	LDA	#$00			; do high byte
.da14  65 ae      adc $ae          	ADC	str_ph		; add high address
.da16  85 ae      sta $ae          	STA	str_ph		; save high address
.da18                              gopr2
.da18  86 ac      stx $ac          	STX	str_ln		; X holds string length
.da1a  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
.da1d  4c 85 cd   jmp $cd85        	JMP	LAB_RTST		; check for space on descriptor stack then put address
.da20                              binferr
.da20  4c 29 cb   jmp $cb29        	JMP	LAB_FCER		; do function call error then warm start
.da23                              lab_hexs
.da23  e0 07      cpx #$07         	CPX	#$07			; max + 1
.da25  b0 f9      bcs $da20        	BCS	BinFErr		; exit if too big ( > or = )
.da27  86 78      stx $78          	STX	TempB			; save # of characters
.da29  a9 06      lda #$06         	LDA	#$06			; need 6 bytes for string
.da2b  20 3a cd   jsr $cd3a        	JSR	LAB_MSSP		; make string space A bytes long
.da2e  a0 05      ldy #$05         	LDY	#$05			; set string index
.da30  f8         sed              	SED				; need decimal mode for nibble convert
.da31  a5 13      lda $13          	LDA	nums_3		; get lowest byte
.da33  20 51 da   jsr $da51        	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.da36  a5 12      lda $12          	LDA	nums_2		; get middle byte
.da38  20 51 da   jsr $da51        	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.da3b  a5 11      lda $11          	LDA	nums_1		; get highest byte
.da3d  20 51 da   jsr $da51        	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
.da40  d8         cld              	CLD				; back to binary
.da41  a2 06      ldx #$06         	LDX	#$06			; character count
.da43  a5 78      lda $78          	LDA	TempB			; get # of characters
.da45  f0 b7      beq $d9fe        	BEQ	EndBHS		; branch if truncate
.da47  aa         tax              	TAX				; copy length to X
.da48  38         sec              	SEC				; set carry for add !
.da49  49 ff      eor #$ff         	EOR	#$FF			; 1's complement
.da4b  69 06      adc #$06         	ADC	#$06			; add 6d
.da4d  f0 c9      beq $da18        	BEQ	GoPr2			; if zero print whole string
.da4f  d0 bc      bne $da0d        	BNE	GoPr1			; else go make output string (branch always)
.da51                              lab_a2hx
.da51  aa         tax              	TAX				; save byte
.da52  29 0f      and #$0f         	AND	#$0F			; mask off top bits
.da54  20 5c da   jsr $da5c        	JSR	LAB_AL2X		; convert low nibble to ASCII and output
.da57  8a         txa              	TXA				; get byte back
.da58  4a         lsr              	LSR				; /2	shift high nibble to low nibble
.da59  4a         lsr              	LSR				; /4
.da5a  4a         lsr              	LSR				; /8
.da5b  4a         lsr              	LSR				; /16
.da5c                              lab_al2x
.da5c  c9 0a      cmp #$0a         	CMP	#$0A			; set carry for +1 if >9
.da5e  69 30      adc #$30         	ADC	#"0"			; add ASCII "0"
.da60  91 ad      sta ($ad),y      	STA	(str_pl),Y		; save to temp string
.da62  88         dey              	DEY				; decrement counter
.da63  60         rts              	RTS
.da64                              lab_nlto
.da64  85 ac      sta $ac          	STA	FAC1_e		; save FAC1 exponent
.da66  a9 00      lda #$00         	LDA	#$00			; clear sign compare
.da68                              lab_mlte
.da68  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.da6a  8a         txa              	TXA				; restore character
.da6b  20 45 d6   jsr $d645        	JSR	LAB_2912		; evaluate new ASCII digit
.da6e                              lab_chex
.da6e  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.da71  90 0a      bcc $da7d        	BCC	LAB_ISHN		; branch if numeric character
.da73  09 20      ora #$20         	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
.da75  e9 61      sbc #$61         	SBC	#"a"			; subtract "a" (carry set here)
.da77  c9 06      cmp #$06         	CMP	#$06			; compare normalised with $06 (max+1)
.da79  b0 2a      bcs $daa5        	BCS	LAB_EXCH		; exit if >"f" or <"0"
.da7b  69 0a      adc #$0a         	ADC	#$0A			; convert to nibble
.da7d                              lab_ishn
.da7d  29 0f      and #$0f         	AND	#$0F			; convert to binary
.da7f  aa         tax              	TAX				; save nibble
.da80  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.da82  f0 e4      beq $da68        	BEQ	LAB_MLTE		; skip multiply if zero
.da84  69 04      adc #$04         	ADC	#$04			; add four to exponent (*16 - carry clear here)
.da86  90 dc      bcc $da64        	BCC	LAB_NLTO		; if no overflow do evaluate digit
.da88                              lab_mlto
.da88  4c c3 d2   jmp $d2c3        	JMP	LAB_2564		; do overflow error and warm start
.da8b                              lab_nxch
.da8b  aa         tax              	TAX				; save bit
.da8c  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.da8e  f0 06      beq $da96        	BEQ	LAB_MLBT		; skip multiply if zero
.da90  e6 ac      inc $ac          	INC	FAC1_e		; increment FAC1 exponent (*2)
.da92  f0 f4      beq $da88        	BEQ	LAB_MLTO		; do overflow error if = $00
.da94  a9 00      lda #$00         	LDA	#$00			; clear sign compare
.da96                              lab_mlbt
.da96  85 b8      sta $b8          	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
.da98  8a         txa              	TXA				; restore bit
.da99  20 45 d6   jsr $d645        	JSR	LAB_2912		; evaluate new ASCII digit
.da9c                              lab_cbin
.da9c  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.da9f  49 30      eor #$30         	EOR	#"0"			; convert "0" to 0 etc.
.daa1  c9 02      cmp #$02         	CMP	#$02			; compare with max+1
.daa3  90 e6      bcc $da8b        	BCC	LAB_NXCH		; branch exit if < 2
.daa5                              lab_exch
.daa5  4c 2a d6   jmp $d62a        	JMP	LAB_28F6		; evaluate -ve flag and return
.daa8                              ctrlc
.daa8  ad 00 02   lda $0200        	LDA	ccflag		; get [CTRL-C] check flag
.daab  d0 18      bne $dac5        	BNE	LAB_FBA2		; exit if inhibited
.daad  20 ea dc   jsr $dcea        	JSR	V_INPT		; scan input device
.dab0  90 0b      bcc $dabd        	BCC	LAB_FBA0		; exit if buffer empty
.dab2  8d 01 02   sta $0201        	STA	ccbyte		; save received byte
.dab5  a2 20      ldx #$20         	LDX	#$20			; "life" timer for bytes
.dab7  8e 02 02   stx $0202        	STX	ccnull		; set countdown
.daba  4c 17 c1   jmp $c117        	JMP	LAB_1636		; return to BASIC
.dabd                              lab_fba0
.dabd  ae 02 02   ldx $0202        	LDX	ccnull		; get countdown byte
.dac0  f0 03      beq $dac5        	BEQ	LAB_FBA2		; exit if finished
.dac2  ce 02 02   dec $0202        	DEC	ccnull		; else decrement countdown
.dac5                              lab_fba2
.dac5  a2 dc      ldx #$dc         	LDX	#NmiBase		; set pointer to NMI values
.dac7  20 d0 da   jsr $dad0        	JSR	LAB_CKIN		; go check interrupt
.daca  a2 df      ldx #$df         	LDX	#IrqBase		; set pointer to IRQ values
.dacc  20 d0 da   jsr $dad0        	JSR	LAB_CKIN		; go check interrupt
.dacf                              lab_crts
.dacf  60         rts              	RTS
.dad0                              lab_ckin
.dad0  b5 00      lda $00,x        	LDA	PLUS_0,X		; get interrupt flag byte
.dad2  10 fb      bpl $dacf        	BPL	LAB_CRTS		; branch if interrupt not enabled
.dad4  0a         asl              	ASL				; move happened bit to setup bit
.dad5  29 40      and #$40         	AND	#$40			; mask happened bits
.dad7  f0 f6      beq $dacf        	BEQ	LAB_CRTS		; if no interrupt then exit
.dad9  95 00      sta $00,x        	STA	PLUS_0,X		; save interrupt flag byte
.dadb  8a         txa              	TXA				; copy index ..
.dadc  a8         tay              	TAY				; .. to Y
.dadd  68         pla              	PLA				; dump return address low byte, call from CTRL-C
.dade  68         pla              	PLA				; dump return address high byte
.dadf  a9 05      lda #$05         	LDA	#$05			; need 5 bytes for GOSUB
.dae1  20 03 bd   jsr $bd03        	JSR	LAB_1212		; check room on stack for A bytes
.dae4  a5 c4      lda $c4          	LDA	Bpntrh		; get BASIC execute pointer high byte
.dae6  48         pha              	PHA				; push on stack
.dae7  a5 c3      lda $c3          	LDA	Bpntrl		; get BASIC execute pointer low byte
.dae9  48         pha              	PHA				; push on stack
.daea  a5 88      lda $88          	LDA	Clineh		; get current line high byte
.daec  48         pha              	PHA				; push on stack
.daed  a5 87      lda $87          	LDA	Clinel		; get current line low byte
.daef  48         pha              	PHA				; push on stack
.daf0  a9 8d      lda #$8d         	LDA	#TK_GOSUB		; token for GOSUB
.daf2  48         pha              	PHA				; push on stack
.daf3  b9 01 00   lda $0001,y      	LDA	PLUS_1,Y		; get interrupt code pointer low byte
.daf6  85 c3      sta $c3          	STA	Bpntrl		; save as BASIC execute pointer low byte
.daf8  b9 02 00   lda $0002,y      	LDA	PLUS_2,Y		; get interrupt code pointer high byte
.dafb  85 c4      sta $c4          	STA	Bpntrh		; save as BASIC execute pointer high byte
.dafd  4c bc c0   jmp $c0bc        	JMP	LAB_15C2		; go do interpreter inner loop
.db00                              inget
.db00  20 ea dc   jsr $dcea        	JSR	V_INPT		; call scan input device
.db03  b0 09      bcs $db0e        	BCS	LAB_FB95		; if byte go reset timer
.db05  ad 02 02   lda $0202        	LDA	ccnull		; get countdown
.db08  f0 09      beq $db13        	BEQ	LAB_FB96		; exit if empty
.db0a  ad 01 02   lda $0201        	LDA	ccbyte		; get last received byte
.db0d  38         sec              	SEC				; flag we got a byte
.db0e                              lab_fb95
.db0e  a2 00      ldx #$00         	LDX	#$00			; clear X
.db10  8e 02 02   stx $0202        	STX	ccnull		; clear timer because we got a byte
.db13                              lab_fb96
.db13  60         rts              	RTS
.db14                              lab_irq
.db14  a2 df      ldx #$df         	LDX	#IrqBase		; set pointer to IRQ values

>db16  2c                          	.byte	$2C			; make next line BIT abs.
.db17                              lab_nmi

.db17  a2 dc      ldx #$dc         	LDX	#NmiBase		; set pointer to NMI values
.db19  c9 93      cmp #$93         	CMP	#TK_ON		; compare with token for ON
.db1b  f0 11      beq $db2e        	BEQ	LAB_INON		; go turn on interrupt
.db1d  c9 b6      cmp #$b6         	CMP	#TK_OFF		; compare with token for OFF
.db1f  f0 07      beq $db28        	BEQ	LAB_IOFF		; go turn off interrupt
.db21  49 a2      eor #$a2         	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
.db23  f0 0e      beq $db33        	BEQ	LAB_INEX		; go clear interrupt flags and return
.db25  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; do syntax error then warm start
.db28                              lab_ioff
.db28  a9 7f      lda #$7f         	LDA	#$7F			; clear A
.db2a  35 00      and $00,x        	AND	PLUS_0,X		; AND with interrupt setup flag
.db2c  10 05      bpl $db33        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
.db2e                              lab_inon
.db2e  b5 00      lda $00,x        	LDA	PLUS_0,X		; get interrupt setup flag
.db30  0a         asl              	ASL				; Shift bit to enabled flag
.db31  15 00      ora $00,x        	ORA	PLUS_0,X		; OR with flag byte
.db33                              lab_inex
.db33  95 00      sta $00,x        	STA	PLUS_0,X		; save interrupt flag byte
.db35  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; update BASIC execute pointer and return
.db38                              lab_sirq
.db38  58         cli              	CLI				; enable interrupts
.db39  a2 df      ldx #$df         	LDX	#IrqBase		; set pointer to IRQ values

>db3b  2c                          	.byte	$2C			; make next line BIT abs.
.db3c                              lab_snmi

.db3c  a2 dc      ldx #$dc         	LDX	#NmiBase		; set pointer to NMI values
.db3e  86 78      stx $78          	STX	TempB			; save interrupt pointer
.db40  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory (past token)
.db43  20 55 c3   jsr $c355        	JSR	LAB_GFPN		; get fixed-point number into temp integer
.db46  a5 79      lda $79          	LDA	Smeml			; get start of mem low byte
.db48  a6 7a      ldx $7a          	LDX	Smemh			; get start of mem high byte
.db4a  20 28 bf   jsr $bf28        	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
.db4d  b0 03      bcs $db52        	BCS	LAB_LFND		; if carry set go set-up interrupt
.db4f  4c 72 c2   jmp $c272        	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
.db52                              lab_lfnd
.db52  a6 78      ldx $78          	LDX	TempB			; get interrupt pointer
.db54  a5 aa      lda $aa          	LDA	Baslnl		; get pointer low byte
.db56  e9 01      sbc #$01         	SBC	#$01			; -1 (carry already set for subtract)
.db58  95 01      sta $01,x        	STA	PLUS_1,X		; save as interrupt pointer low byte
.db5a  a5 ab      lda $ab          	LDA	Baslnh		; get pointer high byte
.db5c  e9 00      sbc #$00         	SBC	#$00			; subtract carry
.db5e  95 02      sta $02,x        	STA	PLUS_2,X		; save as interrupt pointer high byte
.db60  a9 c0      lda #$c0         	LDA	#$C0			; set interrupt enabled/setup bits
.db62  95 00      sta $00,x        	STA	PLUS_0,X		; set interrupt flags
.db64                              lab_irts
.db64  60         rts              	RTS
.db65                              lab_retirq
.db65  d0 fd      bne $db64        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.db67  a5 df      lda $df          	LDA	IrqBase		; get interrupt flags
.db69  0a         asl              	ASL				; copy setup to enabled (b7)
.db6a  05 df      ora $df          	ORA	IrqBase		; OR in setup flag
.db6c  85 df      sta $df          	STA	IrqBase		; save enabled flag
.db6e  4c 79 c2   jmp $c279        	JMP	LAB_16E8		; go do rest of RETURN
.db71                              lab_retnmi
.db71  d0 f1      bne $db64        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
.db73  a5 dc      lda $dc          	LDA	NmiBase		; get set-up flag
.db75  0a         asl              	ASL				; copy setup to enabled (b7)
.db76  05 dc      ora $dc          	ORA	NmiBase		; OR in setup flag
.db78  85 dc      sta $dc          	STA	NmiBase		; save enabled flag
.db7a  4c 79 c2   jmp $c279        	JMP	LAB_16E8		; go do rest of RETURN
.db7d                              lab_mmpp
.db7d  20 e9 c6   jsr $c6e9        	JSR	LAB_EVEZ		; process expression
.db80  4c d0 c6   jmp $c6d0        	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
.db83                              lab_max
.db83  20 b1 db   jsr $dbb1        	JSR	LAB_PHFA		; push FAC1, evaluate expression,
.db86  10 fb      bpl $db83        	BPL	LAB_MAX		; branch if no swap to do
.db88  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.db8a  09 80      ora #$80         	ORA	#$80			; set top bit (clear sign from compare)
.db8c  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.db8e  20 c3 d1   jsr $d1c3        	JSR	LAB_279B		; copy FAC2 to FAC1
.db91  f0 f0      beq $db83        	BEQ	LAB_MAX		; go do next (branch always)
.db93                              lab_min
.db93  20 b1 db   jsr $dbb1        	JSR	LAB_PHFA		; push FAC1, evaluate expression,
.db96  30 fb      bmi $db93        	BMI	LAB_MIN		; branch if no swap to do
.db98  f0 f9      beq $db93        	BEQ	LAB_MIN		; branch if no swap to do
.db9a  a5 b4      lda $b4          	LDA	FAC2_1		; get FAC2 mantissa1
.db9c  09 80      ora #$80         	ORA	#$80			; set top bit (clear sign from compare)
.db9e  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 mantissa1
.dba0  20 c3 d1   jsr $d1c3        	JSR	LAB_279B		; copy FAC2 to FAC1
.dba3  f0 ee      beq $db93        	BEQ	LAB_MIN		; go do next (branch always)
.dba5                              lab_mmec
.dba5  c9 29      cmp #$29         	CMP	#")"			; is it end of function?
.dba7  d0 05      bne $dbae        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
.dba9  68         pla              	PLA				; dump return address low byte
.dbaa  68         pla              	PLA				; dump return address high byte
.dbab  4c bc 00   jmp $00bc        	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
.dbae                              lab_mmse
.dbae  4c 02 c8   jmp $c802        	JMP	LAB_SNER		; do syntax error then warm start
.dbb1                              lab_phfa
.dbb1  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get next BASIC byte
.dbb4  c9 2c      cmp #$2c         	CMP	#","			; is there more ?
.dbb6  d0 ed      bne $dba5        	BNE	LAB_MMEC		; if not go do end check
.dbb8  20 d9 d4   jsr $d4d9        	JSR	LAB_27BA		; round FAC1
.dbbb  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign
.dbbd  09 7f      ora #$7f         	ORA	#$7F			; set all non sign bits
.dbbf  25 ad      and $ad          	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
.dbc1  48         pha              	PHA				; push on stack
.dbc2  a5 ae      lda $ae          	LDA	FAC1_2		; get FAC1 mantissa2
.dbc4  48         pha              	PHA				; push on stack
.dbc5  a5 af      lda $af          	LDA	FAC1_3		; get FAC1 mantissa3
.dbc7  48         pha              	PHA				; push on stack
.dbc8  a5 ac      lda $ac          	LDA	FAC1_e		; get FAC1 exponent
.dbca  48         pha              	PHA				; push on stack
.dbcb  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
.dbce  20 cd c6   jsr $c6cd        	JSR	LAB_EVNM		; evaluate expression and check is numeric,
.dbd1  68         pla              	PLA				; pop exponent
.dbd2  85 b3      sta $b3          	STA	FAC2_e		; save FAC2 exponent
.dbd4  68         pla              	PLA				; pop mantissa3
.dbd5  85 b6      sta $b6          	STA	FAC2_3		; save FAC2 mantissa3
.dbd7  68         pla              	PLA				; pop mantissa1
.dbd8  85 b5      sta $b5          	STA	FAC2_2		; save FAC2 mantissa2
.dbda  68         pla              	PLA				; pop sign/mantissa1
.dbdb  85 b4      sta $b4          	STA	FAC2_1		; save FAC2 sign/mantissa1
.dbdd  85 b7      sta $b7          	STA	FAC2_s		; save FAC2 sign
.dbdf  a9 b3      lda #$b3         	LDA	#<FAC2_e		; set pointer low byte to FAC2
.dbe1  a0 00      ldy #$00         	LDY	#>FAC2_e		; set pointer high byte to FAC2
.dbe3  4c 17 d5   jmp $d517        	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
.dbe6                              lab_wdth
.dbe6  c9 2c      cmp #$2c         	CMP	#","			; is next byte ","
.dbe8  f0 1b      beq $dc05        	BEQ	LAB_TBSZ		; if so do tab size
.dbea  20 8c d0   jsr $d08c        	JSR	LAB_GTBY		; get byte parameter
.dbed  8a         txa              	TXA				; copy width to A
.dbee  f0 0a      beq $dbfa        	BEQ	LAB_NSTT		; branch if set for infinite line
.dbf0  e0 10      cpx #$10         	CPX	#$10			; else make min width = 16d
.dbf2  90 45      bcc $dc39        	BCC	TabErr		; if less do function call error and exit
.dbf4  e4 64      cpx $64          	CPX	TabSiz		; compare with tab size
.dbf6  b0 02      bcs $dbfa        	BCS	LAB_NSTT		; branch if >= tab size
.dbf8  86 64      stx $64          	STX	TabSiz		; else make tab size = terminal width
.dbfa                              lab_nstt
.dbfa  86 0f      stx $0f          	STX	TWidth		; set the terminal width
.dbfc  20 c2 00   jsr $00c2        	JSR	LAB_GBYT		; get BASIC byte back
.dbff  f0 1a      beq $dc1b        	BEQ	WExit			; exit if no following
.dc01  c9 2c      cmp #$2c         	CMP	#","			; else is it ","
.dc03  d0 a9      bne $dbae        	BNE	LAB_MMSE		; if not do syntax error
.dc05                              lab_tbsz
.dc05  20 89 d0   jsr $d089        	JSR	LAB_SGBY		; scan and get byte parameter
.dc08  8a         txa              	TXA				; copy TAB size
.dc09  30 2e      bmi $dc39        	BMI	TabErr		; if >127 do function call error and exit
.dc0b  e0 01      cpx #$01         	CPX	#$01			; compare with min-1
.dc0d  90 2a      bcc $dc39        	BCC	TabErr		; if <=1 do function call error and exit
.dc0f  a5 0f      lda $0f          	LDA	TWidth		; set flags for width
.dc11  f0 06      beq $dc19        	BEQ	LAB_SVTB		; skip check if infinite line
.dc13  e4 0f      cpx $0f          	CPX	TWidth		; compare TAB with width
.dc15  f0 02      beq $dc19        	BEQ	LAB_SVTB		; ok if =
.dc17  b0 20      bcs $dc39        	BCS	TabErr		; branch if too big
.dc19                              lab_svtb
.dc19  86 64      stx $64          	STX	TabSiz		; save TAB size
.dc1b                              wexit
.dc1b  a5 0f      lda $0f          	LDA	TWidth		; get width
.dc1d  f0 06      beq $dc25        	BEQ	LAB_SULP		; branch if infinite line
.dc1f  c5 64      cmp $64          	CMP	TabSiz		; compare with tab size
.dc21  b0 03      bcs $dc26        	BCS	LAB_WDLP		; branch if >= tab size
.dc23  85 64      sta $64          	STA	TabSiz		; else make tab size = terminal width
.dc25                              lab_sulp
.dc25  38         sec              	SEC				; set carry for subtract
.dc26                              lab_wdlp
.dc26  e5 64      sbc $64          	SBC	TabSiz		; subtract tab size
.dc28  b0 fc      bcs $dc26        	BCS	LAB_WDLP		; loop while no borrow
.dc2a  65 64      adc $64          	ADC	TabSiz		; add tab size back
.dc2c  18         clc              	CLC				; clear carry for add
.dc2d  65 64      adc $64          	ADC	TabSiz		; add tab size back again
.dc2f  85 10      sta $10          	STA	Iclim			; save for now
.dc31  a5 0f      lda $0f          	LDA	TWidth		; get width back
.dc33  38         sec              	SEC				; set carry for subtract
.dc34  e5 10      sbc $10          	SBC	Iclim			; subtract remainder
.dc36  85 10      sta $10          	STA	Iclim			; save tab column limit
.dc38                              lab_nosq
.dc38  60         rts              	RTS
.dc39                              taberr
.dc39  4c 29 cb   jmp $cb29        	JMP	LAB_FCER		; do function call error then warm start
.dc3c                              lab_sqr
.dc3c  a5 b0      lda $b0          	LDA	FAC1_s		; get FAC1 sign
.dc3e  30 f9      bmi $dc39        	BMI	TabErr		; if -ve do function call error
.dc40  a5 ac      lda $ac          	LDA	FAC1_e		; get exponent
.dc42  f0 f4      beq $dc38        	BEQ	LAB_NOSQ		; if zero just return
.dc44  20 ca d4   jsr $d4ca        	JSR	LAB_27AB		; round and copy FAC1 to FAC2
.dc47  a9 00      lda #$00         	LDA	#$00			; clear A
.dc49  85 77      sta $77          	STA	FACt_3		; clear remainder
.dc4b  85 76      sta $76          	STA	FACt_2		; ..
.dc4d  85 75      sta $75          	STA	FACt_1		; ..
.dc4f  85 78      sta $78          	STA	TempB			; ..
.dc51  85 af      sta $af          	STA	FAC1_3		; clear root
.dc53  85 ae      sta $ae          	STA	FAC1_2		; ..
.dc55  85 ad      sta $ad          	STA	FAC1_1		; ..
.dc57  a2 18      ldx #$18         	LDX	#$18			; 24 pairs of bits to do
.dc59  a5 b3      lda $b3          	LDA	FAC2_e		; get exponent
.dc5b  4a         lsr              	LSR				; check odd/even
.dc5c  b0 0e      bcs $dc6c        	BCS	LAB_SQE2		; if odd only 1 shift first time
.dc5e                              lab_sqe1
.dc5e  06 b6      asl $b6          	ASL	FAC2_3		; shift highest bit of number ..
.dc60  26 b5      rol $b5          	ROL	FAC2_2		; ..
.dc62  26 b4      rol $b4          	ROL	FAC2_1		; ..
.dc64  26 77      rol $77          	ROL	FACt_3		; .. into remainder
.dc66  26 76      rol $76          	ROL	FACt_2		; ..
.dc68  26 75      rol $75          	ROL	FACt_1		; ..
.dc6a  26 78      rol $78          	ROL	TempB			; .. never overflows
.dc6c                              lab_sqe2
.dc6c  06 b6      asl $b6          	ASL	FAC2_3		; shift highest bit of number ..
.dc6e  26 b5      rol $b5          	ROL	FAC2_2		; ..
.dc70  26 b4      rol $b4          	ROL	FAC2_1		; ..
.dc72  26 77      rol $77          	ROL	FACt_3		; .. into remainder
.dc74  26 76      rol $76          	ROL	FACt_2		; ..
.dc76  26 75      rol $75          	ROL	FACt_1		; ..
.dc78  26 78      rol $78          	ROL	TempB			; .. never overflows
.dc7a  06 af      asl $af          	ASL	FAC1_3		; root = root * 2
.dc7c  26 ae      rol $ae          	ROL	FAC1_2		; ..
.dc7e  26 ad      rol $ad          	ROL	FAC1_1		; .. never overflows
.dc80  a5 af      lda $af          	LDA	FAC1_3		; get root low byte
.dc82  2a         rol              	ROL				; *2
.dc83  85 5b      sta $5b          	STA	Temp3			; save partial low byte
.dc85  a5 ae      lda $ae          	LDA	FAC1_2		; get root low mid byte
.dc87  2a         rol              	ROL				; *2
.dc88  85 5c      sta $5c          	STA	Temp3+1		; save partial low mid byte
.dc8a  a5 ad      lda $ad          	LDA	FAC1_1		; get root high mid byte
.dc8c  2a         rol              	ROL				; *2
.dc8d  85 5d      sta $5d          	STA	Temp3+2		; save partial high mid byte
.dc8f  a9 00      lda #$00         	LDA	#$00			; get root high byte (always $00)
.dc91  2a         rol              	ROL				; *2
.dc92  85 5e      sta $5e          	STA	Temp3+3		; save partial high byte
.dc94  a5 77      lda $77          	LDA	FACt_3		; get remainder low byte
.dc96  e5 5b      sbc $5b          	SBC	Temp3			; subtract partial low byte
.dc98  85 5b      sta $5b          	STA	Temp3			; save partial low byte
.dc9a  a5 76      lda $76          	LDA	FACt_2		; get remainder low mid byte
.dc9c  e5 5c      sbc $5c          	SBC	Temp3+1		; subtract partial low mid byte
.dc9e  85 5c      sta $5c          	STA	Temp3+1		; save partial low mid byte
.dca0  a5 75      lda $75          	LDA	FACt_1		; get remainder high mid byte
.dca2  e5 5d      sbc $5d          	SBC	Temp3+2		; subtract partial high mid byte
.dca4  a8         tay              	TAY				; copy partial high mid byte
.dca5  a5 78      lda $78          	LDA	TempB			; get remainder high byte
.dca7  e5 5e      sbc $5e          	SBC	Temp3+3		; subtract partial high byte
.dca9  90 0e      bcc $dcb9        	BCC	LAB_SQNS		; skip sub if remainder smaller
.dcab  85 78      sta $78          	STA	TempB			; save remainder high byte
.dcad  84 75      sty $75          	STY	FACt_1		; save remainder high mid byte
.dcaf  a5 5c      lda $5c          	LDA	Temp3+1		; get remainder low mid byte
.dcb1  85 76      sta $76          	STA	FACt_2		; save remainder low mid byte
.dcb3  a5 5b      lda $5b          	LDA	Temp3			; get partial low byte
.dcb5  85 77      sta $77          	STA	FACt_3		; save remainder low byte
.dcb7  e6 af      inc $af          	INC	FAC1_3		; increment root low byte (never any rollover)
.dcb9                              lab_sqns
.dcb9  ca         dex              	DEX				; decrement bit pair count
.dcba  d0 a2      bne $dc5e        	BNE	LAB_SQE1		; loop if not all done
.dcbc  38         sec              	SEC				; set carry for subtract
.dcbd  a5 b3      lda $b3          	LDA	FAC2_e		; get exponent
.dcbf  e9 80      sbc #$80         	SBC	#$80			; normalise
.dcc1  6a         ror              	ROR				; /2 and re-bias to $80
.dcc2  69 00      adc #$00         	ADC	#$00			; add bit zero back in (allow for half shift)
.dcc4  85 ac      sta $ac          	STA	FAC1_e		; save it
.dcc6  4c 34 d2   jmp $d234        	JMP	LAB_24D5		; normalise FAC1 and return
.dcc9                              lab_varptr
.dcc9  20 bc 00   jsr $00bc        	JSR	LAB_IGBY		; increment and scan memory
.dccc  20 aa c9   jsr $c9aa        	JSR	LAB_GVAR		; get var address
.dccf  20 ef c7   jsr $c7ef        	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
.dcd2  a4 95      ldy $95          	LDY	Cvaral		; get var address low byte
.dcd4  a5 96      lda $96          	LDA	Cvarah		; get var address high byte
.dcd6  4c 59 cc   jmp $cc59        	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
.dcd9                              lab_pi
.dcd9  a9 bb      lda #$bb         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.dcdb  a0 dd      ldy #$dd         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.dcdd  20 7d d4   jsr $d47d        	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
.dce0  c6 ac      dec $ac          	DEC	FAC1_e		; make result = PI
.dce2  60         rts              	RTS
.dce3                              lab_twopi
.dce3  a9 bb      lda #$bb         	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
.dce5  a0 dd      ldy #$dd         	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
.dce7  4c 7d d4   jmp $d47d        	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
.dcea                              v_inpt
.dcea  6c 05 02   jmp ($0205)      	JMP	(VEC_IN)		; non halting scan input device
.dced                              v_outp
.dced  6c 07 02   jmp ($0207)      	JMP	(VEC_OUT)		; send byte to output device
.dcf0                              v_load
.dcf0  6c 09 02   jmp ($0209)      	JMP	(VEC_LD)		; load BASIC program
.dcf3                              v_save
.dcf3  6c 0b 02   jmp ($020b)      	JMP	(VEC_SV)		; save BASIC program
.dcf6                              pg2_tabs

>dcf6  00                          	.byte	$00			; ctrl-c flag		-	$00 = enabled
>dcf7  00                          	.byte	$00			; ctrl-c byte		-	GET needs this
>dcf8  00                          	.byte	$00			; ctrl-c byte timeout	-	GET needs this
>dcf9  a8 da                       	.word	CTRLC			; ctrl c check vector
.dcfb                              pg2_tabe
.dcfb                              lab_2cee

.dcfb  e6 c3      inc $c3          	INC	Bpntrl		; increment BASIC execute pointer low byte
.dcfd  d0 02      bne $dd01        	BNE	LAB_2CF4		; branch if no carry
.dcff  e6 c4      inc $c4          	INC	Bpntrh		; increment BASIC execute pointer high byte
.dd01                              lab_2cf4
.dd01  ad ff ff   lda $ffff        	LDA	$FFFF			; get byte to scan (addr set by call routine)
.dd04  c9 ad      cmp #$ad         	CMP	#TK_ELSE		; compare with the token for ELSE
.dd06  f0 0e      beq $dd16        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
.dd08  c9 3a      cmp #$3a         	CMP	#":"			; compare with ":"
.dd0a  b0 0a      bcs $dd16        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
.dd0c  c9 20      cmp #$20         	CMP	#" "			; compare with " "
.dd0e  f0 eb      beq $dcfb        	BEQ	LAB_2CEE		; if " " go do next
.dd10  38         sec              	SEC				; set carry for SBC
.dd11  e9 30      sbc #$30         	SBC	#"0"			; subtract "0"
.dd13  38         sec              	SEC				; set carry for SBC
.dd14  e9 d0      sbc #$d0         	SBC	#$D0			; subtract -"0"
.dd16                              lab_2d05
.dd16  60         rts              	RTS
.dd17                              strtab

>dd17  4c                          	.byte	$4C			; JMP opcode
>dd18  00 bc                       	.word LAB_COLD		; initial warm start vector (cold start)
>dd1a  00                          	.byte	$00			; these bytes are not used by BASIC
>dd1b  00 00                       	.word	$0000			; 
>dd1d  00 00                       	.word	$0000			; 
>dd1f  00 00                       	.word	$0000			; 
>dd21  4c                          	.byte	$4C			; JMP opcode
>dd22  29 cb                       	.word	LAB_FCER		; initial user function vector ("Function call" error)
>dd24  00                          	.byte	$00			; default NULL count
>dd25  00                          	.byte	$00			; clear terminal position
>dd26  00                          	.byte	$00			; default terminal width byte
>dd27  f2                          	.byte	$F2			; default limit for TAB = 14
>dd28  00 04                       	.word	Ram_base		; start of user RAM
.dd2a                              endtab
.dd2a                              lab_mszm
>dd2a  0d 0a 4d 65 6d 6f 72 79 20 73 69 7a 65 20 00  	.byte	$0D,$0A,"Memory size ",$00
.dd39                              lab_smsg
>dd39  20 42 79 74 65 73 20 66 72 65 65 0d 0a 0a  	.byte	" Bytes free",$0D,$0A,$0A
>dd47  45 6e 68 61 6e 63 65 64 20 42 41 53 49 43 20 32 2e 32 32 0a 00  	.byte	"Enhanced BASIC 2.22",$0A,$00
.dd5c                              lab_25a0
>dd5c  02                          	.byte	$02			; counter
>dd5d  80 19 56 62                 	.byte	$80,$19,$56,$62	; 0.59898
>dd61  80 76 22 f3                 	.byte	$80,$76,$22,$F3	; 0.96147
>dd65  82 38 aa 40                 	.byte	$82,$38,$AA,$40	; 2.88539
.dd69                              lab_25ad
>dd69  80 35 04 f3                 	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
.dd6d                              lab_25b1
>dd6d  81 35 04 f3                 	.byte	$81,$35,$04,$F3	; 1.41421	root 2
.dd71                              lab_25b5
>dd71  80 80 00 00                 	.byte	$80,$80,$00,$00	; -0.5
.dd75                              lab_25b9
>dd75  80 31 72 18                 	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
.dd79                              lab_2947
>dd79  91 43 4f f8                 	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
.dd7d                              lab_294b
>dd7d  94 74 23 f7                 	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
.dd81                              lab_294f
>dd81  94 74 24 00                 	.byte	$94,$74,$24,$00	; 1000000
.dd85                              lab_2afa
>dd85  81 38 aa 3b                 	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
.dd89                              lab_2afe
>dd89  06                          	.byte	$06			; counter
>dd8a  74 63 90 8c                 	.byte	$74,$63,$90,$8C	; 2.17023e-4
>dd8e  77 23 0c ab                 	.byte	$77,$23,$0C,$AB	; 0.00124
>dd92  7a 1e 94 00                 	.byte	$7A,$1E,$94,$00	; 0.00968
>dd96  7c 63 42 80                 	.byte	$7C,$63,$42,$80	; 0.05548
>dd9a  7e 75 fe d0                 	.byte	$7E,$75,$FE,$D0	; 0.24023
>dd9e  80 31 72 15                 	.byte	$80,$31,$72,$15	; 0.69315
>dda2  81 00 00 00                 	.byte	$81,$00,$00,$00	; 1.00000
.dda6                              lab_2c78
>dda6  81 49 0f db                 	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
.ddaa                              lab_2c84
>ddaa  04                          	.byte	$04			; counter
>ddab  86 1e d7 fb                 	.byte	$86,$1E,$D7,$FB	; 39.7109
>ddaf  87 99 26 65                 	.byte	$87,$99,$26,$65	;-76.575
>ddb3  87 23 34 58                 	.byte	$87,$23,$34,$58	; 81.6022
>ddb7  86 a5 5d e1                 	.byte	$86,$A5,$5D,$E1	;-41.3417
.ddbb                              lab_2c7c
>ddbb  83 49 0f db                 	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
.ddbf                              lab_2cc9
>ddbf  08                          	.byte	$08			; counter
>ddc0  78 3a c5 37                 	.byte	$78,$3A,$C5,$37	; 0.00285
>ddc4  7b 83 a2 5c                 	.byte	$7B,$83,$A2,$5C	;-0.0160686
>ddc8  7c 2e dd 4d                 	.byte	$7C,$2E,$DD,$4D	; 0.0426915
>ddcc  7d 99 b0 1e                 	.byte	$7D,$99,$B0,$1E	;-0.0750429
>ddd0  7d 59 ed 24                 	.byte	$7D,$59,$ED,$24	; 0.106409
>ddd4  7e 91 72 00                 	.byte	$7E,$91,$72,$00	;-0.142036
>ddd8  7e 4c b9 73                 	.byte	$7E,$4C,$B9,$73	; 0.199926
>dddc  7f aa aa 53                 	.byte	$7F,$AA,$AA,$53	;-0.333331
.dde0                              lab_259c
>dde0  81 00 00 00                 	.byte	$81,$00,$00,$00	; 1.000000, used for INC
.dde4                              lab_2afd
>dde4  81 80 00 00                 	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
.dde8                              lab_1df7
>dde8  90                          	.byte	$90			;-32768 (uses first three bytes from 0.5)
.dde9                              lab_2a96
>dde9  80 00 00 00                 	.byte	$80,$00,$00,$00	; 0.5
.dded                              lab_2c80
>dded  7f 00 00 00                 	.byte	$7F,$00,$00,$00	; 0.25
.ddf1                              lab_26b5
>ddf1  84 20 00 00                 	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
.ddf5                              lab_2a9a
>ddf5  fe 79 60                    	.byte	$FE,$79,$60		; -100000
>ddf8  00 27 10                    	.byte	$00,$27,$10		; 10000
>ddfb  ff fc 18                    	.byte	$FF,$FC,$18		; -1000
>ddfe  00 00 64                    	.byte	$00,$00,$64		; 100
>de01  ff ff f6                    	.byte	$FF,$FF,$F6		; -10
>de04  00 00 01                    	.byte	$00,$00,$01		; 1
.de07                              lab_ctbl
>de07  1a c1                       	.word	LAB_END-1		; END
>de09  57 c0                       	.word	LAB_FOR-1		; FOR
>de0b  64 c6                       	.word	LAB_NEXT-1		; NEXT
>de0d  8b c2                       	.word	LAB_DATA-1		; DATA
>de0f  46 c5                       	.word	LAB_INPUT-1		; INPUT
>de11  5e c9                       	.word	LAB_DIM-1		; DIM
>de13  66 c5                       	.word	LAB_READ-1		; READ
>de15  b3 c3                       	.word	LAB_LET-1		; LET
>de17  85 c3                       	.word	LAB_DEC-1		; DEC			new command
>de19  ea c1                       	.word	LAB_GOTO-1		; GOTO
>de1b  a9 c1                       	.word	LAB_RUN-1		; RUN
>de1d  b9 c2                       	.word	LAB_IF-1		; IF
>de1f  41 c1                       	.word	LAB_RESTORE-1	; RESTORE		modified command
>de21  cd c1                       	.word	LAB_GOSUB-1		; GOSUB
>de23  64 db                       	.word	LAB_RETIRQ-1	; RETIRQ		new command
>de25  70 db                       	.word	LAB_RETNMI-1	; RETNMI		new command
>de27  76 c2                       	.word	LAB_RETURN-1	; RETURN
>de29  1d c3                       	.word	LAB_REM-1		; REM
>de2b  18 c1                       	.word	LAB_STOP-1		; STOP
>de2d  26 c3                       	.word	LAB_ON-1		; ON			modified command
>de2f  7f c1                       	.word	LAB_NULL-1		; NULL		modified command
>de31  88 c3                       	.word	LAB_INC-1		; INC			new command
>de33  88 d1                       	.word	LAB_WAIT-1		; WAIT
>de35  ef dc                       	.word	V_LOAD-1		; LOAD
>de37  f2 dc                       	.word	V_SAVE-1		; SAVE
>de39  73 cc                       	.word	LAB_DEF-1		; DEF
>de3b  0d d1                       	.word	LAB_POKE-1		; POKE
>de3d  29 d1                       	.word	LAB_DOKE-1		; DOKE		new command
>de3f  76 d1                       	.word	LAB_CALL-1		; CALL		new command
>de41  b3 c1                       	.word	LAB_DO-1		; DO			new command
>de43  1c c2                       	.word	LAB_LOOP-1		; LOOP		new command
>de45  54 c4                       	.word	LAB_PRINT-1		; PRINT
>de47  85 c1                       	.word	LAB_CONT-1		; CONT
>de49  a2 bf                       	.word	LAB_LIST-1		; LIST
>de4b  9f bf                       	.word	LAB_CLEAR-1		; CLEAR
>de4d  4d bf                       	.word	LAB_NEW-1		; NEW
>de4f  e5 db                       	.word	LAB_WDTH-1		; WIDTH		new command
>de51  23 c4                       	.word	LAB_GET-1		; GET			new command
>de53  4e d1                       	.word	LAB_SWAP-1		; SWAP		new command
>de55  81 d9                       	.word	LAB_BITSET-1	; BITSET		new command
>de57  95 d9                       	.word	LAB_BITCLR-1	; BITCLR		new command
>de59  13 db                       	.word	LAB_IRQ-1		; IRQ			new command
>de5b  16 db                       	.word	LAB_NMI-1		; NMI			new command
>de5d  d4 e6                       	.word   SYSjmp-1                ; SYS         *** added for SBC-2
.de5f                              lab_ftpl
>de5f  64 c8                       	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
>de61  64 c8                       	.word	LAB_PPFN-1		; INT(n)		"
>de63  64 c8                       	.word	LAB_PPFN-1		; ABS(n)		"
>de65  e8 c6                       	.word	LAB_EVEZ-1		; USR(x)	process any expression
>de67  eb c7                       	.word	LAB_1BF7-1		; FRE(x)		"
>de69  eb c7                       	.word	LAB_1BF7-1		; POS(x)		"
>de6b  64 c8                       	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
>de6d  64 c8                       	.word	LAB_PPFN-1		; RND(n)		"
>de6f  64 c8                       	.word	LAB_PPFN-1		; LOG(n)		"
>de71  64 c8                       	.word	LAB_PPFN-1		; EXP(n)		"
>de73  64 c8                       	.word	LAB_PPFN-1		; COS(n)		"
>de75  64 c8                       	.word	LAB_PPFN-1		; SIN(n)		"
>de77  64 c8                       	.word	LAB_PPFN-1		; TAN(n)		"
>de79  64 c8                       	.word	LAB_PPFN-1		; ATN(n)		"
>de7b  64 c8                       	.word	LAB_PPFN-1		; PEEK(n)		"
>de7d  64 c8                       	.word	LAB_PPFN-1		; DEEK(n)		"
>de7f  00 00                       	.word	$0000			; SADD()	none
>de81  5e c8                       	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
>de83  64 c8                       	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
>de85  5e c8                       	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
>de87  5e c8                       	.word	LAB_PPFS-1		; ASC($)		"
>de89  5e c8                       	.word	LAB_PPFS-1		; UCASE$($)		"
>de8b  5e c8                       	.word	LAB_PPFS-1		; LCASE$($)		"
>de8d  64 c8                       	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
>de8f  8b c8                       	.word	LAB_BHSS-1		; HEX$(n)		"
>de91  8b c8                       	.word	LAB_BHSS-1		; BIN$(n)		"
>de93  00 00                       	.word	$0000			; BITTST()	none
>de95  7c db                       	.word	LAB_MMPP-1		; MAX()	process numeric expression
>de97  7c db                       	.word	LAB_MMPP-1		; MIN()		"
>de99  6a c8                       	.word	LAB_PPBI-1		; PI		advance pointer
>de9b  6a c8                       	.word	LAB_PPBI-1		; TWOPI		"
>de9d  00 00                       	.word	$0000			; VARPTR()	none
>de9f  6f c8                       	.word	LAB_LRMS-1		; LEFT$()	process string expression
>dea1  6f c8                       	.word	LAB_LRMS-1		; RIGHT$()		"
>dea3  6f c8                       	.word	LAB_LRMS-1		; MID$()		"
.dea5                              lab_ftbl
>dea5  f6 d4                       	.word	LAB_SGN-1		; SGN()
>dea7  80 d5                       	.word	LAB_INT-1		; INT()
>dea9  13 d5                       	.word	LAB_ABS-1		; ABS()
>deab  4c d9                       	.word	LAB_USR-1		; USR()
>dead  44 cc                       	.word	LAB_FRE-1		; FRE()
>deaf  63 cc                       	.word	LAB_POS-1		; POS()
>deb1  3b dc                       	.word	LAB_SQR-1		; SQR()
>deb3  9c d8                       	.word	LAB_RND-1		; RND()		modified function
>deb5  fa d2                       	.word	LAB_LOG-1		; LOG()
>deb7  fe d7                       	.word	LAB_EXP-1		; EXP()
>deb9  d0 d8                       	.word	LAB_COS-1		; COS()
>debb  d7 d8                       	.word	LAB_SIN-1		; SIN()
>debd  20 d9                       	.word	LAB_TAN-1		; TAN()
>debf  52 d9                       	.word	LAB_ATN-1		; ATN()
>dec1  02 d1                       	.word	LAB_PEEK-1		; PEEK()
>dec3  16 d1                       	.word	LAB_DEEK-1		; DEEK()		new function
>dec5  54 d0                       	.word	LAB_SADD-1		; SADD()		new function
>dec7  6d d0                       	.word	LAB_LENS-1		; LEN()
>dec9  25 cd                       	.word	LAB_STRS-1		; STR$()
>decb  9a d0                       	.word	LAB_VAL-1		; VAL()
>decd  78 d0                       	.word	LAB_ASC-1		; ASC()
>decf  32 d0                       	.word	LAB_UCASE-1		; UCASE$()		new function
>ded1  11 d0                       	.word	LAB_LCASE-1		; LCASE$()		new function
>ded3  83 cf                       	.word	LAB_CHRS-1		; CHR$()
>ded5  22 da                       	.word	LAB_HEXS-1		; HEX$()		new function
>ded7  d3 d9                       	.word	LAB_BINS-1		; BIN$()		new function
>ded9  ab d9                       	.word	LAB_BTST-1		; BITTST()		new function
>dedb  82 db                       	.word	LAB_MAX-1		; MAX()		new function
>dedd  92 db                       	.word	LAB_MIN-1		; MIN()		new function
>dedf  d8 dc                       	.word	LAB_PI-1		; PI			new function
>dee1  e2 dc                       	.word	LAB_TWOPI-1		; TWOPI		new function
>dee3  c8 dc                       	.word	LAB_VARPTR-1	; VARPTR()		new function
>dee5  95 cf                       	.word	LAB_LEFT-1		; LEFT$()
>dee7  9e cf                       	.word	LAB_RIGHT-1		; RIGHT$()
>dee9  cd cf                       	.word	LAB_MIDS-1		; MID$()
.deeb                              lab_oppt
>deeb  79                          	.byte	$79			; +
>deec  c0 d1                       	.word	LAB_ADD-1
>deee  79                          	.byte	$79			; -
>deef  a5 d1                       	.word	LAB_SUBTRACT-1
>def1  7b                          	.byte	$7B			; *
>def2  3b d3                       	.word	LAB_MULTIPLY-1
>def4  7b                          	.byte	$7B			; /
>def5  03 d4                       	.word	LAB_DIVIDE-1
>def7  7f                          	.byte	$7F			; ^
>def8  ba d7                       	.word	LAB_POWER-1
>defa  50                          	.byte	$50			; AND
>defb  d4 c8                       	.word	LAB_AND-1
>defd  46                          	.byte	$46			; EOR			new operator
>defe  ba c8                       	.word	LAB_EOR-1
>df00  46                          	.byte	$46			; OR
>df01  c7 c8                       	.word	LAB_OR-1
>df03  56                          	.byte	$56			; >>			new operator
>df04  80 c9                       	.word	LAB_RSHIFT-1
>df06  56                          	.byte	$56			; <<			new operator
>df07  68 c9                       	.word	LAB_LSHIFT-1
>df09  7d                          	.byte	$7D			; >
>df0a  f3 d7                       	.word	LAB_GTHAN-1
>df0c  5a                          	.byte	$5A			; =
>df0d  16 c8                       	.word	LAB_EQUAL-1
>df0f  64                          	.byte	$64			; <
>df10  f5 c8                       	.word	LAB_LTHAN-1
.df12                              tab_1stc
>df12  2a                          	.byte	"*"
>df13  2b                          	.byte	"+"
>df14  2d                          	.byte	"-"
>df15  2f                          	.byte	"/"
>df16  3c                          	.byte	"<"
>df17  3d                          	.byte	"="
>df18  3e                          	.byte	">"
>df19  3f                          	.byte	"?"
>df1a  41                          	.byte	"A"
>df1b  42                          	.byte	"B"
>df1c  43                          	.byte	"C"
>df1d  44                          	.byte	"D"
>df1e  45                          	.byte	"E"
>df1f  46                          	.byte	"F"
>df20  47                          	.byte	"G"
>df21  48                          	.byte	"H"
>df22  49                          	.byte	"I"
>df23  4c                          	.byte	"L"
>df24  4d                          	.byte	"M"
>df25  4e                          	.byte	"N"
>df26  4f                          	.byte	"O"
>df27  50                          	.byte	"P"
>df28  52                          	.byte	"R"
>df29  53                          	.byte	"S"
>df2a  54                          	.byte	"T"
>df2b  55                          	.byte	"U"
>df2c  56                          	.byte	"V"
>df2d  57                          	.byte	"W"
>df2e  5e                          	.byte	"^"
>df2f  00                          	.byte	$00			; table terminator
.df30                              tab_chrt
>df30  6a df                       	.word	TAB_STAR		; table for "*"
>df32  6c df                       	.word	TAB_PLUS		; table for "+"
>df34  6e df                       	.word	TAB_MNUS		; table for "-"
>df36  70 df                       	.word	TAB_SLAS		; table for "/"
>df38  72 df                       	.word	TAB_LESS		; table for "<"
>df3a  76 df                       	.word	TAB_EQUL		; table for "="
>df3c  78 df                       	.word	TAB_MORE		; table for ">"
>df3e  7c df                       	.word	TAB_QEST		; table for "?"
>df40  7e df                       	.word	TAB_ASCA		; table for "A"
>df42  8e df                       	.word	TAB_ASCB		; table for "B"
>df44  a7 df                       	.word	TAB_ASCC		; table for "C"
>df46  be df                       	.word	TAB_ASCD		; table for "D"
>df48  d7 df                       	.word	TAB_ASCE		; table for "E"
>df4a  e6 df                       	.word	TAB_ASCF		; table for "F"
>df4c  f0 df                       	.word	TAB_ASCG		; table for "G"
>df4e  fd df                       	.word	TAB_ASCH		; table for "H"
>df50  03 e0                       	.word	TAB_ASCI		; table for "I"
>df52  15 e0                       	.word	TAB_ASCL		; table for "L"
>df54  3a e0                       	.word	TAB_ASCM		; table for "M"
>df56  48 e0                       	.word	TAB_ASCN		; table for "N"
>df58  5a e0                       	.word	TAB_ASCO		; table for "O"
>df5a  62 e0                       	.word	TAB_ASCP		; table for "P"
>df5c  77 e0                       	.word	TAB_ASCR		; table for "R"
>df5e  a6 e0                       	.word	TAB_ASCS		; table for "S"
>df60  d4 e0                       	.word	TAB_ASCT		; table for "T"
>df62  e8 e0                       	.word	TAB_ASCU		; table for "U"
>df64  f9 e0                       	.word	TAB_ASCV		; table for "V"
>df66  05 e1                       	.word	TAB_ASCW		; table for "W"
>df68  14 e1                       	.word	TAB_POWR		; table for "^"
.df6a                              tab_star
>df6a  b9 00                       	.byte TK_MUL,$00		; *
.df6c                              tab_plus
>df6c  b7 00                       	.byte TK_PLUS,$00		; +
.df6e                              tab_mnus
>df6e  b8 00                       	.byte TK_MINUS,$00	; -
.df70                              tab_slas
>df70  ba 00                       	.byte TK_DIV,$00		; /
.df72                              tab_less
.df72                              lbb_lshift
>df72  3c c0                       	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
>df74  c3                          	.byte TK_LT			; <
>df75  00                          	.byte	$00
.df76                              tab_equl
>df76  c2 00                       	.byte TK_EQUAL,$00	; =
.df78                              tab_more
.df78                              lbb_rshift
>df78  3e bf                       	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
>df7a  c1                          	.byte TK_GT			; >
>df7b  00                          	.byte	$00
.df7c                              tab_qest
>df7c  9f 00                       	.byte TK_PRINT,$00	; ?
.df7e                              tab_asca
.df7e                              lbb_abs
>df7e  42 53 28 c6                 	.byte	"BS(",TK_ABS	; ABS(
.df82                              lbb_and
>df82  4e 44 bc                    	.byte	"ND",TK_AND		; AND
.df85                              lbb_asc
>df85  53 43 28 d8                 	.byte	"SC(",TK_ASC	; ASC(
.df89                              lbb_atn
>df89  54 4e 28 d1                 	.byte	"TN(",TK_ATN	; ATN(
>df8d  00                          	.byte	$00
.df8e                              tab_ascb
.df8e                              lbb_bins
>df8e  49 4e 24 28 dd              	.byte	"IN$(",TK_BINS	; BIN$(
.df93                              lbb_bitclr
>df93  49 54 43 4c 52 a8           	.byte	"ITCLR",TK_BITCLR	; BITCLR
.df99                              lbb_bitset
>df99  49 54 53 45 54 a7           	.byte	"ITSET",TK_BITSET	; BITSET
.df9f                              lbb_bittst
>df9f  49 54 54 53 54 28 de        	.byte	"ITTST(",TK_BITTST
>dfa6  00                          	.byte	$00
.dfa7                              tab_ascc
.dfa7                              lbb_call
>dfa7  41 4c 4c 9c                 	.byte	"ALL",TK_CALL	; CALL
.dfab                              lbb_chrs
>dfab  48 52 24 28 db              	.byte	"HR$(",TK_CHRS	; CHR$(
.dfb0                              lbb_clear
>dfb0  4c 45 41 52 a2              	.byte	"LEAR",TK_CLEAR	; CLEAR
.dfb5                              lbb_cont
>dfb5  4f 4e 54 a0                 	.byte	"ONT",TK_CONT	; CONT
.dfb9                              lbb_cos
>dfb9  4f 53 28 ce                 	.byte	"OS(",TK_COS	; COS(
>dfbd  00                          	.byte	$00
.dfbe                              tab_ascd
.dfbe                              lbb_data
>dfbe  41 54 41 83                 	.byte	"ATA",TK_DATA	; DATA
.dfc2                              lbb_dec
>dfc2  45 43 88                    	.byte	"EC",TK_DEC		; DEC
.dfc5                              lbb_deek
>dfc5  45 45 4b 28 d3              	.byte	"EEK(",TK_DEEK	; DEEK(
.dfca                              lbb_def
>dfca  45 46 99                    	.byte	"EF",TK_DEF		; DEF
.dfcd                              lbb_dim
>dfcd  49 4d 85                    	.byte	"IM",TK_DIM		; DIM
.dfd0                              lbb_doke
>dfd0  4f 4b 45 9b                 	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
.dfd4                              lbb_do
>dfd4  4f 9d                       	.byte	"O",TK_DO		; DO
>dfd6  00                          	.byte	$00
.dfd7                              tab_asce
.dfd7                              lbb_else
>dfd7  4c 53 45 ad                 	.byte	"LSE",TK_ELSE	; ELSE
.dfdb                              lbb_end
>dfdb  4e 44 80                    	.byte	"ND",TK_END		; END
.dfde                              lbb_eor
>dfde  4f 52 bd                    	.byte	"OR",TK_EOR		; EOR
.dfe1                              lbb_exp
>dfe1  58 50 28 cd                 	.byte	"XP(",TK_EXP	; EXP(
>dfe5  00                          	.byte	$00
.dfe6                              tab_ascf
.dfe6                              lbb_fn
>dfe6  4e af                       	.byte	"N",TK_FN		; FN
.dfe8                              lbb_for
>dfe8  4f 52 81                    	.byte	"OR",TK_FOR		; FOR
.dfeb                              lbb_fre
>dfeb  52 45 28 c8                 	.byte	"RE(",TK_FRE	; FRE(
>dfef  00                          	.byte	$00
.dff0                              tab_ascg
.dff0                              lbb_get
>dff0  45 54 a5                    	.byte	"ET",TK_GET		; GET
.dff3                              lbb_gosub
>dff3  4f 53 55 42 8d              	.byte	"OSUB",TK_GOSUB	; GOSUB
.dff8                              lbb_goto
>dff8  4f 54 4f 89                 	.byte	"OTO",TK_GOTO	; GOTO
>dffc  00                          	.byte	$00
.dffd                              tab_asch
.dffd                              lbb_hexs
>dffd  45 58 24 28 dc              	.byte	"EX$(",TK_HEXS	; HEX$(
>e002  00                          	.byte	$00
.e003                              tab_asci
.e003                              lbb_if
>e003  46 8b                       	.byte	"F",TK_IF		; IF
.e005                              lbb_inc
>e005  4e 43 95                    	.byte	"NC",TK_INC		; INC
.e008                              lbb_input
>e008  4e 50 55 54 84              	.byte	"NPUT",TK_INPUT	; INPUT
.e00d                              lbb_int
>e00d  4e 54 28 c5                 	.byte	"NT(",TK_INT	; INT(
.e011                              lbb_irq
>e011  52 51 a9                    	.byte	"RQ",TK_IRQ		; IRQ
>e014  00                          	.byte	$00
.e015                              tab_ascl
.e015                              lbb_lcases
>e015  43 41 53 45 24 28 da        	.byte	"CASE$(",TK_LCASES
.e01c                              lbb_lefts
>e01c  45 46 54 24 28 e4           	.byte	"EFT$(",TK_LEFTS	; LEFT$(
.e022                              lbb_len
>e022  45 4e 28 d5                 	.byte	"EN(",TK_LEN	; LEN(
.e026                              lbb_let
>e026  45 54 87                    	.byte	"ET",TK_LET		; LET
.e029                              lbb_list
>e029  49 53 54 a1                 	.byte	"IST",TK_LIST	; LIST
.e02d                              lbb_load
>e02d  4f 41 44 97                 	.byte	"OAD",TK_LOAD	; LOAD
.e031                              lbb_log
>e031  4f 47 28 cc                 	.byte	"OG(",TK_LOG	; LOG(
.e035                              lbb_loop
>e035  4f 4f 50 9e                 	.byte	"OOP",TK_LOOP	; LOOP
>e039  00                          	.byte	$00
.e03a                              tab_ascm
.e03a                              lbb_max
>e03a  41 58 28 df                 	.byte	"AX(",TK_MAX	; MAX(
.e03e                              lbb_mids
>e03e  49 44 24 28 e6              	.byte	"ID$(",TK_MIDS	; MID$(
.e043                              lbb_min
>e043  49 4e 28 e0                 	.byte	"IN(",TK_MIN	; MIN(
>e047  00                          	.byte	$00
.e048                              tab_ascn
.e048                              lbb_new
>e048  45 57 a3                    	.byte	"EW",TK_NEW		; NEW
.e04b                              lbb_next
>e04b  45 58 54 82                 	.byte	"EXT",TK_NEXT	; NEXT
.e04f                              lbb_nmi
>e04f  4d 49 aa                    	.byte	"MI",TK_NMI		; NMI
.e052                              lbb_not
>e052  4f 54 b2                    	.byte	"OT",TK_NOT		; NOT
.e055                              lbb_null
>e055  55 4c 4c 94                 	.byte	"ULL",TK_NULL	; NULL
>e059  00                          	.byte	$00
.e05a                              tab_asco
.e05a                              lbb_off
>e05a  46 46 b6                    	.byte	"FF",TK_OFF		; OFF
.e05d                              lbb_on
>e05d  4e 93                       	.byte	"N",TK_ON		; ON
.e05f                              lbb_or
>e05f  52 be                       	.byte	"R",TK_OR		; OR
>e061  00                          	.byte	$00
.e062                              tab_ascp
.e062                              lbb_peek
>e062  45 45 4b 28 d2              	.byte	"EEK(",TK_PEEK	; PEEK(
.e067                              lbb_pi
>e067  49 e1                       	.byte	"I",TK_PI		; PI
.e069                              lbb_poke
>e069  4f 4b 45 9a                 	.byte	"OKE",TK_POKE	; POKE
.e06d                              lbb_pos
>e06d  4f 53 28 c9                 	.byte	"OS(",TK_POS	; POS(
.e071                              lbb_print
>e071  52 49 4e 54 9f              	.byte	"RINT",TK_PRINT	; PRINT
>e076  00                          	.byte	$00
.e077                              tab_ascr
.e077                              lbb_read
>e077  45 41 44 86                 	.byte	"EAD",TK_READ	; READ
.e07b                              lbb_rem
>e07b  45 4d 91                    	.byte	"EM",TK_REM		; REM
.e07e                              lbb_restore
>e07e  45 53 54 4f 52 45 8c        	.byte	"ESTORE",TK_RESTORE
.e085                              lbb_retirq
>e085  45 54 49 52 51 8e           	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
.e08b                              lbb_retnmi
>e08b  45 54 4e 4d 49 8f           	.byte	"ETNMI",TK_RETNMI	; RETNMI
.e091                              lbb_return
>e091  45 54 55 52 4e 90           	.byte	"ETURN",TK_RETURN	; RETURN
.e097                              lbb_rights
>e097  49 47 48 54 24 28 e5        	.byte	"IGHT$(",TK_RIGHTS
.e09e                              lbb_rnd
>e09e  4e 44 28 cb                 	.byte	"ND(",TK_RND	; RND(
.e0a2                              lbb_run
>e0a2  55 4e 8a                    	.byte	"UN",TK_RUN		; RUN
>e0a5  00                          	.byte	$00
.e0a6                              tab_ascs
.e0a6                              lbb_sadd
>e0a6  41 44 44 28 d4              	.byte	"ADD(",TK_SADD	; SADD(
.e0ab                              lbb_save
>e0ab  41 56 45 98                 	.byte	"AVE",TK_SAVE	; SAVE
.e0af                              lbb_sgn
>e0af  47 4e 28 c4                 	.byte	"GN(",TK_SGN	; SGN(
.e0b3                              lbb_sin
>e0b3  49 4e 28 cf                 	.byte	"IN(",TK_SIN	; SIN(
.e0b7                              lbb_spc
>e0b7  50 43 28 b0                 	.byte	"PC(",TK_SPC	; SPC(
.e0bb                              lbb_sqr
>e0bb  51 52 28 ca                 	.byte	"QR(",TK_SQR	; SQR(
.e0bf                              lbb_step
>e0bf  54 45 50 b3                 	.byte	"TEP",TK_STEP	; STEP
.e0c3                              lbb_stop
>e0c3  54 4f 50 92                 	.byte	"TOP",TK_STOP	; STOP
.e0c7                              lbb_strs
>e0c7  54 52 24 28 d6              	.byte	"TR$(",TK_STRS	; STR$(
.e0cc                              lbb_swap
>e0cc  57 41 50 a6                 	.byte	"WAP",TK_SWAP	; SWAP
.e0d0                              lbb_sys
>e0d0  59 53 ab                    	.byte   "YS", TK_SYS    ; SYS    *** added for SBC-2
>e0d3  00                          	.byte	$00
.e0d4                              tab_asct
.e0d4                              lbb_tab
>e0d4  41 42 28 ac                 	.byte	"AB(",TK_TAB	; TAB(
.e0d8                              lbb_tan
>e0d8  41 4e 28 d0                 	.byte	"AN(",TK_TAN	; TAN(
.e0dc                              lbb_then
>e0dc  48 45 4e b1                 	.byte	"HEN",TK_THEN	; THEN
.e0e0                              lbb_to
>e0e0  4f ae                       	.byte	"O",TK_TO		; TO
.e0e2                              lbb_twopi
>e0e2  57 4f 50 49 e2              	.byte	"WOPI",TK_TWOPI	; TWOPI
>e0e7  00                          	.byte	$00
.e0e8                              tab_ascu
.e0e8                              lbb_ucases
>e0e8  43 41 53 45 24 28 d9        	.byte	"CASE$(",TK_UCASES
.e0ef                              lbb_until
>e0ef  4e 54 49 4c b4              	.byte	"NTIL",TK_UNTIL	; UNTIL
.e0f4                              lbb_usr
>e0f4  53 52 28 c7                 	.byte	"SR(",TK_USR	; USR(
>e0f8  00                          	.byte	$00
.e0f9                              tab_ascv
.e0f9                              lbb_val
>e0f9  41 4c 28 d7                 	.byte	"AL(",TK_VAL	; VAL(
.e0fd                              lbb_vptr
>e0fd  41 52 50 54 52 28 e3        	.byte	"ARPTR(",TK_VPTR	; VARPTR(
>e104  00                          	.byte	$00
.e105                              tab_ascw
.e105                              lbb_wait
>e105  41 49 54 96                 	.byte	"AIT",TK_WAIT	; WAIT
.e109                              lbb_while
>e109  48 49 4c 45 b5              	.byte	"HILE",TK_WHILE	; WHILE
.e10e                              lbb_width
>e10e  49 44 54 48 a4              	.byte	"IDTH",TK_WIDTH	; WIDTH
>e113  00                          	.byte	$00
.e114                              tab_powr
>e114  bb 00                       	.byte	TK_POWER,$00	; ^
.e116                              lab_keyt
>e116  03 45                       	.byte	3,"E"
>e118  db df                       	.word	LBB_END		; END
>e11a  03 46                       	.byte	3,"F"
>e11c  e8 df                       	.word	LBB_FOR		; FOR
>e11e  04 4e                       	.byte	4,"N"
>e120  4b e0                       	.word	LBB_NEXT		; NEXT
>e122  04 44                       	.byte	4,"D"
>e124  be df                       	.word	LBB_DATA		; DATA
>e126  05 49                       	.byte	5,"I"
>e128  08 e0                       	.word	LBB_INPUT		; INPUT
>e12a  03 44                       	.byte	3,"D"
>e12c  cd df                       	.word	LBB_DIM		; DIM
>e12e  04 52                       	.byte	4,"R"
>e130  77 e0                       	.word	LBB_READ		; READ
>e132  03 4c                       	.byte	3,"L"
>e134  26 e0                       	.word	LBB_LET		; LET
>e136  03 44                       	.byte	3,"D"
>e138  c2 df                       	.word	LBB_DEC		; DEC
>e13a  04 47                       	.byte	4,"G"
>e13c  f8 df                       	.word	LBB_GOTO		; GOTO
>e13e  03 52                       	.byte	3,"R"
>e140  a2 e0                       	.word	LBB_RUN		; RUN
>e142  02 49                       	.byte	2,"I"
>e144  03 e0                       	.word	LBB_IF		; IF
>e146  07 52                       	.byte	7,"R"
>e148  7e e0                       	.word	LBB_RESTORE		; RESTORE
>e14a  05 47                       	.byte	5,"G"
>e14c  f3 df                       	.word	LBB_GOSUB		; GOSUB
>e14e  06 52                       	.byte	6,"R"
>e150  85 e0                       	.word	LBB_RETIRQ		; RETIRQ
>e152  06 52                       	.byte	6,"R"
>e154  8b e0                       	.word	LBB_RETNMI		; RETNMI
>e156  06 52                       	.byte	6,"R"
>e158  91 e0                       	.word	LBB_RETURN		; RETURN
>e15a  03 52                       	.byte	3,"R"
>e15c  7b e0                       	.word	LBB_REM		; REM
>e15e  04 53                       	.byte	4,"S"
>e160  c3 e0                       	.word	LBB_STOP		; STOP
>e162  02 4f                       	.byte	2,"O"
>e164  5d e0                       	.word	LBB_ON		; ON
>e166  04 4e                       	.byte	4,"N"
>e168  55 e0                       	.word	LBB_NULL		; NULL
>e16a  03 49                       	.byte	3,"I"
>e16c  05 e0                       	.word	LBB_INC		; INC
>e16e  04 57                       	.byte	4,"W"
>e170  05 e1                       	.word	LBB_WAIT		; WAIT
>e172  04 4c                       	.byte	4,"L"
>e174  2d e0                       	.word	LBB_LOAD		; LOAD
>e176  04 53                       	.byte	4,"S"
>e178  ab e0                       	.word	LBB_SAVE		; SAVE
>e17a  03 44                       	.byte	3,"D"
>e17c  ca df                       	.word	LBB_DEF		; DEF
>e17e  04 50                       	.byte	4,"P"
>e180  69 e0                       	.word	LBB_POKE		; POKE
>e182  04 44                       	.byte	4,"D"
>e184  d0 df                       	.word	LBB_DOKE		; DOKE
>e186  04 43                       	.byte	4,"C"
>e188  a7 df                       	.word	LBB_CALL		; CALL
>e18a  02 44                       	.byte	2,"D"
>e18c  d4 df                       	.word	LBB_DO		; DO
>e18e  04 4c                       	.byte	4,"L"
>e190  35 e0                       	.word	LBB_LOOP		; LOOP
>e192  05 50                       	.byte	5,"P"
>e194  71 e0                       	.word	LBB_PRINT		; PRINT
>e196  04 43                       	.byte	4,"C"
>e198  b5 df                       	.word	LBB_CONT		; CONT
>e19a  04 4c                       	.byte	4,"L"
>e19c  29 e0                       	.word	LBB_LIST		; LIST
>e19e  05 43                       	.byte	5,"C"
>e1a0  b0 df                       	.word	LBB_CLEAR		; CLEAR
>e1a2  03 4e                       	.byte	3,"N"
>e1a4  48 e0                       	.word	LBB_NEW		; NEW
>e1a6  05 57                       	.byte	5,"W"
>e1a8  0e e1                       	.word	LBB_WIDTH		; WIDTH
>e1aa  03 47                       	.byte	3,"G"
>e1ac  f0 df                       	.word	LBB_GET		; GET
>e1ae  04 53                       	.byte	4,"S"
>e1b0  cc e0                       	.word	LBB_SWAP		; SWAP
>e1b2  06 42                       	.byte	6,"B"
>e1b4  99 df                       	.word	LBB_BITSET		; BITSET
>e1b6  06 42                       	.byte	6,"B"
>e1b8  93 df                       	.word	LBB_BITCLR		; BITCLR
>e1ba  03 49                       	.byte	3,"I"
>e1bc  11 e0                       	.word	LBB_IRQ		; IRQ
>e1be  03 4e                       	.byte	3,"N"
>e1c0  4f e0                       	.word	LBB_NMI		; NMI
>e1c2  03 53                       	.byte	3,"S"			;
>e1c4  d0 e0                       	.word	LBB_SYS			; SYS   *** Added for SBC-2
>e1c6  04 54                       	.byte	4,"T"
>e1c8  d4 e0                       	.word	LBB_TAB		; TAB
>e1ca  04 45                       	.byte	4,"E"
>e1cc  d7 df                       	.word	LBB_ELSE		; ELSE
>e1ce  02 54                       	.byte	2,"T"
>e1d0  e0 e0                       	.word	LBB_TO		; TO
>e1d2  02 46                       	.byte	2,"F"
>e1d4  e6 df                       	.word	LBB_FN		; FN
>e1d6  04 53                       	.byte	4,"S"
>e1d8  b7 e0                       	.word	LBB_SPC		; SPC
>e1da  04 54                       	.byte	4,"T"
>e1dc  dc e0                       	.word	LBB_THEN		; THEN
>e1de  03 4e                       	.byte	3,"N"
>e1e0  52 e0                       	.word	LBB_NOT		; NOT
>e1e2  04 53                       	.byte	4,"S"
>e1e4  bf e0                       	.word	LBB_STEP		; STEP
>e1e6  05 55                       	.byte	5,"U"
>e1e8  ef e0                       	.word	LBB_UNTIL		; UNTIL
>e1ea  05 57                       	.byte	5,"W"
>e1ec  09 e1                       	.word	LBB_WHILE		; WHILE
>e1ee  03 4f                       	.byte	3,"O"
>e1f0  5a e0                       	.word	LBB_OFF		; OFF
>e1f2  01 2b                       	.byte	1,"+"
>e1f4  00 00                       	.word	$0000			; +
>e1f6  01 2d                       	.byte	1,"-"
>e1f8  00 00                       	.word	$0000			; -
>e1fa  01 2a                       	.byte	1,"*"
>e1fc  00 00                       	.word	$0000			; *
>e1fe  01 2f                       	.byte	1,"/"
>e200  00 00                       	.word	$0000			; /
>e202  01 5e                       	.byte	1,"^"
>e204  00 00                       	.word	$0000			; ^
>e206  03 41                       	.byte	3,"A"
>e208  82 df                       	.word	LBB_AND		; AND
>e20a  03 45                       	.byte	3,"E"
>e20c  de df                       	.word	LBB_EOR		; EOR
>e20e  02 4f                       	.byte	2,"O"
>e210  5f e0                       	.word	LBB_OR		; OR
>e212  02 3e                       	.byte	2,">"
>e214  78 df                       	.word	LBB_RSHIFT		; >>
>e216  02 3c                       	.byte	2,"<"
>e218  72 df                       	.word	LBB_LSHIFT		; <<
>e21a  01 3e                       	.byte	1,">"
>e21c  00 00                       	.word	$0000			; >
>e21e  01 3d                       	.byte	1,"="
>e220  00 00                       	.word	$0000			; =
>e222  01 3c                       	.byte	1,"<"
>e224  00 00                       	.word	$0000			; <
>e226  04 53                       	.byte	4,"S"			;
>e228  af e0                       	.word	LBB_SGN		; SGN
>e22a  04 49                       	.byte	4,"I"			;
>e22c  0d e0                       	.word	LBB_INT		; INT
>e22e  04 41                       	.byte	4,"A"			;
>e230  7e df                       	.word	LBB_ABS		; ABS
>e232  04 55                       	.byte	4,"U"			;
>e234  f4 e0                       	.word	LBB_USR		; USR
>e236  04 46                       	.byte	4,"F"			;
>e238  eb df                       	.word	LBB_FRE		; FRE
>e23a  04 50                       	.byte	4,"P"			;
>e23c  6d e0                       	.word	LBB_POS		; POS
>e23e  04 53                       	.byte	4,"S"			;
>e240  bb e0                       	.word	LBB_SQR		; SQR
>e242  04 52                       	.byte	4,"R"			;
>e244  9e e0                       	.word	LBB_RND		; RND
>e246  04 4c                       	.byte	4,"L"			;
>e248  31 e0                       	.word	LBB_LOG		; LOG
>e24a  04 45                       	.byte	4,"E"			;
>e24c  e1 df                       	.word	LBB_EXP		; EXP
>e24e  04 43                       	.byte	4,"C"			;
>e250  b9 df                       	.word	LBB_COS		; COS
>e252  04 53                       	.byte	4,"S"			;
>e254  b3 e0                       	.word	LBB_SIN		; SIN
>e256  04 54                       	.byte	4,"T"			;
>e258  d8 e0                       	.word	LBB_TAN		; TAN
>e25a  04 41                       	.byte	4,"A"			;
>e25c  89 df                       	.word	LBB_ATN		; ATN
>e25e  05 50                       	.byte	5,"P"			;
>e260  62 e0                       	.word	LBB_PEEK		; PEEK
>e262  05 44                       	.byte	5,"D"			;
>e264  c5 df                       	.word	LBB_DEEK		; DEEK
>e266  05 53                       	.byte	5,"S"			;
>e268  a6 e0                       	.word	LBB_SADD		; SADD
>e26a  04 4c                       	.byte	4,"L"			;
>e26c  22 e0                       	.word	LBB_LEN		; LEN
>e26e  05 53                       	.byte	5,"S"			;
>e270  c7 e0                       	.word	LBB_STRS		; STR$
>e272  04 56                       	.byte	4,"V"			;
>e274  f9 e0                       	.word	LBB_VAL		; VAL
>e276  04 41                       	.byte	4,"A"			;
>e278  85 df                       	.word	LBB_ASC		; ASC
>e27a  07 55                       	.byte	7,"U"			;
>e27c  e8 e0                       	.word	LBB_UCASES		; UCASE$
>e27e  07 4c                       	.byte	7,"L"			;
>e280  15 e0                       	.word	LBB_LCASES		; LCASE$
>e282  05 43                       	.byte	5,"C"			;
>e284  ab df                       	.word	LBB_CHRS		; CHR$
>e286  05 48                       	.byte	5,"H"			;
>e288  fd df                       	.word	LBB_HEXS		; HEX$
>e28a  05 42                       	.byte	5,"B"			;
>e28c  8e df                       	.word	LBB_BINS		; BIN$
>e28e  07 42                       	.byte	7,"B"			;
>e290  9f df                       	.word	LBB_BITTST		; BITTST
>e292  04 4d                       	.byte	4,"M"			;
>e294  3a e0                       	.word	LBB_MAX		; MAX
>e296  04 4d                       	.byte	4,"M"			;
>e298  43 e0                       	.word	LBB_MIN		; MIN
>e29a  02 50                       	.byte	2,"P"			;
>e29c  67 e0                       	.word	LBB_PI		; PI
>e29e  05 54                       	.byte	5,"T"			;
>e2a0  e2 e0                       	.word	LBB_TWOPI		; TWOPI
>e2a2  07 56                       	.byte	7,"V"			;
>e2a4  fd e0                       	.word	LBB_VPTR		; VARPTR
>e2a6  06 4c                       	.byte	6,"L"			;
>e2a8  1c e0                       	.word	LBB_LEFTS		; LEFT$
>e2aa  07 52                       	.byte	7,"R"			;
>e2ac  97 e0                       	.word	LBB_RIGHTS		; RIGHT$
>e2ae  05 4d                       	.byte	5,"M"			;
>e2b0  3e e0                       	.word	LBB_MIDS		; MID$
.e2b2                              lab_baer
>e2b2  d6 e2                       	.word	ERR_NF		;$00 NEXT without FOR
>e2b4  e7 e2                       	.word	ERR_SN		;$02 syntax
>e2b6  ee e2                       	.word	ERR_RG		;$04 RETURN without GOSUB
>e2b8  03 e3                       	.word	ERR_OD		;$06 out of data
>e2ba  0f e3                       	.word	ERR_FC		;$08 function call
>e2bc  1d e3                       	.word	ERR_OV		;$0A overflow
>e2be  26 e3                       	.word	ERR_OM		;$0C out of memory
>e2c0  34 e3                       	.word	ERR_US		;$0E undefined statement
>e2c2  48 e3                       	.word	ERR_BS		;$10 array bounds
>e2c4  55 e3                       	.word	ERR_DD		;$12 double dimension array
>e2c6  66 e3                       	.word	ERR_D0		;$14 divide by 0
>e2c8  75 e3                       	.word	ERR_ID		;$16 illegal direct
>e2ca  84 e3                       	.word	ERR_TM		;$18 type mismatch
>e2cc  92 e3                       	.word	ERR_LS		;$1A long string
>e2ce  a2 e3                       	.word	ERR_ST		;$1C string too complex
>e2d0  b5 e3                       	.word	ERR_CN		;$1E continue error
>e2d2  c4 e3                       	.word	ERR_UF		;$20 undefined function
>e2d4  d7 e3                       	.word ERR_LD		;$22 LOOP without DO
>e2d6  4e 45 58 54 20 77 69 74 68 6f 75 74 20 46 4f 52 00  ERR_NF	.byte	"NEXT without FOR",$00
>e2e7  53 79 6e 74 61 78 00        ERR_SN	.byte	"Syntax",$00
>e2ee  52 45 54 55 52 4e 20 77 69 74 68 6f 75 74 20 47 4f 53 55 42 00  ERR_RG	.byte	"RETURN without GOSUB",$00
>e303  4f 75 74 20 6f 66 20 44 41 54 41 00  ERR_OD	.byte	"Out of DATA",$00
>e30f  46 75 6e 63 74 69 6f 6e 20 63 61 6c 6c 00  ERR_FC	.byte	"Function call",$00
>e31d  4f 76 65 72 66 6c 6f 77 00  ERR_OV	.byte	"Overflow",$00
>e326  4f 75 74 20 6f 66 20 6d 65 6d 6f 72 79 00  ERR_OM	.byte	"Out of memory",$00
>e334  55 6e 64 65 66 69 6e 65 64 20 73 74 61 74 65 6d 65 6e 74 00  ERR_US	.byte	"Undefined statement",$00
>e348  41 72 72 61 79 20 62 6f 75 6e 64 73 00  ERR_BS	.byte	"Array bounds",$00
>e355  44 6f 75 62 6c 65 20 64 69 6d 65 6e 73 69 6f 6e 00  ERR_DD	.byte	"Double dimension",$00
>e366  44 69 76 69 64 65 20 62 79 20 7a 65 72 6f 00  ERR_D0	.byte	"Divide by zero",$00
>e375  49 6c 6c 65 67 61 6c 20 64 69 72 65 63 74 00  ERR_ID	.byte	"Illegal direct",$00
>e384  54 79 70 65 20 6d 69 73 6d 61 74 63 68 00  ERR_TM	.byte	"Type mismatch",$00
>e392  53 74 72 69 6e 67 20 74 6f 6f 20 6c 6f 6e 67 00  ERR_LS	.byte	"String too long",$00
>e3a2  53 74 72 69 6e 67 20 74 6f 6f 20 63 6f 6d 70 6c 65 78 00  ERR_ST	.byte	"String too complex",$00
>e3b5  43 61 6e 27 74 20 63 6f 6e 74 69 6e 75 65 00  ERR_CN	.byte	"Can't continue",$00
>e3c4  55 6e 64 65 66 69 6e 65 64 20 66 75 6e 63 74 69 6f 6e 00  ERR_UF	.byte	"Undefined function",$00
>e3d7  4c 4f 4f 50 20 77 69 74 68 6f 75 74 20 44 4f 00  ERR_LD	.byte	"LOOP without DO",$00
>e3e7  0d 0a 42 72 65 61 6b 00     LAB_BMSG	.byte	$0D,$0A,"Break",$00
>e3ef  20 45 72 72 6f 72 00        LAB_EMSG	.byte	" Error",$00
>e3f6  20 69 6e 20 6c 69 6e 65 20 00  LAB_LMSG	.byte	" in line ",$00
>e400  0d 0a 52 65 61 64 79 0d 0a 00  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
>e40a  20 45 78 74 72 61 20 69 67 6e 6f 72 65 64 0d 0a 00  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
>e41b  20 52 65 64 6f 20 66 72 6f 6d 20 73 74 61 72 74 0d 0a 00  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
.e42e                              aa_end_basic
.e42e                              psave

.e42e  20 6d e4   jsr $e46d        		jsr	pscan
.e431  a0 00      ldy #$00         		ldy	#$00
.e433  a5 11      lda $11          		lda	itempl
.e435  91 11      sta ($11),y      		sta	(itempl),y
.e437  c8         iny              		iny
.e438  a5 12      lda $12          		lda	itemph
.e43a  91 11      sta ($11),y      		sta	(itempl),y
.e43c  a6 79      ldx $79          		ldx	smeml
.e43e  a5 7a      lda $7a          		lda	smemh
.e440  20 f3 e5   jsr $e5f3        		jsr	print2byte
.e443  20 e6 e5   jsr $e5e6        		jsr	print_cr
.e446  38         sec              		sec
.e447  a5 11      lda $11          		lda	itempl
.e449  e5 79      sbc $79          		sbc	smeml
.e44b  aa         tax              		tax
.e44c  a5 12      lda $12          		lda	itemph
.e44e  e5 7a      sbc $7a          		sbc	smemh
.e450  20 f3 e5   jsr $e5f3        		jsr	print2byte
.e453  20 e6 e5   jsr $e5e6        		jsr	print_cr
.e456  60         rts              		rts
.e457                              pload
.e457  20 6d e4   jsr $e46d        		jsr	pscan
.e45a  a5 11      lda $11          		lda	itempl
.e45c  85 7b      sta $7b          		sta	svarl
.e45e  85 7d      sta $7d          		sta	sarryl
.e460  85 7f      sta $7f          		sta	earryl
.e462  a5 12      lda $12          		lda	itemph
.e464  85 7c      sta $7c          		sta	svarh
.e466  85 7e      sta $7e          		sta	sarryh
.e468  85 80      sta $80          		sta	earryh
.e46a  4c 14 be   jmp $be14        		JMP   LAB_1319		
.e46d                              pscan
.e46d  a5 79      lda $79          		lda	smeml
.e46f  85 11      sta $11                	sta	itempl
.e471  a5 7a      lda $7a                	lda	smemh
.e473  85 12      sta $12                	sta	itemph
.e475  a0 00      ldy #$00         pscan1	ldy   #$00
.e477  b1 11      lda ($11),y      		lda   (itempl),y
.e479  d0 13      bne $e48e        		bne   pscan2
.e47b  c8         iny              		iny   
.e47c  b1 11      lda ($11),y      		lda   (itempl),y
.e47e  d0 0e      bne $e48e        		bne   pscan2
.e480  18         clc              		clc
.e481  a9 02      lda #$02         		lda   #$02
.e483  65 11      adc $11          		adc   itempl
.e485  85 11      sta $11          		sta	itempl
.e487  a9 00      lda #$00         		lda	#$00
.e489  65 12      adc $12          		adc	itemph
.e48b  85 12      sta $12          		sta	itemph
.e48d  60         rts              		rts
.e48e  a0 00      ldy #$00         pscan2	ldy   #$00
.e490  b1 11      lda ($11),y      		lda	(itempl),y
.e492  aa         tax              		tax
.e493  c8         iny              		iny
.e494  b1 11      lda ($11),y      		lda	(itempl),y
.e496  85 12      sta $12          		sta	itemph
.e498  86 11      stx $11          		stx	itempl
.e49a  80 d9      bra $e475        		bra	pscan1
.e49c  a2 00      ldx #$00         Via1_init      ldx   #$00              ; get data from table
.e49e  bd aa e4   lda $e4aa,x      Via1init1      lda   Via1idata,x       ; init all 16 regs from 00 to 0F
.e4a1  9d 50 7f   sta $7f50,x                     sta   Via1Base,x        ; 
.e4a4  e8         inx                             inx                     ; 
.e4a5  e0 0f      cpx #$0f                        cpx   #$0f              ; 
.e4a7  d0 f5      bne $e49e                       bne   Via1init1         ;       
.e4a9  60         rts                             rts                     ; done

>e4aa  00                          Via1idata      .byte $00               ; prb  '00000000'
>e4ab  00                                         .byte $00               ; pra  "00000000'
>e4ac  00                                         .byte $00               ; ddrb 'iiiiiiii'
>e4ad  00                                         .byte $00               ; ddra 'iiiiiiii'
>e4ae  00                                         .byte $00               ; tacl  
>e4af  00                                         .byte $00               ; tach  
>e4b0  00                                         .byte $00               ; tall  
>e4b1  00                                         .byte $00               ; talh  
>e4b2  00                                         .byte $00               ; t2cl
>e4b3  00                                         .byte $00               ; t2ch
>e4b4  00                                         .byte $00               ; sr
>e4b5  00                                         .byte $00               ; acr
>e4b6  00                                         .byte $00               ; pcr
>e4b7  7f                                         .byte $7f               ; ifr
>e4b8  7f                                         .byte $7f               ; ier

.e4b9  a2 00      ldx #$00         Via2_init      ldx   #$00              ; get data from table
.e4bb  bd c7 e4   lda $e4c7,x      Via2init1      lda   Via2idata,x       ; init all 16 regs from 00 to 0F
.e4be  9d 60 7f   sta $7f60,x                     sta   Via2Base,x        ; 
.e4c1  e8         inx                             inx                     ; 
.e4c2  e0 0f      cpx #$0f                        cpx   #$0f              ; 
.e4c4  d0 f5      bne $e4bb                       bne   Via2init1         ;       
.e4c6  60         rts                             rts                     ; done

>e4c7  00                          Via2idata      .byte $00               ; prb  '00000000'
>e4c8  00                                         .byte $00               ; pra  "00000000'
>e4c9  00                                         .byte $00               ; ddrb 'iiiiiiii'
>e4ca  00                                         .byte $00               ; ddra 'iiiiiiii'
>e4cb  00                                         .byte $00               ; tacl  
>e4cc  00                                         .byte $00               ; tach  
>e4cd  00                                         .byte $00               ; tall  
>e4ce  00                                         .byte $00               ; talh  
>e4cf  00                                         .byte $00               ; t2cl
>e4d0  00                                         .byte $00               ; t2ch
>e4d1  00                                         .byte $00               ; sr
>e4d2  00                                         .byte $00               ; acr
>e4d3  00                                         .byte $00               ; pcr
>e4d4  7f                                         .byte $7f               ; ifr
>e4d5  7f                                         .byte $7f               ; ier

.e4d6  a2 39      ldx #$39         ACIA1_init     LDX   #<ACIA1_Input      ; set up RAM vectors for
.e4d8  a9 e5      lda #$e5                        LDA   #>ACIA1_Input      ; Input, Output, and Scan
.e4da  a8         tay                             TAY                     	; Routines
.e4db  49 a5      eor #$a5                        EOR   #$A5              	;
.e4dd  8d ed 03   sta $03ed                       sta   ChrInVect+2       	;
.e4e0  8c ec 03   sty $03ec                       sty   ChrInVect+1       	;
.e4e3  8e eb 03   stx $03eb                       stx   ChrInVect         	;
.e4e6  a2 44      ldx #$44                        LDX   #<ACIA1_Scan  	;
.e4e8  a9 e5      lda #$e5                        LDA   #>ACIA1_Scan       ;
.e4ea  a8         tay                             TAY                     	;
.e4eb  49 a5      eor #$a5                        EOR   #$A5              	;
.e4ed  8d f0 03   sta $03f0                       sta   ScanInVect+2      	;
.e4f0  8c ef 03   sty $03ef                       sty   ScanInVect+1      	;
.e4f3  8e ee 03   stx $03ee                       stx   ScanInVect        	;
.e4f6  a2 51      ldx #$51                        LDX   #<ACIA1_Output     ;
.e4f8  a9 e5      lda #$e5                        LDA   #>ACIA1_Output     ;
.e4fa  a8         tay                             TAY                     	;
.e4fb  49 a5      eor #$a5                        EOR   #$A5              	;
.e4fd  8d f3 03   sta $03f3                       sta   ChrOutVect+2      	;
.e500  8c f2 03   sty $03f2                       sty   ChrOutVect+1      	;
.e503  8e f1 03   stx $03f1                       stx   ChrOutVect        	;
.e506  a9 44      lda #$44                        lda   #<ACIA1_scan      	; setup BASIC vectors
.e508  8d 05 02   sta $0205                       sta   VEC_IN
.e50b  a9 e5      lda #$e5         	       lda   #>ACIA1_scan	; BASIC's chr input
.e50d  8d 06 02   sta $0206                       sta   VEC_IN+1
.e510  a9 51      lda #$51                        lda   #<ACIA1_Output	
.e512  8d 07 02   sta $0207                       sta   VEC_OUT
.e515  a9 e5      lda #$e5         	       lda   #>ACIA1_Output	; BASIC's chr output 
.e517  8d 08 02   sta $0208                       sta   VEC_OUT+1
.e51a  a9 2e      lda #$2e         	       lda   #<Psave
.e51c  8d 0b 02   sta $020b                       sta   VEC_SV
.e51f  a9 e4      lda #$e4         	       lda   #>Psave		; SAVE cmd
.e521  8d 0c 02   sta $020c                       sta   VEC_SV+1
.e524  a9 57      lda #$57         	       lda   #<pload
.e526  8d 09 02   sta $0209                       sta   VEC_LD
.e529  a9 e4      lda #$e4         	       lda   #>pload		; LOAD cmd
.e52b  8d 0a 02   sta $020a                       sta   VEC_LD+1
.e52e  a9 1f      lda #$1f         ACIA1portset   lda   #$1F               ; 19.2K/8/1
.e530  8d 73 7f   sta $7f73                       sta   ACIA1ctl           ; control reg 
.e533  a9 0b      lda #$0b                        lda   #$0B               ; N parity/echo off/rx int off/ dtr active low
.e535  8d 72 7f   sta $7f72                       sta   ACIA1cmd           ; command reg 
.e538  60         rts                             rts                      ; done
.e539                              acia1_input
.e539  ad 71 7f   lda $7f71                       lda   ACIA1Sta           ; Serial port status             
.e53c  29 08      and #$08                        and   #$08               ; is recvr full
.e53e  f0 f9      beq $e539                       beq   ACIA1_Input        ; no char to get
.e540  ad 70 7f   lda $7f70                       Lda   ACIA1dat           ; get chr
.e543  60         rts                             RTS                      ;
.e544  18         clc              ACIA1_Scan     clc
.e545  ad 71 7f   lda $7f71                       lda   ACIA1Sta           ; Serial port status
.e548  29 08      and #$08                        and   #$08               ; mask rcvr full bit
.e54a  f0 04      beq $e550                       beq   ACIA1_scan2
.e54c  ad 70 7f   lda $7f70                       Lda   ACIA1dat           ; get chr
.e54f  38         sec              	         sec
.e550  60         rts              ACIA1_scan2    rts
.e551  48         pha              ACIA1_Output   PHA                      ; save registers
.e552  ad 71 7f   lda $7f71        ACIA1_Out1     lda   ACIA1Sta           ; serial port status
.e555  29 10      and #$10                        and   #$10               ; is tx buffer empty
.e557  f0 f9      beq $e552                       beq   ACIA1_Out1         ; no
.e559  68         pla                             PLA                      ; get chr
.e55a  8d 70 7f   sta $7f70                       sta   ACIA1dat           ; put character to Port
.e55d  60         rts                             RTS                      ; done
.e55e  4c cf e6   jmp $e6cf        Start_OS       jmp   MonitorBoot         ; easy access to monitor program
.e561  4c e6 e5   jmp $e5e6        Jmp_CR	   jmp   Print_CR		
.e564  4c 17 e6   jmp $e617        Jmp_1sp	   jmp   Print1SP			; jump table for usable monitor
.e567  4c 14 e6   jmp $e614        Jmp_2sp	   jmp   Print2SP			; routines
.e56a  4c 0f e6   jmp $e60f        Jmp_xsp	   jmp   PrintXSP			; This will not change in future
.e56d  4c 00 e6   jmp $e600        Jmp_nib	   jmp   PrintDig			; releases, only be added to
.e570  4c f7 e5   jmp $e5f7        Jmp_byte	   jmp   Print1Byte
.e573  4c f3 e5   jmp $e5f3        jmp_wrd	   jmp   Print2Byte
.e576  4c 95 e6   jmp $e695        jmp_bell	   jmp   Bell
.e579  4c 9a e6   jmp $e69a        jmp_delay	   jmp   Delay
.e57c  4c 8f e6   jmp $e68f        jmp_scan	   jmp   Scan_input
.e57f  4c 8c e6   jmp $e68c        jmp_inp        jmp   Input_chr  
.e582  4c 92 e6   jmp $e692        jmp_out        jmp   Output
.e585  4c 1f e6   jmp $e61f        jmp_input	   jmp   Input
.e588  4c 23 e6   jmp $e623        jmp_input1     jmp   Input1

>e58b  20 50 43 3d 20 20 41 3d 20 20 58 3d 20 20 59 3d 20 20 53 3d 20 20 50 3d 20 28 4e 56 52 42 44 49 5a 43 29 3d  RegData        .byte" PC=  A=  X=  Y=  S=  P= (NVRBDIZC)="

.e5af  20 e6 e5   jsr $e5e6        PrintReg       Jsr   Print_CR          ; Lead with a CR
.e5b2  a2 ff      ldx #$ff                        ldx   #$ff              ;
.e5b4  a0 ff      ldy #$ff                        ldy   #$ff              ;
.e5b6  c8         iny              Printreg1      iny                     ;
.e5b7  b9 8b e5   lda $e58b,y                     lda   Regdata,y         ;
.e5ba  20 92 e6   jsr $e692                       jsr   Output            ;
.e5bd  c9 3d      cmp #$3d                        cmp   #$3D              ; "="
.e5bf  d0 f5      bne $e5b6                       bne   Printreg1         ;
.e5c1  e8         inx              Printreg2      inx                     ;
.e5c2  e0 07      cpx #$07                        cpx   #$07              ;
.e5c4  f0 0c      beq $e5d2                       beq   Printreg3         ; done with first 6
.e5c6  bd e0 03   lda $03e0,x                     lda   PCH,x             ;  
.e5c9  20 f7 e5   jsr $e5f7                       jsr   Print1Byte        ;
.e5cc  e0 00      cpx #$00                        cpx   #$00              ;
.e5ce  d0 e6      bne $e5b6                       bne   Printreg1         ;
.e5d0  80 ef      bra $e5c1                       bra   Printreg2         ;
.e5d2  ca         dex              Printreg3      dex                     ;
.e5d3  bd e0 03   lda $03e0,x                     lda   PCH,x             ; get Preg
.e5d6  a2 08      ldx #$08                        ldx   #$08              ; 
.e5d8  2a         rol              Printreg4      rol                     ;
.e5d9  a8         tay                             tay                     ;
.e5da  a9 31      lda #$31                        lda   #$31              ;
.e5dc  b0 01      bcs $e5df                       bcs   Printreg5         ;
.e5de  3a         dec                             dec                     ;
.e5df  20 92 e6   jsr $e692        Printreg5      jsr   Output            ;
.e5e2  98         tya                             tya                     ;
.e5e3  ca         dex                             dex                     ;
.e5e4  d0 f2      bne $e5d8                       bne   Printreg4         ;
.e5e6  48         pha              Print_CR       PHA                     ; Save Acc
.e5e7  a9 0d      lda #$0d                        LDA   #$0D              ; "cr"
.e5e9  20 92 e6   jsr $e692                       JSR   OUTPUT            ; send it
.e5ec  a9 0a      lda #$0a                        LDA   #$0A              ; "lf"
.e5ee  20 92 e6   jsr $e692                       JSR   OUTPUT            ; send it
.e5f1  68         pla                             PLA                     ; Restore Acc
.e5f2  60         rts                             RTS                     ; 
.e5f3  20 f7 e5   jsr $e5f7        Print2Byte     JSR   Print1Byte        ;  prints AAXX hex digits
.e5f6  8a         txa                             TXA                     ;
.e5f7  48         pha              Print1Byte     PHA                     ;  prints AA hex digits
.e5f8  4a         lsr                             LSR                     ;  MOVE UPPER NIBBLE TO LOWER
.e5f9  4a         lsr                             LSR                     ;
.e5fa  4a         lsr                             LSR                     ;
.e5fb  4a         lsr                             LSR                     ;
.e5fc  20 00 e6   jsr $e600                       JSR   PrintDig          ;
.e5ff  68         pla                             PLA                     ;
.e600  5a         phy              PrintDig       PHY                     ;  prints A hex nibble (low 4 bits)
.e601  29 0f      and #$0f                        AND   #$0F              ;
.e603  a8         tay                             TAY                     ;
.e604  b9 8f ed   lda $ed8f,y                     LDA   Hexdigdata,Y      ;
.e607  7a         ply                             PLY                     ;
.e608  4c 92 e6   jmp $e692                       jmp   output            ;
.e60b  20 17 e6   jsr $e617        PrintXSP1      JSR   Print1SP          ;
.e60e  ca         dex                             dex                     ;
.e60f  e0 00      cpx #$00         PrintXSP       cpx   #$00              ;
.e611  d0 f8      bne $e60b                       bne   PrintXSP1         ;
.e613  60         rts                             rts                     ;
.e614  20 17 e6   jsr $e617        Print2SP       jsr   Print1SP          ; print 2 SPACES
.e617  a9 20      lda #$20         Print1SP       LDA   #$20              ; print 1 SPACE
.e619  4c 92 e6   jmp $e692                       JMP   OUTPUT            ;
.e61c  a9 21      lda #$21         Input_Assem    lda   #$21              ; Assembler Prompt "!"

>e61e  2c                                         .byte $2c               ; mask out next line to bypass 

.e61f  a9 3e      lda #$3e         Input          lda   #$3E              ; Monitor Prompt ">"
.e621  85 32      sta $32                         sta   Prompt            ; save prompt chr 
.e623  20 e6 e5   jsr $e5e6        Input1         jsr   Print_CR          ; New Line
.e626  a5 32      lda $32                         lda   Prompt            ; get prompt
.e628  20 92 e6   jsr $e692                       jsr   Output            ; Print Prompt
.e62b  a0 ff      ldy #$ff                        ldy   #$ff              ; pointer
.e62d  20 8c e6   jsr $e68c        InputWait      jsr   Input_Chr         ; get a character
.e630  c9 20      cmp #$20                        cmp   #$20              ; is ctrl char?
.e632  b0 3d      bcs $e671                       BCS   InputSave         ; no, echo chr 
.e634  c9 0d      cmp #$0d                        cmp   #$0d              ; cr
.e636  f0 4a      beq $e682                       Beq   InputDone         ; done
.e638  c9 1b      cmp #$1b                        cmp   #$1B              ; esc
.e63a  f0 e7      beq $e623                       beq   Input1            ; cancel and new line
.e63c  c9 08      cmp #$08                        cmp   #$08              ; bs
.e63e  f0 09      beq $e649                       beq   backspace         ;
.e640  c9 09      cmp #$09         		   cmp   #$09		   ; TAB key
.e642  f0 1b      beq $e65f        		   beq   tabkey		   ;
.e644  c9 02      cmp #$02                        cmp   #$02              ; Ctrl-B
.e646  d0 e5      bne $e62d                       bne   InputWait         ; Ignore other codes
.e648  00         brk                             brk                     ; Force a keyboard Break cmd
.e649  c0 ff      cpy #$ff         backspace      cpy   #$ff              ;
.e64b  f0 e0      beq $e62d                       beq   InputWait         ; nothing to do
.e64d  88         dey                             dey                     ; remove last char
.e64e  a9 08      lda #$08                        Lda   #$08              ; backup one space
.e650  20 92 e6   jsr $e692                       jsr   Output            ;
.e653  a9 20      lda #$20                        Lda   #$20              ; Print space (destructive BS)
.e655  20 92 e6   jsr $e692                       jsr   Output            ;
.e658  a9 08      lda #$08                        Lda   #$08              ; backup one space
.e65a  20 92 e6   jsr $e692                       jsr   Output            ;
.e65d  80 ce      bra $e62d                       BRA   InputWait         ; ready for next key
.e65f  a9 20      lda #$20         tabkey	   lda   #$20		   ; convert tab to space
.e661  c8         iny              		   iny			   ; move cursor
.e662  30 1f      bmi $e683                       bmi   InputTooLong	   ; line too long?
.e664  99 00 03   sta $0300,y                     sta   Buffer,y		   ; no, save space in buffer
.e667  20 92 e6   jsr $e692        		   jsr   output		   ; print the space too
.e66a  98         tya                             tya   			   ; test to see if tab is on multiple of 8
.e66b  29 07      and #$07         		   and   #$07		   ; mask remainder of cursor/8
.e66d  d0 f0      bne $e65f                       bne   tabkey		   ; not done, add another space
.e66f  80 bc      bra $e62d        		   bra   InputWait	   ; done. 
.e671  c9 61      cmp #$61         InputSave      CMP   #$61              ;   ucase
.e673  90 02      bcc $e677                       BCC   InputSave1        ;
.e675  e9 20      sbc #$20                        SBC   #$20              ;
.e677  c8         iny              InputSave1     INY                     ;
.e678  30 09      bmi $e683                       BMI   InputTooLong      ; get next char (up to 127)
.e67a  99 00 03   sta $0300,y                     STA   Buffer,y          ;
.e67d  20 92 e6   jsr $e692                       JSR   Output            ; OutputCharacter
.e680  80 ab      bra $e62d                       BRA   InputWait         ;
.e682  c8         iny              InputDone      INY                     ;
.e683  a9 0d      lda #$0d         InputTooLong   LDA   #$0d              ; force CR at end of 128 characters 
.e685  99 00 03   sta $0300,y                     sta   Buffer,y          ;
.e688  20 92 e6   jsr $e692                       JSR   Output            ;
.e68b  60         rts                             RTS                     ;
.e68c  6c eb 03   jmp ($03eb)      Input_chr      jmp   (ChrInVect)       ;
.e68f  6c ee 03   jmp ($03ee)      Scan_input     jmp   (ScanInVect)      ; 
.e692  6c f1 03   jmp ($03f1)      Output         jmp   (ChrOutVect)      ;
.e695  a9 07      lda #$07         bell           LDA  #$07               ; Ctrl G Bell
.e697  4c 92 e6   jmp $e692                       jmp  Output             ; 
.e69a  48         pha              Delay          PHA                     ; use A to execute a delay loop
.e69b  3a         dec              delay1         DEC                     ;
.e69c  d0 fd      bne $e69b                       BNE   delay1            ;
.e69e  68         pla                             PLA                     ;
.e69f  3a         dec                             DEC                     ;
.e6a0  d0 f8      bne $e69a                       BNE   Delay             ;
.e6a2  60         rts              GRTS           RTS                     ;
.e6a3  8d e2 03   sta $03e2        BRKroutine     sta   ACC               ; save A    Monitor"s break handler
.e6a6  8e e3 03   stx $03e3                       stx   Xreg              ; save X
.e6a9  8c e4 03   sty $03e4                       sty   Yreg              ; save Y
.e6ac  68         pla                             pla                     ; 
.e6ad  8d e6 03   sta $03e6                       sta   Preg              ; save P
.e6b0  68         pla                             pla                     ; PCL
.e6b1  fa         plx                             plx                     ; PCH
.e6b2  38         sec                             sec                     ;
.e6b3  e9 02      sbc #$02                        sbc   #$02              ;
.e6b5  8d e1 03   sta $03e1                       sta   PCL               ; backup to BRK cmd
.e6b8  b0 01      bcs $e6bb                       bcs   Brk2              ;
.e6ba  ca         dex                             dex                     ;
.e6bb  8e e0 03   stx $03e0        Brk2           stx   PCH               ; save PC
.e6be  ba         tsx                             TSX                     ; get stack pointer
.e6bf  8e e5 03   stx $03e5                       stx   SPtr              ; save stack pointer
.e6c2  20 95 e6   jsr $e695                       jsr   Bell              ; Beep speaker
.e6c5  20 af e5   jsr $e5af                       jsr   PrintReg          ; dump register contents 
.e6c8  a2 ff      ldx #$ff                        ldx   #$FF              ; 
.e6ca  9a         txs                             txs                     ; clear stack
.e6cb  58         cli                             cli                     ; enable interrupts again
.e6cc  4c d5 e6   jmp $e6d5                       jmp   Monitor           ; start the monitor
.e6cf                              monitorboot
.e6cf  20 95 e6   jsr $e695                       jsr   bell              ; beep ready
.e6d2  20 4a e7   jsr $e74a                       JSR   Version           ;
.e6d5                              sysjmp
.e6d5  a2 ff      ldx #$ff         Monitor        LDX   #$FF              ; 
.e6d7  9a         txs                             TXS			   ;  Init the stack
.e6d8  20 1f e6   jsr $e61f                       JSR   input             ;  line input
.e6db  a9 00      lda #$00                        LDA   #$00              ;
.e6dd  a8         tay                             TAY                     ;  set to 1st character in line
.e6de  85 33      sta $33                         sta   LineCnt           ; normal list vs range list 
.e6e0  85 37      sta $37          Mon01          STA   Memchr            ;
.e6e2  64 3c      stz $3c          Mon02          STZ   Hexdigits         ;  holds parsed hex
.e6e4  64 3d      stz $3d                         STZ   Hexdigits+1       ;
.e6e6  20 0b e7   jsr $e70b                       JSR   ParseHexDig       ;  Get any Hex chars
.e6e9  a2 11      ldx #$11                        LDX   #CmdCount         ;  get # of cmds currently used
.e6eb  dd 9f ed   cmp $ed9f,x      Mon08          CMP   CmdAscii,X        ;  is non hex cmd chr?
.e6ee  f0 05      beq $e6f5                       BEQ   Mon09             ;  yes x= cmd number
.e6f0  ca         dex                             DEX                     ;
.e6f1  10 f8      bpl $e6eb                       BPL   Mon08             ;
.e6f3  80 e0      bra $e6d5                       BRA   Monitor           ;  no
.e6f5  da         phx              Mon09          PHX                     ;  save command
.e6f6  5a         phy                             PHY                     ;  Save input line pointer
.e6f7  8a         txa                             TXA                     ;
.e6f8  0a         asl                             ASL                     ;  ptr * 2
.e6f9  aa         tax                             TAX                     ;  
.e6fa  20 08 e7   jsr $e708                       JSR   Mon10             ;  Execute cmd
.e6fd  7a         ply                             PLY                     ;
.e6fe  fa         plx                             PLX                     ;
.e6ff  f0 d4      beq $e6d5                       BEQ   Monitor           ;  done
.e701  bd d5 ed   lda $edd5,x                     LDA   Cmdseccode,X      ;  
.e704  30 dc      bmi $e6e2                       BMI   Mon02             ;
.e706  80 d8      bra $e6e0                       BRA   Mon01             ;
.e708  7c b1 ed   jmp ($edb1,x)    Mon10          JMP   (Cmdjmptbl,X)     ;
.e70b  64 35      stz $35          ParseHexDig    STZ   Hexdigcnt         ;  cntr
.e70d  80 0e      bra $e71d                       BRA   ParseHex05        ;
.e70f  8a         txa              ParseHex03     TXA                     ;  parse hex dig
.e710  a2 04      ldx #$04                        LDX   #$04              ;  
.e712  06 3c      asl $3c          ParseHex04     ASL   Hexdigits         ;
.e714  26 3d      rol $3d                         ROL   Hexdigits+1       ;
.e716  ca         dex                             DEX                     ;
.e717  d0 f9      bne $e712                       BNE   ParseHex04        ;
.e719  04 3c      tsb $3c                         TSB   Hexdigits         ;
.e71b  c6 35      dec $35                         DEC   Hexdigcnt         ;
.e71d  b9 00 03   lda $0300,y      ParseHex05     LDA   buffer,Y          ;
.e720  a2 0f      ldx #$0f                        LDX   #$0F              ;   is hex chr?
.e722  c8         iny                             INY                     ;
.e723  dd 8f ed   cmp $ed8f,x      ParseHex07     CMP   Hexdigdata,X      ;
.e726  f0 e7      beq $e70f                       BEQ   ParseHex03        ;   yes
.e728  ca         dex                             DEX                     ;
.e729  10 f8      bpl $e723                       BPL   ParseHex07        ;
.e72b  60         rts                             RTS                     ; Stored in HexDigits if HexDigCnt <> 0
.e72c  a9 05      lda #$05         Help_cmd       lda   #<Helptxt         ;  lower byte - Menu of Commands
.e72e  85 3a      sta $3a                         sta   addrptr           ;
.e730  a9 f1      lda #$f1                        lda   #>Helptxt         ;  upper byte
.e732  85 3b      sta $3b                         sta   addrptr+1         ;
.e734  80 0f      bra $e745                       bra   Help_cmd3         ;
.e736  c9 7e      cmp #$7e         Help_Cmd4      cmp   #$7e              ;  "~"
.e738  f0 05      beq $e73f                       beq   Help_Cmd1         ;
.e73a  20 92 e6   jsr $e692                       jsr   Output            ;
.e73d  80 03      bra $e742                       bra   Help_cmd2         ;
.e73f  20 e6 e5   jsr $e5e6        Help_cmd1      jsr   Print_CR          ;     
.e742  20 fc e7   jsr $e7fc        Help_cmd2      jsr   Inc_addrptr       ;
.e745  b2 3a      lda ($3a)        Help_cmd3      lda   (addrptr)         ;
.e747  d0 ed      bne $e736                       bne   Help_cmd4         ;
.e749  60         rts                             rts                     ;
.e74a  20 e6 e5   jsr $e5e6        Version        jsr   Print_CR          ; 
.e74d  a2 ff      ldx #$ff                        ldx   #$FF              ; set txt pointer
.e74f  a9 0d      lda #$0d                        lda   #$0d              ; 
.e751  e8         inx              PortReadyMsg   inx                     ;
.e752  20 92 e6   jsr $e692                       JSR   Output            ; put character to Port
.e755  bd ef f6   lda $f6ef,x                     lda   porttxt,x         ; get message text
.e758  d0 f7      bne $e751                       bne   PortReadyMsg      ; 
.e75a  60         rts                             rts                     ;
.e75b  20 64 e7   jsr $e764        Excute_cmd     jsr   exe1              ;
.e75e  a2 ff      ldx #$ff                        ldx   #$FF              ; reset stack
.e760  9a         txs                             txs                     ;
.e761  4c d5 e6   jmp $e6d5                       jmp   Monitor           ;
.e764  6c 3c 00   jmp ($003c)      exe1           JMP   (Hexdigits)       ;
.e767  a6 3c      ldx $3c          DOT_cmd        LDX   Hexdigits         ; move address to addrptr
.e769  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e76b  86 3a      stx $3a                         STX   Addrptr           ;
.e76d  85 3b      sta $3b                         STA   Addrptr+1         ;
.e76f  e6 33      inc $33                         inc   LineCnt           ; range list command
.e771  60         rts                             RTS                     ;
.e772  c0 01      cpy #$01         CR_cmd         CPY   #$01              ;
.e774  d0 0c      bne $e782                       BNE   SP_cmd            ;
.e776  a5 3a      lda $3a                         LDA   Addrptr           ; CR alone - move addrptr to hexdigits
.e778  09 0f      ora #$0f                        ORA   #$0F              ;  to simulate entering an address
.e77a  85 3c      sta $3c                         STA   Hexdigits         ; *** change 07 to 0f for 16 byte/line
.e77c  a5 3b      lda $3b                         LDA   Addrptr+1         ;
.e77e  85 3d      sta $3d                         STA   Hexdigits+1       ;
.e780  80 17      bra $e799                       BRA   SP_cmd2           ;
.e782  a5 35      lda $35          SP_cmd         LDA   Hexdigcnt         ; Space command entry
.e784  f0 5a      beq $e7e0                       BEQ   SP_cmd5           ; any digits to process? no - done
.e786  a6 37      ldx $37                         LDX   Memchr            ; yes - is sec cmd code 0 ? yes - 
.e788  f0 0a      beq $e794                       BEQ   SP_cmd1           ; yes - 
.e78a  ca         dex                             DEX                     ; Is sec cmd = 1?       
.e78b  f0 1c      beq $e7a9                       BEQ   SP_cmd3           ;       yes - is sec cmd code 1 ?
.e78d  a5 3c      lda $3c                         LDA   Hexdigits         ;             no - ":" cmd processed
.e78f  92 3a      sta ($3a)                       STA   (Addrptr)         ;
.e791  4c fc e7   jmp $e7fc                       JMP   Inc_addrptr       ; set to next address and return
.e794  20 67 e7   jsr $e767        SP_cmd1        JSR   DOT_cmd           ; sec dig = 0  move address to addrptr
.e797  80 10      bra $e7a9                       BRA   SP_cmd3           ;
.e799  a5 3a      lda $3a          SP_cmd2        LDA   Addrptr           ; CR cmd entry 
.e79b  89 0f      bit #$0f                        BIT   #$0F              ; *** changed 07 to 0F for 16 bytes/line
.e79d  f0 0a      beq $e7a9                       BEQ   SP_cmd3           ; if 16, print new line
.e79f  c0 00      cpy #$00                        cpy   #$00              ; if TXT cmd, don"t print the - or spaces between chrs
.e7a1  f0 46      beq $e7e9                       beq   TXT_cmd1          ;
.e7a3  89 07      bit #$07                        BIT   #$07              ; if 8, print -
.e7a5  f0 11      beq $e7b8                       BEQ   SP_cmd33          ;
.e7a7  80 19      bra $e7c2                       BRA   SP_cmd4           ; else print next byte
.e7a9  20 e6 e5   jsr $e5e6        SP_cmd3        JSR   Print_CR          ; "." cmd - display address and data 
.e7ac  20 8f e6   jsr $e68f                       jsr   Scan_Input        ; see if brk requested
.e7af  b0 2d      bcs $e7de                       bcs   SP_brk            ; if so, stop 
.e7b1  a5 3b      lda $3b                         LDA   Addrptr+1         ; print address
.e7b3  a6 3a      ldx $3a                         LDX   Addrptr           ;
.e7b5  20 f3 e5   jsr $e5f3                       JSR   Print2Byte        ;
.e7b8  a9 20      lda #$20         SP_cmd33       LDA   #$20              ; " " print 1 - 16 bytes of data
.e7ba  20 92 e6   jsr $e692                       JSR   OUTPUT            ;
.e7bd  a9 2d      lda #$2d                        LDA   #$2D              ; "-"
.e7bf  20 92 e6   jsr $e692                       JSR   OUTPUT            ;
.e7c2  a9 20      lda #$20         SP_cmd4        LDA   #$20              ; " " 
.e7c4  20 92 e6   jsr $e692                       JSR   OUTPUT            ;
.e7c7  c0 00      cpy #$00                        cpy   #$00              ;
.e7c9  f0 1e      beq $e7e9                       beq   TXT_Cmd1          ;
.e7cb  b2 3a      lda ($3a)                       LDA   (Addrptr)         ;
.e7cd  20 f7 e5   jsr $e5f7                       JSR   Print1Byte        ;
.e7d0  38         sec              SP_cmd44       SEC                     ;  checks if range done
.e7d1  a5 3a      lda $3a                         LDA   Addrptr           ;
.e7d3  e5 3c      sbc $3c                         SBC   Hexdigits         ;
.e7d5  a5 3b      lda $3b                         LDA   Addrptr+1         ;
.e7d7  e5 3d      sbc $3d                         SBC   Hexdigits+1       ;
.e7d9  20 fc e7   jsr $e7fc                       jsr   Inc_addrptr       ;
.e7dc  90 bb      bcc $e799                       BCC   SP_cmd2           ; loop until range done
.e7de  64 37      stz $37          SP_brk         STZ   Memchr            ; reset sec cmd code
.e7e0  60         rts              SP_cmd5        RTS                     ; done or no digits to process
.e7e1  5a         phy              TXT_Cmd        PHY                     ;
.e7e2  a0 00      ldy #$00                        ldy   #$00              ;
.e7e4  20 82 e7   jsr $e782                       jsr   SP_cmd            ;
.e7e7  7a         ply                             PLY                     ;
.e7e8  60         rts                             RTS                     ;
.e7e9  b2 3a      lda ($3a)        TXT_cmd1       LDA   (Addrptr)         ;
.e7eb  29 7f      and #$7f                        AND   #$7F              ;
.e7ed  c9 7f      cmp #$7f                        CMP   #$7F              ;
.e7ef  f0 04      beq $e7f5                       BEQ   TXT_Cmd2          ;
.e7f1  c9 20      cmp #$20                        CMP   #$20              ; " "
.e7f3  b0 02      bcs $e7f7                       BCS   TXT_Cmd3          ;
.e7f5  a9 2e      lda #$2e         TXT_Cmd2       LDA   #$2E              ; "." use "." if not printable char
.e7f7  20 92 e6   jsr $e692        TXT_Cmd3       JSR   OUTPUT            ;
.e7fa  80 d4      bra $e7d0                       BRA   SP_cmd44          ;
.e7fc  e6 3a      inc $3a          Inc_addrptr    INC   Addrptr           ;  increments addrptr
.e7fe  d0 02      bne $e802                       BNE   Inc_addr1         ;
.e800  e6 3b      inc $3b                         INC   Addrptr+1         ;
.e802  60         rts              Inc_addr1      RTS                     ;
.e803  a5 33      lda $33          Insert_cmd     lda   Linecnt           ;  "I" cmd code
.e805  f0 3e      beq $e845                       beq   Insert_3          ; abort if no . cmd entered
.e807  38         sec                             sec                     ;
.e808  a5 3c      lda $3c                         lda   Hexdigits         ;
.e80a  e5 3a      sbc $3a                         sbc   addrptr           ;
.e80c  aa         tax                             tax                     ;
.e80d  a5 3d      lda $3d                         lda   Hexdigits+1       ;
.e80f  e5 3b      sbc $3b                         sbc   addrptr+1         ;
.e811  a8         tay                             tay                     ;
.e812  90 31      bcc $e845                       bcc   Insert_3          ;
.e814  18         clc                             clc                     ;
.e815  8a         txa                             txa                     ;
.e816  65 3e      adc $3e                         adc   memptr            ;
.e818  85 3c      sta $3c                         sta   hexdigits         ;
.e81a  98         tya                             tya                     ;
.e81b  65 3f      adc $3f                         adc   memptr+1          ;
.e81d  85 3d      sta $3d                         sta   hexdigits+1       ;
.e81f  b2 3e      lda ($3e)        Insert_0       LDA   (memptr)          ;
.e821  92 3c      sta ($3c)                       STA   (Hexdigits)       ;
.e823  a9 ff      lda #$ff                        lda   #$FF              ;
.e825  c6 3c      dec $3c                         DEC   Hexdigits         ;  
.e827  c5 3c      cmp $3c                         cmp   Hexdigits         ;  
.e829  d0 02      bne $e82d                       BNE   Insert_1          ;
.e82b  c6 3d      dec $3d                         DEC   Hexdigits+1       ;
.e82d  c6 3e      dec $3e          Insert_1       dec   Memptr            ;  
.e82f  c5 3e      cmp $3e                         cmp   Memptr            ;
.e831  d0 02      bne $e835                       bne   Insert_2          ;
.e833  c6 3f      dec $3f                         dec   Memptr+1          ;
.e835  38         sec              Insert_2       SEC                     ;  
.e836  a5 3e      lda $3e                         LDA   memptr            ;
.e838  e5 3a      sbc $3a                         SBC   Addrptr           ;
.e83a  a5 3f      lda $3f                         LDA   memptr+1          ;
.e83c  e5 3b      sbc $3b                         SBC   Addrptr+1         ;
.e83e  90 05      bcc $e845                       bcc   Insert_3          ;
.e840  20 8f e6   jsr $e68f                       jsr   Scan_Input        ; see if brk requested
.e843  90 da      bcc $e81f                       bcc   Insert_0          ; if so, stop List
.e845  60         rts              Insert_3       RTS                     ;
.e846  a5 33      lda $33          Move_cmd       lda   Linecnt           ; *** any changes to this routine affect EEPROM_WR too!!!
.e848  d0 0d      bne $e857                       bne   Move_cmd3         ; abort if no . cmd was used
.e84a  60         rts              Move_brk       RTS                     ;
.e84b  e6 3a      inc $3a          Move_cmd1      INC   Addrptr           ;  increments addrptr
.e84d  d0 02      bne $e851                       BNE   Move_cmd2         ;
.e84f  e6 3b      inc $3b                         INC   Addrptr+1         ;
.e851  e6 3c      inc $3c          Move_cmd2      inc   Hexdigits         ;  "M" cmd code
.e853  d0 02      bne $e857                       bne   Move_cmd3         ;
.e855  e6 3d      inc $3d                         inc   Hexdigits+1       ;
.e857  38         sec              Move_cmd3      SEC                     ;  checks if range done
.e858  a5 3e      lda $3e                         LDA   Memptr            ;
.e85a  e5 3a      sbc $3a                         SBC   Addrptr           ;
.e85c  a5 3f      lda $3f                         LDA   Memptr+1          ;
.e85e  e5 3b      sbc $3b                         SBC   Addrptr+1         ;
.e860  90 e8      bcc $e84a                       BCC   Move_brk          ;  exit if range done
.e862  20 8f e6   jsr $e68f                       jsr   Scan_Input        ; see if brk requested
.e865  b0 e3      bcs $e84a                       bcs   Move_brk          ; 
.e867  b2 3a      lda ($3a)                       LDA   (Addrptr)         ;  Moves one byte
.e869  92 3c      sta ($3c)                       STA   (Hexdigits)       ;
.e86b  80 de      bra $e84b                       BRA   Move_cmd1         ; (zapped after move from eeprom_wr)
.e86d  b2 3a      lda ($3a)        EEPROM_TEST    lda   (Addrptr)         ;    moved along with Move_cmd for EEPROM_WR
.e86f  52 3c      eor ($3c)                       eor   (Hexdigits)       ;    ""
.e871  30 fa      bmi $e86d                       bmi   EEPROM_TEST       ;    ""
.e873  80 d6      bra $e84b                       bra   Move_cmd1         ;    ""
.e875  a5 3a      lda $3a          EEPROM_WR      lda   Addrptr           ;  move the Move_cmd sub to $0280 (kybrd buffer)
.e877  48         pha                             pha                     ;  adding EEPROM test routine 
.e878  a5 3b      lda $3b                         lda   Addrptr+1         ;  then run the burn program from RAM
.e87a  48         pha                             pha                     ;  
.e87b  a9 46      lda #$46                        lda   #<Move_cmd        ;
.e87d  85 3a      sta $3a                         sta   Addrptr           ;
.e87f  a9 e8      lda #$e8                        lda   #>Move_cmd        ;
.e881  85 3b      sta $3b                         sta   Addrptr+1         ;
.e883  a0 2e      ldy #$2e                        ldy   #$2E              ;  47 instructions
.e885  b1 3a      lda ($3a),y      EEPROM_WR1     lda   (Addrptr),y       ;
.e887  99 80 02   sta $0280,y                     sta   $0280,y           ;
.e88a  88         dey                             dey                     ;
.e88b  10 f8      bpl $e885                       bpl   EEPROM_WR1        ;
.e88d  a9 ea      lda #$ea                        lda   #$EA              ; NOP instruction
.e88f  8d a5 02   sta $02a5                       sta   $02A5             ; *
.e892  8d a6 02   sta $02a6                       sta   $02A6             ; * affected by changes to Move_cmd routine
.e895  8d 9c 02   sta $029c                       sta   $029C             ; * affected by changes to Move_cmd routine
.e898  8d 9d 02   sta $029d                       sta   $029D             ; * affected by changes to Move_cmd routine
.e89b  8d 9e 02   sta $029e                       sta   $029E             ; * affected by changes to Move_cmd routine
.e89e  8d 9f 02   sta $029f                       sta   $029F             ; * affected by changes to Move_cmd routine
.e8a1  8d a0 02   sta $02a0                       sta   $02A0             ; * affected by changes to Move_cmd routine
.e8a4  68         pla                             pla                     ;
.e8a5  85 3b      sta $3b                         sta   Addrptr+1         ;
.e8a7  68         pla                             pla                     ;
.e8a8  85 3a      sta $3a                         sta   Addrptr           ;        
.e8aa  4c 80 02   jmp $0280                       jmp   $0280             ;
.e8ad  a6 3c      ldx $3c          Dest_cmd       LDX   Hexdigits         ;  ">" cmd code
.e8af  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e8b1  86 3e      stx $3e                         STX   Memptr            ;  move address to memptr
.e8b3  85 3f      sta $3f                         STA   Memptr+1          ;
.e8b5  60         rts                             RTS                     ;  
.e8b6  a5 33      lda $33          LIST_cmd       lda   LineCnt           ;  Check for normal/range
.e8b8  f0 29      beq $e8e3                       beq   List_cmd_1        ;  0 = normal  1=range 
.e8ba  a5 3a      lda $3a                         LDA   Addrptr           ;  Dissassemble range of code
.e8bc  a6 3b      ldx $3b                         LDX   Addrptr+1         ;  move addrptr to startaddr
.e8be  85 38      sta $38                         STA   Startaddr         ;
.e8c0  86 39      stx $39                         STX   Startaddr+1       ;
.e8c2  38         sec              List_range     sec                     ;
.e8c3  a5 38      lda $38                         lda   Startaddr         ;
.e8c5  e5 3a      sbc $3a                         sbc   Addrptr           ;
.e8c7  a5 39      lda $39                         lda   Startaddr+1       ; 
.e8c9  e5 3b      sbc $3b                         sbc   Addrptr+1         ;
.e8cb  90 15      bcc $e8e2                       bcc   List_done         ;
.e8cd  20 fb e8   jsr $e8fb                       jsr   List_Line         ;  list one line
.e8d0  20 8f e6   jsr $e68f                       jsr   Scan_Input        ; see if brk requested
.e8d3  b0 0d      bcs $e8e2                       bcs   List_done         ; if so, stop List
.e8d5  38         sec                             SEC                     ;  checks if range done
.e8d6  a5 3c      lda $3c                         LDA   Hexdigits         ;
.e8d8  e5 38      sbc $38                         SBC   Startaddr         ;
.e8da  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e8dc  e5 39      sbc $39                         SBC   Startaddr+1       ;
.e8de  b0 e2      bcs $e8c2                       BCS   List_range        ;  if not, loop until done
.e8e0  64 33      stz $33                         stz   LineCnt           ;
.e8e2  60         rts              List_done      RTS                     ;
.e8e3  a5 35      lda $35          List_cmd_1     LDA   Hexdigcnt         ; Dissassemble one page of cmds
.e8e5  f0 08      beq $e8ef                       BEQ   List1             ; followed with more pages 
.e8e7  a6 3c      ldx $3c                         LDX   Hexdigits         ;
.e8e9  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.e8eb  86 38      stx $38                         STX   Startaddr         ;
.e8ed  85 39      sta $39                         STA   Startaddr+1       ;
.e8ef  a9 14      lda #$14         List1          LDA   #$14              ; one page of dissassembly
.e8f1  85 33      sta $33                         STA   Linecnt           ;
.e8f3  20 fb e8   jsr $e8fb        List2          JSR   List_line         ;
.e8f6  c6 33      dec $33                         DEC   Linecnt           ;
.e8f8  d0 f9      bne $e8f3                       BNE   List2             ;
.e8fa  60         rts                             RTS                     ;
.e8fb  20 e6 e5   jsr $e5e6        List_line      JSR   Print_CR          ; 
.e8fe  20 0d e9   jsr $e90d                       JSR   List_one          ; one line of dissassembly
.e901  18         clc                             CLC                     ;
.e902  a5 38      lda $38                         LDA   Startaddr         ; inc address pointer to next cmd
.e904  65 35      adc $35                         ADC   Hexdigcnt         ;
.e906  85 38      sta $38                         STA   Startaddr         ;
.e908  90 02      bcc $e90c                       BCC   List3             ;
.e90a  e6 39      inc $39                         INC   Startaddr+1       ;
.e90c  60         rts              List3          RTS                     ;
.e90d  b2 38      lda ($38)        List_one       LDA   (Startaddr)       ; Dissassemble one CMD from Startaddr
.e90f  aa         tax                             TAX                     ; Initialize List Cmd pointers
.e910  bd e7 ed   lda $ede7,x                     LDA   OPCtxtidx,X       ;
.e913  85 36      sta $36                         STA   OPCtxtptr         ;
.e915  bd e7 ee   lda $eee7,x                     LDA   OPCaddmode,X      ;
.e918  29 0f      and #$0f                        AND   #$0F              ; mask out psuedo-modes
.e91a  85 34      sta $34                         STA   Modejmp           ;
.e91c  aa         tax                             TAX                     ;
.e91d  bd e7 ef   lda $efe7,x                     LDA   ModeByteCnt,X     ;
.e920  85 35      sta $35                         STA   Hexdigcnt         ;
.e922  a5 39      lda $39                         LDA   Startaddr+1       ;
.e924  a6 38      ldx $38                         LDX   Startaddr         ;
.e926  20 f3 e5   jsr $e5f3                       JSR   Print2Byte        ; print address 
.e929  a9 2d      lda #$2d                        LDA   #$2D              ;  "-"
.e92b  20 92 e6   jsr $e692                       JSR   OUTPUT            ;
.e92e  20 14 e6   jsr $e614                       JSR   Print2SP          ; print "  "
.e931  a2 01      ldx #$01                        LDX   #$01              ;---------
.e933  a0 00      ldy #$00         List4          LDY   #$00              ;print up to 3 ascii chars...
.e935  c4 35      cpy $35          List5          CPY   Hexdigcnt         ;  two spaces...
.e937  b0 0b      bcs $e944                       BCS   List6             ;  up to three hex chars...
.e939  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;  two spaces
.e93b  e0 00      cpx #$00                        CPX   #$00              ;
.e93d  d0 0e      bne $e94d                       BNE   List8             ;
.e93f  20 f7 e5   jsr $e5f7                       JSR   Print1Byte        ;
.e942  80 07      bra $e94b                       BRA   List7             ;
.e944  e0 00      cpx #$00         List6          CPX   #$00              ;
.e946  d0 03      bne $e94b                       BNE   List7             ;
.e948  20 14 e6   jsr $e614                       JSR   Print2SP          ;
.e94b  a9 20      lda #$20         List7          LDA   #$20              ; " "
.e94d  29 7f      and #$7f         List8          AND   #$7F              ;
.e94f  c9 7f      cmp #$7f                        CMP   #$7F              ;
.e951  f0 04      beq $e957                       BEQ   List9             ;
.e953  c9 20      cmp #$20                        CMP   #$20              ; " "
.e955  b0 02      bcs $e959                       BCS   List10            ;
.e957  a9 2e      lda #$2e         List9          LDA   #$2E              ; "." use "." if not printable char
.e959  20 92 e6   jsr $e692        List10         JSR   OUTPUT            ;
.e95c  c8         iny                             INY                     ;
.e95d  c0 03      cpy #$03                        CPY   #$03              ;
.e95f  90 d4      bcc $e935                       BCC   List5             ;
.e961  20 14 e6   jsr $e614                       JSR   Print2SP          ;
.e964  ca         dex                             DEX                     ;
.e965  f0 cc      beq $e933                       BEQ   List4             ;---------
.e967  a5 36      lda $36                         LDA   OPCtxtptr         ; get opcode text
.e969  0a         asl                             ASL                     ;
.e96a  65 36      adc $36                         ADC   OPCtxtptr         ;
.e96c  aa         tax                             TAX                     ;
.e96d  a0 fd      ldy #$fd                        LDY   #$FD              ;
.e96f  bd 27 f0   lda $f027,x      List11         LDA   OPCtxtData,X      ;
.e972  20 92 e6   jsr $e692                       JSR   OUTPUT            ; print opcode text
.e975  e8         inx                             INX                     ;
.e976  c8         iny                             INY                     ;
.e977  d0 f6      bne $e96f                       BNE   List11            ;
.e979  a5 36      lda $36                         LDA   OPCtxtptr         ;
.e97b  c9 42      cmp #$42                        CMP   #$42              ; 4chr opcodes start
.e97d  30 19      bmi $e998                       BMI   List12		   ;
.e97f  c9 46      cmp #$46                        CMP   #$46              ; the .xx cmds
.e981  10 15      bpl $e998                       BPL   List12            ; 
.e983  b2 38      lda ($38)                       lda   (startaddr)	   ; get opcode of 4byte code
.e985  4a         lsr                             lsr
.e986  4a         lsr                             lsr
.e987  4a         lsr                             lsr
.e988  4a         lsr                             lsr
.e989  29 07      and #$07                        AND   #$07              ; strip last 3 bits
.e98b  09 30      ora #$30                        ora   #$30              ; add CHR '0'
.e98d  20 92 e6   jsr $e692                       jsr   Output            ; print it
.e990  a9 20      lda #$20                        lda   #$20              ; " "
.e992  20 92 e6   jsr $e692                       jsr   Output            ; 
.e995  4c 9b e9   jmp $e99b                       jmp   List13            ;
.e998  20 14 e6   jsr $e614        List12         JSR   Print2SP          ;
.e99b  a5 34      lda $34          List13         LDA   Modejmp           ; setup to print operand
.e99d  0a         asl                             ASL                     ;
.e99e  aa         tax                             TAX                     ;
.e99f  7c f7 ef   jmp ($eff7,x)                   JMP   (ModeJmpTbl,X)    ; goto operand printing command
.e9a2  a9 23      lda #$23         IMM_mode       LDA   #$23              ; print #$HH
.e9a4  20 92 e6   jsr $e692                       JSR   output            ;
.e9a7  a9 24      lda #$24         ZP_mode        LDA   #$24              ; print $HH
.e9a9  20 92 e6   jsr $e692                       JSR   output            ;
.e9ac  a0 01      ldy #$01                        LDY   #$01              ;
.e9ae  b1 38      lda ($38),y      Byte_mode      LDA   (Startaddr),Y     ;
.e9b0  4c f7 e5   jmp $e5f7                       JMP   Print1Byte        ;
.e9b3  20 a7 e9   jsr $e9a7        ZP_X_mode      JSR   ZP_mode           ; print $HH,X
.e9b6  a9 2c      lda #$2c         X_mode         LDA   #$2C              ; print ,X
.e9b8  20 92 e6   jsr $e692                       JSR   output            ;
.e9bb  a9 58      lda #$58                        LDA   #$58              ; 
.e9bd  4c 92 e6   jmp $e692                       JMP   output            ;
.e9c0  20 a7 e9   jsr $e9a7        ZP_Y_mode      JSR   ZP_mode           ; print $HH,Y
.e9c3  a9 2c      lda #$2c         Y_mode         LDA   #$2C              ; Print ,Y
.e9c5  20 92 e6   jsr $e692                       JSR   output            ;
.e9c8  a9 59      lda #$59                        LDA   #$59              ; 
.e9ca  4c 92 e6   jmp $e692                       JMP   output            ;
.e9cd  20 13 ea   jsr $ea13        INDZP_mode     JSR   IND0_mode         ; Print ($HH)
.e9d0  20 a7 e9   jsr $e9a7                       JSR   ZP_mode           ;
.e9d3  a9 29      lda #$29         IND1_mode      LDA   #$29              ; Print )
.e9d5  4c 92 e6   jmp $e692                       JMP   output            ;
.e9d8  20 13 ea   jsr $ea13        INDZP_X_mode   JSR   IND0_mode         ; Print ($HH,X)
.e9db  20 a7 e9   jsr $e9a7                       JSR   ZP_mode           ;
.e9de  20 b6 e9   jsr $e9b6                       JSR   X_mode            ;
.e9e1  80 f0      bra $e9d3                       BRA   IND1_mode         ;
.e9e3  20 cd e9   jsr $e9cd        INDZP_Y_mode   JSR   INDZP_mode        ; Print ($HH),Y
.e9e6  80 db      bra $e9c3                       BRA   Y_mode            ;
.e9e8  a9 24      lda #$24         ABS_mode       LDA   #$24              ; Print $HHHH
.e9ea  20 92 e6   jsr $e692                       JSR   output            ;
.e9ed  a0 02      ldy #$02                        LDY   #$02              ;
.e9ef  20 ae e9   jsr $e9ae                       JSR   Byte_mode         ;
.e9f2  88         dey                             DEY                     ;
.e9f3  80 b9      bra $e9ae                       BRA   Byte_mode         ;
.e9f5  20 e8 e9   jsr $e9e8        ABS_X_mode     JSR   ABS_mode          ; Print $HHHH,X
.e9f8  80 bc      bra $e9b6                       BRA   X_mode            ;
.e9fa  20 e8 e9   jsr $e9e8        ABS_Y_mode     JSR   ABS_mode          ; Print $HHHH,Y
.e9fd  80 c4      bra $e9c3                       BRA   Y_mode            ;
.e9ff  20 13 ea   jsr $ea13        INDABS_mode    JSR   IND0_mode         ; Print ($HHHH)
.ea02  20 e8 e9   jsr $e9e8                       JSR   ABS_mode          ;
.ea05  80 cc      bra $e9d3                       BRA   IND1_mode         ;
.ea07  20 13 ea   jsr $ea13        INDABSX_mode   JSR   IND0_mode         ; Print ($HHHH,X)
.ea0a  20 e8 e9   jsr $e9e8                       JSR   ABS_mode          ;
.ea0d  20 b6 e9   jsr $e9b6                       JSR   X_mode            ;
.ea10  80 c1      bra $e9d3                       BRA   IND1_mode         ;
.ea12  60         rts              IMPLIED_mode   RTS                     ; Implied/Accumulator mode 
.ea13  a9 28      lda #$28         IND0_mode      LDA   #$28              ; Print (
.ea15  4c 92 e6   jmp $e692                       JMP   output            ;
.ea18  20 a7 e9   jsr $e9a7        BBREL_mode     JSR   ZP_mode		   ;
.ea1b  a9 2c      lda #$2c         		   LDA   #$2C              ; Print ,
.ea1d  20 92 e6   jsr $e692                       JSR   output            ;
.ea20  a9 24      lda #$24                        LDA   #$24              ; Print $
.ea22  20 92 e6   jsr $e692                       JSR   output            ;
.ea25  a0 02      ldy #$02                        LDY   #$02		   ;
.ea27  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;
.ea29  85 37      sta $37                         STA   Memchr            ;
.ea2b  18         clc                             CLC                     ;
.ea2c  a5 38      lda $38                         LDA   Startaddr         ;
.ea2e  69 03      adc #$03                        ADC   #$03              ;
.ea30  4c 43 ea   jmp $ea43                       JMP   REL_mode0         ;
.ea33  a9 24      lda #$24         REL_mode       LDA   #$24              ; Print $HHHH as Relative Branch
.ea35  20 92 e6   jsr $e692                       JSR   output            ;
.ea38  a0 01      ldy #$01                        LDY   #$01              ;
.ea3a  b1 38      lda ($38),y                     LDA   (Startaddr),Y     ;
.ea3c  85 37      sta $37                         STA   Memchr            ;
.ea3e  18         clc                             CLC                     ;
.ea3f  a5 38      lda $38                         LDA   Startaddr         ;
.ea41  69 02      adc #$02                        ADC   #$02              ;
.ea43  aa         tax              REL_mode0      TAX                     ;
.ea44  a5 39      lda $39                         LDA   Startaddr+1       ;
.ea46  69 00      adc #$00                        ADC   #$00              ;
.ea48  a8         tay                             TAY                     ;
.ea49  18         clc                             CLC                     ;
.ea4a  8a         txa                             TXA                     ;
.ea4b  65 37      adc $37                         ADC   Memchr            ;
.ea4d  aa         tax                             TAX                     ;
.ea4e  98         tya                             TYA                     ;
.ea4f  a4 37      ldy $37                         LDY   Memchr            ;
.ea51  10 01      bpl $ea54                       BPL   Rel_mode1         ;
.ea53  3a         dec                             DEC                     ;
.ea54  69 00      adc #$00         Rel_mode1      ADC   #$00              ;
.ea56  4c f3 e5   jmp $e5f3                       JMP   Print2Byte        ;
.ea59  ba         tsx              Assem_Init     tsx                     ;
.ea5a  e8         inx                             inx                     ;
.ea5b  e8         inx                             inx                     ;
.ea5c  e8         inx                             inx                     ;
.ea5d  e8         inx                             inx                     ;
.ea5e  9e 00 01   stz $0100,x                     stz   $0100,x           ;
.ea61  20 4a e7   jsr $e74a                       jsr   version           ;  show version and ? prompt
.ea64  4c 87 ea   jmp $ea87                       jmp   Assembler         ;
.ea67  a9 31      lda #$31         Asm_Help       lda   #<AsmHelptxt      ;  lower byte - Menu of Commands
.ea69  85 3a      sta $3a                         sta   addrptr           ;
.ea6b  a9 f5      lda #$f5                        lda   #>AsmHelptxt      ;  upper byte
.ea6d  85 3b      sta $3b                         sta   addrptr+1         ;
.ea6f  80 0f      bra $ea80                       bra   AsmHelp3          ;
.ea71  c9 7e      cmp #$7e         ASmHelp4       cmp   #$7e              ;  "~"
.ea73  f0 05      beq $ea7a                       beq   AsmHelp1          ;
.ea75  20 92 e6   jsr $e692                       jsr   Output            ;
.ea78  80 03      bra $ea7d                       bra   AsmHelp2          ;
.ea7a  20 e6 e5   jsr $e5e6        AsmHelp1       jsr   Print_CR          ;     
.ea7d  20 fc e7   jsr $e7fc        AsmHelp2       jsr   Inc_addrptr       ;
.ea80  b2 3a      lda ($3a)        AsmHelp3       lda   (addrptr)         ;
.ea82  d0 ed      bne $ea71                       bne   AsmHelp4          ;
.ea84  20 55 ed   jsr $ed55                       jsr   Opcode_List       ;  
.ea87  a2 ff      ldx #$ff         Assembler      LDX   #$FF              ;
.ea89  9a         txs                             TXS                     ; init stack
.ea8a  64 35      stz $35                         stz   HexDigCnt         ;
.ea8c  20 1c e6   jsr $e61c                       jsr   Input_assem       ;
.ea8f  a0 00      ldy #$00                        ldy   #$00              ; beginning of input line
.ea91  ad 00 03   lda $0300                       lda   buffer            ;
.ea94  c9 0d      cmp #$0d                        cmp   #$0d              ; Enter = done 
.ea96  d0 03      bne $ea9b                       bne   Asm01             ;
.ea98  4c d5 e6   jmp $e6d5                       JMP   Monitor           ; exit assembler
.ea9b  c9 3f      cmp #$3f         Asm01          cmp   #$3f              ; "?" Print Help
.ea9d  f0 c8      beq $ea67                       beq   Asm_Help          ;
.ea9f  c9 20      cmp #$20                        cmp   #$20              ; space
.eaa1  f0 3b      beq $eade                       beq   Asm_opfetch       ;
.eaa3  c9 3b      cmp #$3b                        cmp   #$3b              ;  ";" ignore line
.eaa5  f0 e0      beq $ea87                       beq   Assembler         ;
.eaa7  c9 4c      cmp #$4c                        cmp   #$4C              ;  "L" list
.eaa9  f0 2c      beq $ead7                       beq   Asm_List          ;
.eaab  c9 24      cmp #$24                        cmp   #$24              ;  "$" ignore this
.eaad  d0 01      bne $eab0                       bne   Asm02             ;
.eaaf  c8         iny                             iny                     ;
.eab0  64 3c      stz $3c          Asm02          STZ   Hexdigits         ;  holds parsed hex
.eab2  64 3d      stz $3d                         STZ   Hexdigits+1       ;
.eab4  20 0b e7   jsr $e70b                       JSR   ParseHexDig       ;  get Hex Chars 
.eab7  a6 35      ldx $35                         LDX   Hexdigcnt         ;
.eab9  f0 08      beq $eac3                       Beq   Asm_Err           ;
.eabb  c9 4c      cmp #$4c                        cmp   #$4C              ; "L" do list               ???
.eabd  f0 1a      beq $ead9                       Beq   Asm_List1         ;
.eabf  c9 20      cmp #$20                        cmp   #$20              ; Space
.eac1  f0 1b      beq $eade                       Beq   Asm_opfetch       ;
.eac3  98         tya              Asm_Err        tya                     ;  get line pointer
.eac4  aa         tax                             tax                     ;
.eac5  a9 0a      lda #$0a                        lda   #$0a              ; LF move down one line
.eac7  20 92 e6   jsr $e692                       jsr   output            ;
.eaca  20 0f e6   jsr $e60f                       jsr   PrintXSP          ; move to where error occured
.eacd  a9 5e      lda #$5e                        lda   #$5E              ; "^"                       ???
.eacf  20 92 e6   jsr $e692                       jsr   Output            ; mark it 
.ead2  20 95 e6   jsr $e695                       jsr   bell              ; 
.ead5  80 b0      bra $ea87                       bra   Assembler         ;
.ead7  64 35      stz $35          Asm_list       stz   HexDigcnt         ;
.ead9  20 e3 e8   jsr $e8e3        Asm_List1      jsr   List_Cmd_1        ;
.eadc  80 a9      bra $ea87        Asm_hop        bra   Assembler         ;
.eade  a5 35      lda $35          Asm_opfetch    lda   HexDigCnt         ;
.eae0  f0 0a      beq $eaec                       beq   Asm_op01          ; no address change
.eae2  a6 3c      ldx $3c                         LDX   Hexdigits         ;
.eae4  a5 3d      lda $3d                         LDA   Hexdigits+1       ;
.eae6  86 3a      stx $3a                         STX   AddrPtr           ;
.eae8  85 3b      sta $3b                         STA   AddrPtr+1         ;
.eaea  88         dey                             dey                     ;
.eaeb  c8         iny              Asm_stripSP    iny                     ;
.eaec  b9 00 03   lda $0300,y      Asm_op01       lda   buffer,y          ;
.eaef  c9 20      cmp #$20                        cmp   #$20              ; strip spaces
.eaf1  f0 f8      beq $eaeb                       beq   Asm_stripSP       ;
.eaf3  c9 0d      cmp #$0d                        cmp   #$0d              ; done
.eaf5  f0 e5      beq $eadc                       beq   Asm_hop           ;
.eaf7  c9 3b      cmp #$3b                        cmp   #$3b              ; ";" comment char done
.eaf9  f0 e1      beq $eadc                       beq   Asm_hop           ;
.eafb  a2 00      ldx #$00                        ldx   #$00              ;
.eafd  86 36      stx $36                         stx   OpcTxtPtr         ;
.eaff  84 33      sty $33                         sty   LineCnt           ;
.eb01  a4 33      ldy $33          Asm_opclp      ldy   LineCnt           ;
.eb03  a5 36      lda $36                         lda   OpcTxtPtr         ;
.eb05  0a         asl                             ASL                     ;
.eb06  65 36      adc $36                         adc   OpcTxtPtr         ;
.eb08  aa         tax                             tax                     ;
.eb09  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.eb0c  c8         iny                             iny                     ;
.eb0d  dd 27 f0   cmp $f027,x                     cmp   OpcTxtData,x      ;
.eb10  d0 14      bne $eb26                       bne   Asm_getnext       ;
.eb12  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.eb15  e8         inx                             inx                     ;
.eb16  c8         iny                             iny                     ;
.eb17  dd 27 f0   cmp $f027,x                     cmp   OpcTxtData,x      ;
.eb1a  d0 0a      bne $eb26                       bne   Asm_getnext       ;
.eb1c  b9 00 03   lda $0300,y                     lda   buffer,y          ;
.eb1f  e8         inx                             inx                     ;
.eb20  c8         iny                             iny                     ;
.eb21  dd 27 f0   cmp $f027,x                     cmp   OpcTxtData,x      ;
.eb24  f0 0c      beq $eb32                       beq   Asm_goodop        ;
.eb26  a6 36      ldx $36          Asm_getnext    ldx   OpcTxtPtr         ;
.eb28  e8         inx                             inx                     ;
.eb29  86 36      stx $36                         stx   OpcTxtPtr         ;
.eb2b  e0 4a      cpx #$4a                        cpx   #$4A              ; last one? then err
.eb2d  d0 d2      bne $eb01                       bne   Asm_opclp
.eb2f  4c c3 ea   jmp $eac3        Asm_err2       jmp   Asm_err
.eb32  a9 00      lda #$00         Asm_goodop     lda   #$00
.eb34  85 34      sta $34                         sta   ModeJmp           ; 
.eb36  c6 34      dec $34                         dec   ModeJmp           ; init to FF for () check
.eb38  85 3c      sta $3c                         sta   HexDigits         ; and Byte holder
.eb3a  85 3d      sta $3d                         sta   HexDigits+1       ; 
.eb3c  85 35      sta $35                         sta   HexDigCnt         ;
.eb3e  a6 36      ldx $36                         ldx   OpcTxtPtr         ;
.eb40  e0 42      cpx #$42                        cpx   #$42              ; 
.eb42  30 18      bmi $eb5c                       bmi   Asm_goodSP        ; not a 4 chr opcode
.eb44  e0 46      cpx #$46                        cpx   #$46              
.eb46  10 14      bpl $eb5c                       bpl   Asm_goodSP        ; not a 4 chr opcode
.eb48  b9 00 03   lda $0300,y                     lda   buffer,y          ; get next chr
.eb4b  c8         iny                             iny                     ; advance pointer
.eb4c  c9 38      cmp #$38                        cmp   #$38              ; 
.eb4e  10 df      bpl $eb2f                       bpl   Asm_err2          ; not chr "0"-"7"
.eb50  c9 30      cmp #$30                        cmp   #$30
.eb52  30 db      bmi $eb2f                       bmi   Asm_err2          ; not chr "0"-"7"
.eb54  0a         asl                             ASL
.eb55  0a         asl                             ASL
.eb56  0a         asl                             ASL
.eb57  0a         asl                             ASL
.eb58  85 39      sta $39                         sta   startaddr_H       ; temp holder for 4th chr opcode
.eb5a  a9 80      lda #$80                        LDA   #$80              ; flag for 
.eb5c  be 00 03   ldx $0300,y      Asm_goodSP     ldx   buffer,y          ; get next operand char
.eb5f  c8         iny                             iny                     ; point to next operand chr
.eb60  e0 20      cpx #$20                        cpx   #$20              ;  sp
.eb62  d0 24      bne $eb88                       bne   Asm_GoodSP2
.eb64  c9 80      cmp #$80                        cmp   #$80
.eb66  30 f4      bmi $eb5c                       bmi   Asm_goodSP
.eb68  a6 36      ldx $36          Asm_goodSP1    ldx   OpcTxtPtr         ; check if its a BBRx or BBSx opcode
.eb6a  e0 44      cpx #$44                        cpx   #$44              ; 
.eb6c  10 ee      bpl $eb5c                       bpl   Asm_GoodSP        ;
.eb6e  a6 35      ldx $35                         ldx   HexDigCnt         ;
.eb70  f0 ea      beq $eb5c                       beq   Asm_goodSP        ;
.eb72  c9 d0      cmp #$d0                        cmp   #$D0              ; already have zp & rel?
.eb74  10 e6      bpl $eb5c                       bpl   Asm_GoodSP        ; we don't care then
.eb76  c9 c0      cmp #$c0                        cmp   #$C0              ; already got a zp address?
.eb78  10 b5      bpl $eb2f                       bpl   Asm_Err2          ; then error
.eb7a  a6 3d      ldx $3d                         ldx   HexDigits+1
.eb7c  d0 b1      bne $eb2f                       bne   Asm_err2          ; not zero page
.eb7e  a6 3c      ldx $3c                         ldx   HexDigits
.eb80  86 38      stx $38                         stx   startaddr         ; temp zp value for BBRx & BBSx cmds 
.eb82  09 40      ora #$40                        ora   #$40              ; mark zp address fetched
.eb84  29 f7      and #$f7                        and   #$F7              ; mask out zp address found
.eb86  80 d4      bra $eb5c                       bra   Asm_goodSP        ; get next chr
.eb88  e0 0d      cpx #$0d         Asm_goodSp2    cpx   #$0d              ;  CR
.eb8a  d0 03      bne $eb8f                       bne   Asm_eol
.eb8c  4c 46 ec   jmp $ec46        Asm_jmp1       jmp   Asm_modeSrch
.eb8f  e0 3b      cpx #$3b         Asm_eol        cpx   #$3b              ;  ";"
.eb91  f0 f9      beq $eb8c                       beq   Asm_jmp1
.eb93  48         pha                             pha
.eb94  a5 36      lda $36                         lda   OpcTxtPtr
.eb96  c9 46      cmp #$46                        cmp   #$46              ; normal opcode if <=45h
.eb98  30 44      bmi $ebde                       bmi   Asm_opnd1
.eb9a  d0 19      bne $ebb5                       bne   Asm_xtra1
.eb9c  e0 24      cpx #$24                        cpx   #$24              ; $ .db pseudo-opcode
.eb9e  f0 01      beq $eba1                       beq   Asm_db1
.eba0  88         dey                             dey
.eba1  20 0b e7   jsr $e70b        Asm_db1        jsr   ParseHexDig
.eba4  fa         plx                             plx
.eba5  a6 35      ldx $35                         ldx   HexDigCnt
.eba7  f0 86      beq $eb2f                       beq   Asm_err2          ; no digits retrieved
.eba9  a0 00      ldy #$00                        ldy   #$00
.ebab  a9 01      lda #$01                        lda   #$01
.ebad  48         pha                             PHA
.ebae  a5 3c      lda $3c                         lda   HexDigits
.ebb0  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ebb2  4c e1 ec   jmp $ece1                       jmp   Asm_save
.ebb5  c9 47      cmp #$47         Asm_xtra1      cmp   #$47              ; .dw pseudo-opcode
.ebb7  d0 1e      bne $ebd7                       bne   Asm_xtra2 
.ebb9  e0 24      cpx #$24                        cpx   #$24              ; $
.ebbb  f0 01      beq $ebbe                       beq   Asm_dw1
.ebbd  88         dey                             dey
.ebbe  20 0b e7   jsr $e70b        Asm_dw1        jsr   ParseHexDig
.ebc1  fa         plx                             plx
.ebc2  a6 35      ldx $35                         ldx   HexDigCnt
.ebc4  f0 7d      beq $ec43                       beq   Asm_err1          ; no digits retrieved
.ebc6  a0 00      ldy #$00                        ldy   #$00
.ebc8  a9 02      lda #$02                        lda   #$02
.ebca  48         pha                             PHA
.ebcb  a5 3c      lda $3c                         lda   HexDigits
.ebcd  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ebcf  a5 3d      lda $3d                         lda   HexDigits+1
.ebd1  c8         iny                             iny
.ebd2  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ebd4  4c e1 ec   jmp $ece1                       jmp   Asm_save
.ebd7  c9 48      cmp #$48         Asm_xtra2      cmp   #$48              ; .ds pseudo-opcode
.ebd9  d0 68      bne $ec43                       bne   Asm_err1 
.ebdb  4c 27 ed   jmp $ed27                       jmp   Asm_txt
.ebde  68         pla              Asm_opnd1      pla
.ebdf  e0 23      cpx #$23                        cpx   #$23              ;  #    20
.ebe1  d0 05      bne $ebe8                       bne   Asm_parse01
.ebe3  09 20      ora #$20                        ora   #$20
.ebe5  4c 5c eb   jmp $eb5c                       jmp   Asm_goodSP 
.ebe8  e0 28      cpx #$28         Asm_parse01    cpx   #$28              ;  (   04
.ebea  d0 0b      bne $ebf7                       bne   Asm_parse02
.ebec  09 04      ora #$04                        ora   #$04
.ebee  a6 34      ldx $34                         ldx   modeJmp
.ebf0  10 51      bpl $ec43                       bpl   Asm_err1          ;  more than one ( 
.ebf2  e6 34      inc $34                         inc   ModeJmp
.ebf4  4c 5c eb   jmp $eb5c                       jmp   Asm_goodSP 
.ebf7  e0 29      cpx #$29         Asm_parse02    cpx   #$29              ;  )
.ebf9  d0 09      bne $ec04                       bne   Asm_parse03
.ebfb  a6 34      ldx $34                         ldx   ModeJmp
.ebfd  d0 44      bne $ec43                       bne   Asm_err1          ;  ) without (
.ebff  e6 34      inc $34                         inc   ModeJmp
.ec01  4c 5c eb   jmp $eb5c                       jmp   Asm_goodSP 
.ec04  e0 2c      cpx #$2c         Asm_parse03    cpx   #$2C              ;  ,
.ec06  d0 1e      bne $ec26                       bne   Asm_parse04
.ec08  be 00 03   ldx $0300,y                     ldx   buffer,y
.ec0b  e0 58      cpx #$58                        cpx   #$58              ;  X        02
.ec0d  d0 06      bne $ec15                       bne   Asm_parse31
.ec0f  09 02      ora #$02                        ora   #$02
.ec11  c8         iny                             iny
.ec12  4c 5c eb   jmp $eb5c                       jmp   Asm_goodSP
.ec15  e0 59      cpx #$59         Asm_parse31    cpx   #$59              ;  Y        01 
.ec17  f0 07      beq $ec20                       beq   Asm_parse32
.ec19  c9 80      cmp #$80                        cmp   #$80              ;  is BBRx or BBSx cmd active?
.ec1b  30 26      bmi $ec43                       bmi   Asm_err1          ;  , without X or Y or 4byte opcode      
.ec1d  4c 68 eb   jmp $eb68                       jmp   Asm_goodSP1       ;  save zp address
.ec20  09 01      ora #$01         Asm_parse32    ora   #$01
.ec22  c8         iny                             iny
.ec23  4c 5c eb   jmp $eb5c                       jmp   Asm_goodSP 
.ec26  e0 24      cpx #$24         Asm_parse04    cpx   #$24              ;  $
.ec28  f0 01      beq $ec2b                       beq   Asm_parse42       ;   
.ec2a  88         dey                             dey                     ; not #$(),X,Y  so try Hexdig, if not err
.ec2b  48         pha              Asm_parse42    pha
.ec2c  20 0b e7   jsr $e70b                       jsr   ParseHexDig
.ec2f  88         dey                             dey                     ; adjust input line pointer
.ec30  68         pla                             pla
.ec31  a6 35      ldx $35                         ldx   HexDigCnt
.ec33  f0 0e      beq $ec43                       beq   Asm_err1          ; no digits retrieved
.ec35  a6 3d      ldx $3d                         ldx   HexDigits+1    
.ec37  d0 05      bne $ec3e                       bne   Asm_parse41
.ec39  09 08      ora #$08                        ora   #$08              ; <256               08
.ec3b  4c 5c eb   jmp $eb5c                       jmp   Asm_goodSP
.ec3e  09 10      ora #$10         Asm_parse41    ora   #$10              ; 2 bytes            10 
.ec40  4c 5c eb   jmp $eb5c                       jmp   Asm_goodSP 
.ec43  4c c3 ea   jmp $eac3        Asm_err1       jmp   Asm_Err
.ec46  a2 0f      ldx #$0f         Asm_ModeSrch   ldx   #$0F              ; # of modes
.ec48  dd 17 f0   cmp $f017,x      Asm_ModeS1     cmp   Asm_ModeLst,x
.ec4b  f0 05      beq $ec52                       beq   Asm_ModeFnd 
.ec4d  ca         dex                             dex   
.ec4e  10 f8      bpl $ec48                       bpl   Asm_ModeS1
.ec50  80 f1      bra $ec43                       bra   Asm_Err1          ; invalid Mode
.ec52  86 37      stx $37          Asm_ModeFnd    stx   Memchr            ; save mode
.ec54  c9 80      cmp #$80                        cmp   #$80              ; is it 4 chr opcode?
.ec56  30 05      bmi $ec5d                       bmi   Asm_opcSrch       ;no
.ec58  8a         txa                             txa
.ec59  05 39      ora $39                         ora   startaddr_H       ; adjust the psuedo mode               
.ec5b  85 37      sta $37                         sta   Memchr            ; set proper mode
.ec5d  a2 00      ldx #$00         Asm_opcSrch    ldx   #$00
.ec5f  bd e7 ed   lda $ede7,x      Asm_opcSrch1   lda   OpcTxtidx,x
.ec62  c5 36      cmp $36                         cmp   OpcTxtPtr
.ec64  d0 07      bne $ec6d                       bne   Asm_srchNxt   
.ec66  bd e7 ee   lda $eee7,x                     lda   OPCaddmode,x
.ec69  c5 37      cmp $37                         cmp   Memchr
.ec6b  f0 2d      beq $ec9a                       beq   Asm_OpcFnd
.ec6d  e8         inx              Asm_srchNxt    inx
.ec6e  d0 ef      bne $ec5f                       bne   Asm_opcSrch1 
.ec70  a5 37      lda $37                         lda   Memchr            ;
.ec72  c9 02      cmp #$02                        cmp   #$02              ; ZP
.ec74  d0 06      bne $ec7c                       bne   Asm_srchAlt 
.ec76  a9 01      lda #$01                        LDA   #$01              ; ABS
.ec78  85 37      sta $37                         sta   Memchr
.ec7a  80 e1      bra $ec5d                       bra   Asm_opcSrch
.ec7c  c9 01      cmp #$01         Asm_srchAlt    cmp   #$01              ; ABS
.ec7e  d0 06      bne $ec86                       bne   Asm_srchA0
.ec80  a9 0a      lda #$0a                        LDA   #$0A              ; REL
.ec82  85 37      sta $37                         sta   Memchr
.ec84  80 d7      bra $ec5d                       bra   Asm_opcSrch
.ec86  c9 0d      cmp #$0d         Asm_srchA0     cmp   #$0d               ;  ind zp
.ec88  d0 06      bne $ec90                       bne   Asm_srchA1
.ec8a  a9 0b      lda #$0b                        LDA   #$0b              ; ind Abs
.ec8c  85 37      sta $37                         sta   Memchr
.ec8e  80 cd      bra $ec5d                       bra   Asm_opcSrch
.ec90  c9 07      cmp #$07         Asm_SrchA1     cmp   #$07              ; zp,y
.ec92  d0 af      bne $ec43                       bne   Asm_Err1          ; no more modes to try, bad mode err
.ec94  a9 09      lda #$09                        LDA   #$09              ; ABS,y
.ec96  85 37      sta $37                         sta   Memchr
.ec98  80 c3      bra $ec5d                       bra   Asm_opcSrch
.ec9a  a5 37      lda $37          Asm_OpcFnd     lda   Memchr
.ec9c  29 0f      and #$0f                        and   #$0F              ; mask out psuedo modes
.ec9e  85 37      sta $37                         sta   Memchr            ;
.eca0  c9 0e      cmp #$0e                        CMP   #$0E              ; BBR mode?
.eca2  d0 0b      bne $ecaf                       bne   Asm_opcFnd0       ;
.eca4  20 ee ec   jsr $ecee                       jsr   Asm_BRelCalc      ;
.eca7  85 3d      sta $3d                         sta   HexDigits_H       ;
.eca9  a5 38      lda $38                         lda   Startaddr         ;
.ecab  85 3c      sta $3c                         sta   Hexdigits         ;
.ecad  80 07      bra $ecb6                       bra   Asm_OpcFnd1       ;   
.ecaf  c9 0a      cmp #$0a         Asm_OpcFnd0    cmp   #$0A              ; is Rel Mode?
.ecb1  d0 03      bne $ecb6                       bne   Asm_OpcFnd1 
.ecb3  20 06 ed   jsr $ed06                       jsr   Asm_RelCalc       ; adjust rel address
.ecb6  a0 00      ldy #$00         Asm_OpcFnd1    ldy   #$00
.ecb8  8a         txa                             txa
.ecb9  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ecbb  c8         iny                             iny
.ecbc  a6 37      ldx $37                         ldx   Memchr            ; 
.ecbe  bd e7 ef   lda $efe7,x                     lda   ModeByteCnt,x
.ecc1  48         pha                             PHA                     ; Save # of bytes
.ecc2  c9 01      cmp #$01                        cmp   #$01
.ecc4  f0 10      beq $ecd6                       beq   Asm_EchoL
.ecc6  a5 3c      lda $3c                         lda   HexDigits
.ecc8  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ecca  c8         iny                             iny
.eccb  bd e7 ef   lda $efe7,x                     lda   ModeByteCnt,x
.ecce  c9 02      cmp #$02                        cmp   #$02
.ecd0  f0 04      beq $ecd6                       beq   Asm_EchoL
.ecd2  a5 3d      lda $3d                         lda   HexDigits+1
.ecd4  91 3a      sta ($3a),y                     sta   (AddrPtr),y
.ecd6  a5 3a      lda $3a          Asm_EchoL      lda   AddrPtr
.ecd8  85 38      sta $38                         sta   StartAddr
.ecda  a5 3b      lda $3b                         lda   AddrPtr+1
.ecdc  85 39      sta $39                         sta   StartAddr+1
.ecde  20 0d e9   jsr $e90d                       jsr   List_One
.ece1  18         clc              Asm_Save       clc
.ece2  68         pla                             PLA
.ece3  65 3a      adc $3a                         adc   AddrPtr
.ece5  85 3a      sta $3a                         sta   AddrPtr
.ece7  90 02      bcc $eceb                       bcc   Asm_done
.ece9  e6 3b      inc $3b                         inc   AddrPtr+1
.eceb  4c 87 ea   jmp $ea87        Asm_done       jmp   Assembler
.ecee  20 f5 ec   jsr $ecf5        Asm_BRelCalc   jsr   Asm_relsub
.ecf1  e9 03      sbc #$03                        sbc   #$03
.ecf3  80 16      bra $ed0b                       bra   Asm_RelC1
.ecf5  38         sec              Asm_RelSub     sec
.ecf6  a5 3c      lda $3c                         lda   Hexdigits
.ecf8  e5 3a      sbc $3a                         sbc   AddrPtr
.ecfa  85 3e      sta $3e                         sta   Memptr
.ecfc  a5 3d      lda $3d                         lda   Hexdigits+1
.ecfe  e5 3b      sbc $3b                         sbc   AddrPtr+1
.ed00  85 3f      sta $3f                         sta   Memptr+1
.ed02  38         sec                             sec
.ed03  a5 3e      lda $3e                         lda   Memptr
.ed05  60         rts                             rts 
.ed06  20 f5 ec   jsr $ecf5        Asm_RelCalc    jsr   Asm_relsub
.ed09  e9 02      sbc #$02                        sbc   #$02
.ed0b  85 3e      sta $3e          Asm_Relc1      sta   Memptr
.ed0d  b0 02      bcs $ed11                       bcs   Asm_relC2
.ed0f  c6 3f      dec $3f                         dec   Memptr+1
.ed11  a5 3f      lda $3f          Asm_relC2      lda   Memptr+1               
.ed13  f0 0b      beq $ed20                       beq   Asm_relC4         ; positive
.ed15  c9 ff      cmp #$ff                        cmp   #$FF              ; negative
.ed17  d0 0b      bne $ed24                       bne   Asm_txtErr
.ed19  a5 3e      lda $3e                         lda   Memptr
.ed1b  10 07      bpl $ed24                       bpl   Asm_txtErr
.ed1d  85 3c      sta $3c          Asm_relC3      sta   HexDigits
.ed1f  60         rts                             rts
.ed20  a5 3e      lda $3e          Asm_relC4      lda   Memptr
.ed22  10 f9      bpl $ed1d                       bpl   Asm_relC3
.ed24  4c c3 ea   jmp $eac3        Asm_txtErr     jmp   Asm_Err
.ed27  fa         plx              Asm_txt        plx                      ; process the .ds pseudo-opcode
.ed28  88         dey                             dey
.ed29  98         tya                             tya
.ed2a  aa         tax                             tax
.ed2b  a0 fe      ldy #$fe                        ldy   #$fe
.ed2d  c8         iny              Asm_txt1       iny
.ed2e  bd 00 03   lda $0300,x      Asm_txt2       lda   buffer,x           ; get next operand char
.ed31  e8         inx                             inx                      ; point to next operand chr
.ed32  c9 0d      cmp #$0d                        cmp   #$0d             ;  CR
.ed34  f0 1a      beq $ed50                       beq   Asm_txt9
.ed36  c9 27      cmp #$27                        cmp   #$27             ; "
.ed38  d0 06      bne $ed40                       bne   Asm_txt3
.ed3a  c0 ff      cpy #$ff                        cpy   #$ff             ; opening " found?
.ed3c  d0 12      bne $ed50                       bne   Asm_txt9         ; no, closing, so done
.ed3e  80 ed      bra $ed2d                       bra   Asm_txt1         ; yes, get first text chr
.ed40  c0 ff      cpy #$ff         Asm_txt3       cpy   #$ff             ; already found opening "?
.ed42  f0 04      beq $ed48                       beq   Asm_txt4         ; 
.ed44  91 3a      sta ($3a),y                     sta   (AddrPtr),y      ; yes, save chr
.ed46  80 e5      bra $ed2d                       bra   Asm_txt1
.ed48  c9 20      cmp #$20         Asm_txt4       cmp   #$20             ; no, if not a space, then err
.ed4a  f0 e2      beq $ed2e                       beq   Asm_txt2
.ed4c  8a         txa                             txa
.ed4d  a8         tay                             tay
.ed4e  80 d4      bra $ed24                       bra   Asm_txtErr
.ed50  98         tya              Asm_txt9       tya
.ed51  48         pha                             pha
.ed52  4c e1 ec   jmp $ece1                       jmp   Asm_save
.ed55  a0 49      ldy #$49         Opcode_List    ldy   #$49              ; Number of Opcodes (64)
.ed57  a2 00      ldx #$00                        ldx   #$00              ; pointer to characters
.ed59  8a         txa              Opcode_List1   txa                     ; 
.ed5a  29 0f      and #$0f                        and   #$0F              ; Print CR after each 16 opcodes 
.ed5c  d0 03      bne $ed61                       bne   Opcode_List2      ; not divisible by 16
.ed5e  20 e6 e5   jsr $e5e6                       jsr   Print_CR          ;
.ed61  bd 27 f0   lda $f027,x      Opcode_List2   lda   OPCtxtData,x      ; get opcode chr data
.ed64  20 92 e6   jsr $e692                       jsr   Output            ; print 1st char
.ed67  e8         inx                             inx                     ;
.ed68  bd 27 f0   lda $f027,x                     lda   OPCtxtData,x      ; 
.ed6b  20 92 e6   jsr $e692                       jsr   Output            ; print 2nd char
.ed6e  e8         inx                             inx                     ;
.ed6f  bd 27 f0   lda $f027,x                     lda   OPCtxtData,x      ;
.ed72  20 92 e6   jsr $e692                       jsr   Output            ; print 3rd char
.ed75  e8         inx                             inx                     ;
.ed76  c0 08      cpy #$08                        cpy   #$08              ; 
.ed78  10 09      bpl $ed83                       bpl   Opcode_List3      ; not 4 byte code
.ed7a  c0 04      cpy #$04                        cpy   #$04              ;
.ed7c  30 05      bmi $ed83                       bmi   Opcode_list3      ;
.ed7e  a9 78      lda #$78                        lda   #$78              ; add 'x'
.ed80  20 92 e6   jsr $e692                       jsr   output            ; for RMBx, SMBx,BBRx, & BBSx
.ed83  a9 20      lda #$20         Opcode_List3   lda   #$20              ; print space
.ed85  20 92 e6   jsr $e692                       jsr   Output            ;
.ed88  88         dey                             dey                     ;
.ed89  d0 ce      bne $ed59                       bne   Opcode_List1      ; 
.ed8b  20 e6 e5   jsr $e5e6                       jsr   Print_CR          ; one last CR-LF
.ed8e  60         rts                             rts                     ;

>ed8f  30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46  Hexdigdata     .byte "0123456789ABCDEF";hex char table 
>ed9f  0d                          CmdAscii       .byte $0D               ; 0 enter    cmd codes
>eda0  20                                         .byte $20               ; 1 SPACE
>eda1  2e                                         .byte $2E               ; 2 .
>eda2  3a                                         .byte $3A               ; 3 :
>eda3  3e                                         .byte $3E               ; 4 >  
>eda4  3f                                         .byte $3f               ; 5 ? - Help
>eda5  21                                         .byte $21               ; 6 ! - Assembler
>eda6  47                                         .byte $47               ; 7 g - Go
>eda7  49                                         .byte $49               ; 8 i - Insert
>eda8  4c                                         .byte $4C               ; 9 l - List
>eda9  4d                                         .byte $4D               ; A m - Move
>edaa  51                                         .byte $51               ; B q - Query memory (text dump)
>edab  52                                         .byte $52               ; C r - Registers
>edac  40                                         .byte $40               ; D @ - Cold Start Basic
>edad  23                                         .byte $23               ; E # - Warm Start Basic
>edae  55                          		   .byte $55		   ; F U - Uploader
>edaf  56                                         .byte $56               ;10 v - Version
>edb0  57                                         .byte $57               ;11 w - "(W)rite" eeprom
>edb1  72 e7                       Cmdjmptbl      .word CR_cmd            ; 0  enter   cmd jmp table
>edb3  82 e7                                      .word SP_cmd            ; 1   space
>edb5  67 e7                                      .word DOT_cmd           ; 2    .
>edb7  67 e7                                      .word DOT_cmd           ; 3    :
>edb9  ad e8                                      .word Dest_cmd          ; 4    >  
>edbb  2c e7                                      .word Help_Cmd          ; 5    ?
>edbd  59 ea                                      .word Assem_init        ; 6    !
>edbf  5b e7                                      .word Excute_cmd        ; 7    g
>edc1  03 e8                                      .word Insert_Cmd        ; 8    i
>edc3  b6 e8                                      .word LIST_cmd          ; 9    l
>edc5  46 e8                                      .word Move_cmd          ; A    m
>edc7  e1 e7                                      .word TXT_cmd           ; B    q
>edc9  af e5                                      .word Printreg          ; C    r
>edcb  00 bc                                      .word $BC00             ; D    @
>edcd  00 00                                      .word $0000             ; E    #
>edcf  00 fc                                      .word xmodem            ; F    u
>edd1  4a e7                                      .word Version           ;10    v
>edd3  75 e8                                      .word EEPROM_WR         ;11    w  
>edd5  00                          Cmdseccode     .byte $00               ; 0   enter       secondary command table
>edd6  ff                                         .byte $FF               ; 1   sp
>edd7  01                                         .byte $01               ; 2   .
>edd8  02                                         .byte $02               ; 3   :
>edd9  00                                         .byte $00               ; 4   > 
>edda  00                                         .byte $00               ; 5   ?
>eddb  00                                         .byte $00               ; 6   !
>eddc  00                                         .byte $00               ; 7   g
>eddd  00                                         .byte $00               ; 8   i
>edde  00                                         .byte $00               ; 9   l
>eddf  00                                         .byte $00               ; A   m
>ede0  00                                         .byte $00               ; B   q
>ede1  00                                         .byte $00               ; C   r
>ede2  00                                         .byte $00               ; D   @
>ede3  00                                         .byte $00               ; E   #
>ede4  00                                         .byte $00               ; F   u
>ede5  00                                         .byte $00               ;10   v
>ede6  00                                         .byte $00               ;11   w
>ede7  0b                          OPCtxtidx      .byte $0B               ;0   operand text index
>ede8  23                                         .byte $23               ;1
>ede9  49                                         .byte $49               ;2
>edea  49                                         .byte $49               ;3
>edeb  3b                                         .byte $3B               ;4
>edec  23                                         .byte $23               ;5
>eded  02                                         .byte $02               ;6
>edee  44                                         .byte $44               ;7
>edef  25                                         .byte $25               ;8
>edf0  23                                         .byte $23               ;9
>edf1  02                                         .byte $02               ;A
>edf2  49                                         .byte $49               ;B
>edf3  3b                                         .byte $3B               ;C
>edf4  23                                         .byte $23               ;D
>edf5  02                                         .byte $02               ;E
>edf6  42                                         .byte $42               ;F
>edf7  09                                         .byte $09               ;10
>edf8  23                                         .byte $23               ;11
>edf9  23                                         .byte $23               ;12
>edfa  49                                         .byte $49               ;13
>edfb  3a                                         .byte $3A               ;14
>edfc  23                                         .byte $23               ;15
>edfd  02                                         .byte $02               ;16
>edfe  44                                         .byte $44               ;17
>edff  0e                                         .byte $0E               ;18
>ee00  23                                         .byte $23               ;19
>ee01  19                                         .byte $19               ;1A
>ee02  49                                         .byte $49               ;1B
>ee03  3a                                         .byte $3A               ;1C
>ee04  23                                         .byte $23               ;1D
>ee05  02                                         .byte $02               ;1E
>ee06  42                                         .byte $42               ;1F
>ee07  1d                                         .byte $1D               ;20
>ee08  01                                         .byte $01               ;21
>ee09  49                                         .byte $49               ;22
>ee0a  49                                         .byte $49               ;23
>ee0b  06                                         .byte $06               ;24
>ee0c  01                                         .byte $01               ;25
>ee0d  2c                                         .byte $2C               ;26
>ee0e  44                                         .byte $44               ;27
>ee0f  29                                         .byte $29               ;28
>ee10  01                                         .byte $01               ;29
>ee11  2c                                         .byte $2C               ;2A
>ee12  49                                         .byte $49               ;2B
>ee13  06                                         .byte $06               ;2C
>ee14  01                                         .byte $01               ;2D
>ee15  2c                                         .byte $2C               ;2E
>ee16  42                                         .byte $42               ;2F
>ee17  07                                         .byte $07               ;30
>ee18  01                                         .byte $01               ;31
>ee19  01                                         .byte $01               ;32
>ee1a  49                                         .byte $49               ;33
>ee1b  06                                         .byte $06               ;34
>ee1c  01                                         .byte $01               ;35
>ee1d  2c                                         .byte $2C               ;36
>ee1e  44                                         .byte $44               ;37
>ee1f  31                                         .byte $31               ;38
>ee20  01                                         .byte $01               ;39
>ee21  15                                         .byte $15               ;3A
>ee22  49                                         .byte $49               ;3B
>ee23  06                                         .byte $06               ;3C
>ee24  01                                         .byte $01               ;3D
>ee25  2c                                         .byte $2C               ;3E
>ee26  42                                         .byte $42               ;3F
>ee27  2e                                         .byte $2E               ;40
>ee28  18                                         .byte $18               ;41
>ee29  49                                         .byte $49               ;42
>ee2a  49                                         .byte $49               ;43
>ee2b  49                                         .byte $49               ;44
>ee2c  18                                         .byte $18               ;45
>ee2d  21                                         .byte $21               ;46
>ee2e  44                                         .byte $44               ;47
>ee2f  24                                         .byte $24               ;48
>ee30  18                                         .byte $18               ;49
>ee31  21                                         .byte $21               ;4A
>ee32  49                                         .byte $49               ;4B
>ee33  1c                                         .byte $1C               ;4C
>ee34  18                                         .byte $18               ;4D
>ee35  21                                         .byte $21               ;4E
>ee36  42                                         .byte $42               ;4F
>ee37  0c                                         .byte $0C               ;50
>ee38  18                                         .byte $18               ;51
>ee39  18                                         .byte $18               ;52
>ee3a  49                                         .byte $49               ;53
>ee3b  49                                         .byte $49               ;54
>ee3c  18                                         .byte $18               ;55
>ee3d  21                                         .byte $21               ;56
>ee3e  44                                         .byte $44               ;57
>ee3f  10                                         .byte $10               ;58
>ee40  18                                         .byte $18               ;59
>ee41  27                                         .byte $27               ;5A
>ee42  49                                         .byte $49               ;5B
>ee43  49                                         .byte $49               ;5C
>ee44  18                                         .byte $18               ;5D
>ee45  21                                         .byte $21               ;5E
>ee46  42                                         .byte $42               ;5F
>ee47  2f                                         .byte $2F               ;60
>ee48  00                                         .byte $00               ;61
>ee49  49                                         .byte $49               ;62
>ee4a  49                                         .byte $49               ;63
>ee4b  37                                         .byte $37               ;64
>ee4c  00                                         .byte $00               ;65
>ee4d  2d                                         .byte $2D               ;66
>ee4e  44                                         .byte $44               ;67
>ee4f  28                                         .byte $28               ;68
>ee50  00                                         .byte $00               ;69
>ee51  2d                                         .byte $2D               ;6A
>ee52  49                                         .byte $49               ;6B
>ee53  1c                                         .byte $1C               ;6C
>ee54  00                                         .byte $00               ;6D
>ee55  2d                                         .byte $2D               ;6E
>ee56  42                                         .byte $42               ;6F
>ee57  0d                                         .byte $0D               ;70
>ee58  00                                         .byte $00               ;71
>ee59  00                                         .byte $00               ;72
>ee5a  49                                         .byte $49               ;73
>ee5b  37                                         .byte $37               ;74
>ee5c  00                                         .byte $00               ;75
>ee5d  2d                                         .byte $2D               ;76
>ee5e  44                                         .byte $44               ;77
>ee5f  33                                         .byte $33               ;78
>ee60  00                                         .byte $00               ;79
>ee61  2b                                         .byte $2B               ;7A
>ee62  49                                         .byte $49               ;7B
>ee63  1c                                         .byte $1C               ;7C
>ee64  00                                         .byte $00               ;7D
>ee65  2d                                         .byte $2D               ;7E
>ee66  42                                         .byte $42               ;7F
>ee67  0a                                         .byte $0A               ;80
>ee68  34                                         .byte $34               ;81
>ee69  49                                         .byte $49               ;82
>ee6a  49                                         .byte $49               ;83
>ee6b  36                                         .byte $36               ;84
>ee6c  34                                         .byte $34               ;85
>ee6d  35                                         .byte $35               ;86
>ee6e  45                                         .byte $45               ;87
>ee6f  17                                         .byte $17               ;88
>ee70  06                                         .byte $06               ;89
>ee71  3d                                         .byte $3D               ;8A
>ee72  49                                         .byte $49               ;8B
>ee73  36                                         .byte $36               ;8C
>ee74  34                                         .byte $34               ;8D
>ee75  35                                         .byte $35               ;8E
>ee76  43                                         .byte $43               ;8F
>ee77  03                                         .byte $03               ;90
>ee78  34                                         .byte $34               ;91
>ee79  34                                         .byte $34               ;92
>ee7a  49                                         .byte $49               ;93
>ee7b  36                                         .byte $36               ;94
>ee7c  34                                         .byte $34               ;95
>ee7d  35                                         .byte $35               ;96
>ee7e  45                                         .byte $45               ;97
>ee7f  3f                                         .byte $3F               ;98
>ee80  34                                         .byte $34               ;99
>ee81  3e                                         .byte $3E               ;9A
>ee82  49                                         .byte $49               ;9B
>ee83  37                                         .byte $37               ;9C
>ee84  34                                         .byte $34               ;9D
>ee85  37                                         .byte $37               ;9E
>ee86  43                                         .byte $43               ;9F
>ee87  20                                         .byte $20               ;A0
>ee88  1e                                         .byte $1E               ;A1
>ee89  1f                                         .byte $1F               ;A2
>ee8a  49                                         .byte $49               ;A3
>ee8b  20                                         .byte $20               ;A4
>ee8c  1e                                         .byte $1E               ;A5
>ee8d  1f                                         .byte $1F               ;A6
>ee8e  45                                         .byte $45               ;A7
>ee8f  39                                         .byte $39               ;A8
>ee90  1e                                         .byte $1E               ;A9
>ee91  38                                         .byte $38               ;AA
>ee92  49                                         .byte $49               ;AB
>ee93  20                                         .byte $20               ;AC
>ee94  1e                                         .byte $1E               ;AD
>ee95  1f                                         .byte $1F               ;AE
>ee96  43                                         .byte $43               ;AF
>ee97  04                                         .byte $04               ;B0
>ee98  1e                                         .byte $1E               ;B1
>ee99  1e                                         .byte $1E               ;B2
>ee9a  49                                         .byte $49               ;B3
>ee9b  20                                         .byte $20               ;B4
>ee9c  1e                                         .byte $1E               ;B5
>ee9d  1f                                         .byte $1F               ;B6
>ee9e  45                                         .byte $45               ;B7
>ee9f  11                                         .byte $11               ;B8
>eea0  1e                                         .byte $1E               ;B9
>eea1  3c                                         .byte $3C               ;BA
>eea2  49                                         .byte $49               ;BB
>eea3  20                                         .byte $20               ;BC
>eea4  1e                                         .byte $1E               ;BD
>eea5  1f                                         .byte $1F               ;BE
>eea6  43                                         .byte $43               ;BF
>eea7  14                                         .byte $14               ;C0
>eea8  12                                         .byte $12               ;C1
>eea9  49                                         .byte $49               ;C2
>eeaa  49                                         .byte $49               ;C3
>eeab  14                                         .byte $14               ;C4
>eeac  12                                         .byte $12               ;C5
>eead  15                                         .byte $15               ;C6
>eeae  45                                         .byte $45               ;C7
>eeaf  1b                                         .byte $1B               ;C8
>eeb0  12                                         .byte $12               ;C9
>eeb1  16                                         .byte $16               ;CA
>eeb2  40                                         .byte $40               ;CB
>eeb3  14                                         .byte $14               ;CC
>eeb4  12                                         .byte $12               ;CD
>eeb5  15                                         .byte $15               ;CE
>eeb6  43                                         .byte $43               ;CF
>eeb7  08                                         .byte $08               ;D0
>eeb8  12                                         .byte $12               ;D1
>eeb9  12                                         .byte $12               ;D2
>eeba  49                                         .byte $49               ;D3
>eebb  49                                         .byte $49               ;D4
>eebc  12                                         .byte $12               ;D5
>eebd  15                                         .byte $15               ;D6
>eebe  45                                         .byte $45               ;D7
>eebf  0f                                         .byte $0F               ;D8
>eec0  12                                         .byte $12               ;D9
>eec1  26                                         .byte $26               ;DA
>eec2  41                                         .byte $41               ;DB
>eec3  49                                         .byte $49               ;DC
>eec4  12                                         .byte $12               ;DD
>eec5  15                                         .byte $15               ;DE
>eec6  43                                         .byte $43               ;DF
>eec7  13                                         .byte $13               ;E0
>eec8  30                                         .byte $30               ;E1
>eec9  49                                         .byte $49               ;E2
>eeca  49                                         .byte $49               ;E3
>eecb  13                                         .byte $13               ;E4
>eecc  30                                         .byte $30               ;E5
>eecd  19                                         .byte $19               ;E6
>eece  45                                         .byte $45               ;E7
>eecf  1a                                         .byte $1A               ;E8
>eed0  30                                         .byte $30               ;E9
>eed1  22                                         .byte $22               ;EA
>eed2  49                                         .byte $49               ;EB
>eed3  13                                         .byte $13               ;EC
>eed4  30                                         .byte $30               ;ED
>eed5  19                                         .byte $19               ;EE
>eed6  43                                         .byte $43               ;EF
>eed7  05                                         .byte $05               ;F0
>eed8  30                                         .byte $30               ;F1
>eed9  30                                         .byte $30               ;F2
>eeda  49                                         .byte $49               ;F3
>eedb  49                                         .byte $49               ;F4
>eedc  30                                         .byte $30               ;F5
>eedd  19                                         .byte $19               ;F6
>eede  45                                         .byte $45               ;F7
>eedf  32                                         .byte $32               ;F8
>eee0  30                                         .byte $30               ;F9
>eee1  2a                                         .byte $2A               ;FA
>eee2  49                                         .byte $49               ;FB
>eee3  49                                         .byte $49               ;FC
>eee4  30                                         .byte $30               ;FD
>eee5  19                                         .byte $19               ;FE
>eee6  43                                         .byte $43               ;FF
>eee7  03                          OPCaddmode     .byte $03               ;0   opcode address mode
>eee8  04                                         .byte $04               ;1
>eee9  03                                         .byte $03               ;2
>eeea  03                                         .byte $03               ;3
>eeeb  02                                         .byte $02               ;4
>eeec  02                                         .byte $02               ;5
>eeed  02                                         .byte $02               ;6
>eeee  0f                                         .byte $0F               ;7
>eeef  03                                         .byte $03               ;8
>eef0  00                                         .byte $00               ;9
>eef1  03                                         .byte $03               ;A
>eef2  03                                         .byte $03               ;B
>eef3  01                                         .byte $01               ;C
>eef4  01                                         .byte $01               ;D
>eef5  01                                         .byte $01               ;E
>eef6  0e                                         .byte $0E               ;F
>eef7  0a                                         .byte $0A               ;10
>eef8  05                                         .byte $05               ;11
>eef9  0d                                         .byte $0D               ;12
>eefa  03                                         .byte $03               ;13
>eefb  02                                         .byte $02               ;14
>eefc  06                                         .byte $06               ;15
>eefd  06                                         .byte $06               ;16
>eefe  1f                                         .byte $1F               ;17
>eeff  03                                         .byte $03               ;18
>ef00  09                                         .byte $09               ;19
>ef01  03                                         .byte $03               ;1A
>ef02  03                                         .byte $03               ;1B
>ef03  01                                         .byte $01               ;1C
>ef04  08                                         .byte $08               ;1D
>ef05  08                                         .byte $08               ;1E
>ef06  1e                                         .byte $1E               ;1F
>ef07  01                                         .byte $01               ;20
>ef08  04                                         .byte $04               ;21
>ef09  03                                         .byte $03               ;22
>ef0a  03                                         .byte $03               ;23
>ef0b  02                                         .byte $02               ;24
>ef0c  02                                         .byte $02               ;25
>ef0d  02                                         .byte $02               ;26
>ef0e  2f                                         .byte $2F               ;27
>ef0f  03                                         .byte $03               ;28
>ef10  00                                         .byte $00               ;29
>ef11  03                                         .byte $03               ;2A
>ef12  03                                         .byte $03               ;2B
>ef13  01                                         .byte $01               ;2C
>ef14  01                                         .byte $01               ;2D
>ef15  01                                         .byte $01               ;2E
>ef16  2e                                         .byte $2E               ;2F
>ef17  0a                                         .byte $0A               ;30
>ef18  05                                         .byte $05               ;31
>ef19  0d                                         .byte $0D               ;32
>ef1a  03                                         .byte $03               ;33
>ef1b  06                                         .byte $06               ;34
>ef1c  06                                         .byte $06               ;35
>ef1d  06                                         .byte $06               ;36
>ef1e  3f                                         .byte $3F               ;37
>ef1f  03                                         .byte $03               ;38
>ef20  09                                         .byte $09               ;39
>ef21  03                                         .byte $03               ;3A
>ef22  03                                         .byte $03               ;3B
>ef23  08                                         .byte $08               ;3C
>ef24  08                                         .byte $08               ;3D
>ef25  08                                         .byte $08               ;3E
>ef26  3e                                         .byte $3E               ;3F
>ef27  03                                         .byte $03               ;40
>ef28  04                                         .byte $04               ;41
>ef29  03                                         .byte $03               ;42
>ef2a  03                                         .byte $03               ;43
>ef2b  03                                         .byte $03               ;44
>ef2c  02                                         .byte $02               ;45
>ef2d  02                                         .byte $02               ;46
>ef2e  4f                                         .byte $4F               ;47
>ef2f  03                                         .byte $03               ;48
>ef30  00                                         .byte $00               ;49
>ef31  03                                         .byte $03               ;4A
>ef32  03                                         .byte $03               ;4B
>ef33  01                                         .byte $01               ;4C
>ef34  01                                         .byte $01               ;4D
>ef35  01                                         .byte $01               ;4E
>ef36  4e                                         .byte $4E               ;4F
>ef37  0a                                         .byte $0A               ;50
>ef38  05                                         .byte $05               ;51
>ef39  0d                                         .byte $0D               ;52
>ef3a  03                                         .byte $03               ;53
>ef3b  03                                         .byte $03               ;54
>ef3c  06                                         .byte $06               ;55
>ef3d  06                                         .byte $06               ;56
>ef3e  5f                                         .byte $5F               ;57
>ef3f  03                                         .byte $03               ;58
>ef40  09                                         .byte $09               ;59
>ef41  03                                         .byte $03               ;5A
>ef42  03                                         .byte $03               ;5B
>ef43  03                                         .byte $03               ;5C
>ef44  08                                         .byte $08               ;5D
>ef45  08                                         .byte $08               ;5E
>ef46  5e                                         .byte $5E               ;5F
>ef47  03                                         .byte $03               ;60
>ef48  04                                         .byte $04               ;61
>ef49  03                                         .byte $03               ;62
>ef4a  03                                         .byte $03               ;63
>ef4b  02                                         .byte $02               ;64
>ef4c  02                                         .byte $02               ;65
>ef4d  02                                         .byte $02               ;66
>ef4e  6f                                         .byte $6F               ;67
>ef4f  03                                         .byte $03               ;68
>ef50  00                                         .byte $00               ;69
>ef51  03                                         .byte $03               ;6A
>ef52  03                                         .byte $03               ;6B
>ef53  0b                                         .byte $0B               ;6C
>ef54  01                                         .byte $01               ;6D
>ef55  01                                         .byte $01               ;6E
>ef56  6e                                         .byte $6E               ;6F
>ef57  0a                                         .byte $0A               ;70
>ef58  05                                         .byte $05               ;71
>ef59  0d                                         .byte $0D               ;72
>ef5a  03                                         .byte $03               ;73
>ef5b  06                                         .byte $06               ;74
>ef5c  06                                         .byte $06               ;75
>ef5d  06                                         .byte $06               ;76
>ef5e  7f                                         .byte $7F               ;77
>ef5f  03                                         .byte $03               ;78
>ef60  09                                         .byte $09               ;79
>ef61  03                                         .byte $03               ;7A
>ef62  03                                         .byte $03               ;7B
>ef63  0c                                         .byte $0C               ;7C
>ef64  08                                         .byte $08               ;7D
>ef65  08                                         .byte $08               ;7E
>ef66  7e                                         .byte $7E               ;7F
>ef67  0a                                         .byte $0A               ;80
>ef68  04                                         .byte $04               ;81
>ef69  03                                         .byte $03               ;82
>ef6a  03                                         .byte $03               ;83
>ef6b  02                                         .byte $02               ;84
>ef6c  02                                         .byte $02               ;85
>ef6d  02                                         .byte $02               ;86
>ef6e  0f                                         .byte $0F               ;87
>ef6f  03                                         .byte $03               ;88
>ef70  00                                         .byte $00               ;89
>ef71  03                                         .byte $03               ;8A
>ef72  03                                         .byte $03               ;8B
>ef73  01                                         .byte $01               ;8C
>ef74  01                                         .byte $01               ;8D
>ef75  01                                         .byte $01               ;8E
>ef76  0e                                         .byte $0E               ;8F
>ef77  0a                                         .byte $0A               ;90
>ef78  05                                         .byte $05               ;91
>ef79  0d                                         .byte $0D               ;92
>ef7a  03                                         .byte $03               ;93
>ef7b  06                                         .byte $06               ;94
>ef7c  06                                         .byte $06               ;95
>ef7d  07                                         .byte $07               ;96
>ef7e  1f                                         .byte $1F               ;97
>ef7f  03                                         .byte $03               ;98
>ef80  09                                         .byte $09               ;99
>ef81  03                                         .byte $03               ;9A
>ef82  03                                         .byte $03               ;9B
>ef83  01                                         .byte $01               ;9C
>ef84  08                                         .byte $08               ;9D
>ef85  08                                         .byte $08               ;9E
>ef86  1e                                         .byte $1E               ;9F
>ef87  00                                         .byte $00               ;A0
>ef88  04                                         .byte $04               ;A1    changed from 0d to 04
>ef89  00                                         .byte $00               ;A2
>ef8a  03                                         .byte $03               ;A3
>ef8b  02                                         .byte $02               ;A4
>ef8c  02                                         .byte $02               ;A5
>ef8d  02                                         .byte $02               ;A6
>ef8e  2f                                         .byte $2F               ;A7
>ef8f  03                                         .byte $03               ;A8
>ef90  00                                         .byte $00               ;A9
>ef91  03                                         .byte $03               ;AA
>ef92  03                                         .byte $03               ;AB
>ef93  01                                         .byte $01               ;AC
>ef94  01                                         .byte $01               ;AD
>ef95  01                                         .byte $01               ;AE
>ef96  2e                                         .byte $2E               ;AF
>ef97  0a                                         .byte $0A               ;B0
>ef98  05                                         .byte $05               ;B1
>ef99  0d                                         .byte $0D               ;B2     
>ef9a  03                                         .byte $03               ;B3
>ef9b  06                                         .byte $06               ;B4
>ef9c  06                                         .byte $06               ;B5
>ef9d  07                                         .byte $07               ;B6
>ef9e  3f                                         .byte $3F               ;B7
>ef9f  03                                         .byte $03               ;B8
>efa0  09                                         .byte $09               ;B9
>efa1  03                                         .byte $03               ;BA
>efa2  03                                         .byte $03               ;BB
>efa3  08                                         .byte $08               ;BC
>efa4  08                                         .byte $08               ;BD
>efa5  09                                         .byte $09               ;BE
>efa6  3e                                         .byte $3E               ;BF
>efa7  00                                         .byte $00               ;C0
>efa8  04                                         .byte $04               ;C1
>efa9  03                                         .byte $03               ;C2
>efaa  03                                         .byte $03               ;C3
>efab  02                                         .byte $02               ;C4
>efac  02                                         .byte $02               ;C5
>efad  02                                         .byte $02               ;C6
>efae  4f                                         .byte $4F               ;C7
>efaf  03                                         .byte $03               ;C8
>efb0  00                                         .byte $00               ;C9
>efb1  03                                         .byte $03               ;CA
>efb2  03                                         .byte $03               ;CB
>efb3  01                                         .byte $01               ;CC
>efb4  01                                         .byte $01               ;CD
>efb5  01                                         .byte $01               ;CE
>efb6  4e                                         .byte $4E               ;CF
>efb7  0a                                         .byte $0A               ;D0
>efb8  05                                         .byte $05               ;D1
>efb9  0d                                         .byte $0D               ;D2
>efba  03                                         .byte $03               ;D3
>efbb  03                                         .byte $03               ;D4
>efbc  06                                         .byte $06               ;D5
>efbd  06                                         .byte $06               ;D6
>efbe  5f                                         .byte $5F               ;D7
>efbf  03                                         .byte $03               ;D8
>efc0  09                                         .byte $09               ;D9
>efc1  03                                         .byte $03               ;DA
>efc2  03                                         .byte $03               ;DB
>efc3  03                                         .byte $03               ;DC
>efc4  08                                         .byte $08               ;DD
>efc5  08                                         .byte $08               ;DE
>efc6  5e                                         .byte $5E               ;DF
>efc7  00                                         .byte $00               ;E0
>efc8  04                                         .byte $04               ;E1
>efc9  03                                         .byte $03               ;E2
>efca  03                                         .byte $03               ;E3
>efcb  02                                         .byte $02               ;E4
>efcc  02                                         .byte $02               ;E5
>efcd  02                                         .byte $02               ;E6
>efce  6f                                         .byte $6F               ;E7
>efcf  03                                         .byte $03               ;E8
>efd0  00                                         .byte $00               ;E9
>efd1  03                                         .byte $03               ;EA
>efd2  03                                         .byte $03               ;EB
>efd3  01                                         .byte $01               ;EC
>efd4  01                                         .byte $01               ;ED
>efd5  01                                         .byte $01               ;EE
>efd6  6e                                         .byte $6E               ;EF
>efd7  0a                                         .byte $0A               ;F0
>efd8  05                                         .byte $05               ;F1
>efd9  0d                                         .byte $0D               ;F2
>efda  03                                         .byte $03               ;F3
>efdb  03                                         .byte $03               ;F4
>efdc  06                                         .byte $06               ;F5
>efdd  06                                         .byte $06               ;F6
>efde  7f                                         .byte $7F               ;F7
>efdf  03                                         .byte $03               ;F8
>efe0  09                                         .byte $09               ;F9
>efe1  03                                         .byte $03               ;FA
>efe2  03                                         .byte $03               ;FB
>efe3  03                                         .byte $03               ;FC
>efe4  08                                         .byte $08               ;FD
>efe5  08                                         .byte $08               ;FE
>efe6  7e                                         .byte $7E               ;FF
>efe7  02                          ModeByteCnt    .byte $02               ;0  opcode mode byte count
>efe8  03                                         .byte $03               ;1
>efe9  02                                         .byte $02               ;2
>efea  01                                         .byte $01               ;3
>efeb  02                                         .byte $02               ;4
>efec  02                                         .byte $02               ;5
>efed  02                                         .byte $02               ;6
>efee  02                                         .byte $02               ;7
>efef  03                                         .byte $03               ;8
>eff0  03                                         .byte $03               ;9
>eff1  02                                         .byte $02               ;A
>eff2  03                                         .byte $03               ;B
>eff3  03                                         .byte $03               ;C
>eff4  02                                         .byte $02               ;D
>eff5  03                                         .byte $03               ;E
>eff6  02                                         .byte $02               ;F 
>eff7  a2 e9                       ModeJmpTbl     .word IMM_mode          ;0  Operand print table
>eff9  e8 e9                                      .word ABS_mode          ;1
>effb  a7 e9                                      .word ZP_mode           ;2
>effd  12 ea                                      .word IMPLIED_mode      ;3
>efff  d8 e9                                      .word INDZP_X_mode      ;4
>f001  e3 e9                                      .word INDZP_Y_mode      ;5
>f003  b3 e9                                      .word ZP_X_mode         ;6
>f005  c0 e9                                      .word ZP_Y_mode         ;7
>f007  f5 e9                                      .word ABS_X_mode        ;8
>f009  fa e9                                      .word ABS_Y_mode        ;9
>f00b  33 ea                                      .word REL_mode          ;a
>f00d  ff e9                                      .word INDABS_mode       ;b
>f00f  07 ea                                      .word INDABSX_mode      ;c
>f011  cd e9                                      .word INDZP_mode        ;d
>f013  18 ea                       		   .word BBREL_mode        ;e
>f015  a7 e9                                      .word ZP_mode           ;f  dup of ZP for RMB,SMB cmds
>f017  28                          Asm_ModeLst    .byte $28               ;0 IMM_mode
>f018  10                                         .byte $10               ;1 ABS_mode
>f019  08                                         .byte $08               ;2 ZP_mode
>f01a  00                                         .byte $00               ;3 IMPLIED_mode
>f01b  0e                                         .byte $0E               ;4 INDZP_X_mode
>f01c  0d                                         .byte $0D               ;5 INDZP_Y_mode
>f01d  0a                                         .byte $0A               ;6 ZP_X_mode
>f01e  09                                         .byte $09               ;7 ZP_Y_mode
>f01f  12                                         .byte $12               ;8 ABS_X_mode
>f020  11                                         .byte $11               ;9 ABS_Y_mode
>f021  40                                         .byte $40               ;A REL_mode   Never set!!!
>f022  14                                         .byte $14               ;B INDABS_mode
>f023  16                                         .byte $16               ;C INDABSX_mode
>f024  0c                                         .byte $0C               ;D INDZP_mode
>f025  d0                                         .byte $D0               ;E BBREL_mode
>f026  88                                         .byte $88               ;F used for RMBx & SMBx 
>f027  41 44 43                    OPCtxtData     .byte "ADC"             ;0
>f02a  41 4e 44                                   .byte "AND"             ;1
>f02d  41 53 4c                                   .byte "ASL"             ;2
>f030  42 43 43                                   .byte "BCC"             ;3
>f033  42 43 53                                   .byte "BCS"             ;4
>f036  42 45 51                                   .byte "BEQ"             ;5
>f039  42 49 54                                   .byte "BIT"             ;6
>f03c  42 4d 49                                   .byte "BMI"             ;7
>f03f  42 4e 45                                   .byte "BNE"             ;8
>f042  42 50 4c                                   .byte "BPL"             ;9
>f045  42 52 41                                   .byte "BRA"             ;A
>f048  42 52 4b                                   .byte "BRK"             ;B
>f04b  42 56 43                                   .byte "BVC"             ;C
>f04e  42 56 53                                   .byte "BVS"             ;D
>f051  43 4c 43                                   .byte "CLC"             ;E
>f054  43 4c 44                                   .byte "CLD"             ;F
>f057  43 4c 49                                   .byte "CLI"             ;10
>f05a  43 4c 56                                   .byte "CLV"             ;11
>f05d  43 4d 50                                   .byte "CMP"             ;12
>f060  43 50 58                                   .byte "CPX"             ;13
>f063  43 50 59                                   .byte "CPY"             ;14
>f066  44 45 43                                   .byte "DEC"             ;15
>f069  44 45 58                                   .byte "DEX"             ;16
>f06c  44 45 59                                   .byte "DEY"             ;17
>f06f  45 4f 52                                   .byte "EOR"             ;18
>f072  49 4e 43                                   .byte "INC"             ;19
>f075  49 4e 58                                   .byte "INX"             ;1A
>f078  49 4e 59                                   .byte "INY"             ;1B
>f07b  4a 4d 50                                   .byte "JMP"             ;1C
>f07e  4a 53 52                                   .byte "JSR"             ;1D
>f081  4c 44 41                                   .byte "LDA"             ;1E
>f084  4c 44 58                                   .byte "LDX"             ;1F
>f087  4c 44 59                                   .byte "LDY"             ;20
>f08a  4c 53 52                                   .byte "LSR"             ;21
>f08d  4e 4f 50                                   .byte "NOP"             ;22
>f090  4f 52 41                                   .byte "ORA"             ;23
>f093  50 48 41                                   .byte "PHA"             ;24
>f096  50 48 50                                   .byte "PHP"             ;25
>f099  50 48 58                                   .byte "PHX"             ;26
>f09c  50 48 59                                   .byte "PHY"             ;27
>f09f  50 4c 41                                   .byte "PLA"             ;28
>f0a2  50 4c 50                                   .byte "PLP"             ;29
>f0a5  50 4c 58                                   .byte "PLX"             ;2A
>f0a8  50 4c 59                                   .byte "PLY"             ;2B
>f0ab  52 4f 4c                                   .byte "ROL"             ;2C
>f0ae  52 4f 52                                   .byte "ROR"             ;2D
>f0b1  52 54 49                                   .byte "RTI"             ;2E
>f0b4  52 54 53                                   .byte "RTS"             ;2F
>f0b7  53 42 43                                   .byte "SBC"             ;30
>f0ba  53 45 43                                   .byte "SEC"             ;31
>f0bd  53 45 44                                   .byte "SED"             ;32
>f0c0  53 45 49                                   .byte "SEI"             ;33
>f0c3  53 54 41                                   .byte "STA"             ;34
>f0c6  53 54 58                                   .byte "STX"             ;35
>f0c9  53 54 59                                   .byte "STY"             ;36
>f0cc  53 54 5a                                   .byte "STZ"             ;37
>f0cf  54 41 58                                   .byte "TAX"             ;38
>f0d2  54 41 59                                   .byte "TAY"             ;39
>f0d5  54 52 42                                   .byte "TRB"             ;3A
>f0d8  54 53 42                                   .byte "TSB"             ;3B
>f0db  54 53 58                                   .byte "TSX"             ;3C
>f0de  54 58 41                                   .byte "TXA"             ;3D
>f0e1  54 58 53                                   .byte "TXS"             ;3E
>f0e4  54 59 41                                   .byte "TYA"             ;3F
>f0e7  57 41 49                                   .byte "WAI"             ;40
>f0ea  53 54 50                                   .byte "STP"             ;41
>f0ed  42 42 52                                   .byte "BBR"             ;42 4Byte Opcodes
>f0f0  42 42 53                                   .byte "BBS"             ;43
>f0f3  52 4d 42                                   .byte "RMB"             ;44
>f0f6  53 4d 42                                   .byte "SMB"             ;45
>f0f9  2e 44 42                                   .byte ".DB"             ;46 define 1 byte for assembler
>f0fc  2e 44 57                                   .byte ".DW"             ;47 define 1 word for assembler
>f0ff  2e 44 53                                   .byte ".DS"             ;48 define a string block for assembler
>f102  3f 3f 3f                                   .byte "???"             ;49 for invalid opcode
>f105  7e 43 75 72 72 65 6e 74 20 63 6f 6d 6d 61 6e 64 73 20 61 72 65 20 3a 7e  HelpTxt        .byte "~Current commands are :~"
>f11d  53 79 6e 74 61 78 20 3d 20 7b 7d 20 72 65 71 75 69 72 65 64 2c 20 5b 5d 20 6f 70 74 69 6f 6e 61 6c 2c 20 48 48 48 48 20 68 65 78 20 61 64 64 72 65 73 73 2c 20 44 44 20 68 65 78 20 64 61 74 61 7e                 .byte "Syntax = {} required, [] optional, HHHH hex address, DD hex data~"
>f15e  7e                                         .byte "~"
>f15f  5b 48 48 48 48 5d 5b 20 48 48 48 48 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 48 65 78 20 64 75 6d 70 20 61 64 64 72 65 73 73 28 73 29 28 75 70 20 74 6f 20 31 36 20 69 66 20 6e 6f 20 61 64 64 72 65 73 73 20 65 6e 74 65 72 65 64 29 7e                 .byte "[HHHH][ HHHH]{Return} - Hex dump address(s)(up to 16 if no address entered)~"
>f1ab  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 48 65 78 20 64 75 6d 70 20 72 61 6e 67 65 20 6f 66 20 61 64 64 72 65 73 73 65 73 20 28 31 36 20 70 65 72 20 6c 69 6e 65 29 7e                 .byte "[HHHH]{.HHHH}{Return} - Hex dump range of addresses (16 per line)~"
>f1ed  5b 48 48 48 48 5d 7b 3a 44 44 7d 5b 20 44 44 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 43 68 61 6e 67 65 20 64 61 74 61 20 62 79 74 65 73 7e                 .byte "[HHHH]{:DD}[ DD]{Return} - Change data bytes~"
>f21a  5b 48 48 48 48 5d 7b 47 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 45 78 65 63 75 74 65 20 61 20 70 72 6f 67 72 61 6d 20 28 75 73 65 20 52 54 53 20 74 6f 20 72 65 74 75 72 6e 20 74 6f 20 6d 6f 6e 69 74 6f 72 29 7e                 .byte "[HHHH]{G}{Return} - Execute a program (use RTS to return to monitor)~"
>f25f  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 49 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 6d 6f 76 65 20 72 61 6e 67 65 20 61 74 20 32 6e 64 20 48 48 48 48 20 64 6f 77 6e 20 74 6f 20 31 73 74 20 74 6f 20 33 72 64 20 48 48 48 48 7e                 .byte "{HHHH.HHHH>HHHH{I}{Return} - move range at 2nd HHHH down to 1st to 3rd HHHH~"
>f2ab  5b 48 48 48 48 5d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4c 69 73 74 20 28 64 69 73 61 73 73 65 6d 62 6c 65 29 20 32 30 20 6c 69 6e 65 73 20 6f 66 20 70 72 6f 67 72 61 6d 7e                 .byte "[HHHH]{L}{Return} - List (disassemble) 20 lines of program~"
>f2e6  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 44 69 73 73 61 73 73 65 6d 62 6c 65 20 61 20 72 61 6e 67 65 7e                 .byte "[HHHH]{.HHHH}{L}{Return} - Dissassemble a range~"
>f316  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 4d 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4d 6f 76 65 20 72 61 6e 67 65 20 61 74 20 31 73 74 20 48 48 48 48 20 74 68 72 75 20 32 6e 64 20 74 6f 20 33 72 64 20 48 48 48 48 7e                 .byte "{HHHH.HHHH>HHHH{M}{Return} - Move range at 1st HHHH thru 2nd to 3rd HHHH~"
>f35f  5b 48 48 48 48 5d 5b 20 48 48 48 48 5d 7b 51 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 54 65 78 74 20 64 75 6d 70 20 61 64 64 72 65 73 73 28 73 29 7e                 .byte "[HHHH][ HHHH]{Q}{Return} - Text dump address(s)~"
>f38f  5b 48 48 48 48 5d 7b 2e 48 48 48 48 7d 7b 51 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 54 65 78 74 20 64 75 6d 70 20 72 61 6e 67 65 20 6f 66 20 61 64 64 72 65 73 73 65 73 20 28 31 36 20 70 65 72 20 6c 69 6e 65 29 7e                 .byte "[HHHH]{.HHHH}{Q}{Return} - Text dump range of addresses (16 per line)~"
>f3d5  7b 52 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 72 65 67 69 73 74 65 72 20 63 6f 6e 74 65 6e 74 73 20 66 72 6f 6d 20 6d 65 6d 6f 72 79 20 6c 6f 63 61 74 69 6f 6e 73 7e                 .byte "{R}{Return} - Print register contents from memory locations~"
>f411  7b 55 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 55 70 6c 6f 61 64 20 46 69 6c 65 20 28 58 6d 6f 64 65 6d 2f 43 52 43 20 6f 72 20 49 6e 74 65 6c 20 48 65 78 29 7e                 .byte "{U}{Return} - Upload File (Xmodem/CRC or Intel Hex)~"
>f445  7b 56 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4d 6f 6e 69 74 6f 72 20 56 65 72 73 69 6f 6e 7e                 .byte "{V}{Return} - Monitor Version~"
>f463  7b 48 48 48 48 2e 48 48 48 48 3e 48 48 48 48 7b 57 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 57 72 69 74 65 20 64 61 74 61 20 69 6e 20 52 41 4d 20 74 6f 20 45 45 50 52 4f 4d 7e                 .byte "{HHHH.HHHH>HHHH{W}{Return} - Write data in RAM to EEPROM~"
>f49c  7b 21 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 45 6e 74 65 72 20 41 73 73 65 6d 62 6c 65 72 7e                 .byte "{!}{Return} - Enter Assembler~"
>f4ba  7b 40 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 43 6f 6c 64 2d 53 74 61 72 74 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 7e                 .byte "{@}{Return} - Cold-Start Enhanced Basic~"
>f4e2  7b 23 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 57 61 72 6d 5f 53 74 61 72 74 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 7e                 .byte "{#}{Return} - Warm_Start Enhanced Basic~"
>f50a  7b 3f 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 6d 65 6e 75 20 6f 66 20 63 6f 6d 6d 61 6e 64 73 7e 7e                 .byte "{?}{Return} - Print menu of commands~~"
>f530  00                                         .byte $00
>f531  7e 43 75 72 72 65 6e 74 20 63 6f 6d 6d 61 6e 64 73 20 61 72 65 20 3a 7e  AsmHelpTxt     .byte "~Current commands are :~"
>f549  53 79 6e 74 61 78 20 3d 20 7b 7d 20 72 65 71 75 69 72 65 64 2c 20 5b 5d 20 6f 70 74 69 6f 6e 61 6c 7e                 .byte "Syntax = {} required, [] optional~"
>f56b  48 48 48 48 3d 68 65 78 20 61 64 64 72 65 73 73 2c 20 4f 50 43 3d 4f 70 63 6f 64 65 2c 20 44 44 3d 68 65 78 20 64 61 74 61 2c 20 27 5f 27 3d 53 70 61 63 65 20 42 61 72 20 6f 72 20 54 61 62 7e                 .byte "HHHH=hex address, OPC=Opcode, DD=hex data, '_'=Space Bar or Tab~"
>f5ab  27 24 27 20 53 79 6d 62 6f 6c 73 20 61 72 65 20 6f 70 74 69 6f 6e 61 6c 2c 20 61 6c 6c 20 76 61 6c 75 65 73 20 61 72 65 20 48 45 58 2e 7e                 .byte "'$' Symbols are optional, all values are HEX.~"
>f5d9  41 6e 79 20 69 6e 70 75 74 20 61 66 74 65 72 20 61 20 27 73 65 6d 69 2d 63 6f 6c 6f 6e 27 20 69 73 20 69 67 6e 6f 72 65 64 2e 7e                 .byte "Any input after a 'semi-colon' is ignored.~"
>f604  7e                                         .byte "~"
>f605  7b 48 48 48 48 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 53 65 74 20 69 6e 70 75 74 20 61 64 64 72 65 73 73 7e                 .byte "{HHHH}{Return} - Set input address~"
>f628  5b 48 48 48 48 5d 5b 5f 5d 7b 4f 50 43 7d 5b 5f 5d 5b 23 28 24 44 44 5f 48 48 48 48 2c 58 29 2c 59 5d 7b 52 65 74 75 72 6e 7d 20 2d 20 41 73 73 65 6d 62 6c 65 20 6c 69 6e 65 7e                 .byte "[HHHH][_]{OPC}[_][#($DD_HHHH,X),Y]{Return} - Assemble line~"
>f663  5b 48 48 48 48 5d 7b 4c 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 4c 69 73 74 20 28 64 69 73 61 73 73 65 6d 62 6c 65 29 20 32 30 20 6c 69 6e 65 73 20 6f 66 20 70 72 6f 67 72 61 6d 7e                 .byte "[HHHH]{L}{Return} - List (disassemble) 20 lines of program~"
>f69e  7b 52 65 74 75 72 6e 7d 20 2d 20 45 78 69 74 20 41 73 73 65 6d 62 6c 65 72 20 62 61 63 6b 20 74 6f 20 4d 6f 6e 69 74 6f 72 7e                 .byte "{Return} - Exit Assembler back to Monitor~"
>f6c8  7b 3f 7d 7b 52 65 74 75 72 6e 7d 20 2d 20 50 72 69 6e 74 20 6d 65 6e 75 20 6f 66 20 63 6f 6d 6d 61 6e 64 73 7e 7e                 .byte "{?}{Return} - Print menu of commands~~"
>f6ee  00                                         .byte $00
>f6ef  36 35 43 30 32 20 4d 6f 6e 69 74 6f 72 20 76 35 2e 31 20 28 35 2d 33 30 2d 30 35 29 20 52 65 61 64 79  Porttxt        .byte "65C02 Monitor v5.1 (5-30-05) Ready"
>f711  0d 0a                                      .byte  $0d, $0a
>f713  77 69 74 68 20 45 6e 68 61 6e 63 65 64 20 42 61 73 69 63 20 49 6e 74 65 72 70 72 65 74 65 72 20 28 63 29 20 4c 65 65 20 44 61 76 69 73 6f 6e                 .byte "with Enhanced Basic Interpreter (c) Lee Davison" 
>f742  0d 0a                                      .byte  $0d, $0a
>f744  28 50 72 65 73 73 20 3f 20 66 6f 72 20 68 65 6c 70 29                 .byte "(Press ? for help)"
>f756  00                                         .byte $00
.fa00                              crclo

>fa00  00 21 42 63 84 a5 c6 e7 08 29 4a 6b 8c ad ce ef   .byte $00,$21,$42,$63,$84,$A5,$C6,$E7,$08,$29,$4A,$6B,$8C,$AD,$CE,$EF
>fa10  31 10 73 52 b5 94 f7 d6 39 18 7b 5a bd 9c ff de   .byte $31,$10,$73,$52,$B5,$94,$F7,$D6,$39,$18,$7B,$5A,$BD,$9C,$FF,$DE
>fa20  62 43 20 01 e6 c7 a4 85 6a 4b 28 09 ee cf ac 8d   .byte $62,$43,$20,$01,$E6,$C7,$A4,$85,$6A,$4B,$28,$09,$EE,$CF,$AC,$8D
>fa30  53 72 11 30 d7 f6 95 b4 5b 7a 19 38 df fe 9d bc   .byte $53,$72,$11,$30,$D7,$F6,$95,$B4,$5B,$7A,$19,$38,$DF,$FE,$9D,$BC
>fa40  c4 e5 86 a7 40 61 02 23 cc ed 8e af 48 69 0a 2b   .byte $C4,$E5,$86,$A7,$40,$61,$02,$23,$CC,$ED,$8E,$AF,$48,$69,$0A,$2B
>fa50  f5 d4 b7 96 71 50 33 12 fd dc bf 9e 79 58 3b 1a   .byte $F5,$D4,$B7,$96,$71,$50,$33,$12,$FD,$DC,$BF,$9E,$79,$58,$3B,$1A
>fa60  a6 87 e4 c5 22 03 60 41 ae 8f ec cd 2a 0b 68 49   .byte $A6,$87,$E4,$C5,$22,$03,$60,$41,$AE,$8F,$EC,$CD,$2A,$0B,$68,$49
>fa70  97 b6 d5 f4 13 32 51 70 9f be dd fc 1b 3a 59 78   .byte $97,$B6,$D5,$F4,$13,$32,$51,$70,$9F,$BE,$DD,$FC,$1B,$3A,$59,$78
>fa80  88 a9 ca eb 0c 2d 4e 6f 80 a1 c2 e3 04 25 46 67   .byte $88,$A9,$CA,$EB,$0C,$2D,$4E,$6F,$80,$A1,$C2,$E3,$04,$25,$46,$67
>fa90  b9 98 fb da 3d 1c 7f 5e b1 90 f3 d2 35 14 77 56   .byte $B9,$98,$FB,$DA,$3D,$1C,$7F,$5E,$B1,$90,$F3,$D2,$35,$14,$77,$56
>faa0  ea cb a8 89 6e 4f 2c 0d e2 c3 a0 81 66 47 24 05   .byte $EA,$CB,$A8,$89,$6E,$4F,$2C,$0D,$E2,$C3,$A0,$81,$66,$47,$24,$05
>fab0  db fa 99 b8 5f 7e 1d 3c d3 f2 91 b0 57 76 15 34   .byte $DB,$FA,$99,$B8,$5F,$7E,$1D,$3C,$D3,$F2,$91,$B0,$57,$76,$15,$34
>fac0  4c 6d 0e 2f c8 e9 8a ab 44 65 06 27 c0 e1 82 a3   .byte $4C,$6D,$0E,$2F,$C8,$E9,$8A,$AB,$44,$65,$06,$27,$C0,$E1,$82,$A3
>fad0  7d 5c 3f 1e f9 d8 bb 9a 75 54 37 16 f1 d0 b3 92   .byte $7D,$5C,$3F,$1E,$F9,$D8,$BB,$9A,$75,$54,$37,$16,$F1,$D0,$B3,$92
>fae0  2e 0f 6c 4d aa 8b e8 c9 26 07 64 45 a2 83 e0 c1   .byte $2E,$0F,$6C,$4D,$AA,$8B,$E8,$C9,$26,$07,$64,$45,$A2,$83,$E0,$C1
>faf0  1f 3e 5d 7c 9b ba d9 f8 17 36 55 74 93 b2 d1 f0   .byte $1F,$3E,$5D,$7C,$9B,$BA,$D9,$F8,$17,$36,$55,$74,$93,$B2,$D1,$F0 
.fb00                              crchi

>fb00  00 10 20 30 40 50 60 70 81 91 a1 b1 c1 d1 e1 f1   .byte $00,$10,$20,$30,$40,$50,$60,$70,$81,$91,$A1,$B1,$C1,$D1,$E1,$F1
>fb10  12 02 32 22 52 42 72 62 93 83 b3 a3 d3 c3 f3 e3   .byte $12,$02,$32,$22,$52,$42,$72,$62,$93,$83,$B3,$A3,$D3,$C3,$F3,$E3
>fb20  24 34 04 14 64 74 44 54 a5 b5 85 95 e5 f5 c5 d5   .byte $24,$34,$04,$14,$64,$74,$44,$54,$A5,$B5,$85,$95,$E5,$F5,$C5,$D5
>fb30  36 26 16 06 76 66 56 46 b7 a7 97 87 f7 e7 d7 c7   .byte $36,$26,$16,$06,$76,$66,$56,$46,$B7,$A7,$97,$87,$F7,$E7,$D7,$C7
>fb40  48 58 68 78 08 18 28 38 c9 d9 e9 f9 89 99 a9 b9   .byte $48,$58,$68,$78,$08,$18,$28,$38,$C9,$D9,$E9,$F9,$89,$99,$A9,$B9
>fb50  5a 4a 7a 6a 1a 0a 3a 2a db cb fb eb 9b 8b bb ab   .byte $5A,$4A,$7A,$6A,$1A,$0A,$3A,$2A,$DB,$CB,$FB,$EB,$9B,$8B,$BB,$AB
>fb60  6c 7c 4c 5c 2c 3c 0c 1c ed fd cd dd ad bd 8d 9d   .byte $6C,$7C,$4C,$5C,$2C,$3C,$0C,$1C,$ED,$FD,$CD,$DD,$AD,$BD,$8D,$9D
>fb70  7e 6e 5e 4e 3e 2e 1e 0e ff ef df cf bf af 9f 8f   .byte $7E,$6E,$5E,$4E,$3E,$2E,$1E,$0E,$FF,$EF,$DF,$CF,$BF,$AF,$9F,$8F
>fb80  91 81 b1 a1 d1 c1 f1 e1 10 00 30 20 50 40 70 60   .byte $91,$81,$B1,$A1,$D1,$C1,$F1,$E1,$10,$00,$30,$20,$50,$40,$70,$60
>fb90  83 93 a3 b3 c3 d3 e3 f3 02 12 22 32 42 52 62 72   .byte $83,$93,$A3,$B3,$C3,$D3,$E3,$F3,$02,$12,$22,$32,$42,$52,$62,$72
>fba0  b5 a5 95 85 f5 e5 d5 c5 34 24 14 04 74 64 54 44   .byte $B5,$A5,$95,$85,$F5,$E5,$D5,$C5,$34,$24,$14,$04,$74,$64,$54,$44
>fbb0  a7 b7 87 97 e7 f7 c7 d7 26 36 06 16 66 76 46 56   .byte $A7,$B7,$87,$97,$E7,$F7,$C7,$D7,$26,$36,$06,$16,$66,$76,$46,$56
>fbc0  d9 c9 f9 e9 99 89 b9 a9 58 48 78 68 18 08 38 28   .byte $D9,$C9,$F9,$E9,$99,$89,$B9,$A9,$58,$48,$78,$68,$18,$08,$38,$28
>fbd0  cb db eb fb 8b 9b ab bb 4a 5a 6a 7a 0a 1a 2a 3a   .byte $CB,$DB,$EB,$FB,$8B,$9B,$AB,$BB,$4A,$5A,$6A,$7A,$0A,$1A,$2A,$3A
>fbe0  fd ed dd cd bd ad 9d 8d 7c 6c 5c 4c 3c 2c 1c 0c   .byte $FD,$ED,$DD,$CD,$BD,$AD,$9D,$8D,$7C,$6C,$5C,$4C,$3C,$2C,$1C,$0C
>fbf0  ef ff cf df af bf 8f 9f 6e 7e 4e 5e 2e 3e 0e 1e   .byte $EF,$FF,$CF,$DF,$AF,$BF,$8F,$9F,$6E,$7E,$4E,$5E,$2E,$3E,$0E,$1E 

.fc00  20 fc fc   jsr $fcfc        XModem		jsr   	prtMsg		; send prompt and info
.fc03  a9 01      lda #$01         		lda   	#$01
.fc05  85 3c      sta $3c          		sta	blkno		; set block # to 1
.fc07  85 3f      sta $3f          		sta	bflag		; set flag to get address from block 1
.fc09  a9 43      lda #$43         StartCrc	lda	#"C"		; "C" start with CRC mode
.fc0b  20 92 e6   jsr $e692        		jsr	output		; send it
.fc0e  a9 ff      lda #$ff         		lda	#$FF	
.fc10  85 3e      sta $3e          		sta	retry2		; set loop counter for ~3 sec delay
.fc12  a9 00      lda #$00         		lda   	#$00
.fc14  85 38      sta $38                          sta	crc
.fc16  85 39      sta $39          		sta	crch		; init CRC value	
.fc18  20 e9 fc   jsr $fce9        		jsr	GetByte		; wait for input
.fc1b  b0 11      bcs $fc2e                        bcs     GotByte         ; byte received, process it
.fc1d  90 ea      bcc $fc09        		bcc	StartCrc	; resend "C"
.fc1f  a9 ff      lda #$ff         StartBlk	lda	#$FF		; 
.fc21  85 3e      sta $3e          		sta	retry2		; set loop counter for ~3 sec delay
.fc23  a9 00      lda #$00         		lda   	#$00		;
.fc25  85 38      sta $38          		sta	crc		;
.fc27  85 39      sta $39          		sta	crch		; init CRC value	
.fc29  20 e9 fc   jsr $fce9        		jsr	GetByte		; get first byte of block
.fc2c  90 f1      bcc $fc1f        		bcc	StartBlk	; timed out, keep waiting...
.fc2e  c9 1b      cmp #$1b         GotByte         cmp     #ESC            ; quitting?
.fc30  d0 01      bne $fc33                        bne     GotByte3
.fc32  00         brk                              brk
.fc33  c9 01      cmp #$01         GotByte3        cmp     #SOH            ; start of block?
.fc35  f0 0e      beq $fc45        		beq	BegBlk		; yes
.fc37  c9 3a      cmp #$3a         		cmp	#":"		; Intel-Hex format - jump to its handler below
.fc39  d0 03      bne $fc3e        		bne	GotByte1	; 
.fc3b  4c 5a fd   jmp $fd5a        		jmp	HexUpLd		; 
.fc3e  c9 04      cmp #$04         GotByte1	cmp	#EOT		;
.fc40  d0 59      bne $fc9b        		bne	BadCrc		; Not SOH, ":", EOT, so flush buffer & send NAK	
.fc42  4c dc fc   jmp $fcdc        		jmp	Done		; EOT - all done!
.fc45  a2 00      ldx #$00         BegBlk		ldx	#$00
.fc47  a9 ff      lda #$ff         GetBlk		lda	#$ff		; 3 sec window to receive characters
.fc49  85 3e      sta $3e          		sta 	retry2		;
.fc4b  20 e9 fc   jsr $fce9        GetBlk1		jsr	GetByte		; get next character
.fc4e  90 4b      bcc $fc9b        		bcc	BadCrc		; chr rcv error, flush and send NAK
.fc50  9d 00 03   sta $0300,x      GetBlk2		sta	Rbuff,x		; good char, save it in the rcv buffer
.fc53  e8         inx              		inx			; inc buffer pointer	
.fc54  e0 84      cpx #$84         		cpx	#$84		; <01> <FE> <128 bytes> <CRCH> <CRCL>
.fc56  d0 ef      bne $fc47        		bne	GetBlk		; get 132 characters
.fc58  a2 00      ldx #$00         		ldx	#$00		;
.fc5a  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get block # from buffer
.fc5d  c5 3c      cmp $3c          		cmp	blkno		; compare to expected block #	
.fc5f  f0 0b      beq $fc6c        		beq	GoodBlk1	; matched!
.fc61  a9 fe      lda #$fe         		lda	#>MsgCrcBadBlkno
.fc63  a2 45      ldx #$45         		ldx	#<MsgCrcBadBlkno
.fc65  20 30 fe   jsr $fe30        		jsr	PrintStrAX	; Unexpected block number - abort	
.fc68  20 40 fd   jsr $fd40        		jsr	Flush		; mismatched - flush buffer and then do BRK
.fc6b  00         brk              		brk			; unexpected block # - fatal error
.fc6c  49 ff      eor #$ff         GoodBlk1	eor	#$ff		; 1's comp of block #
.fc6e  e8         inx              		inx			;
.fc6f  dd 00 03   cmp $0300,x      		cmp	Rbuff,x		; compare with expected 1's comp of block #
.fc72  f0 0b      beq $fc7f        		beq	GoodBlk2 	; matched!
.fc74  a9 fe      lda #$fe         		lda	#>MsgCrcBadBlkno
.fc76  a2 45      ldx #$45         		ldx	#<MsgCrcBadBlkno
.fc78  20 30 fe   jsr $fe30        		jsr	PrintStrAX	; Unexpected block number - abort	
.fc7b  20 40 fd   jsr $fd40        		jsr 	Flush		; mismatched - flush buffer and then do BRK
.fc7e  00         brk              		brk			; bad 1's comp of block#	
.fc7f  a0 02      ldy #$02         GoodBlk2	ldy	#$02		; 
.fc81  b9 00 03   lda $0300,y      CalcCrc		lda	Rbuff,y		; calculate the CRC for the 128 bytes of data	
.fc84  20 4a fd   jsr $fd4a        		jsr	UpdCrc		; could inline sub here for speed
.fc87  c8         iny              		iny			;
.fc88  c0 82      cpy #$82         		cpy	#$82		; 128 bytes
.fc8a  d0 f5      bne $fc81        		bne	CalcCrc		;
.fc8c  b9 00 03   lda $0300,y      		lda	Rbuff,y		; get hi CRC from buffer
.fc8f  c5 39      cmp $39          		cmp	crch		; compare to calculated hi CRC
.fc91  d0 08      bne $fc9b        		bne	BadCrc		; bad crc, send NAK
.fc93  c8         iny              		iny			;
.fc94  b9 00 03   lda $0300,y      		lda	Rbuff,y		; get lo CRC from buffer
.fc97  c5 38      cmp $38          		cmp	crc		; compare to calculated lo CRC
.fc99  f0 0b      beq $fca6        		beq	GoodCrc		; good CRC
.fc9b  20 40 fd   jsr $fd40        BadCrc		jsr	Flush		; flush the input port
.fc9e  a9 15      lda #$15         		lda	#NAK		;
.fca0  20 92 e6   jsr $e692        		jsr	output		; send NAK to resend block
.fca3  4c 1f fc   jmp $fc1f        		jmp	StartBlk	; start over, get the block again			
.fca6  a2 02      ldx #$02         GoodCrc		ldx	#$02		;
.fca8  a5 3c      lda $3c          		lda	blkno		; get the block number
.fcaa  c9 01      cmp #$01         		cmp	#$01		; 1st block?
.fcac  d0 12      bne $fcc0        		bne	CopyBlk		; no, copy all 128 bytes
.fcae  a5 3f      lda $3f          		lda	bflag		; is it really block 1, not block 257, 513 etc.
.fcb0  f0 0e      beq $fcc0        		beq	CopyBlk		; no, copy all 128 bytes
.fcb2  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get target address from 1st 2 bytes of blk 1
.fcb5  85 3a      sta $3a          		sta	ptr		; save lo address
.fcb7  e8         inx              		inx			;
.fcb8  bd 00 03   lda $0300,x      		lda	Rbuff,x		; get hi address
.fcbb  85 3b      sta $3b          		sta	ptr+1		; save it
.fcbd  e8         inx              		inx			; point to first byte of data
.fcbe  c6 3f      dec $3f          		dec	bflag		; set the flag so we won't get another address		
.fcc0  a0 00      ldy #$00         CopyBlk		ldy	#$00		; set offset to zero
.fcc2  bd 00 03   lda $0300,x      CopyBlk3	lda	Rbuff,x		; get data byte from buffer
.fcc5  91 3a      sta ($3a),y      		sta	(ptr),y		; save to target
.fcc7  e6 3a      inc $3a          		inc	ptr		; point to next address
.fcc9  d0 02      bne $fccd        		bne	CopyBlk4	; did it step over page boundry?
.fccb  e6 3b      inc $3b          		inc	ptr+1		; adjust high address for page crossing
.fccd  e8         inx              CopyBlk4	inx			; point to next data byte
.fcce  e0 82      cpx #$82         		cpx	#$82		; is it the last byte
.fcd0  d0 f0      bne $fcc2        		bne	CopyBlk3	; no, get the next one
.fcd2  e6 3c      inc $3c          IncBlk		inc	blkno		; done.  Inc the block #
.fcd4  a9 06      lda #$06         		lda	#ACK		; send ACK
.fcd6  20 92 e6   jsr $e692        		jsr	output
.fcd9  4c 1f fc   jmp $fc1f        		jmp	StartBlk	; get next block
.fcdc  a9 06      lda #$06         Done		lda	#ACK		; last block, send ACK and exit.
.fcde  20 92 e6   jsr $e692        		jsr	output
.fce1  a9 fe      lda #$fe         		lda	#>MsgCrcDone
.fce3  a2 75      ldx #$75         		ldx	#<MsgCrcDone
.fce5  20 30 fe   jsr $fe30        		jsr	PrintStrAX	;
.fce8  60         rts              		rts			;
.fce9  a9 00      lda #$00         GetByte		lda	#$00		; wait for chr input and cycle timing loop
.fceb  85 3d      sta $3d          		sta	retry		; set low value of timing loop
.fced  20 8f e6   jsr $e68f        StartCrcLp	jsr	Scan_Input	; get chr from serial port, don't wait 
.fcf0  b0 09      bcs $fcfb        		bcs	GetByte1	; got one, so exit
.fcf2  c6 3d      dec $3d          		dec   	retry		; no character received, so dec counter
.fcf4  d0 f7      bne $fced        		bne	StartCrcLp	;
.fcf6  c6 3e      dec $3e          		dec	retry2		; dec hi byte of counter
.fcf8  d0 f3      bne $fced        		bne	StartCrcLp	; look for character again
.fcfa  18         clc              		clc			; if loop times out, CLC, else SEC and return
.fcfb  60         rts              GetByte1	rts			; with character in "A"
.fcfc  a2 00      ldx #$00         PrtMsg		ldx	#$00		; PRINT starting message
.fcfe  bd 0b fd   lda $fd0b,x      PrtMsg1		lda   	Msg,x
.fd01  f0 07      beq $fd0a        		beq	PrtMsg2
.fd03  20 92 e6   jsr $e692        		jsr   	output
.fd06  e8         inx              		inx
.fd07  4c fe fc   jmp $fcfe                        jmp     PrtMsg1
.fd0a  60         rts              PrtMsg2		rts

>fd0b  42 65 67 69 6e 20 58 4d 4f 44 45 4d 2f 43 52 43 20 74 72 61 6e 73 66 65 72 2e  Msg             .byte   "Begin XMODEM/CRC transfer."
>fd25  0d 0a                                       .byte   CR,LF
>fd27  50 72 65 73 73 20 3c 45 73 63 3e 20 74 6f 20 61 62 6f 72 74 2e 2e 2e 20                  .byte   "Press <Esc> to abort... "
>fd3f  00                                          .byte   0

.fd40  a9 70      lda #$70         Flush		lda	#$70		; flush receive buffer
.fd42  85 3e      sta $3e          		sta	retry2		; flush until empty for ~1 sec.
.fd44  20 e9 fc   jsr $fce9        Flush1		jsr	GetByte		; read the port
.fd47  b0 f7      bcs $fd40        		bcs	Flush
.fd49  60         rts              		rts	
.fd4a  45 39      eor $39          UpdCrc		eor 	crc+1 		; Quick CRC computation with lookup tables
.fd4c  aa         tax                       	tax		 
.fd4d  a5 38      lda $38                   	lda 	crc
.fd4f  5d 00 fb   eor $fb00,x               	eor 	CRCHI,X
.fd52  85 39      sta $39                   	sta 	crc+1
.fd54  bd 00 fa   lda $fa00,x               	lda 	CRCLO,X
.fd57  85 38      sta $38                   	sta 	crc
.fd59  60         rts                       	rts
.fd5a  a9 0d      lda #$0d         HexUpLd 	lda     #CR
.fd5c  20 92 e6   jsr $e692        		jsr	output
.fd5f  a9 0a      lda #$0a         		lda	#LF
.fd61  20 92 e6   jsr $e692        		jsr	output
.fd64  a9 00      lda #$00         		lda    	#0
.fd66  85 3e      sta $3e                  	sta	dlfail          ;Start by assuming no D/L failure
.fd68  f0 07      beq $fd71        	  	beq	IHex		
.fd6a  20 0a fe   jsr $fe0a        HdwRecs 	jsr     GetSer          ; Wait for start of record mark ':'
.fd6d  c9 3a      cmp #$3a                 	cmp     #":"
.fd6f  d0 f9      bne $fd6a                	bne     HdwRecs         ; not found yet
.fd71  20 13 fe   jsr $fe13        IHex    	jsr     GetHex          ; Get the record length
.fd74  85 39      sta $39                  	sta     reclen          ; save it
.fd76  85 38      sta $38                 	 	sta     chksum          ; and save first byte of checksum
.fd78  20 13 fe   jsr $fe13                	jsr     GetHex          ; Get the high part of start address
.fd7b  85 3c      sta $3c                  	sta     start_hi
.fd7d  18         clc                      	clc
.fd7e  65 38      adc $38                  	adc     chksum          ; Add in the checksum       
.fd80  85 38      sta $38                  	sta     chksum          ; 
.fd82  20 13 fe   jsr $fe13                	jsr     GetHex          ; Get the low part of the start address
.fd85  85 3b      sta $3b                  	sta     start_lo
.fd87  18         clc                      	clc
.fd88  65 38      adc $38                  	adc     chksum
.fd8a  85 38      sta $38                  	sta     chksum  
.fd8c  20 13 fe   jsr $fe13                	jsr     GetHex          ; Get the record type
.fd8f  85 3d      sta $3d                  	sta     rectype         ; & save it
.fd91  18         clc                      	clc
.fd92  65 38      adc $38                  	adc     chksum
.fd94  85 38      sta $38                  	sta     chksum   
.fd96  a5 3d      lda $3d                  	lda     rectype
.fd98  d0 2c      bne $fdc6                	bne     HdEr1           ; end-of-record
.fd9a  a6 39      ldx $39                  	ldx     reclen          ; number of data bytes to write to memory
.fd9c  a0 00      ldy #$00                 	ldy     #0              ; start offset at 0
.fd9e  20 13 fe   jsr $fe13        HdLp1   	jsr     GetHex          ; Get the first/next/last data byte
.fda1  91 3b      sta ($3b),y              	sta     (start_lo),y    ; Save it to RAM
.fda3  18         clc                      	clc
.fda4  65 38      adc $38                  	adc     chksum
.fda6  85 38      sta $38                  	sta     chksum          ; 
.fda8  c8         iny                      	iny                     ; update data pointer
.fda9  ca         dex                      	dex                     ; decrement count
.fdaa  d0 f2      bne $fd9e                	bne     HdLp1
.fdac  20 13 fe   jsr $fe13                	jsr     GetHex          ; get the checksum
.fdaf  18         clc                      	clc
.fdb0  65 38      adc $38                  	adc     chksum
.fdb2  d0 08      bne $fdbc                	bne     HdDlF1          ; If failed, report it
.fdb4  a9 23      lda #$23                 	lda     #"#"            ; Character indicating record OK = '#'
.fdb6  8d 70 7f   sta $7f70                	sta	ACIA1dat        ; write it out but don't wait for output 
.fdb9  4c 6a fd   jmp $fd6a                	jmp     HdwRecs         ; get next record     
.fdbc  a9 46      lda #$46         HdDlF1  	lda     #"F"            ; Character indicating record failure = 'F'
.fdbe  85 3e      sta $3e                  	sta     dlfail          ; upload failed if non-zero
.fdc0  8d 70 7f   sta $7f70                	sta	ACIA1dat        ; write it to transmit buffer register
.fdc3  4c 6a fd   jmp $fd6a                	jmp     HdwRecs         ; wait for next record start
.fdc6  c9 01      cmp #$01         HdEr1   	cmp     #1              ; Check for end-of-record type
.fdc8  f0 1b      beq $fde5                	beq     HdEr2
.fdca  a9 fe      lda #$fe         		lda	#>MsgUnknownRecType
.fdcc  a2 97      ldx #$97         		ldx	#<MsgUnknownRecType
.fdce  20 30 fe   jsr $fe30                        jsr     PrintStrAX      ; Warn user of unknown record type
.fdd1  a5 3d      lda $3d          		lda     rectype         ; Get it
.fdd3  85 3e      sta $3e                  	sta     dlfail          ; non-zero --> upload has failed
.fdd5  20 f7 e5   jsr $e5f7                	jsr     Print1Byte      ; print it
.fdd8  a9 0d      lda #$0d         		lda     #CR		; but we'll let it finish so as not to 
.fdda  20 92 e6   jsr $e692                	jsr     output		; falsely start a new d/l from existing 
.fddd  a9 0a      lda #$0a                 	lda     #LF		; file that may still be coming in for 
.fddf  20 92 e6   jsr $e692                	jsr     output          ; quite some time yet.
.fde2  4c 6a fd   jmp $fd6a        		jmp	HdwRecs
.fde5  20 13 fe   jsr $fe13        HdEr2   	jsr     GetHex          ; get the checksum 
.fde8  18         clc                      	clc
.fde9  65 38      adc $38                  	adc     chksum          ; Add previous checksum accumulator value
.fdeb  f0 07      beq $fdf4                	beq     HdEr3           ; checksum = 0 means we're OK!
.fded  a9 fe      lda #$fe         		lda	#>MsgBadRecChksum
.fdef  a2 b1      ldx #$b1         		ldx	#<MsgBadRecChksum
.fdf1  4c 30 fe   jmp $fe30                        jmp     PrintStrAX
.fdf4  a5 3e      lda $3e          HdEr3   	lda     dlfail
.fdf6  f0 07      beq $fdff                	beq     HdErOK
.fdf8  a9 fe      lda #$fe         		lda	#>MsgUploadFail
.fdfa  a2 ca      ldx #$ca         		ldx	#<MsgUploadFail
.fdfc  4c 30 fe   jmp $fe30                        jmp     PrintStrAX
.fdff  a9 fe      lda #$fe         HdErOK  	lda	#>MsgUploadOK
.fe01  a2 e7      ldx #$e7         		ldx	#<MsgUploadOK
.fe03  20 30 fe   jsr $fe30                        jsr     PrintStrAX
.fe06  20 40 fd   jsr $fd40        	  	jsr     Flush		; flush the input buffer
.fe09  60         rts              HdErNX  	rts
.fe0a  20 8f e6   jsr $e68f        GetSer  	jsr	scan_input	; get input from Serial Port	    
.fe0d  c9 1b      cmp #$1b                         cmp     #ESC            ; check for abort 
.fe0f  d0 01      bne $fe12                	bne     GSerXit         ; return character if not
.fe11  00         brk                              brk
.fe12  60         rts              GSerXit 	rts
.fe13  a9 00      lda #$00         GetHex  	lda     #$00
.fe15  85 3f      sta $3f          	  	sta     temp
.fe17  20 20 fe   jsr $fe20                	jsr     GetNibl
.fe1a  0a         asl                      	asl     a
.fe1b  0a         asl                      	asl     a
.fe1c  0a         asl                      	asl     a
.fe1d  0a         asl                     	 	asl     a       	; This is the upper nibble
.fe1e  85 3f      sta $3f                  	sta     temp
.fe20  20 0a fe   jsr $fe0a        GetNibl 	jsr     GetSer
.fe23  c9 3a      cmp #$3a         	        cmp     #"9"+1  	; See if it's 0-9 or 'A'..'F' (no lowercase yet)
.fe25  90 02      bcc $fe29               	 	bcc     MkNnh   	; If we borrowed, we lost the carry so 0..9
.fe27  e9 08      sbc #$08                 	sbc     #7+1    	; Subtract off extra 7 (sbc subtracts off one less)
.fe29  e9 2f      sbc #$2f         MkNnh   	sbc     #"0"-1  	; subtract off '0' (if carry clear coming in)
.fe2b  29 0f      and #$0f                 	and     #$0F    	; no upper nibble no matter what
.fe2d  05 3f      ora $3f                  	ora     temp
.fe2f  60         rts                      	rts             	; return with the nibble received
.fe30  85 41      sta $41          PrintStrAX      sta     strptr+1
.fe32  86 40      stx $40          		stx	strptr
.fe34  98         tya              		tya
.fe35  48         pha              		pha
.fe36  a0 00      ldy #$00         		ldy	#0
.fe38  b1 40      lda ($40),y      PrintStrAXL1    lda     (strptr),y
.fe3a  f0 06      beq $fe42                        beq     PrintStrAXX1      ; quit if NULL
.fe3c  20 92 e6   jsr $e692            		jsr	output
.fe3f  c8         iny              		iny
.fe40  d0 f6      bne $fe38                        bne     PrintStrAXL1      ; quit if > 255
.fe42  68         pla              PrintStrAXX1    pla
.fe43  a8         tay              		tay
.fe44  60         rts              		rts   

>fe45  0d 0a 0d 0a                 MsgCrcBadBlkno  .byte	CR,LF,CR,LF
>fe49  55 6e 65 78 70 65 63 74 65 64 20 62 6c 6f 63 6b 20 6e 75 6d 62 65 72 20 72 65 63 65 69 76 65 64  		.byte  	"Unexpected block number received"
>fe69  20 41 62 6f 72 74 69 6e 67   		.byte	" Aborting"
>fe72  0d 0a                       		.byte 	CR,LF
>fe74  00                          		.byte 	0
>fe75  0d 0a                       MsgCrcDone	.byte 	CR,LF
>fe77  58 4d 4f 44 45 4d 2d 43 52 43 20 64 6f 77 6e 6c 6f 61 64 20 69 73 20 63 6f 6d 70 6c 65 74 65                  .byte   "XMODEM-CRC download is complete"
>fe96  00                          		.byte 	0
.fe97                              msgunknownrectype
>fe97  0d 0a 0d 0a                 		.byte   CR,LF,CR,LF
>fe9b  55 6e 6b 6e 6f 77 6e 20 72 65 63 6f 72 64 20 74 79 70 65 20 24        		.byte   "Unknown record type $"
>feb0  00                          		.byte	0		; null-terminate every string
>feb1  0d 0a 0d 0a                 MsgBadRecChksum .byte   CR,LF,CR,LF
>feb5  42 61 64 20 72 65 63 6f 72 64 20 63 68 65 63 6b 73 75 6d 21                  .byte   "Bad record checksum!"
>fec9  00                                  	.byte   0		; Null-terminate  
>feca  0d 0a 0d 0a                 MsgUploadFail   .byte   CR,LF,CR,LF
>fece  55 70 6c 6f 61 64 20 46 61 69 6c 65 64 0d 0a                  .byte   "Upload Failed",CR,LF
>fedd  41 62 6f 72 74 69 6e 67 21                  .byte   "Aborting!"
>fee6  00                                          .byte   0               ; null-terminate every string or crash'n'burn
>fee7  0d 0a 0d 0a                 MsgUploadOK	.byte   CR,LF,CR,LF
>feeb  55 70 6c 6f 61 64 20 53 75 63 63 65 73 73 66 75 6c 21                  .byte   "Upload Successful!"
>fefd  00                                  	.byte   0         	

.ff00  78         sei              Reset          SEI                     ; diable interupts
.ff01  d8         cld                             CLD                     ; clear decimal mode                      
.ff02  a2 ff      ldx #$ff                        LDX   #$FF              ;
.ff04  9a         txs                             TXS                     ; init stack pointer
.ff05  a9 7f      lda #$7f         Zeromem        lda   #$7F              ; top page of RAM
.ff07  85 01      sta $01                         sta   $01               ; 
.ff09  a9 00      lda #$00                        lda   #$00              ; top of page & fill chr
.ff0b  85 00      sta $00                         sta   $00               ;
.ff0d  92 00      sta ($00)        Zeromem1       sta   ($00)             ; loop will fill loc 0 of each page then 
.ff0f  c6 00      dec $00                         dec   $00               ; fill from ff->01 of that page
.ff11  d0 fa      bne $ff0d                       bne   zeromem1          ; then will drop one page and fill loc 0
.ff13  c6 01      dec $01                         dec   $01               ; doing that until page is back to FF
.ff15  10 f6      bpl $ff0d                       bpl   Zeromem1          ;
.ff17  85 01      sta $01                         sta   $01               ; fix last byte from ff to 00
.ff19  ad f8 03   lda $03f8        Set_Vectors    lda   RESvector+1       ; reset vector 
.ff1c  49 a5      eor #$a5                        EOR   #$A5              ; on reset, perform code @ label reset
.ff1e  cd f9 03   cmp $03f9                       CMP   RESvector+2       ; if checksm ok, then jmp ind to address
.ff21  f0 10      beq $ff33                       beq   nextvec1          ; else set up to jmp to monitor
.ff23  a2 5e      ldx #$5e                        LDX   #<Start_OS        ; *** only outside reference in reset routine
.ff25  a9 e5      lda #$e5                        LDA   #>Start_OS        ; *** points to Monitor Boot routine
.ff27  a8         tay                             TAY                     ;
.ff28  49 a5      eor #$a5                        EOR   #$A5              ;
.ff2a  8d f9 03   sta $03f9                       sta   RESvector+2       ;
.ff2d  8c f8 03   sty $03f8                       sty   RESvector+1       ;
.ff30  8e f7 03   stx $03f7                       stx   RESvector         ;
.ff33  ad fe 03   lda $03fe        Nextvec1       lda   NMIvector+1       ; set up NMI vectors if checksum invalid
.ff36  49 a5      eor #$a5                        EOR   #$A5              ;  
.ff38  cd ff 03   cmp $03ff                       CMP   NMIvector+2       ;
.ff3b  f0 10      beq $ff4d                       beq   nextvec2          ;
.ff3d  a2 bf      ldx #$bf                        LDX   #<INTret          ; set up to point to RTI command 
.ff3f  a9 ff      lda #$ff                        LDA   #>INTret          ; (no system NMI applications)
.ff41  a8         tay                             TAY                     ;
.ff42  49 a5      eor #$a5                        EOR   #$A5              ;
.ff44  8d ff 03   sta $03ff                       sta   NMIvector+2       ;
.ff47  8c fe 03   sty $03fe                       sty   NMIvector+1       ;
.ff4a  8e fd 03   stx $03fd                       stx   NMIvector         ;
.ff4d  ad fb 03   lda $03fb        Nextvec2       lda   INTvector+1       ;
.ff50  49 a5      eor #$a5                        EOR   #$A5              ;
.ff52  cd fc 03   cmp $03fc                       CMP   INTvector+2       ;
.ff55  f0 10      beq $ff67                       beq   Nextvec3          ;
.ff57  a2 bf      ldx #$bf                        LDX   #<INTret          ; set up to point to RTI command 
.ff59  a9 ff      lda #$ff                        LDA   #>INTret          ; (no system INT applications)
.ff5b  a8         tay                             TAY                     ;
.ff5c  49 a5      eor #$a5                        EOR   #$A5              ;
.ff5e  8d fc 03   sta $03fc                       sta   INTvector+2       ;
.ff61  8c fb 03   sty $03fb                       sty   INTvector+1       ;
.ff64  8e fa 03   stx $03fa                       stx   INTvector         ;
.ff67  ad f5 03   lda $03f5        Nextvec3       lda   BRKvector+1       ;
.ff6a  49 a5      eor #$a5                        EOR   #$A5              ;
.ff6c  cd f6 03   cmp $03f6                       CMP   BRKvector+2       ;
.ff6f  f0 10      beq $ff81                       beq   Nextvec4          ;
.ff71  a2 a3      ldx #$a3                        LDX   #<BRKroutine      ; set up to point to my BRK routine
.ff73  a9 e6      lda #$e6                        LDA   #>BRKroutine      ; 
.ff75  a8         tay                             TAY                     ;
.ff76  49 a5      eor #$a5                        EOR   #$A5              ;
.ff78  8d f6 03   sta $03f6                       sta   BRKvector+2       ;
.ff7b  8c f5 03   sty $03f5                       sty   BRKvector+1       ;
.ff7e  8e f4 03   stx $03f4                       stx   BRKvector         ;
.ff81  a9 44      lda #$44         Nextvec4       lda   #<ACIA1_Scan
.ff83  8d 05 02   sta $0205                       sta   VEC_IN
.ff86  a9 e5      lda #$e5         		   lda   #>ACIA1_Scan
.ff88  8d 06 02   sta $0206                       sta   VEC_IN+1
.ff8b  a9 51      lda #$51         	         lda   #<ACIA1_Output
.ff8d  8d 07 02   sta $0207                       sta   VEC_OUT
.ff90  a9 e5      lda #$e5         		   lda   #>ACIA1_OUTPUT
.ff92  8d 08 02   sta $0208                       sta   VEC_OUT+1
.ff95  a9 2e      lda #$2e         	         lda   #<Psave
.ff97  8d 0b 02   sta $020b                       sta   VEC_SV
.ff9a  a9 e4      lda #$e4         	         lda   #>Psave
.ff9c  8d 0c 02   sta $020c                       sta   VEC_SV+1
.ff9f  a9 57      lda #$57         		   lda   #<pload
.ffa1  8d 09 02   sta $0209                       sta   VEC_LD
.ffa4  a9 e4      lda #$e4         		   lda   #>pload
.ffa6  8d 0a 02   sta $020a                       sta   VEC_LD+1
.ffa9  20 9c e4   jsr $e49c        		   jsr   VIA1_init	   ; init the I/O devices
.ffac  20 b9 e4   jsr $e4b9        		   jsr   VIA2_init	   ; init the I/O devices
.ffaf  20 d6 e4   jsr $e4d6        		   jsr   ACIA1_init	   ; init the I/O devices
.ffb2  a9 00      lda #$00         Clr_regs       lda   #$00              ; Clear registers
.ffb4  a8         tay                             TAY                     ;
.ffb5  aa         tax                             TAX                     ;
.ffb6  18         clc                             CLC                     ; clear flags
.ffb7  d8         cld                             CLD                     ; clear decimal mode
.ffb8  58         cli                             CLI                     ; Enable interrupt system
.ffb9  6c f7 03   jmp ($03f7)                     JMP  (RESvector)        ; Monitor for cold reset                       
.ffbc  6c fd 03   jmp ($03fd)      NMIjump        jmp  (NMIvector)        ;
.ffbf  40         rti              INTret         RTI                     ; Null Interrupt return
.ffc0  da         phx              Interrupt      PHX                     ;
.ffc1  48         pha                             PHA                     ;
.ffc2  ba         tsx                             TSX                     ; get stack pointer
.ffc3  bd 03 01   lda $0103,x                     LDA   $0103,X           ; load INT-P Reg off stack
.ffc6  29 10      and #$10                        AND   #$10              ; mask BRK
.ffc8  d0 05      bne $ffcf                       BNE   BrkCmd            ; BRK CMD
.ffca  68         pla                             PLA                     ;
.ffcb  fa         plx                             PLX                     ;
.ffcc  6c fa 03   jmp ($03fa)                     jmp   (INTvector)       ; let user routine have it 
.ffcf  68         pla              BrkCmd         pla                     ;
.ffd0  fa         plx                             plx                     ;
.ffd1  6c f4 03   jmp ($03f4)                     jmp   (BRKvector)       ; patch in user BRK routine
.ffd4  60         rts              RRTS           rts                     ; documented RTS instruction

>fffa  bc ff                                      .word  NMIjump
>fffc  00 ff                                      .word  Reset 
>fffe  c0 ff                                      .word  Interrupt

--- end of code ---
