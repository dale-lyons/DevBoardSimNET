;********************************************************************************
;		PROGRAM: SDK-85 MONITOR VER 2.1
;
;       	
;		
;		
;		
;
;
;********************************************************************************
;
; ABSTRACT
; ========
;
;	THIS PROGRAM IS A SMALL MONITOR FOR THE INTEL 8085 KIT AND
;	PROVIDES A MINIMUM LEVEL OF UTILITY FUNCTIONS FOR THE USER EMPLOYING
;	EITHER AN INTER-ACTIVE CONSOLE (I.E. TELETYPE) OR THE KIT'S
;	KEYBOARD/LED DISPLAY. THE KEYBOARD MONITOR ALLOWS THE USER TO PERFORM
;	SUCH FUNCTIONS AS MEMORY AND REGISTER MANIPULATION, PROGRAM LOADING,
;	PROGRAM EXECUTION, INTERRUPTION OF AN EXECUTING PROGRAM, AND
;	SYSTEM RESET.
;
;PROGRAM ORGANIZATION
;======= ============
;
;THE PROGRAM IS ORGANIZED AS FOLLOWS:-
;	1) COLD START ROUTINE (RESET)
;	2) WARM START - REGISTER SAVE ROUTINE
;	3) INTERRUPT VECTORS
;	4) KEYBOARD MONITOR
;	5) TTY MONITOR
;	6) LAYOUT OF RAM USAGE
;
;	THE KEYBOARD MONITOR BEGINS WITH THE COMMAND RECOGNIZER, FOLLOWED BY
;	THE COMMAND ROUTINE SECTION, UTILITY ROUTINE SECTION AND MONITOR
;	TABLES. THE COMMAND AND UTILITY ROUTINES ARE IN ALPHABETICAL ORDER
;	WITHIN THEIR RESPECTIVE SECTIONS.
;	THROUGHOUT THE KEYBOARD MONITOR, A COMMENT FIELD BEGINNING
;	WITH "ARG - " INDICATES A STATEMENT WHICH LOADS A VALUE INTO
;	A REGISTER AS AN ARGUMENT FOR A FUNCTION. WHEN THE DESIRED VALUE
;	LIST OF KEYBOARD MONITOR ROUTINES
;
;
;CMMND
;-----
;	EXAM
;	GOCMD
;	SSTEP
;	SUBST
;       -----
;	CLEAR
;	CLDIS
;	CLDST
;	DISPC
;	ERR
;	GTBEX
;	HXDSP
;	ININT
;	INSDG
;	NXTRG
;	OUT PT
;	RDKBD
;	RETF
;	RETT
;	RGLOC
;	RSTOR
;	SETRG
;	UPDAD
;	UPDDT
;
;                           NAME	ADVANCED SDK-85
;
;************************************************************************************
;
;			SET CONDITIONAL ASSEMBLY FLAG
;
;************************************************************************************
;
;
;WAITS SET	0	;0 = N0	WAIT STATES
		        ;1 = A	WAIT STATE IS GENERATED FOR EVERY M CYCLE
		        ;THE APPROPRIATE DELAY TIME MUST BE USED FOR
			;TTY DELAY OR SET UP SINGLE
			;STEP TIMER FOR EACH CASE
;
;
;*************************************************************************************
;
;				MONITOR EQUATES
;
;*************************************************************************************
;
RAMST EQU	2000H	;START ADDRESS OF RAM - THIS PROGRAM ASSUMES
			;THAT 256 BYTES OF RANDOM ACCESS MEMORY BEGIN AT THIS ADDRESS.
			;THE PROGRAM USES STORAGE AT THE END OF THIS SPACE FOR VARIABLES,
			;SAVING REGISTERS AND THE PROGRAM STACK
;
RMUSE		EQU	23	;RAM USAGE- CURRENTLY,23 BYTES ARE USED FOR
				;/SAVING REGISTERS AND VARIABLES
;
SKLN		EQU	24	;MONITOR STACK USAGE- MAX OF 12	LEVELS
;
UBRLN		EQU	15	;5 USER BRANCHES-3 BYTES EACH
;CURDT
ADFLD           EQU	0       ;INDICATES USE OF ADDRESS FIELD OF DISPLAY
ADISP		EQU	90H	;CONTROL CHARACTER TO INDICATE OUTPUT TO
				;/ADDRESS FIELD OF DISPLAY
CNTRL		EQU	1900H	;ADDRESS FOR SENDING CONTROL CHARACTERS TO
				;/DISPLAY CHIP
COMMA   	EQU	11H	;COMMA FROM KEYBOARD
CSNIT		EQU	0	;INITIAL VALUE FOR COMMAND STATUS REGISTER
CSR		EQU	20H	;OUTPUT PORT FOR COMMAND STATUS REGISTER
DDISP		EQU	94H	;CONTROL CHARACTER TO INDICATE OUTPUT TO
				;/DATA FIELD OF DISPLAY
DOT		EQU	1	;INDICATOR FOR DOT IN DISPLAY
DSPLY		EQU	1800H	;ADDRESS FOR SENDING CHARACTERS TO DISPLAY
DTFLD 		EQU	1	;INDICATES USE OF DATA FIELD OF DISPLAY
DTMSK		EQU	08H	;MASK FOR TURNING ON DOT IN DISPLAY
EMPTY		EQU	80H	;HIGH ORDER 1 INDICATES EMPTY INPUT BUFFER
KBNIT		EQU	0CCH	;CONTROL CHARACTER TO SET DISPLAY OUTPUT TO
				;ALL ONES DURING BLANKING PERIOD
KMODE		EQU	0	; CONTROL CHAR. TO SET KEYBOARD/DISPLAY MODE
				;(2 KEY ROLLOVER,8 CHARACTER LEFT ENTRY)
;MNSTK		EQU	RAMST +	256 - RMUSE ;START OF MONITOR STACK
NODOT   	EQU	0	;INDICATOR FOR NO DOT IN DISPLAY
;NUMC-DEFINED LATER		;NUMBER OF COMMANDS
;NUMRG-DEFINED LATER		;NUMBER OF REGISTER SAVE LOCATIONS
PERIO		EQU	10H	;PERIOD FROM KEYBOARD
PRMPT 		EQU	0FBH	;PROMPT CHARACTER FOR DISPLAY	(DASH)
READ		EQU	40H	;CONTROL CHARACTER TO INDICATE INPUT FROM
				;/KEYBOARD
TIMHI		EQU	25H	;OUTPUT PORT FOR HIGH ORDER BYTE OF TIMER VALUE
TIMLO		EQU	24H	;OUTPUT PORT FOR LOW ORDER BYTE OF TIMER VALUE
TMODE 		EQU	40H	;TIMER MODE - SQUARE WAVE, AUTO RELOAD
TSTRT 		EQU	0C0H	;START TIMER
UNMSK		EQU	0EH     ;UNMASK INPUT INTERRUPT
;USRBR 		EQU	RAMST +	256-(RMUSE+ SKLN+UBRLN)	;START OF USER
							;/BRANCH LOCATIONS
;	IF	1-WAITS		;TIMER VALUE FOR SINGLE STEP IF NO WAIT STATE
;TIMER		EQU	197
;	ENDIF
;	IF	WAITS		;TIMER VALUE FOR SINGLE STEP IF ONE WAIT STATE INSERTED
TIMER		EQU	237
;	ENDIF
;
;**************************************************************************************************************
;
;   					MONITOR MACROS
;
;***************************************************************************************************************
;
;	TRUE	MACRO WHERE	;BRANCH IF FUNCTION RETURNS TRUE
;	JC	WHERE
;	ENDM
	;
;	FALSE	MACRO WHERE	;BRANCH IF FUNCTION RETURNS FALSE
;	JNC	WHERE
;	ENDM
;
;
;***************************************************************************************************************
;
;*********  "RESET" KEY ENTRY POINT- COLD START
;********** RST 0 ENTRY POINT
;
	MVI	A,KMODE		;GET CONTROL CHARACTER
	STA	CNTRL		;SET KEYBOARD/DISPLAY MODE
	JMP	CLDST		;GO FINISH COLD START
CLDBK:				;THEN JUMP BACK HERE

;*********  RST 1 ENTRY POINT - WARM START
;
	ORG	8
;       SAVE REGISTERS
	SHLD	LSAV		;SAVE H & L REGISTERS
	POP	H		;GET USER PROGRAM COUNTER FROM TOP OF STACK
	SHLD	PSAV		;/AND SAVE IT
	PUSH	PSW
	POP	H
	SHLD	FSAV		;SAVE FLIP/FLOPS & REGISTER A
	LXI	H,0		;CLEAR H & L
	DAD	SP		;GET USER STACK POINTER
	SHLD	SSAV		;/AND SAVE IT
	LXI	H,BSAV+1	;SET STACK POINTER FOR SAVING
	SPHL			;/REMAINING REGISTERS
	PUSH	B		;SAVE B & C
	PUSH	D		;SAVE D & E
	JMP	RES10		;LEAVE ROOM FOR VECTORED INTERRUPTS
;
;****** TIMER INTERRUPT(TRAP) ENTRY POINT(RST 4.5)
	ORG	24H
	JMP	STP25		;BACK TO SINGLE STEP ROUTINE
;
;****** RST 5 ENTRY POINT
;
	ORG     28H
	JMP	20C2H		;BRANCH TO RST 5 LOCATION IN RAM
;
;****** INPUT INTERRUPT ENTRY POINT(RST	5.5)

	ORG	2CH
	JMP	ININT		;BRANCH TO INPUT INTERRUPT ROUTINE
;
;****** RST 6 ENTRY POINT
;
	ORG	30H
	JMP	20C5H		;BRANCH TO RST 6 LOCATION IN RAM
;
;****** HARD WIRED USER INTERRUPT ENTRY POINT(RST 6.5)
;
	ORG	34H
	JMP	20C8H		;BRANCH TO RST 6.5 LOCATION IN RAM
;
;****** RST 7	ENTRY POINT
;
	ORG	38H
	JMP	20CBH		;BRANCH TO RST 7 LOCATION IN RAM
;
;****** "VECTORED INTERRUPT" KEY ENTRY POINT (RST 7.5)
	ORG	3CH
	JMP	20CEH		;BRANCH TO USER INTERRUPT LOCATION IN RAM
;
RES10:	; CONTINUE SAVING USER STATUS
	RIM			;GET USER INTERRUPT STATUS AND INTERRUPT MASK
	ANI	0FH		;KEEP STATUS & MASK BITS
	STA	ISAV		;SAVE INTERRUPT STATUS & MASK
	MVI	A,UNMSK		;UNMASK INTERRUPTS FOR MONITOR USE
	SIM
	DI			;INTERRUPTS DISABLED WHILE MONITOR IS RUNNING
				;(EXCEPT WHEN WAITING FOR INPUT)
	RIM			;TTY OR KEYBOARD MONITOR?
	RLC			;IS TTY CONNECTED	?
	JC	03FAH		;YES-BRANCH TO TTY MONITOR
				;NO-ENTER KEYBOARD MONITOR
;
;***********************************************************************************************************
;
;				BEGINNING OF KEYBOARD MONITOR CODE
;
;***********************************************************************************************************
;
;	OUTPUTSIGN-ON MESSAGE
	XRA	A		;ARG -USE ADDRESS FIELD OF DISPLAY
	MVI	B,NODOT		;ARG -NO DOT IN ADDRESS FIELD
	LXI	H,SGNAD		;ARG -GET ADDRESS OF ADDRESS FIELD PORTION OF
				;/SIGN-ON MESSAGE
	CALL	OUTPT		;OUTPUT SIGN-ON MESSAGE TO ADDRESS FIELD
	MVI	A,DTFLD		;ARG -USE DATA FIELD OF DISPLAY
	MVI	B,NODOT		;ARG -NO DOT IN DATA FIELD
	LXI	H,SGNDT		;ARG -GET ADDRESS OF DATA FIELD PORTION OF
				;/SIGN-ON MESSAGE
	CALL	OUTPT		;OUTPUT SIGN-ON MESSAGE TO DATA FIELD
	MVI	A,EMPTY
	STA	IBUFF		;SET INPUT BUFFER EMPTY FLAG
;
;****************************************************************************************************
;
;FUNCTION: CMMND-COMMAND RECOGNIZER
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: RDKBD,ERR,SUBST,EXAM,GOCMD,SSTEP
;DESTROYS: A,B,C,D, E,H, L, F/F'S
;
CMMND:
	LXI	H,MNSTK		;INITIALIZE MONITOR STACK POINTER
	SPHL
				;OUTPUT PROMPT CHARACTER TO DISPLAY
	LXI	H,CNTRL		;GET ADDRESS FOR CONTROL CHARACTER
	MVI	M,ADISP		;OUTPUT CONTROL CHARACTER TO USE ADDRESS FIELD
	DCR	H		;ADDRESS FOR OUTPUT CHARACTER
	MVI	M,PRMPT	        ;OUTPUT PROMPT CHARACTER
	CALL	RDKBD		;READ KEYBOARD
	LXI	B,NUMC		;COUNTER FOR NUMBER OF COMMANDS IN C
	LXI	H,CMDTB		;GET ADDRESS OF COMMAND TABLE
CMD10:
	CMP	M		;RECOGNIZE THE COMMAND?
	JZ	CMD15	        ;YES-GO PROCESS IT
	INX	H		;NO-NEXT COMMAND TABLE ENTRY
	DCR	C		;END OF TABLE?
	JNZ	CMD10		;NO-GO CHECK NEXT ENTRY
				;YES-COMMAND UNKNOWN
	JMP	ERR		;DISPLAY ERROR MESSAGE AND GET ANOTHER COMMAND
CMD15:
	LXI	H,CMDAD		;GET ADDRESS OF COMMAND ADDRESS TABLE
	DCR	C		; ADJUST COMMAND COUNTER
		     		;COUNTER ACTS AS POINTER TO COMMAND ADDRESS TABLE
	DAD	B		;ADD POINTER TO TABLE ADDRESS TWICE BECAUSE
	DAD	B	   	;TABLE HAS 2 BYTE ENTRIES
	MOV	A,M		;GET LOW ORDER BYTE OF COMMAND ADDRESS
	INX	H
	MOV	H,M		;GET HIGH ORDER BYTE OF COMMAND ADDRESS IN H
	MOV	L,A		;PUT LOW ORDER BYTE IN L
		;COMMAND ROUTINE ADDRESS IS NOW IN H & L
	PCHL			;BRANCH TO ADDRESS IN H & L
;
;**************************************************************************************************
;
;					COMMAND ROUTINES
;
;**************************************************************************************************
;
;FUNCTION: EXAM	- EXAMINE AND MODIFY REGISTERS
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: CLEAR,SETRG,ERR,RGNAM,RGLOC,UPDDT,GTHEX,NXTRG
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;
EXAM:
	MVI	B,DOT		;ARG - DOT IN ADDRESS FIELD OF DISPLAY
	CALL	CLEAR		;CLEAR DISPLAY
	CALL	SETRG		;GET REGISTER DESIGNATOR FROM KEYBOARD AND
				;/SET REGISTER POINTER ACCORDINGLY
				;WAS CHARACTER A REGISTER DESIGNATOR?
;	FALSE 	ERR		;NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
	JNC	ERR
EXM05:
	CALL	RGNAM		;OUTPUT REGISTER NAME TO ADDRESS FIELD
	CALL	RGLOC		;GET REGISTER SAVE LOCATION IN H & L
	MOV	A,M		;GET REGISTER CONTENTS
	STA	CURDT		;STORE REGISTER CONTENTS AT CURRENT DATA
	MVI	B,DOT		;ARG - DOT IN DATA FIELD
	CALL	UPDDT		;UPDATE DATA FIELD OF DISPLAY
	MVI	B,DTFLD		;ARG - USE DATA FIELD OF DISPLAY
	CALL	GTHEX		;GET HEX DIGITS	- WERE ANY DIGITS RECEIVED?
;	FALSE 	EXM10		;NO-DO NOT UPDATE REGISTER CONTENTS
	JNC	EXM10
	CALL	RGLOC		;YES-GET REGISTER SAVE LOCATION IN H & L
	MOV	M,E		;UPDATE REGISTER CONTENTS
EXM10:
	CPI	PERIO		;WAS LAST CHARACTER A PERIOD ?
	JZ	CLDIS		;YES-CLEAR DISPLAY AND TERMINATE COMMAND
	CPI	COMMA		;WAS LAST CHARACTER ','	?
	JNZ	ERR		;NO-DISPLAY ERROR MSG. AND TERMINATE COMMAND
	CALL	NXTRG		;YES-ADVANCE REGISTER POINTER TO
				;/NEXT REGISTER
				;ANY MORE REGISTERS ?
;	TRUE	EXM05		;YES-CONTINUE PROCESSING WITH NEXT REGISTER
	JC	EXM05
	JMP	CLDIS		;NO-CLEAR DISPLAY AND TERMINATE COMMAND
;
;**********************************************************************************************************
;
;FUNCTION: GOCMD - EXECUTE USER PROGRAM
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: DISPC,RDKBD,CLEAR,GTHEX,ERR,OUTPT
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;
GOCMD:
	CALL	DISPC		;DISPLAY USER PROGRAM COUNTER
	CALL	RDKBD		;READ FROM KEYBOARD
	CPI	PERIO		;IS CHARACTER A PERIOD	?
	JZ	G10		;YES-GO EXECUTE THE COMMAND
				;NO-ARG-CHARACTER IS STILL IN A
	STA	IBUFF		;REPLACE CHARACTER IN INPUT BUFFER
	MVI	B,DOT		;ARG-DOT IN ADDRESS FIELD
	CALL	CLEAR		;CLEAR DISPLAY
	MVI	B,ADFLD		;ARG-USE ADDRESS FIELD
	CALL	GTHEX		;GET HEX DIGITS
	CPI	PERIO		;WAS LAST CHARACTER A PERIOD?
	JNZ	ERR		;NO- DISPLAY ERROR MSG. AND TERMINATE COMMAND
	XCHG			;PUT HEX VALUE FROM GTHEX TO H & L
	SHLD	PSAV		;HEXVALUE IS NEW USER PC
G10:
	MVI	B,NODOT  	;YES-ARG - NO DOT IN ADDRESS FIELD
	CALL	CLEAR		;CLEAR DISPLAY
	XRA	A		;ARG- USE ADDRESS FIELD OF DISPLAY
	MVI	B,NODOT		;ARG- NO DOT IN ADDRESS FIELD
	LXI	H,EXMSG		;GET ADDRESS OF EXECUTION MESSAGE IN H & L
	CALL	OUTPT		;DISPLAY EXECUTION MESSAGE
	JMP	RSTOR		;RESTORE USER REGISTERS INCL. PROGRAM COUNTER
				;/I.E. BEGIN EXECUTION OF USER PROGRAM
;
;************************************************************************************************************
;
;FUNCTION: SSTEP - SINGLE STEP	(EXECUTE ONE USER INSTRUCTION)
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: DISPC,RDKBD,CLEAR,GTHEX,ERR
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;
SSTEP:
	CALL	DISPC		;DISPLAY USER PROGRAM COUNTER
	CALL	RDKBD		;READ FROM KEYBOARD
	CPI	PERIO		;WAS CHARACTER A PERIOD	?
	JZ	CLDIS		;YES-CLEAR DISPLAY AND TERMINATE COMMAND
	CPI	COMMA		;WAS LAST CHARACTER ','	?
	JZ	STP20		;YES-GO SET TIMER
	; NO-CHARACTERFROM KEYBOARD WAS NEITHER PERIOD NOR COMMA
	STA	IBUFF		;REPLACE THE CHARACTER IN THE INPUT BUFFER
	MVI	B,DOT		;ARG-DOT IN ADDRESS FIELD
	CALL	CLEAR		;CLEAR DISPLAY
	MVI	B,ADFLD		;ARG-USE ADDRESS FIELD OF DISPLAY
	CALL	GTHEX		;GET HEX DIGITS-WERE ANY DIGITS RECEIVED?
;	FALSE	ERR		;NO-DISPLAY ERROR MSG. AND TERMINATE COMMAND
	JNC	ERR
	XCHG			;HEX VALUE FROM GTHEX TO H & L
	SHLD	PSAV		;HEX VALUE IS NEW USER PC
	CPI	PERIO		;WAS LAST CHARACTER FROM GTHEX A PERIOD	?
	JZ	CLDIS		;YES-CLEAR DISPLAY AND TERMINATE COMMAND
				;NO-MUST HAVE BEEN A COMMA
STP20:
	LDA	ISAV		;GET USER INTERRUPT MASK
	ANI	08H		;KEEP INTERRUPT STATUS
	STA	TEMP		;SAVE USER INTERRUPT STATUS
	LHLD	PSAV		;GET USER PC
	MOV	A,M		;GET USER INSTRUCTION
	CPI	0F3H		;DI INSTRUCTION	?
	JNZ	STP21		;NO
	XRA	A		;YES-RESET USER INTERRUPT STATUS
	JMP	STP22
STP21:
	CPI	0FBH		;EI INSTRUCTION	?
	JNZ	STP23		;NO
	MVI	A,08H		;YES-SET USER INTERRUPT STATUS
STP22:
	STA	TEMP		;SAVE NEW USER INTERRUPT STATUS
STP23:
	MVI	A,040H  ;(TIMER SHR 8) OR TMODE ;HIGH ORDER BITS OF TIMER VALUE
				         ;/OR'ED WITH TIMER MODE
	OUT	TIMHI
	MVI	A,0C5H  ;TIMER AND OFFH ; LOW ORDER BITS OF TIMER VALUE
	OUT	TIMLO
	LDA	USCSR		;GET USER IMAGE OF WHAT'S IN CSR
	ORI	TSTRT		;SET TIMER COMMAND BITS TO START TIMER
	OUT	CSR		;START TIMER
	JMP	RSTOR		;RESTORE USER REGISTERS
;
STP25:				;BRANCH HERE WHEN TIMER INTERRUPTS AFTER
				;/ONE USER INSTRUCTION
	PUSH	PSW		;SAVE PSW
	LDA	USCSR		;GET USER IMAGE OF WHAT'S IN CSR
	ANI	3FH		;CLEAR 2 HIGH ORDER BITS
	ORI	40H		;SET TIMER STOP BIT
	OUT	CSR		;STOP TIMER
	POP	PSW		;RETRIEVE PSW
	SHLD	LSAV		;SAVE H & L
	POP	H		;GET USER PROGRAM COUNTER FROM TOP OF STACK
	SHLD	PSAV		;SAVE USER PC
	PUSH	PSW
	POP	H
	SHLD	FSAV		;SAVE FLIP/FLOPS AND A REGISTER
	LXI	H,0		;CLEAR H & L
	DAD	SP		;GET USER STACK POINTER
	SHLD	SSAV		;SAVE USER STACK POINTER
	LXI	H,BSAV+1	;SET MONITOR STACK POINTER FOR
	SPHL			;/SAVING REMAINING USER REGISTERS
	PUSH	B		;SAVE B & C
	PUSH	D		;SAVE D & E
	RIM			;GET USER INTERRUPT MASK
	ANI	07H		;KEEP MASK BITS
	LXI	H,TEMP		;GET USER INTERRUPT STATUS
	ORA	M		;OR IT INTO MASK
	STA	ISAV		;SAVE INTERRUPT STATUS & MASK
	MVI	A,UNMSK		;UNMASK INTERRUPTS FOR MONITOR USE
	db	030h
;	SIM
	JMP	SSTEP		;GO GET READY FOR ANOTHER INSTRUCTION
;
;**********************************************************************************************
;
;FUNCTION: SUBST - SUBSTITUTE MEMORY
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: CLEAR, GTHEX,UPDAD, UPDDT,ERR
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;
SUBST:
	MVI	B,DOT		;ARG-DOT IN ADDRESS FIELD
	CALL	CLEAR		;CLEAR THE DISPLAY
	MVI	B,ADFLD		;ARG-USE ADDRESS FIELD OF DISPLAY
	CALL	GTHEX		;GET HEX DIGITS	- WERE ANY DIGITS RECEIVED?
;	FALSE	ERR		;NO-DISPLAY ERROR MSG. AND TERMINATE COMMAND
	JNC	ERR
	XCHG			;ASSIGN HEX VALUE RETURNED BY GTHEX TO
	SHLD	CURAD		;/CURRENT ADDRESS
SUB05:
	CPI	COMMA		;WAS ',' THE LAST CHARACTER FROM KEYBOARD?
	JNZ	SUB15		;NO-GO TERMINATE THE COMMAND
	MVI	B,NODOT		;ARG- NO DOT IN ADDRESS FIELD
	CALL	UPDAD		;UPDATE ADDRESS FIELD OF DISPLAY
	LHLD	CURAD		;GET CURRENT ADDRESS IN H & L
	MOV	A,M		;GET DATA BYTE POINTED TO BY CURRENT ADDRESS
	STA	CURDT		;STORE DATA BYTE AT CURRENT DATA
	MVI	B,DOT		;ARG-DOT IN DATA FIELD
	CALL	UPDDT		;UPDATE DATA FIELD OF DISPLAY
	MVI	B,DTFLD		;ARG-USE DATA FIELD
	CALL	GTHEX		;GET HEX DIGITS	- WERE ANY HEX DIGITS RECEIVED?
	PUSH	PSW		;(SAVE LAST CHARACTER)
;	FALSE 	SUB10		;NO-LEAVE DATA UNCHANGED AT CURRENT ADDRESS
	JNC	SUB10
	LHLD	CURAD		;YES-GET CURRENT ADDRESS IN H & L
	MOV	M,E		;STORE NEW DATA AT CURRENT ADDRESS
		;MAKE SURE DATA WAS ACTUALLY STORED IN CASE
		;/CURRENT ADDRESS IS IN ROM OR IS NON-EXISTANI
	MOV	A,E		;DATA TO A FOR COMPARISON
	CMP	M		;WAS DATA STORED CORRECTLY?
	JNZ	ERR		;NO - DISPLAY ERROR MSG. AND TERMINATE COMMAND
SUB10:
	LHLD	CURAD		;INCREMENT CURRENT ADDRESS
	INX	H
	SHLD	CURAD
	POP	PSW		;RETRIEVE LAST CHARACTER
	JMP	SUB05
SUB15:
	CPI	PERIO		;WAS LAST CHARACTER '.'	?
	JNZ	ERR		;NO-DISPLAY ERROR MSG. AND TERMINATE COMMAND
	JMP	CLDIS		;YES-CLEAR DISPLAY AND TERMINATE COMMAND
;
;
;*****************************************************************************************************************
;
;					UTILITY ROUTINES
;
;*****************************************************************************************************************
;
;FUNCTION: CLEAR - CLEAR THE DISPLAY
;INPUTS: B	- DOT FLAG -	1 MEANS PUT DOT IN ADDRESS FIELD OF DISPLAY
;			   -	0 MEANS NO DOT
;OUTPUTS: NONE
;CALLS: OUTPT
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	CLEAR SENDS BLANK CHARACTERS TO BOTH THE ADDRESS FIELD
;		AND THE DATA FIELD OF THE DISPLAY. IF THE DOT FLAG IS
;		SET THEN A DOT WILL APPEAR AT THE RIGHT EDGE OF THE
;		ADDRESS FIELD.
;
CLEAR:
	XRA	A		;ARG - USE ADDRESS FIELD OF DISPLAY
				;ARG - FLAG FOR DOT IN ADDR. FIELD IS IN B
	LXI	H,BLNKS		;ARG - ADDRESS OF BLANKS FOR DISPLAY
	CALL	OUTPT		;OUTPUT BLANKS TO ADDRESS FIELD
	MVI	A,DTFLD 	;ARG - USE DATA FIELD OF DISPLAY
	MVI	B,NODOT 	;ARG - NO DOT IN DATA FIELD
	LXI	H,BLNKS		;ARG - ADDRESS OF BLANKS FOR DISPLAY
	CALL	OUTPT		;OUTPUT BLANKS TO DATA FIELD
	RET			;RETURN
;
;************************************************************************************************
;
;FUNCTION: CLDIS - CLEAR DISPLAY AND TERMINATE COMMAND
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: CLEAR
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	CLDIS IS JUMPED TO BY COMMAND ROUTINES WISHING TO
;		TERMINATE NORMALLY. CLDIS CLEARS THE DISPLAY AND
;		BRANCHES TO THE COMMAND RECOGNIZER.
;
CLDIS:
	MVI	B,NODOT 	;ARG - NO DOT IN ADDRESS FIELD
	CALL	CLEAR		;CLEAR THE DISPLAY
	JMP	CMMND		;GO GET ANOTHER COMMAND
;
;*************************************************************************************************************
;
;FUNCTION: CLDST - COLD START
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: NOTHING
;DESTROYS: A
;DESCRIPTION:	CLDST IS JUMPED TO BY THE MAIN COLD START PROCEDURE,
;		COMPLETES COLD START INITIALIZATION, AID JUMPS BACK
;		TO THE MAIN COLD START PROCEDURE.
;
CLDST:
	MVI	A,KBNIT		;GET CONTROL CHARACTER
	STA	CNTRL		;INITIALIZE KEYBOARD/DISPLAY BLANKING
	MVI	A,CSNIT		;INITIAL VALUE OF COMMAND STATUS REGISTER
	OUT	CSR		;INITIALIZE CSR
	STA	USCSR		;INITIALIZE USER CSR VALUE
	JMP	CLDBK		;BACK TO MAIN PROCEDURE
;
;*******************************************************************************************
;
;FUNCTION: DISPC - DISPLAY PROGRAM COUNTER
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: UPDAD,UPDDT
; DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	DISPC DISPLAYS THE USER PROGRAM COUNTER IN THE ADDRESS
;		FIELD OF THE DISPLAY, WITH A DOT AT THE RIGHT EDGE
;		OF THE FIELD. THE BYTE OF DATA ADDRESSED BY THE PROGRAM
;		COUNTER IS DISPLAYED IN THE DATA FIELD OF THE DISPLAY.
;
DISPC:
	LHLD	PSAV		;GETUSER PROGRAM COUNTER
	SHLD	CURAD		;MAKEIT THE CURRENT ADDRESS
	MOV	A,M		;GETTHE INSTRUCTION AT THAT ADDRESS
	STA	CURDT		;MAKEIT THE CURRENT DATA
	MVI	B,DOT		;ARG- DOT IN ADDRESS FIELD
	CALL	UPDAD		;UPDATE ADDRESS FIELD OF DISPLAY
	MVI	B,NODOT		;ARG - NO DOT IN DATA FIELD
	CALL	UPDDT		;UPDATE DATA FIELD OF DISPLAY
	RET
;
;****************************************************************************************************************
;
;FUNCTION: ERR - DISPLAY ERROR MESSAGE
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: OUTPT
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	ERR IS JUMPED TO BY COMMAND ROUTINES WISHING TO
;		TERMINATE BECAUSE OF AN ERROR.
;		ERR OUTPUTS AN ERROR MESSAGE TO THE DISPLAY AND
;		BRANCHES TO THE COMMAND RECOGNIZER.

ERR:
	XRA	A		;ARG - USE ADDRESS FIELD
	MVI	B,NODOT		;ARG - NO DOT IN ADDRESS FIELD
	LXI	H,ERMSG		;ARG - ADDRESS OF ERROR MESSAGE
	CALL	OUTPT		;OUTPUT ERROR MESSAGE TO ADDRESS FIELD
	MVI	A,DTFLD		;ARG - USE DATA FIELD
	MVI	B,NODOT		;ARG - NO DOT IN DATA FIELD
	LXI	H,BLNKS		;ARG - ADDRESS OF BLANKS FOR DISPLAY
	CALL	OUTPT		;OUTPUT BLANKS TO DATA FIELD
	JMP	CMMND		;GO GET A NEW COMMAND
;
;*****************************************************************************************************************
;
;FUNCTION: GTHEX - GET HEX DIGITS
;INPUTS: B- DISPLAY FLAG - 0 MEANS USE ADDRESS FIELD OF DISPLAY
;	                - 1 MEANS USE DATA FIELD OF DISPLAY
;OUTPUTS: A  - LAST CHARACTER READ FROM KEYBOARD
;	  DE - HEX DIGITS FROM KEYBOARD EVALUATED MODULO  2**16
;         CARRY - SET IF AT LEAST ONE VALID HEX DIGIT WAS READ
;               - RESET OTHERWISE
;CALLS: RDKBD,INSDG,HXDSP,OUTPT
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	GTHEX ACCEPTS A STRING OF HEX DIGITS FROM THE KEYBOARD,
;		DISPLAYS THEM AS THEY ARE RECEIVED, AND RETURNS THEIR
;		VALUE AS A 16	BIT INTEGER. IF MORE THAN 4 HEX DIGITS
;		ARE RECEIVED, ONLY THE LAST 4 ARE USED. IF THE DISPLAY
;		FLAG IS SET, THE LAST 2 HEX DIGITS ARE DISPLAYED IN THE
;		DATA FIELD OF THE DISPLAY. OTHERWISE, THE LAST	 4 HEX
;		DIGITS ARE DISPLAYED IN THE ADDRESS FIELD OF THE
;		DISPLAY. IN EITHER CASE, A DOT WILL BE DISPLAYED AT THE
;		RIGHTMOST EDGE OF THE FIELD. A CHARACTER WHICH IS NOT
;		A HEX DIGIT TERMINATES THE STRING AND IS RETURNED AS
;		AN OUTPUT OF THE FUNCTION. IF THE TERMINATOR IS NOT
;		A PERIOD OR A COMMA THEN ANY HEX DIGITS WHICH MAY HAVE
;		BEEN RECEIVED ARE CONSIDERED TO BE INVALID. THE
;		FUNCTION RETURNS A FLAG INDICATING WHETHER OR NOT ANY
;		VALID HEX DIGITS WERE RECEIVED.

GTHEX:
	MVI	C,0		;RESET HEX DIGIT FLAG
	PUSH	B		;SAVE DISPLAY AND HEX DIGIT FLAGS
	LXI	D,0		;SET HEX VALUE TO ZERO
	PUSH	D		;SAVE HEX VALUE
GTH05:
	CALL	RDKBD		;READ KEYBOARD
	CPI	10H		;IS CHARACTER A HEX DIGIT?
	JNC	GTH20		;NO-GO CHECK FOR TERMINATOR
				;YES- ARG - NEW HEX DIGIT IS IN A
	POP	D		;ARG - RETRIEVE HEX VALUE
	CALL	INSDG		;INSERT NEW DIGIT IN HEX VALUE
	POP	B		;RETRIEVE DISPLAY FLAG
	MVI	C,1		; SET HEX DIGIT FLAG
				;/(I.E. A HEX DIGIT HAS BEEN READ)
	PUSH	B		;SAVE DISPLAY AND HEX DIGIT FLAGS
	PUSH	D		;SAVE HEX VALUE
	MOV	A,B		;TEST DISPLAY FLAG
	RRC			;SHOULD ADDRESS FIELD OF DISPLAY BE USED?
	JNC	GTH10		;YES- USE HEX VALUE AS IS
				;NO- ONLY LOW ORDER BYTE OF HEX VALUE SHOULD
				;/BE USED FOR DATA FIELD OF DISPLAY
	MOV	D,E		;PUT LOW ORDER BYTE OF HEX VALUE IN D
GTH10:
				;ARG - HEX VALUE TO BE EXPANDED IS IN D & E
	CALL	HXDSP		;EXPAND HEX VALUE FOR DISPLAY
				;ARG - ADDRESS OF EXPANDED HEX VALUE IN H & L
	MOV	A,B		;ARG - PUT DISPLAY FLAG IN A
	MVI	B,DOT		;ARG - DOT IN APPROPRIATE FIELD
	CALL	OUTPT		;OUTPUT HEX VALUE TO DISPLAY
	JMP	GTH05		;GO GET NEXT CHARACTER
GTH20:				;LAST CHARACTER WAS NOT A HEX DIGIT
	POP	D		;RETRIEVE HEX VALUE
	POP	B		;RETRIEVE HEX DIGIT FLAG IN C
	CPI	COMMA		;WAS LAST CHARACTER ' '?
	JZ	GTH25		;YES	- READY TO RETURN
	CPI	PERIO		;NO - WAS LAST CHARACTER '.'?
	JZ	GTH25		;YES - READY TO RETURN
				; NO - INVALID TERMINATOR - IGNORE ANY HEX DIGITS READ
	LXI	D,0		;SET HEX VALUE TO ZERO
	JMP	RETF		;RETURN FALSE
GTH25:
	MOV	B,A		;SAVE LAST CHARACTER
	MOV	A,C		;SHIFT HEX DIGIT FLAG TO
	RRC			;/CARRY BIT
	MOV	A,B		;RESTORE LAST CHARACTER
	RET			;RETURN
;
;*****************************************************************************************************************
;
;FUNCTION: HXDSP - EXPAND HEX DIGITS FOR DISPLAY
;INPUTS: DE -4	HEX DIGITS
;OUTPUTS: HL - ADDRESS OF OUTPUT BUFFER
;CALLS: NOTHING
;DESTROYS: A,H,L,F/F'S
;DESCRIPTION: 	HXDSP EXPANDS EACH INPUT BYTE TO 2 BYTES IN A FORM
;		SUITABLE FOR DISPLAY BY THE OUTPUT ROUTINES. EACH INPUT
;		BYTE IS DIVIDED INTO 2 HEX DIGITS. EACH HEX DIGIT IS
;		PLACED IN THE LOW ORDER 4 BITS OF A BYTE WHOSE HIGH
;		ORDER 4	BITS ARE SET TO ZERO. THE RESULTING BYTE IS
;		STORED IN THE OUTPUT BUFFER. THE FUNCTION RETURNS THE
;		ADDRESS OF THE OUTPUT BUFFER.
;
HXDSP:
	MOV	A,D		;GET FIRST DATA BYTE
	RRC			;CONVERT 4 HIGH ORDER BITS
	RRC			;/TO A SINGLE CHARACTER
	RRC
	RRC
	ANI	0FH
	LXI	H,OBUFF		; GET ADDRESS OF OUTPUT BUFFER
	MOV	M,A		;STORE CHARACTER IN OUTPUT BUFFER
	MOV	A,D		;GET FIRST DATA BYTE AND CONVERT 4 LOW ORDER
	ANI	0FH		;/BITS TO A SINGLE CHARACTER
	INX	H		;NEXT BUFFER POSITION
	MOV	M,A		;STORE CHARACTER IN BUFFER
	MOV	A,E		;GET SECOND DATA BYTE
	RRC			;CONVERT 4 HIGH ORDER BITS
	RRC			;/TO A SINGLE CHARACTER
	RRC
	RRC
	ANI	0FH
	INX	H		;NEXT BUFFER POSITION
	MOV	M,A		;STORE CHARACTER IN BUFFER
	MOV	A,E		;GET SECOND DATA BYTE AND CONVERT LOW ORDER
	ANI	0FH		;/4 BITS TO A SINGLE CHARACTER
	INX	H		;NEXT BUFFER POSITION
	MOV	M,A		;STORE CHARACTER IN BUFFER
	LXI	H,OBUFF		;RETURN ADDRESS OF OUTPUT BUFFER IN H & L
	RET
;
;********************************************************************************************************************
;
;FUNCTION: ININT- INPUT INTERRUPT PROCESSING
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: NOTHING
;DESTROYS: NOTHING
;DESCRIPTION: 	ININT IS ENTERED BY MEANS OF AN INTERRUPT VECTOR	(IV2C)
;		WHEN THE READ KEYBOARD ROUTINE IS WAITING FOR A
;		CHARACTER AND THE USER HAS PRESSED A KEY ON THE
;		KEYBOARD(EXCEPT "RESET" OR "VECTORED INTERRUPT").
;		ININT STORES THE INPUT CHARACTER IN THE INPUT BUFFER AND
;		RETURNS CONTROL TO THE READ KEYBOARD ROUTINE.
;
ININT:
	PUSH	H		;SAVE H & L
	PUSH	PSW		;SAVE F/F'S & REGISTER A
	LXI	H,CNTRL		;ADDRESS FOR CONTROL CHARACTER OUTPUT
	MVI	M,READ		;OUTPUT CONTROL CHARACTER FOR READING
				;/FROM KEYBOARD
	DCR	H		;ADDRESS FOR CHARACTER INPUT
	MOV	A,M		;READ A CHARACTER
	ANI	3FH		;ZERO 2 HIGH ORDER BITS
	STA	IBUFF		;STORE CHARACTER IN INPUT BUFFER
	POP	PSW		;RESTORE F/F'S & REGISTER A
	POP	H		;RESTORE H & L
	RET
;
;**************************************************************************************************************************
;
;FUNCTION: INSDG - INSERT HEX DIGIT
;INPUTS: A HEX DIGIT TO BE INSERTED
;	 DE - HEX VALUE
;OUTPUTS: DE - HEX VALUE WITH DIGIT INSERTED
;CALLS: NOTHING
;DESTROYS: A,F/F'S
;DESCRIPTION: 	INSDG SHIFTS THE CONTENTS OF D & E LEFT	4 BITS
;		(1 HEX DIGIT) AND INSERTS THE HEX DIGIT IN A IN THE LOW
;		ORDER DIGIT POSITION OF THE RESULT. A IS ASSUMED TO
;		CONTAIN A SINGLE HEX DIGIT IN THE LOW ORDER 4 BITS AND
;		ZEROS IN THE HIGH ORDER	4 BITS.
;
INSDG:
	XCHG			;PUT D & E IN H & L
	DAD	H		;SHIFT H & L LEFT 4 BITS
	DAD	H
	DAD	H
	DAD	H
	ADD	L		;INSERT LOW ORDER DIGIT
	MOV	L,A
	XCHG			;PUT H & L BACK IN D & E
	RET
;
;******************************************************************************************************************
;
;FUNCTION: NXTRG - ADVANCE REGISTER POINTER TO NEXT REGISTER
;INPUTS: NONE
;OUTPUTS: CARRY	- 1 IF POINTER IS ADVANCED SUCCESSFULLY
;		  0 OTHERWISE
;CALLS: NOTHING
;DESTROYS: A,F/F'S
;DESCRIPTION: 	IF THE REGISTER POINTER POINTS TO THE LAST REGISTER IN
;		THE EXAMINE REGISTER SEQUENCE, THE POINTER IS NOT
;		CHANGED AND THE FUNCTION RETURNS FALSE. IF THE REGISTER
;		POINTER DOES NOT POINT TO THE LAST REGISTER THEN THE
;		POINTER IS ADVANCED TO THE NEXT REGISTER IN THE SEQUENCE
;		AND THE FUNCTION RETURNS TRUE.
;
NXTRG:
	LDA	RGPTR		;GET REGISTER POINTER
	CPI	NUMRG-1		;DOES POINTER POINT TO LAST REGISTER?
	JNC	RETF		;YES- UNABLE TO ADVANCE POINTER - RETURN FALSE
	INR	A		;NO - ADVANCE REGISTER POINTER
	STA	RGPTR		;SAVE REGISTER POINTER
	JMP	RETT		;RETURN TRUE
;
;***********************************************************************************************************************
;
;FUNCTION: OUTPT - OUTPUT CHARACTERS TO DISPLAY
;INPUTS:    A - DISPLAY FLAG -	0 = USE ADDRESS FIELD
;				1 = USE DATA FIELD
;           B - DOT FLAG     -	1 = OUTPUT DOT AT RIGHT EDGE OF FIELD
;			        0 = NO DOT
;           HL- ADDRESS OF CHARACTERS TO BE OUTPUT
;CALLS: NOTHING
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	OUTPT SENDS CHARACTERS TO THE DISPLAY. THE ADDRESS
;		OF THE CHARACTERS IS RECEIVED AS AN ARGUMENT. EITHER
;		2 CHARACTERS ARE SENT TO THE DATA FIELD, OR 4 CHARACTERS
;		ARE SENT TO THE ADDRESS FIELD, DEPENDING ON THE
;		DISPLAY FLAG ARGUMENT. THE DOT FLAG ARGUMENT DETERMINES
;		WHETHER OR NOT A DOT(DECIMAL POINT) WILL BE SENT
;		ALONG WITH THE LAST OUTPUT CHARACTER.
;
OUTPT:
	RRC		 	;USE DATA FIELD	?
	JC	OUT05		;YES - GO SET UP TO USE DATA FIELD
	MVI	C,4		;NO - COUNT FOR ADDRESS FIELD
	MVI	A,ADISP		;CONTROL CHARACTER FOR OUTPUT TO ADDRESS
				;/FIELD OF DISPLAY
	JMP	OUT10
OUT05:
	MVI	C,2		;COUNT FOR DATA FIELD
	MVI	A,DDISP		;CONTROL CHARACTER FOR OUTPUT TO DATA FIELD
				;/OF DISPLAY
OUT10:
	STA	CNTRL
OUT15:
	MOV	A,M		;GET OUTPUT CHARACTER
	XCHG			;SAVE OUTPUT CHARACTER ADDRESS IN D & E
	LXI	H,DSPTB		;GET DISPLAY FORMAT TABLE ADDRESS
	ADD	L		;USE OUTPUT CHARACTER AS A POINTER TO
	MOV	L,A		;/DISPLAY FORMAT TABLE
	MOV	A,M		;GET DISPLAY FORMAT CHARACTER FROM TABLE
	MOV	H,C		;TEST COUNTER WITHOUT CHANGING IT
	DCR	H		;IS THIS THE LAST CHARACTER ?
	JNZ	OUT20		;NO - GO OUTPUT CHARACTER AS IS
	DCR	B		;YES - IS DOT FLAG SET	?
	JNZ	OUT20		;NO - GO OUTPUT CHARACTER AS IS
	ORI	DTMSK		;YES - OR IN MASK TO DISPLAY DOT WITH
				;/LAST CHARACTER
OUT20:
	CMA			;COMPLEMENT OUTPUT CHARACTER
	STA	DSPLY		;SEND CHARACTER TO DISPLAY
	XCHG			;RETRIEVE OUTPUT CHARACTER ADDRESS
	INX	H		;NEXT OUTPUT CHARACTER
	DCR	C		;ANY MORE OUTPUT CHARACTERS ?
	JNZ	OUT15		;YES - GO PROCESS ANOTHER CHARACTER
	RET			;NO - RETURN
;
;*****************************************************************************************************************
;
;FUNCTION: RDKBD - READ KEYBOARD
;INPUTS: NONE
;OUTPUTS: A - CHARACTER READ FROM KEYBOARD
;CALLS: NOTHING
;DESTROYS: A,H,L,F/F'S
;DESCRIPTION: 	RDKBD DETERMINES WHETHER OR NOT THERE IS A CHARACTER IN
;		THE INPUT BUFFER. IF NOT, THE FUNCTION ENABLES
;		INTERRUPTS AND LOOPS UNTIL THE INPUT INTERRUPT
;		ROUTINE STORES A CHARACTER IN THE BUFFER. WHEN
;		THE BUFFER CONTAINS A CHARACTER, THE FUNCTION FLAGS
;		THE BUFFER AS EMPTY AND RETURNS THE CHARACTER
;		AS OUTPUT.
;
RDKBD:
	LXI	H,IBUFF		;GET INPUT BUFFER ADDRESS
	MOV	A,M		;GET BUFFER CONTENTS
				;HIGH ORDER BIT -1 MEANS BUFFER IS EMPTY
	ORA	A		;IS A CHARACTER AVAILABLE ?
	JP	RDK10		;YES - EXIT FROM LOOP
	EI	;NO - READY FOR CHARACTER FROM KEYBOARD
	JMP	RDKBD
RDK10:
	MVI	M,EMPTY		;SET BUFFER EMPTY FLAG
	DI			;RETURN WITH INTERRUPTS DISABLED
	RET
;
;********************************************************************************************************************
;
;FUNCTION: RETF - RETURN FALSE
;INPUTS: NONE
;OUTPUTS: CARRY	0 (FALSE)
;CALLS: NOTHING
;DESTROYS: CARRY
;DESCRIPTION:	RETF IS JUMPED TO BY FUNCTIONS WISHING TO RETURN FALSE.
;		RETF RESETS CARRY TO 0	AND RETURNS TO THE CALLER OF
;		THE ROUTINE INVOKING RETF.
;
RETF:
	STC		;SET CARRY TRUE
	CMC		;COMPLEMENT CARRY TO MAKE IT FALSE
	RET
;
;************************************************************************************************************************
;
;FUNCTION: RETT RETURN TRUE
;INPUTS: NONE
;OUTPUTS: CARRY	1	(TRUE)
;CALLS: NOTHING
;DESTROYS: CARRY
;DESCRIPTION: 	RETT IS JUMPED TO BY ROUTINES WISHING TO RETURN TRUE.
;		RETT SETS CARRY TO 1	AND RETURNS TO THE CALLER OF
;		THE ROUTINE INVOKING RETT.
;
RETT:
	STC		;SET CARRY TRUE
	RET
;
;***************************************************************************************************************
;
;FUNCTION: RGLOC	- GET REGISTER SAVE LOCATION
;INPUTS: NONE
;OUTPUTS: HL	- REGISTER SAVE LOCATION
;CALLS: NOTHING
;DESTROYS: B,C,H,L,F/F'S
;DESCRIPTION: 	RGLOC RETURNS THE SAVE LOCATION OF THE REGISTER
;		INDICATED BY THE CURRENT REGISTER POINTER VALUE.
;
RGLOC:
	LHLD	RGPTR		;GET REGISTER POINTER
	MVI	H,0		;/IN H & L
	LXI	B,RGTBL		;GET REGISTER SAVE LOCATION TABLE ADDRESS
	DAD	B		;POINTER INDEXES TABLE
	MOV	L,M		;GET LOW ORDER BYTE OF REGISTER SAVE LOC.
	MVI	H,020H    ;(RAMST SHR 8) GET HIGH ORDER BYTE OF
				;/REGISTER SAVE LOCATION
	RET
;
;*****************************************************************************************************************
;
;FUNCTION: RGNAM - DISPLAY REGISTER NAME
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: OUTPT
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	RGNAM DISPLAYS, IN THE ADDRESS FIELD OF THE DISPLAY,
;		THE REGISTER NAME CORRESPONDING TO THE CURRENT
;		REGISTER POINTER VALUE.
;
RGNAM:
	LHLD	RGPTR		;GET REGISTER POINTER
	MVI	H,0
	DAD	H		;MULTIPLY POINTER VALUE BY 4
	DAD	H		;/(REGISTER NAME TABLE HAS 4 BYTE ENTRIES)
	LXI	B,NMTBL		;GET ADDRESS OF START OF REGISTER NAME TABLE
	DAD	B		;ARG - ADD TABLE ADDRESS TO POINTER - RESULT IS
				;/ADDRESS OF APPROPRIATE REGISTER NAME IN H & L
	XRA	A		;ARG - USE ADDRESS FIELD OF DISPLAY
	MVI	B,NODOT		;ARG - NO DOT IN ADDRESS FIELD
	CALL	OUTPT		;OUTPUT REGISTER NAME TO ADDRESS FIELD
	RET
;
;***************************************************************************************************************
;
;FUNCTION: RSTOR - RESTOR USER REGISTERS
;INPUTS: NONE
;OUTPUTS: NONE
;CALLS: NOTHING
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION:	 RSTOR RESTORES ALL CPU REGISTERS, FLIP/FLOPS,
;		INTERRUPT STATUS, INTERRUPT MASK, STACK POINTER
;		AND PROGRAM COUNTER FROM THEIR RESPECTIVE
;		SAVE LOCATIONS IN MEMORY. BY RESTORING THE PROGRAM
;		COUNTER, THE ROUTINE EFFECTIVELY TRANSFERS CONTROL TO
;		THE ADDRESS IN THE PROGRAM COUNTER SAVE LOCATION.
;
;		THE TIMING OF THIS ROUTINE IS CRITICAL TO THE
;		CORRECT OPERATION OF THE SINGLE STEP ROUTINE.
;		IF ANY MODIFICATION CHANGES THE NUMBER OF CPU
;		STATES NEEDED TO EXECUTE THIS ROUTINE THEN THE
;		TIMER VALUE MUST BE ADJUSTED BY THE SAME NUMBER.
;
;*****  THIS IS ALSO THE ENTRY POINT FOR THE TTY MONITOR
	;TO RESTORE REGISTERS.
;
RSTOR:
	LDA	ISAV		;GET USER INTERRUPT MASK
	ORI	18H		;ENABLE SETTING OF INTERRUPT MASK AND
				;/RESET RST7.5	FLIP FLOP
	SIM			;RESTORE USER INTERRUPT MASK
;	RESTORE USER INTERRUPT STATUS
	LDA	ISAV		;GET USER INTERRUPT MASK
	ANI	08H		;SHOULD USER INTERRUPTS BE ENABLED ?
	JZ	RSR05		;NO - LEAVE INTERRUPTS DISABLED
	EI			;YES - ENABLE INTERRUPTS FOR USER PROGRAM
	JMP	RSR10
RSR05:
	STC			;DUMMY INSTRUCTIONS - WHEN SINGLE STEP ROUTINE
	JNC	RSR10		;/IS BEING USED, THE TIMER IS RUNNING AND
				;/EXECUTE TIME FOR THIS ROUTINE MUST NOT
				;/VARY.
RSR10:
	LXI	H,MNSTK		;SET MONITOR STACK POINTER TO START OF STACK
	SPHL			;/WHICH IS ALSO END OF REGISTER SAVE AREA
	POP	D		;RESTORE REGISTERS
	POP	B
	POP	PSW
	LHLD	SSAV		;RESTORE USER STACK POINTER
	SPHL
	LHLD	PSAV
	PUSH	H		;PUT USER PROGRAM COUNTER ON STACK
	LHLD	LSAV		;RESTORE H & L REGISTERS
	RET			;JUMP TO USER PROGRAM COUNTER
;
;********************************************************************************************************************
;
;FUNCTION: SETRG - SET REGISTER POINTER
;INPUTS: NONE
;OUTPUTS: CARRY	- SET IF CHARACTER FROM KEYBOARD IS A REGISTER DESIGNATOR
;		  RESET OTHERWISE
;CALLS: RDKBD
;DESTROYS: A,B,C,H,L,F/F'S
;DESCRIPTION:	SETRG READS A CHARACTER FROM THE KEYBOARD. IF THE
;		CHARACTER IS A REGISTER DESIGNATOR, IT IS CONVERTED TO
;		THE CORRESPONDING REGISTER POINTER VALUE, THE POINTER IS
;		SAVED, AND THE FUNCTION RETURNS 'TRUE'. OTHERWISE, THE
;		FUNCTION RETURNS 'FALSE'.
;
SETRG:
	CALL	RDKBD		;READ FROM KEYBOARD
	CPI	10H		;IS CHARACTER A DIGIT?
	JNC	RETF		;NO - RETURN FALSE - CHARACTER IS NOT A
				;/REGISTER DESIGNATOR
	SUI	3		;YES - TRY TO CONVERT REGISTER DESIGNATOR TO
				;/INDEX INTO REGISTER POINTER TABLE
				;WAS CONVERSION SUCCESSFUL?
	JC	RETF		;NO - RETURN FALSE
	MOV	C,A		;INDEX TO B & C
	MVI	B,0
	LXI	H,RGPTB		;GET ADDRESS OF REGISTER POINTER TABLE
	DAD	B		;INDEX POINTS INTO TABLE
	MOV	A,M		;GET REGISTER POINTER FROM TABLE
	STA	RGPTR		;SAVE REGISTER POINTER
	JMP	RETT		;RETURN TRUE
;
;*******************************************************************************************************************
;
;FUNCTION: UPDAD - UPDATE ADDRESS FIELD OF DISPLAY
;INPUTS:  B - DOT FLAG - 1  MEANS PUT DOT AT RIGHT EDGE OF FIELD
;	                 0  MEANS NO DOT
;OUTPUTS: NONE
;CALLS: HXDSP,OUTPT
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	UPDAD UPDATES THE ADDRESS FIELD OF THE DISPLAY USING
;		THE CURRENT ADDRESS.
;
UPDAD:
	LHLD	CURAD		;GET CURRENT ADDRESS
	XCHG			;ARG - PUT CURRENT ADDRESS IN D & E
	CALL	HXDSP		;EXPAND CURRENT ADDRESS FOR DISPLAY
				;ARG - ADDRESS OF EXPANDED ADDRESS IS IN H & L
	XRA	A		;ARG	- USE ADDRESS FIELD OF DISPLAY
				;ARG - DOT FLAG IS IN B
	CALL	OUTPT		;OUTPUT CURRENT ADDRESS TO ADDRESS FIELD
	RET
;
;******************************************************************************************************************
;
;FUNCTION: UPDDT - UPDATE DATA FIELD OF DISPLAY
;INPUTS: B - DOT FLAG -	1  MEANS PUT DOT AT RIGHT EDGE OF FIELD
;		        0  MEANS NO DOT
;OUTPUTS: NONE
;CALLS: HXDSP,OUTDT
;DESTROYS: A,B,C,D,E,H,L,F/F'S
;DESCRIPTION: 	UPDDT UPDATES THE DATA FIELD OF THE DISPLAY USING
;		THE CURRENT DATA BYTE.
;
UPDDT:
	LDA	CURDT		;GET CURRENT DATA
	MOV	D,A		;ARG - PUT CURRENT DATA IN D
	CALL	HXDSP		;EXPAND CURRENT DATA FOR DISPLAY
				;ARG - ADDRESS OF EXPANDED DATA IS IN H & L
	MVI	A,DTFLD		;ARG - USE DATA FIELD OF DISPLAY
				;ARG - DOT FLAG IS IN B
	CALL	OUTPT		;OUTPUT CURRENT DATA TO DATA FIELD
	RET
;
;******************************************************************************************************************
;
;					MONITOR TABLES
;
;******************************************************************************************************************
;
;COMMAND TABLE
;       COMMAND CHARACTERS AS RECEIVED FROM KEYBOARD
CMDTB:
	DB	12H		;GO COMMAND
	DB	13H		;SUBSTITUTE MEMORY COMMAND
	DB	14H		;EXAMINE REGISTERS COMMAND
	DB	15H		;SINGLE STEP COMMAND
NUMC	EQU	$-CMDTB		;NUMBER OF COMMANDS
;
;*******************************************************************************************************************
;
; COMMAND ROUTINE ADDRESS TABLE
; (MUST BE IN REVERSE ORDER OF COMMAND TABLE)
CMDAD:
	DW	SSTEP		;ADDRESSOFSINGLE STEP ROUTINE
	DW	EXAM		;ADDRESSOFEXAMINE REGISTERS ROUTINE
	DW	SUBST		;ADDRESSOFSUBSTITUTE MEMORY ROUTINE
	DW	GOCMD		;ADDRESSOFGO ROUTINE
;
;*******************************************************************************************************************
;
DSPTB:				; TABLE FOR TRANSLATING CHARACTERS FOR OUTPUT
;
;		DISPLAY
;		FORMAT      	CHARACTER
;		=======		=========
;
ZERO	EQU	$- DSPTB
	DB	0F3H		;0
	DB	 60H		;1
	DB	0B5H		;2
	DB	0F4H		;3
	DB	 66H		;4
FIVE	EQU	$- DSPTB
LETRS	EQU	$- DSPTB
	DB	0D6H		;5 AND S
	DB	0D7H		;6
	DB	 70H		;7
EIGHT	EQU	$- DSPTB
	DB	0F7H		;8
	DB	 76H		;9
LETRA   EQU	$- DSPTB
	DB	 77H		;A
LETRB	EQU	$- DSPTB
	DB	0C7H		;B(LOWER CASE)
LETRC	EQU	$- DSPTB
	DB	 93H		;C
LETRD	EQU	$- DSPTB
	DB	0E5H		;D(LOWER CASE)
LETRE	EQU	$- DSPTB
	DB	 97H		;E
LETRF   EQU	$- DSPTB
	DB	 17H		;F
LETRH	EQU	$- DSPTB
	DB	 67H		;H
LETRL   EQU	$- DSPTB
	DB	 83H	;	;L
LETRP	EQU	$- DSPTB
	DB	 37H		;P
LETRI	EQU	$- DSPTB
	DB	 60H		;I
LETRR	EQU	$- DSPTB
	DB	 05H		;R(LOWER CASE)
BLANK	EQU	$- DSPTB
	DB	 00H		;BLANK
;
;*************************************************************************************************************************
;
;MESSAGES FOR OUTPUT TO DISPLAY
;
BLNKS: DB	BLANK,BLANK,BLANK,BLANK	;FOR ADDRESS OR DATA FIELD
ERMSG: DB	BLANK,LETRE,LETRR,LETRR	;ERROR MESSAGE FOR ADDR. FIELD
EXMSG: DB	LETRE,BLANK,BLANK,BLANK	;EXECUTION MESSAGE
					;/FOR ADDRESS FIELD
SGNAD: DB	BLANK,BLANK,EIGHT,ZERO	;SIGN ON MESSAGE (ADDR. FIELD)
SGNDT: DB	EIGHT,FIVE		;SIGN ON MESSAGE(DATA FIELD)
;
;**************************************************************************************************************************
;
RGPTB:	; REGISTER POINTER TABLE
;		THE ENTRIES IN THIS TABLE ARE IN THE SAME ORDER
;		AS THE REGISTER DESIGNATOR KEYS ON THE KEYBOARD.
;		EACH ENTRY CONTAINS THE REGISTER POINTER VALUE WHICH
;		CORRESPONDS TO THE REGISTER DESIGNATOR. REGISTER
;		POINTER VALUES ARE USED TO POINT INTO THE REGISTER
;		NAME TABLE	(NMTBL) AND REGISTER SAVE LOCATION
;		TABLE	(RGTTL).
;
	DB	6	;INTERRUPTMASK
	DB	9	;SPH
	DB	10	;SPL
	DB	11	;PCH
	DB	12	;PCL
	DB	7	;H
	DB	8	;L
	DB	0	;A
	DB	1	;B
	DB	2	;C
	DB	3	;D
	DB	4	;E
	DB	5	;FLAGS
;
;***********************************************************************************************
;
NMTBL:	;REGISTER NAME TABLE
	;NAMES OF REGISTERS IN DISPLAY FORMAT
	DB	BLANK,BLANK,BLANK,LETRA	;A REGISTER
	DB	BLANK,BLANK,BLANK,LETRB	;B REGISTER
	DB	BLANK,BLANK,BLANK,LETRC	;C REGISTER
	DB	BLANK,BLANK,BLANK,LETRD	;D REGISTER
	DB	BLANK,BLANK,BLANK,LETRE	;E REGISTER
	DB	BLANK,BLANK,BLANK,LETRF	;FLAGS
	DB	BLANK,BLANK,BLANK,LETRI	;INTERRUPT MASK
	DB	BLANK,BLANK,BLANK,LETRH	;H REGISTER
	DB	BLANK,BLANK,BLANK,LETRL	;L REGISTER
	DB	BLANK,LETRS,LETRP,LETRH	;STACK POINTER HIGH ORDER BYTE
	DB	BLANK,LETRS,LETRP,LETRL	;STACK POINTER LOW ORDER BYTE
	DB	BLANK,LETRP,LETRC,LETRH	;PROGRAM COUNTER HIGH BYTE
	DB	BLANK,LETRP,LETRC,LETRL	;PROGRAM COUNTER LOW BYTE
;
;***************************************************************************************************
;
;REGISTER SAVE LOCATION TABLE
;ADDRESSES OF SAVE LOCATIONS OF REGISTERS IN THE ORDER IN WHICH
;THE REGISTERS ARE DISPLAYED BY THE EXAMINE COMMAND
;
RGTBL:
	DB	0EEH		;A REGISTER
	DB	0ECH		;B REGISTER
	DB	0EBH		;C REGISTER
	DB	0EAH		;D REGISTER
	DB	0E9H		;E REGISTER
	DB	0EDH		;FLAGS
	DB	0F1H		;INTERRUPT MASK
	DB	0F0H		;H REGISTER
	DB	0EFH		;L REGISTER
	DB	0F5H		;STACK POINTER HIGH ORDER BYTE
	DB	0F4H		;STACK POINTER LOW ORDER BYTE
	DB	0F3H		;PROGRAM COUNTER HIGH ORDER BYTE
	DB	0F2H		;PROGRAM COUNTER LOW ORDER BYTE
NUMRG	EQU	$- RGTBL	;NUMBER OF ENTRIES IN
				;/REGISTER SAVE LOCATION TABLE

CURDT 	EQU 	20F8H
CURAD 	EQU 	20F6H
RGPTR 	EQU	20FDH
LSAV	EQU	20EFH
PSAV	EQU	20F2H
FSAV	EQU	20EDH
SSAV	EQU 	20F4H
IBUFF 	EQU 	20FEH
ISAV 	EQU	20F1H
MNSTK	EQU 	20E9H
OBUFF 	EQU	20F9H
USCSR	EQU	20FFH
;CLDBK	EQU	0008H
BSAV	EQU	20ECH
USRBR	EQU	20C2H
TEMP 	EQU	20FDH
	END
