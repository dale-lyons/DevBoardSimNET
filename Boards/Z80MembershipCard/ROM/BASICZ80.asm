		;*************************************************************
		;                       MICRO-BASIC                          *
		;------------------------------------------------------------*
		;   A SMALL INTEGER BASIC INTERPRETER FOR THE 8080/8085/Z80  *
		;                                D.F. DUNFIELD  JAN 25/1983  *
		;------------------------------------------------------------*
		;Translated to Z80 code for use with Lee Hart's Z80
		;Membership Card.  April 1, 2017 by Josh Bensadon.
		;
		;------------------------------------------------------------*
		;                      BASIC COMMANDS                        *
		;                                                            *
		;  CLEAR,    DATA,     DIM,      END,      BEXIT,     FOR,    *
		;  GOSUB,    GOSUB(N), GOTO,     GOTO(N),  IF/THEN,  INPUT,  *
		;  LET,      LIF/THEN, LIST,     LOAD,     NEW,      NEXT,   *
		;  ORDER,    PLOT,     PRINT,    READ,     REM,      RETURN, *
		;  RUN,      SAVE,     SIZE,     STOP,     USR,      <EDIT>  *
		;------------------------------------------------------------*
		;                     BASIC OPERATORS                        *
		;                                                            *
		; NUMERIC:     + - * % / \ & | ; ( ) < = > == -= <= >=       *
		; CHARACTER:   + = == -=                                     *
		; OTHER:       : # $ @ ? [ ] ( )                             *
		;------------------------------------------------------------*
		;                      BASIC VARIABLES                       *
		;                                                            *
		;     A - Z ......... 16 BIT SIMPLE INTEGER VARIABLES.       *
		;     A$ - Z$ ....... SIMPLE CHARACTER VARIABLES. < 36 CHARS *
		;     A[N] - Z[N] ... 16 BIT INTEGER ARRAYS.                 *
		;     @[N] .......... PSEUDO MEMORY REFERENCE ARRAY.         *
		;     @[N]$ ......... NUMERIC TO CHARACTER CONVERSION.(CHR$) *
		;     ? ............. PSEUDO RANDOM NUMBER GENERATOR.        *
		;------------------------------------------------------------*
		;                        MEMORY MAP                          *
		;                                                            *
		;    0000-03FF     1K SYSTEM MONITOR (IN ROM).               *
		;    0400-0FFF     3K BASIC INTERPRETER (IN ROM).            *
		;    1000-13FF     1K MEMORY MAPPED 64*16 VIDEO DISPLAY      *
		;    1400-15FF     0.5K POINTERS, STACKS, BUFFERS.           *
		;    1600-19FF     1K VARIABLES AND POINTERS.                *
		;    1A00-FFFF     PROGRAM AND ARRAY STORAGE.                *
		;*************************************************************
		;	PAGE
		;
		;*************************************************************
		;                   CONSTANTS AND EQUATES
		;*************************************************************
		;
		; MONITOR ROUTINES
		;
		BINCHR	EQU	0x51		;INPUT ROUTINE ADDRESS
		BPUTCHR EQU	0x45		;OUTPUT ROUTINE ADDRESS
		;CTRLC	EQU	0x27E		;CONTROL-C TEST ROUTINE ADDRESS
		BEXIT	EQU	0x42		;TERMINATION RETURN ADDRESS
		;GETR	EQU	0x2EB		;ROUTINE TO LOAD INTEL HEX FORMAT
		;TDUMP	EQU	0xD6		;ROUTINE TO DUMP IN INTEL HEX FORMAT
		;TON	EQU	0x396		;ROUTINE TO START TAPE
		;TOFF	EQU	0x3A6		;ROUTINE TO STOP TAPE
		;CURPOS	EQU	0x37E		;ROUTINE TO POSITION CURSOR
		BPUTSP	EQU	0x7D		;DISPLAY SPACE ON CONSOLE
		BPUTNL	EQU	0x80		;ROUTINE TO PRINT A <LF>, <CR> ON TERMINAL
		PRINTM	EQU	0x57		;DISPLAY'S MSGM UP TO ZERO OR <CR>
		;CR	EQU	0x0D
		;LF	EQU	0x0A
		; MEMORY ALLOCATION
		BUFF	EQU	0x8000		;START OF RAM, INPUT BUFFER
		IOCON	EQU	BUFF+0xFF	;INPUT/OUTPUT CONFIGURATION
		USROUT	EQU	IOCON-2		;USER SUPPLIED OUTPUT DEVICE VECTOR
		CURSOR	EQU	USROUT-2	;CURSOR POSITION
		LSTCHR	EQU	CURSOR-2	;CHARACTER UNDER CURSOR
		STACK	EQU	LSTCHR-2	;MACHINE STACK
		TB	EQU	BUFF+50		;TEMPORARY TEXT BUFFER
		XBF	EQU	TB+50		;EXTRA TEXT BUFFER
		EDBUF	EQU	BUFF+256	;EDIT BUFFER
		CS	EQU	EDBUF+0xFA	;CONTROL STACK SPACE
		CSP	EQU	CS+1		;CONTROL STACK POINTER
		ARYLOC	EQU	CSP+2		;LOCATION OF ARRAYS
		SEED	EQU	ARYLOC+1	;RANDOM NUMBER SEED
		VARS	EQU	SEED+2		;VARIABLE SPACE
		RFLAG	EQU	VARS+52		;PROGRAM RUNNING FLAG
		IFLAG	EQU	RFLAG+1		;INPUTTING FLAG
		PP	EQU	IFLAG+1		;POINTER TO END OF EXPRESSION
		EFLAG	EQU	PP+1		;ASSIGNMENT FLAG
		DATA	EQU	EFLAG+1		;READ/DATA POINTER
		LAST	EQU	DATA+2		;LAST FREE ARRAY SPACE
		SIGT	EQU	LAST+2		;SIGNATURE TO PREVENT CLEARING OF PROGRAM
		TEMP	EQU	SIGT+2		;TEMPORARY STORAGE
		TEXT	EQU	VARS+1024	;PROGRAM AND ARRAY STORAGE
		NEGTEXT EQU     0x007a
		DELETE	EQU	0x7F		;DELETE CHARACTER
		;	PAGE
		;
		;*******************************************************************
		; START OF MAIN PROGRAM, FIRST INITIALIZE, INSURING WE DON'T THINK *
		; WE HAVE A VALID PROGRAM, ALSO CLEAR OUT HIS VARIABLES AND ARRAYS *
		;*******************************************************************
		;
		;	ORG	0x8000		;FOLLOW MONITOR
		BASIC	LD	HL,INTRO	;ADDRESS OF 'INTRO' MESSAGE
			CALL	PRINTM		;TELL HIM WHO WROTE THIS!
			LD	HL,(SIGT)	;CHECK IF RAM IS SIGNED
			LD	DE,0x1369
			XOR	A
			SBC	HL,DE
			JR Z,	INIT		;JUMP IF SIGNATURE, IE DON'T INIT TEXT SPACE
			
			LD	(SIGT),DE	;SIGN RAM FOR NEXT TIME
		NEW	LD	A,0xFF		;INDICATES END OF PROGRAM
			LD	(TEXT), A	;INITIALIZE TO NO PROGRAM
		RESV	CALL	CLEAR		;CLEAR OUT HIS VARIABLES
		; RESET FLAGS, AND PROMPT WITH 'READY', SO HE WILL KNOW WE ARE LISTENING
		INIT	LD	HL,0		;GET DOUBLE BYTE ZERO
			LD	(RFLAG), HL	;INDICATE NOT RUNNING, AND NOT INPUT
			LD	(PP), HL		;INDICATE NO ASSIGNMENT DONE
			LD	HL,RDY		;ADDRESS OF 'READY' MESSAGE
			CALL	PRINTM		;TELL HIM WE ARE READY
		; GET A LINE FROM CONSOLE, AND SEE WHAT HE WANTS
		TOP	LD	SP,STACK	;FIX UP STACK IN CASE WE ABORTED SOMETHING
			
			LD	HL,RC_TYPE	;Check Auto Boot
			BIT	7,(HL)
			RES	7,(HL)
			JP  NZ,	RUN
			
			CALL	GLINE		;LET HIM GIVE US A LINE
			CP	CR		;DID HE ONLY PRESS RETURN
			JP Z,	TOP		;NOT GOOD ENOUGH, MAKE HIM TRY AGAIN
			CALL	NUM		;DID HIS LINE START WITH A NUMBER
			JP NC,	EDIT		;IF SO, HE IS WRITING A PROGRAM!!!
		; LOOK UP COMMAND AND EXECUTE
			LD	BC,INIT		;ADDRESS TO RETURN TO
			PUSH	BC		;SAVE SO WE CAN RETURN
			LD	HL,KTAB-1	;POINT TO COMMAND TABLE
		;
		; LOCATES COMMAND POINTED TO BY D-E IN THE COMMAND TABLE POINTED TO BY H-L
		; AND CHAINS TO THE COMMAND PROCESSING CODE FOR THAT COMMAND
		;
		CMD	CALL	PARSE1		;ADVANCE TO NEXT CHARACTER
		TLP0	PUSH	DE		;SAVE POINTER TO START OF COMMAND
		CMDL	INC	HL		;ADVANCE IN TABLE
			LD	A, (DE)		;GET DATA FROM COMMAND
			CP	(HL)		;COMPARE WITH TABLE CONTENTS
			INC	DE		;ADVANCE IN COMMAND
			JP Z,	CMDL		;IF SAME, KEEP TESTING
		; DIDN'T MATCH, SEE IF IT'S END OF WORD (HIGH BIT SET)
			OR	0x80		;ARE WE AT END?
			CP	(HL)		;AND IS IT THIS ONE?
			JP Z,	GOTCMD		;IF SO, WE HAVE IT
		; WASN'T THAT ENTRY, KEEP LOOKING
			SUB	A		;SEE IT THIS IS END OF TABLE
			CP	(HL)		;ARE WE AT END?
			JP Z,	GOTDEF		;IF SO, WE WILL SAY WE FOUND
			POP	DE		;RESTORE POINTER TO COMMAND
		CMD1	OR	(HL)		;TEST FOR AT END OF TABLE ENTRY
			INC	HL		;POINT TO NEXT
			JP P,	CMD1		;IF NO, KEEP LOOKING
			INC	HL		;SKIP FIRST ADDRESS BYTE
			JP	TLP0		;TEST THIS ENTRY
		; WE HIT THE END OF THE TABLE, ASSUME THE DEFAULT ADDRESS (LET)
		GOTDEF	DEC	DE		;BACKUP TO START OF WORD
		; WE MATCHED ALL THE WAY TO THE END OF A COMMAND WORD, GET IT'S ADDRESS
		GOTCMD	INC	HL		;POINT TO ADDRESS BYTE
			LD	C,(HL)		;SAVE TEMPORARY
			INC	HL		;POINT TO NEXT ADDRESS BYTE
			LD	H,(HL)		;GET LOW ADDRESS
			LD	L,C		;GET HIGH ADDRESS
			EX	(SP), HL	
			JP	PARSE1		;SKIP TO NEXT NON-BLANK, AND CHAIN TO CODE
		;
		;***************************************************************
		;              ERROR CHECKING AND HANDLING CODE
		;***************************************************************
		;
		; VCHAR... TESTS FOR A VALID VARIABLE, SYNTAX ERROR IF NOT
		;
		VCHAR	CALL	CHAR		;TEST VARIABLE
			RET NC			;IF OK, GO BACK
		;
		; SYNTAX ERROR... HE'S NOT MAKEING ANY SENSE AT ALL
		; ISSUE NASTY MESSAGE TO STRAIGHTEN HIM OUT
		;
		SYNT	LD	HL,SYN		;GET NASTY 'SYNTAX' MESSAGE
			DEC	DE		;BACK UP IN SOURCE SO WE DONT SAY WRONG LINE
		;
		; ERROR STUFF... SOMETHING HAS GONE WRONG... TELL HIM THE BAD NEWS AND
		; QUIT ANYTHING THAT WE MAY HAVE STARTED, SO THAT THINGS CAN'T GET WORSE
		; ALSO, IF WE WERE RUNNING, GIVE HIM THE LINE NUMBER AS A CLUE
		;
		ERR	LD	A,'?'		;PRECEDE ERROR MESSAGE BY '?'
			CALL	BPUTCHR	;DISPLAY ON TERMINAL
			LD	A, (IFLAG)	;WERE WE TRYING TO 'INPUT' SOMETHING)
			AND	A		;IF WE WERE, THEN ..
			JP NZ,	INERR		;SPECIAL MESSAGE + HANDLEING
		; NOW THAT WE HAVE FIGURED OUT WHAT'S GOING ON, LET HIM IN ON IT
			CALL	PRINTM		;PRINT ERROR MESSAGE
			LD	HL,EM		;FOLLOWED BY..
		; PRINT MESSAGE FOLLOWED BY LINE NUMBER (ALSO USED BY 'STOP IN LINE XXXX')
		PERR	CALL	PRINTM		;THE ' ERROR ' PART
			LD	A, (RFLAG)	;WERE WE RUNNING..
			AND	A		;IF NOT,
			JP Z,	INLF		;THEN THATS ALL WE HAVE TO DO
		; DISPLAY LINE NUMBER OF RUNNING PROGRAM
			LD	HL,INL		;ADDRESS OF 'IN LINE ' MESSAGE
			CALL	PRINTM		;DISPLAY FOR HIM
		; FIND START OF OUR LINE, AND DISPLAY LINE NUMBER
		FSOL	DEC	DE		;BACK UP IN SOURCE
			LD	A,D		;GET HIGH BYTE OF ADDRESS
			CP	HIGH TEXT	;TEST FOR BEYOND BEGINNING
			JP C,	STLIN		;AT START OF LINE
			LD	A, (DE)		;GET CHARACTER FROM BUFER
			CP	CR		;TEST FOR CARRIAGE RETURN
			JP NZ,	FSOL		;IF NOT, KEEP LOOKING
		STLIN	INC	DE		;ADVANCE IN SOURCE
			EX	DE, HL	
			CALL	PNUM		;PRINT AND BUFFER LINE NUMBER
		; COPY LINE WITH ERROR INTO OLD LINE EDIT BUFFER, INCASE HE WANTS TO FIX IT
		FIXIT	INC	HL		;SKIP LENGTH BYTE, ADVANCE TO NEXT IN SOURCE
			LD	A,(HL)		;GET CHARACTER FROM LINE
			LD	(DE), A		;SAVE IN BUFFER
			INC	DE		;ADVANCE TO NEXT IN BUFFER
			CP	CR		;TEST FOR END-OF-LINE
			JP NZ,	FIXIT		;IF NOT, KEEP COPYING
		; WAIT FOR CONSOLE INPUT, ON A NEW LINE
		INLF	CALL	BPUTNL		;ADVANCE A LINE ON HIS TERMINAL
			CALL	RESET		;RESET DATA POINTER AND CONTROL-STACK
			JP	INIT		;GET NEXT COMMAND
		;
		; SUBROUTINE TEST FOR VALID ASCII DIGIT (0-9), RETURNS WITH C=1 IF NOT
		;
		NUM	CP	'0'		;TEST FOR < '0'
			RET C			;IF SO, BAD DIGIT
			CP	'9'+1		;TEST FOR >'9'
			CCF			;INVERT LOGIC, C=1 IF BAD
			RET
		;
		;***************************************************************
		;                    TEXT EDITING ROUTINES
		;***************************************************************
		;
		; SUBROUTINE TO GET AND EDIT COMMAND LINE FROM TERMINAL
		;
		BADLN	CALL	BPUTNL		;ADVANCE TO NEW LINE
		GLINE	LD	DE,BUFF		;POINT TO INPUT BUFFER
			LD	HL,EDBUF	;POINT TO EDIT BUFFER
			LD	B,E		;CLEAR INSERT FLAG (LOW ADR OF BUFFER IS ZERO)
		LOOP1	LD	A,E		;GET LOW ADDRESS OF OUR POSITION
			AND	A		;TEST FOR NEGATIVE
			JP M,	BADLN		;IF SO, HE'S DELETED BEYOND START OF BUFFER
			CALL	BGETCHR		;GET A CHARACTER
			CP	3		;TEST FOR CONTROL-C (CANCEL)
			JP Z,	INLF		;IF SO, ABORT BACK TO COMMAND HANDLER
			CP	6		;TEST FOR CONTROL-F (FIND COMMAND)
			JP Z,	GFIND		;EXECUTE FIND
			CP	1		;TEST FOR CONTROL-A (ADVANCE COMMAND)
			JP Z,	GADV		;EXECUTE ADVANCE
			CP	9		;TEST FOR CONTROL-I (TOGGLE INSERT MODE)
			JP Z,	GINST		;TOGGLE INSERT MODE
			CP	4		;TEST FOR CONTROL-D (DELETE CHARACTER.)
			JP Z,	GRUB		;ERASE CHARACTER
			CP	' '		;TEST FOR CONTROL-CHARACTER
			JP NC,	OKPRT		;IF NOT, OK TO PROCESS
			CP	CR		;CARRIAGE RETURN IS OK,
			JP Z,	OKPRT		;SO PROCESS IT
			CP	8		;SO IS A BACKSPACE
			JP NZ,	LOOP1		;ANYTHING ELSE SHOULD BE IGNORED
		; WE HAVE GOTTEN A VALID CHARACTER
		OKPRT	CP	DELETE		;TEST FOR DELETE CHARACTER
			JP NZ,	RECT		;IF IT IS A DELETE,
			LD	A,8		;MAKE IT INTO A BACKSPACE
		RECT	LD	C,A		;COPY INTO C
			CALL	BPUTCHR		;DISPLAY ON TERMINAL
			DEC	DE		;ASSUME DELETE (BACKSPACE)
		; DON'T DELETE CHARS FROM OLD LINE BUFFER IF WE ARE INSERTING
			OR	B		;TEST INSERT FLAG
			JP M,	IND		;IF NOT, WE ARE INSERTING
			DEC	HL		;REDUCE OLD BUFFER POSITION
		IND	LD	A,C		;GET CHARACTER BACK
			CP	8		;TEST FOR DELETE (BACKSPACE)
			JP Z,	LOOP1		;IF SO, WE WERE RIGHT, GET NEXT CHARACTER
			INC	DE		;FIX OUR MISTAKE (NOT DELETE)
			LD	(DE), A		;SAVE CHARACTER IN BUFFER)
		; DON'T MOVE OLD LINE POINTER IF WE ARE INSERTING
			OR	B		;TEST INSERT FLAG
			JP M,	INOK		;IF SO, DON'T INCREMENT
			INC	HL		;ADVANCE IN OLD LINE BUFFER
			LD	A,(HL)		;GET CHARACTER FROM OLD LINE
			CP	CR		;TEST FOR END OF OLD LINE
			JP Z,	INOK		;IF SO, DON'T GO PAST IT
			INC	HL		;ADVANCE TO NEXT CHARACTER OF OLD LINE
		INOK	LD	A,C		;GET CHARACTER BACK
			INC	DE		;ADVANCE POINTER IN NEW LINE
			CP	CR		;TEST FOR CARRAIGE RETURN (END OF LINE)
			JP NZ,	LOOP1		;IF NOT, KEEP GETTING CHARACTERS
			CALL	BPUTNL		;PRINT LINE-FEED CARRIAGE RETURN
		; COPY NEW LINE INTO OLD LINE BUFFER (MAKEING IT THE 'NEW' OLD LINE)
			LD	DE,BUFF		;POINT BACK TO NEW LINE BUFFER
			PUSH	DE		;SAVE BUFFER ADDRESS
			LD	HL,EDBUF	;POINT TO OLD LINE BUFFER
		MOVL	LD	A, (DE)		;GET CHARACTER FROM NEW LINE
			LD	(HL),A		;SAVE IN OLD LINE BUFFER
			INC	HL		;POINT TO NEXT
			INC	DE		;POINT TO NEXT
			CP	CR		;TEST FOR END OF LINE
			JP NZ,	MOVL		;IF NOT, KEEP MOVEING
			POP	DE		;RESTORE BUFFER ADDRESS
			LD	A, (DE)		;AND FIRST CHARACTER FROM IT
			RET
		; COPY ONE CHARACTER FROM OLD LINE TO NEW LINE
		GADV	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
			CP	CR		;INSURE ITS NOT THE END
			JP Z,	LOOP1		;IF SO, IGNORE COMMAND
			OR	B		;TEST INSERT FLAG
			LD	A,(HL)		;GET CHARACTER BACK
			JP P,	RECT		;IF NO INSERT, OK
			INC	HL		;ADVANCE TO NEXT
			JP	RECT		;PASS CHARACTER TO INPUT ROUTINE
		; RUB OUT ONE CHARACTER FROM THE OLD LINE
		GRUB	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
			CP	CR		;TEST FOR END OF LINE
			JP Z,	LOOP1		;IF SO, IGNORE COMMAND
			LD	A,'*'		;INDICATE RUBBED OUT CHARACTER WITH '*'
			CALL	BPUTCHR	;PRINT  IT TO SHOW WHAT WE ARE DOING
			INC	HL		;ADVANCE PASSED CHARACTER (RUBBING IT OUT)
			JP	LOOP1		;RETURN FOR NEXT CHARACTER
		; FIND NEXT CHARACTER IN NEW LINE
		GFIND	CALL	BGETCHR		;GET A CHARACTER
			LD	C,A		;SAVE IN C (TO COMPARE AGAINST.)
			PUSH	HL		;SAVE POSITION IN OLD LINE
		; FIND OUT IF IT IS THERE..
		GF1	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
		GF0	CP	CR		;TEST FOR END OF LINE
			JP Z,	ABFND		;IF SO, WE DIDN'T FIND IT
			INC	HL		;ADVANCE TO NEXT CHARACTER
			LD	A,(HL)		;GET CHARACTER
			CP	C		;TEST FOR CHARACTER WE DESIRE
			JP NZ,	GF0		;IF NOT, KEEP LOOKING
			POP	HL		;RESTORE POSITION ON OLD LINE
		; NOW COPY OLD LINE OVER..
		GF2	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
		GF3	LD	(DE), A		;SAVE IN NEW LINE
			CALL	BPUTCHR	;DISPLAY ON TERMINAL
			INC	HL		;POINT TO NEXT CHAR. IN OLD LINE
			INC	DE		;POINT TO NEXT CHAR IN NEW LINE
			LD	A,(HL)		;GET NEXT CHAR FROM NEW LINE
			CP	C		;TEST FOR CHARACTER WE WANT
			JP NZ,	GF3		;IF NOT, KEEP COPYING
			PUSH	HL		;FIX UP STACK
		ABFND	POP	HL		;RESTORE POSITION IN OLD LINE
			JP	LOOP1		;GET NEXT CHARACTER
		; TOGGLE INSERT MODE
		GINST	LD	A,B		;GET INSERT MODE FLAG
			XOR	0xFF		;COMPLEMENT, SETTING FLAGS
			LD	B,A		;REAVE IN FLAG REGISTER
			LD	A,'<'		;INDICATE ENTERING INSERT MODE
			JP M,	GIN1		;IF SO, INDICATE SO
			LD	A,'>'		;INDICATE LEAVING INSERT
		GIN1	CALL	BPUTCHR	;DISPLAY INDICATOR ON TERMINAL
			JP	LOOP1		;GET NEXT CHARACTER FROM TERMINAL
		;
		; GET A PACKED-DECIMAL LINE NUMBER FROM THE COMMAND BUFFER
		;
		GETLN	LD	HL,0		;START WITH ZERO
		ELOOP	LD	A, (DE)		;GET DIGIT FROM COMMAND BUFFER
			CALL	NUM		;TEST FOR ASCII DIGIT
			RET C			;IF NOT, STOP (WE HAVE IT)
			INC	DE		;ADVANCE TO NEXT BUFFER POSITION
			ADD	HL,HL		;MAKE ROOM FOR DIGIT IN BOTTOM..
			ADD	HL,HL		;OF THE RESULT, BY ..
			ADD	HL,HL		;ROTATING IT..
			ADD	HL,HL		;LEFT BY FOUR BITS
			AND	0x0F		;CONVERT DIGIT TO BINARY
			OR	L		;INSERT INTO LOWER DIGITS OF RESULT
			LD	L,A		;AND REPLACE BYTE IN RESULT WITH NEW VALUE
			JP	ELOOP		;GET NEXT DIGIT
		;
		; LINE EDITOR, EDITS PROGRAM SOURCE BY LINE NUMBER IN COMMAND BUFFER
		;
		EDIT	CALL	LINEF		;LOCATE LINE NUMBER IN SOURCE
			PUSH	HL		;SAVE POINTER INTO TEXT
			JP NZ,	INS		;IF NEW LINE, DON'T TRY TO DELETE
		; DELETE LINE POINTED TO BY H-L
		DEL	LD	D,H		;COPY POINTER INTO
			LD	E,L		;THE D-E PAIR FOR BACKWARDS COPY
			LD	A,CR		;WE ARE LOOKING FOR A CARRIAGE RETURN
		; FIND START OF NEXT LINE
		DELNX	CP	(HL)		;TEST FOR END OF LINE TO DELETE
			INC	HL		;POINT TO NEXT CHARACTER IN SOURCE
			JP NZ,	DELNX		;IF NOT END OF LINE, KEEP LOOKING
		; COPY REST OF PROGRAM BACK OVER DELETED LINE
		DELLP	LD	A,(HL)		;GET CHARACTER FROM NEXT LINE
			LD	(DE), A		;SAVE OVER DELETED LINE
			INC	DE		;POINT TO NEXT IN NEW LINE
			INC	HL		;POINT TO NEXT IN OLD LINE
			INC	A		;TEST FOR END OF FILE
			JP NZ,	DELLP		;IF NOT, KEEP DELETEING
		; INSERT LINE INTO TEXT
		INS	LD	BC,2		;SET LENGTH TO 2 (PACKED DECIMAL NUMBERS ARE 2)
			LD	DE,BUFF		;POINT TO BUFFER (CONTAINING NEW LINE)
		; CALCULATE LENGTH OF LINE
			CALL	GETLN		;REMOVE NUMBERS AS THEY ARE NOT STORED AS TEXT
		ILP	INC	C		;INCREMENT LENGTH
			LD	A, (DE)		;GET CHARACTER FROM NEW LINE (IN BUFFER)
			INC	DE		;POINT TO NEXT CHARACTER FROM NEW LINE
			CP	CR		;TEST FOR END OF LINE
			JP NZ,	ILP		;IF NOT, KEEP COUNTING
			LD	A,C		;GET LENGTH
			POP	HL		;RESTORE POSITION IN TEXT
			CP	3		;TEST FOR NULL LINE
			JP Z,	TOP		;IS SO, DON'T INSERT
		; INSERT NEW LINE INTO TEXT
		INLN	LD	D,H		;SET D-E TO POINT TO
			LD	E,L		;THE LINE POSITION
			CALL	GETEOF		;GET END OF FILE ADDRESS
			INC	HL		;ADVANCE TO FREE BYTE
			PUSH	BC		;SAVE LENGTH
			PUSH	HL		;STACK END OF FILE ADDRESS
			ADD	HL,BC		;ADD LENGTH
			POP	BC		;GET END OF FILE ADDRESS
			INC	HL		;ADVANCE BECAUSE WE DECREMENT
		IL01	DEC	HL		;REDUCE POINTER INTO NEW POSITION
			DEC	BC		;REDUCE POINTER TO OLD POSITION
			LD	A, (BC)		;GET BYTE OF OLD DATA
			LD	(HL),A		;SAVE IN NEW POSITION
			LD	A,C		;GET LOW ADDRESS
			CP	E		;TEST AGAINST WHERE WE ARE GOING
			JP NZ,	IL01		;IF NOT, KEEP COPYING
			LD	A,B		;GET HIGH ADDRESS
			CP	D		;TEST AGAINST DESTINATION
			JP NZ,	IL01		;IF NOT SAME, KEEP COPYING
			LD	DE,BUFF		;GET ADDRESS OF NEW LINE
			CALL	GETLN		;OBTAIN NUMBERS
			LD	A,H		;GET HIGH 2 DIGITS
			LD	(BC), A		;SAVE IN NEW LINE
			INC	BC		;POINT TO NEXT CHARACTER OF NEW LINE
			LD	A,L		;GET LOW DIGITS
			LD	(BC), A		;SAVE IN NEW LINE
			INC	BC		;ADVANCE TO NEXT CHARACTER IN NEW LINE
			POP	HL		;RESTORE LENGTH
			LD	A,L		;GET LENGTH
			ADD	A,0x10		;ADD OFFSET TO MAKE UNIQUE
			LD	(BC), A		;SAVE IN NEW LINE
			INC	BC		;POINT TO NEXT CHARACTER
		IL02	LD	A, (DE)		;GET CHARACTER FROM NEW LINE IN BUFFER
			LD	(BC), A		;SAVE IN TEXT
			INC	BC		;POINT TO NEXT POSITION IN TEXT
			INC	DE		;ADVANCE IN BUFFER
			CP	CR		;TEST FOR END OF LINE
			JP NZ,	IL02		;IF NOT, KEEP LOOKING
		; WE ARE INSERTING OR REPLACEING A LINE, SINCE WE DON'T KNOW HOW MUCH
		; MEMORY IT WILL REQUIRE, WE MUST CLEAR THE ARRAYS, AS THEY FOLLOW THE
		; PROGRAM. WE DO NOT HAVE TO DO THIS WHEN DELETING LINES
			CALL	CLRARY		;CLEAR ARRAYS AND RETURN
			JP	TOP		;GO BACK FOR NEXT COMMAND
		;
		; LOCATE LINE IN TEXT, SYNTAX ERROR IF NOT LINE NUMBER
		;
		FNDLIN	CALL	NUM		;IS IT A VALID NUMBER
			JP C,	SYNT		;IF NOT, IT'S A INVALID
		;
		; FINDS LINE IN PROGRAM TEXT. RETURNS WITH Z FLAG SET IF LINE EXISTS
		; H-L POINTS TO START OF LINE. B-C CONTAINS LINE NUMBER OF ACTUAL
		; LINE FOUND. (IF LINE NOT FOUND, POINTS TO FIRST GREATER LINE NUMBER)
		;
		LINEF	CALL	GETLN		;GET LINE NUMBER FROM COMMAND BUFFER
			EX	DE, HL	
			LD	HL,TEXT		;START AT TOP OF PROGRAM
		TRY	LD	A,(HL)		;GET FIRST CHARACTER FROM PROGRAM LINE
			CP	0xFF		;TEST FOR END OF FILE
			JP Z,	EOF		;IF SO, WE DIDN'T FIND
			INC	HL		;ADVANCE POINTER TO LOW DIGITS
			CP	D		;TEST FOR HIGH DIGITS CORRECT
			JP C,	NEXTL		;IF LESS, FIND NEXT LINE
			JP NZ,	NOTFND		;IF GREATER, LINE WASN'T FOUND
			LD	A,(HL)		;GET LOW DIGITS
			CP	E		;TEST LOW DIGITS
			JP NC,	NOTFND		;IF LESS, LINE IS HERE OR DOSN'T EXIST
		; ADVANCE TO NEXT LINE IN SOURCE
		NEXTL	INC	HL		;POINT TO LINE LENGTH
			LD	A,(HL)		;GET LENGTH
			SUB	0x11		;SUBTRACT OFFSET USED TO MAKE IT UNIQUE
			ADD	A,L		;ADD TO POINTER
			LD	L,A		;AND REPLACE IN POINTER
			JP NC,	TRY		;IF NO CARRY, THATS IT
			INC	HL		;BUMP HIGH ADDRESS
			JP	TRY		;AND TEST THIS LINE
		; LINE IS HERE OR BEFORE
		NOTFND	DEC	HL		;BACK UP TO DIGIT
			LD	C,A		;PLACE LOW ORDER DIGIT IN C
			LD	B,(HL)		;PLACE HIGH ORDER DIGIT IN B
			CP	E		;TEST FOR LINE FOUND
			RET NZ			;IF NOT SAME, RETURN INDICATING SO
			LD	A,B		;GET HIGH DIGIT
			CP	D		;INDICATE IF NUMBERS SAME
			RET
		; LINE WAS GREATER THAN ALL LINES IN PROGRAM, INDICATE EOF REACHED
		EOF	LD	B,A		;RETURN HIGH LINE NUMBER
			AND	A		;INDICATE LINE DOSN'T EXIST
			RET
		;
		; PRINTS PACKED-DECIMAL LINE NUMBER ON TERMINAL, AS WELL AS PLACEING
		; IT AT THE START OF THE EDIT BUFFER
		;
		PNUM	LD	DE,EDBUF	;SET UP POINTER TO EDIT BUFFER
			CALL	HPOUT		;PRINT FIRST TWO DIGITS
		HPOUT	LD	A,(HL)		;GET CONTENTS OF MEMORY
			INC	HL		;AND POINT TO NEXT
			PUSH	AF
			RRCA			;ROTATE
			RRCA			;UPPER DIGIT
			RRCA			;INTO
			RRCA			;LOWER DIGIT
			CALL	POUT		;DISPLAY UPPER DIGIT
			POP	AF
		; DISPLAYS ONE DIGIT
		POUT	AND	0x0F		;REMOVE UPPER GARBAGE
			OR	0x30		;CONVERT TO ASCII DIGIT
			LD	(DE), A		;SAVE IN EDIT BUFFER
			INC	DE		;ADVANCE POINTER IN EDIT BUFFER
			JP	BPUTCHR	;DISPLAY DIGIT ON TERMINAL AND RETURN
		;
		;*****************************************************************
		;                   BASIC COMMAND HANDLERS
		;*****************************************************************
		;
		; IT'S A 'LIST' COMMAND, LETS GIVE HIM A PEEK AT THE SOURCE
		; ALSO PLACE LAST LINE LISTED IN BUFFER, INCASE HE WANTS TO EDIT IT
		;
		LIST:	PUSH	DE		;SAVE PROGRAM POINTER
			LD	HL,TEXT		;START AT THE BEGINNING OF THE PROGRAM
			LD	B,255		;SET ENDING LINE BEYOND END OF TEXT
			LD	A, (DE)		;GET CHARACTER OF OPERAND
			CALL	NUM		;TEST FOR A NUMBER
			JP C,	GO		;IF NOT, LIST WHOLE THING
			CALL	GETLN		;GET LINE NUMBER
			PUSH	HL		;SAVE ON STACK
			INC	DE		;POINT TO NEXT CHARACTER
			CP	','		;TEST FOR ENDING NUMBER
			CALL Z,	LINEF		;IF SO, GET ENDING NUMBER
			INC	HL		;ADVANCE PAST BEGINNING OF LINE
			POP	DE		;GET STARTING LINE NUMBER BACK
			PUSH	HL		;SAVE ENDING LINE
			CALL	LINEF+4		;FIND STARTING LINE ADDRESS
			POP	BC		;GET ENDING ADDRESS BACK
		; LIST TEXT FROM STARTING LINE IN H-L TO ENDING LINE IN B-C
		GO	LD	A,(HL)		;GET CHARACTER FROM START OF LINE
			INC	A		;TEST FOR END OF FILE
			JP Z,	LIRET		;IF SO, STOP LISTING
			CALL	PNUM		;DISPLAY LINE NUMBER AND BUFFER IT
			INC	HL		;SKIP LENGTH BYTE, AS IT DOSN'T LOOK PRETTY
		PRINS	LD	A,(HL)		;GET CHARACTER FROM LINE
			LD	(DE), A		;PLACE INTO BUFFER
			INC	DE		;ADVANCE IN BUFFER
			CALL	BPUTCHR	;DISPLAY ON TERMINAL
			INC	HL		;ADVANCE POINTER IN PROGRAM
			CP	CR		;TEST FOR END OF LINE
			JP NZ,	PRINS		;IF NOT, KEEP PRINTING
			CALL	BPUTNL		;NEW LINE ON TERMINAL
			CALL	COMP		;TEST FOR LAST LINE LISTED
			JP NC,	LIRET		;IF SO, STOP LISTING
			CALL	CTRLC		;TEST FOR ABORT FROM TERMINAL
			JP NZ,	GO		;KEEP LISTING IF NOT
		LIRET	POP	DE		;RESTORE PROGRAM POINTER
			RET
		;
		; CLEARS VARIABLES AND ARRAYS. (INITIALIZES THEM) AND INITIALIZES EDIT BUFFER
		;
		CLEAR	LD	HL,VARS		;POINT TO VARIABLE SPACE
			LD	A,CR		;GET A CARRIAGE RETURN (END OF LINE CHARACTER)
			LD	(EDBUF), A	;INITIALIZE EDIT BUFFER TO A NULL LINE
			LD	C,52		;26 VARIABLE TIMES 2 BYTES/VARIABLE
		CVLP	LD	(HL),0		;CLEAR INTEGER VARAIBLES TO ZERO
			INC	HL		;ADVANCE TO NEXT BYTE OF VARIABLE SPACE
			DEC	C		;REDUCE COUNT OF VARAIABLES LEFT
			JP NZ,	CVLP		;KEEP GOING TILL ALL INTEGERS ARE ZERO'ED
			LD	A,HIGH (VARS + 0x400) ;ADDRESS OF END OF VARIABLE TABLE
			LD	BC,10		;SKIP AHEAD 10 BYTES
			ADD	HL,BC		;SO THAT WE DON'T CLOBBER OUR FLAGS
		CVL1	LD	(HL),255	;0xFF IS NULL CHARACTER FOR CHAR. VARS
			INC	HL		;POINT TO NEXT BYTE IN CHAR. VAR. SPACE
			CP	H		;TEST FOR COMPLETE (ALL SET TO NULL STRINGS)
			JP NZ,	CVL1		;KEEP GOING TILL WE DO THEM ALL
		; INITIALIZE ARRAYS, RESET ARRAY SPACE TO FIRST PAGE FOLLOWING PROGRAM
		CLRARY	CALL	GETEOF		;GET ADDRESS OF FIRST FREE PAGE+SET POINTER
			LD	(ARYLOC), A	;STASH IN ARRAY TABLE POINTER
			LD	H,A		;PLACE IN H, SO WE CAN REFERENCE INDERECT
			LD	L,52		;START AT END OF TABLE
			LD	(LAST), HL	;INDICATE FREE SPACE FOR NEXT ARRAY
			SUB	A		;GET A ZERO
		CALS	DEC	L		;BACK UP IN TABLE
			LD	(HL),A		;INITIALIZE TO INDICATE NO ARRAY
			JP NZ,	CALS		;KEEP GOING TILL TABLE IS CLEARED
		; RESET CONTROL STACK AND DATA POINTER
		RESET	LD	HL,CS		;GET USER STACK POINTER
			LD	(CSP), HL	;INITIALZE USER STACK POINTER
			LD	HL,0		;GET A ZERO (NO DATA POINTER)
			LD	(DATA), HL	;INSURE NO DATA PRESENT
			RET
		;
		; ** WE'VE GOTTEN A 'RUN' COMMAND, LETS START THE PROGRAM ROLLING **
		;
		RUN	LD	A, (TEXT)	;GET FIRST CHARACTER OF PROGRAM
			LD	HL,NP		;AND ADDRESS OF 'NO PROGRAM' MESSAGE
			INC	A		;TEST FOR EXISTANCE OF PROGRAM
			JP Z,	ERR		;IF NOT, POINT OUT HIS MISTAKE
			CALL	CLEAR		;CLEAR VARIABLES AND ARRAYS
			LD	DE,TEXT		;START INTERPRETING AT THE BEGINNING
		RGON	LD	A,255		;INDICATE THAT WE ARE RUNNING
			LD	(RFLAG), A	;BY SETTING THIS FLAG
		RNEWL	INC	DE		;SKIP PACKED DECIMAL LINE
			INC	DE		;NUMBERS, AND THE LENGTH BYTE,
			INC	DE		;AS THE COMMAND FINDER WON'T LIKE IT
		; MAIN 'RUN' INTERPRETING LOOP
		RLOOP	LD	SP,STACK	;REPAIR ANY DAMAGE
			CALL	CTRLC		;TEST FOR 'MAGIC' CONTROL-C CHARACTER
			JP Z,	STOP		;IF SO, FAKE A 'STOP' COMMAND
			LD	HL,PTAB-1	;POINT TO PROGRAM COMMAND TABLE
			CALL	CMD		;RUN PROGRAM CODE
		; ADVANCE TO NEXT STATEMENT
		RNEXT	LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	'"'		;TEST FOR A QUOTE
			CALL Z,	SKPQUO		;IF SO, SEARCH FOR NEXT ONE
			INC	DE		;ADVANCE TO NEXT CHARACTER
			CP	':'		;TEST FOR COLON (NEW STATEMENT)
			JP Z,	RLOOP		;IF SO, EXECUTE NEXT COMMAND
			CP	CR		;TEST FOR CARRIAGE RETURN
			JP NZ,	RNEXT		;IF NOT, KEEP LOOKING
			LD	A, (DE)		;GET FIRST CHAR OF NEW LINE
			INC	A		;TEST FOR 0xFF (END OF FILE)
			JP Z,	INIT		;IF SO, GO BACK TO COMMAND MODE
			JP	RNEWL		;EXECUTE THIS LINE
			
		;
		; EITHER WE HAVE GOTTEN A 'STOP' COMMAND, OR THE OPERATOR PRESSED
		; CONTROL-C, EITHER WAY, PRINT THE MESSAGE AND BEXIT
		;
		STOP	LD	HL,STMSG	;ADDRESS OF 'STOP' MESSAGE
			JP	PERR		;TREAT IT LIKE AN ERROR
		; IT'S A 'THEN', FOLLOWING AN 'IF', LOOK FOR LINE NUMBER OR A STATEMENT
		THEN	CALL	NUM		;IS IT A NUMBER?
			JP NC,	GOTO		;IF SO, ITS A NUMBER TO 'GOTO'
			JP	RLOOP		;IF NOT, ITS A STATEMENT TO EXECUTE
		;
		; IT'S A 'GOSUB' SAVE RETURN ADDRESS, AND PRETEND IT'S 'GOTO'
		;
		GOSUB	CALL	PUSHD		;SAVE SOURCE POSITION
			SUB	A		;INDICATE GOSUB ENTRY
			CALL	PUSHS		;SAVE ON USER STACK
			LD	A, (DE)		;RESTORE OPERAND CHARACTER
		;
		; IT'S A 'GOTO' MAKE THE BIG JUMP
		;
		GOTO	CP	'('		;TEST FOR COMPUTED GOTO
			JP NZ,	NOON		;IF NO, NOT AN 'ON' STATEMENT
			CALL	EXPR		;GET VALUE OF INTERNAL EXPRESSION
		GLPO	CALL	SKIP		;SKIP TO NEXT EXPRESSION
			CP	','		;IF THERE IS NO MORE COMMA'S
			JP NZ,	SYNT		;THEN WE RAN OUT OF OPERANDS
		GLPD	INC	DE		;SKIP THE COMMA
			DEC	L		;REDUCE OUR COUNT
			JP P,	GLPO		;IF IT'S STILL POSITIVE, KEEP SKIPPING
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	' '		;TEST FOR BLANKS
			JP Z,	GLPD		;AND KEEP GOING TILL WE SKIP THEM
		NOON	PUSH	DE		;SAVE POSITION (IN CASE WE FAIL)
			CALL	FNDLIN		;FIND THE LINE HE WANTS
			POP	DE		;RESTORE OUR POSITION
			EX	DE, HL	
			JP Z,	RGON		;IF SUCESS, GOTO NEW LINE
			EX	DE, HL	
		;
		; OH OH, LOOKS LIKE HE'S TRIED TO GOTO, GOSUB OR ORDER TO A LINE HE FORGOT
		; TO TYPE IN, TELL HIM ABOUT IT AND LET HIM TRY TO FIGURE IT OUT
		;
		BADLIN	LD	HL,LIN		;ADDRESS OF 'LINE NUMBER' MESSAGE
			JP	ERR		;HANDLE LIKE ANY ERROR
		;
		; IT'S A 'RETURN', HOPE SOMEBODY DID A 'GOSUB' SOMEWHERE
		;
		RETURN	CALL	POPS		;GET TYPE OF STACK ENTRY
			AND	A		;TEST FOR 'GOSUB' ENTRY
			JP Z,	POPD		;IF SO, GET ADDRESS BACK AND RETURN
		;
		; HE SCREWED UP THE FOR/NEXT, GOSUB/RETURN NESTING
		; LET HIM IN ON IT AND DIE WHILE WE CAN
		;
		NSTERR	LD	HL,CSTK		;ADDRESS OF 'NESTING' MESSAGE
			JP	ERR		;HANDLE LIKE ANY ERROR
		;
		; IT'S A 'FOR' COMMAND, LETS THROW THIS THING FOR A LOOP
		;
		FOR	CALL	VCHAR		;INSURE IT'S A VARIABLE
			PUSH	AF
			DEC	DE		;BACK UP POINT JUST BEFORE EXPRESSION
			LD	A,E		;GET LOW ADDRESS
			LD	(PP), A		;AND PLACE IN POSITION FLAG
		FINTO	LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	CR		;TEST FOR END OF LINE
			JP Z,	SYNT		;IF SO, HE'S GOOFED
			INC	DE		;SKIP TO NEXT
			CP	'T'		;TEST FOR A 'T'
			JP NZ,	FINTO		;IF NOT, WE ARN'T THERE YET
			LD	A, (DE)		;GET NEXT CHARACTER
			CP	'O'		;IS IT 'TO'
			JP NZ,	FINTO		;NO, MUST BE VARIABLE 'T'
			PUSH	DE		;SAVE OUR POSITION
			DEC	DE		;BACKUP TO THE 'T'
			CALL	DOEXP		;EVALUATE EXPRESSION
			POP	DE		;RESTORE OUT POSITION
			INC	DE		;SKIP 'O'
			CALL	EXPR		;GET LIMIT EXPRESSION
			CALL	PUSHD		;SAVE OUR POSITION ON STACK
			EX	DE, HL	
			CALL	PUSHD		;SAVE ON STACK
			EX	DE, HL	
			POP	AF
		;
		; SAVES A SINGLE BYTE ENTRY ON THE USER (CONTROL) STACK
		;
		PUSHS	PUSH	HL		;SAVE H-L
			LD	HL, (CSP)	;GET STACK POINTER
			LD	(HL),A		;SAVE BYTE ON STACK
		PSH1	DEC	HL		;REDUCE POINTER
		PSH2	LD	(CSP), HL	;RESAVE STACK POINTER
			POP	HL		;RESTORE H-L
			RET
		;
		; POP A SINGLE BYTE ENTRY FROM THE USER (CONTROL) STACK
		;
		POPS	PUSH	HL		;SAVE H-L
			LD	HL, (CSP)	;GET STACK POINTER
			INC	HL		;ADVANCE TO NEXT ENTRY
			LD	A,(HL)		;GET BYTE BACK
			JP	PSH2		;SAVE POINTER AND CONTINUE
		;
		; PUSHES A DOUBLE BYTE ENTRY ON THE USER (CONTROL) STACK
		;
		PUSHD	PUSH	HL		;SAVE H-L
			LD	HL, (CSP)	;GET STACK POINTER
			LD	(HL),D		;SAVE HIGH BYTE
			DEC	HL		;BACK UP
			LD	(HL),E		;SAVE LOW BYTE
			JP	PSH1		;SAVE POINTER AND CONTINUE
		;
		; POPS A DOUBLE BYTE ENTRY FROM THE USER STACK
		;
		POPD	PUSH	HL		;SAVE H-L
			LD	HL, (CSP)	;GET STACK POINTER
			INC	HL		;ADVANCE TO LAST ENTRY
			LD	E,(HL)		;GET LOW BYTE
			INC	HL		;ADVANCE TO HIGH BYTE
			LD	D,(HL)		;GET HIGH BYTE
			JP	PSH2		;SAVE AND CONTINUE
		;
		; LET COMMAND, EVALUATE EXPRESSION
		;
		LET	CALL	EXPR		;EVALUATE EXPRESSION
			LD	A, (EFLAG)	;DID HE MAKE AN ASSIGNMENT?
			AND	A		;IF NOT..
			JP Z,	SYNT		;HE'S MADE ANOTHER MISTAKE
			SUB	A		;RESET THE FLAG
			LD	(EFLAG), A	;SO WE KNOW WHEN HE SCREW'S UP AGAIN
			RET
		;
		; IT'S A NEXT COMMAND, TEST INDEX AGAINST LIMIT, AND LOOP IF NEEDED
		;
		NEXT	CALL	VCHAR		;TEST FOR VALID VARIABLE
			LD	B,A		;STASH IN B FOR SAFEKEEPING
			LD	HL, (CSP)	;SAVE CONTROL STACK POINTER..
			LD	(TEMP), HL	;IN CASE WE NEED TO LOOP AGAIN
			CALL	POPS		;GET VARIABLE NAME FROM STACK
			CP	B		;TEST FOR WHAT HE GAVE US
			JP NZ,	NSTERR		;IF NOT, HE'S SCREWED UP THE NESTING
			CALL	LOOK		;GET VARIABLE VALUE
			PUSH	DE		;SAVE POSITION
			CALL	POPD		;GET LIMIT FROM STACK
			LD	B,D		;GET LIMIT
			LD	C,E		;INTO B-C SO WE CAN 'COMP'
			CALL	COMP		;TEST IF INDEX >= LIMIT
			JP NC,	NOMORE		;IF SO, DON'T LOOP ANYMORE
			POP	DE		;GET POSITION BACK
			INC	HL		;INCREMENT LOOP INDEX
			LD	A, (DE)		;GET VARIABLE NAME BACK
			CALL	STOR		;SAVE IT AWAY
			CALL	POPD		;GET NEW POSITION
			LD	HL, (TEMP)	;GET CONTROL-STACK POINTER
			LD	(CSP), HL	;AND REPLACE IT (LEAVING STACK UNCHANGED)
			RET
		; WE HAVE HIT THE END OF A FOR NEXT LOOP
		NOMORE	CALL	POPD		;CLEAN UP CONTROL STACK
			POP	DE		;GET PROGRAM COUNTER BACK
		;
		; REMARK, DO NOTHING, BUT RETURN, ALLOWING 'RNEXT' TO SKIP THE COMMAND
		;
		REM:	RET
		;
		; IT'S AN 'IF' STATEMENT. FIND OUT 'IF' WE DO IT OR NOT
		;
		IF:	DEC	DE		;BACK UP IN SOURCE
			LD	A,E		;GET LOW ADDRESS
			LD	(PP), A		;SAVE IN POSITION POINTER
		FTHEN	LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	CR		;IF IT'S A CARRIAGE RETURN..
			JP Z,	SYNT		;THEN HE DIDN'T TYPE IN A 'THEN'
			INC	DE		;ADVANCE TO NEXT CHARACTER
			CP	'T'		;IS IT A 'T'?
			JP NZ,	FTHEN		;IF NOT, IT AINT THE START OF 'THEN'
			LD	A, (DE)		;GET NEXT CHARACTER
			CP	'H'		;TEST FOR NEXT CHARACTER OF 'THEN'
			JP NZ,	FTHEN		;NO, MUST BE VARIABLE 'T' (OR HE CAN'T SPELL)
			DEC	DE		;BACK UP TO 'T'
			PUSH	DE		;SAVE POSITION IN SOURCE
			CALL	DOEXP		;EVALUATE CONDITION EXPRESSION
			POP	DE		;GET POSITION BACK
			LD	A,H		;GET RESULT AND TEST.
			OR	L		;IT FOR ZERO (FALSE)
			RET Z			;IF SO, SKIP THIS STATEMENT
			JP	RLOOP		;EXECUTE THE 'THEN'
		;
		; LONG IF, CONTROLS REMAINDER OF ENTIRE LINE
		;
		LIF	CALL	IF		;CALCULATE AND PROCESS IF TRUE
		LNXT	INC	DE		;ADVANCE IN SOURCE
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	CR		;TEST FOR END OF LINE
			JP NZ,	LNXT		;KEEP LOOKING
			RET
		;
		; IT A 'PLOT' COMMAND, (HE'S PLOTTING AGAINST US)
		;
		PLOT	CALL	EXPR		;GET X COORDINATE
			JP C,	SYNT		;IF CHARACTER, IT'S NO GOOD
			PUSH	HL		;SAVE X COORDINATE
			INC	DE		;ADVANCE PAST ','
			CALL	EXPR		;GET Y COORDINATE
			POP	BC		;GET X POSITION IN B-C
			ADD	HL,HL		;MULTIPLY.
			ADD	HL,HL		;Y POSITION.
			ADD	HL,HL		;BY 64.
			ADD	HL,HL		;TO PLACE ADDRESS.
			ADD	HL,HL		;ON PROPER LINE.
			ADD	HL,HL		;OF THE DISPLAY
			ADD	HL,BC		;ADD IN X POSITION
			LD	BC,1024		;TEST AGAINST END OF SCREEN
			CALL	COMP		;TO SEE IF WE ARE OVER
			JP NC,	DIMERR		;IF SO, 'DIMENSION ERROR'
			;CALL	CURPOS		;POSITION THE CURSOR
		; LOOK FOR END OF LINE, OR OTHER OPERANDS
			CALL	SKIP		;GET NEXT SEPERATOR
			CP	','		;TEST FOR COMMA
			RET NZ			;IF NOT, WE ARE DONE
			INC	DE		;SKIP ','
		; OUT STATEMENT, LET'S OUTPUT SOMETHING TO A PORT
		OUTP	CALL	EXPR		;GET EXPRESSION FOR PORT#
			JP  C,	SYNT
			PUSH	BC
			LD	C,L		;SET PORT
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	','		;TEST FOR COMMA
			JP NZ,	SYNT
			CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
			CALL	EXPR		;GET EXPRESSION FOR PORT#
			JP  C,	SYNT
			OUT	(C),L
			LD	A,C		;IF OUTPUT TO 0x40, THEN WRITE TO SCAN LED
			AND	0xE0
			CP	0x40
			JR  NZ,	OUTPR
			LD	A,L
			LD	(0xFFF5),A	;SCAN_LED ON Z80MC
		OUTPR	POP	BC
			RET
		;
		; PRINT STATEMENT, LET'S OUTPUT SOMETHING SO HE WON'T GET UPSET
		; WHILE STARING AT THE TUBE WONDERING IF WE DIED
		;
		BPRINT	CALL	EXPR		;GET EXPRESSION TO PRINT
			PUSH	DE		;SAVE BASIC'S PROGRAM COUNTER
			CALL NC, DECPRT		;IF NUMERIC, OUTPUT DECIMAL NUMBER
			POP	DE		;RESTORE BASIC'S PROGRAM COUNTER
			CALL C,	PV1		;IF CHARACTER, DISPLAY CHARACTER VALUE
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	','		;TEST FOR COMMA
			JP NZ,	BPUTNL		;IF NOT, IT'S THE END
			CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
			JP NZ,	BPRINT		;PRINT NEXT EXPRESSION
			RET
		; PRINT CHARACTER EXPRESSIONS
		PV1	LD	HL,XBF		;EXPRESSION IS IN EXTRA BUFFER
		PZ	LD	A,(HL)		;GET CHARACTER FROM EXPRESSION
			INC	HL		;POINT TO NEXT
			AND	A		;TEST FOR END OF EXPRESSION
			RET M			;IF SO, END IT NOW
			CALL	BPUTCHR	;PRINT CHARACTER
			JP	PZ		;KEEP GOING TILL END
			
		; RECURSIVE ROUTINE OUTPUTS NUMBER IN DECIMAL
		DECPRT	CP	'('		;TEST FOR SPECIAL CASE
			CALL NZ, BPUTSP	;IF NOT, PRECEDE WITH SPACE
		DECP1	LD	BC,10		;DIVIDE BY 10
			CALL	DODIV		;PERFORM DIVISION
			LD	A,0x30		;TO CONVERT TO ASCII
			ADD	A,L		;GET DIGIT
			PUSH	AF
			EX	DE, HL	
			LD	A,H		;GET HIGH BYTE
			OR	L		;TEST FOR ZERO, (FINISHED)
			CALL NZ, DECP1		;IF NOT, GET NEXT VALUE
			POP	AF
			JP	BPUTCHR	;DISPLAY AND RETURN
		;
		; IT'S AN 'INPUT', LETS GIVE HIM A CHANCE TO DO SOME TYPING.. BUT
		; KEEP AN EYE ON HIM, IN CASE HE TRY'S TO PUT SOMETHING OVER ON US
		;
		INPUT	CALL	CLBF		;CLEAR EXTRA TEXT BUFFER
			LD	A,'?'		;GET A QUESTION MARK.
			LD	(XBF), A	;TO USE AS THE DEFAULT PROMPT
			LD	A, (DE)		;GET FIRST CHAR OF OPERAND
			CP	'"'		;TEST FOR USER SUPPLIED PROMPT
			JP NZ,	INP1		;IF NOT, DON'T CHANGE EXISTING ONE
			CALL	EXPR		;EVALUATE USER SUPPLIED PROMPT
			CALL	PARSE		;SKIP TO NEXT NON-BLANK
		INP1	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
			PUSH	DE		;SAVE SOURCE POSITION
			INC	DE		;ADVANCE TO NEXT CHARACTER
			PUSH	AF
			LD	A, (DE)		;GET NEXT CHARACTER
			CP	'$'		;TEST FOR CHARACTER INPUT
			JP Z,	GCHR		;IF SO, GET CHARACTER DATA
			LD	HL,0		;START WITH A ZERO
			ADD	HL,SP		;AND GET STACK POINTER. IN CASE WE BLOW UP
			LD	(TEMP), HL	;SAVE SO WE CAN GET IT BACK LATER
		RETRY	CALL	PV1		;DISPLAY USER PROMPT
			SUB	A		;GET A ZERO
			LD	(IFLAG), A	;AND CLEAR THE INPUT FLAG (IN CASE HE CTRL-C'S)
			CALL	GLINE		;GET A LINE FROM THE TERMINAL
			LD	(IFLAG), A	;SET IFLAG. (SO GET ERROR, WE CAN COME BACK)
			CALL	EXPR		;EVALUATE EXPRESSION
			POP	AF
			CALL	STOR		;STASH VALUE IN VARIABLE
			POP	DE		;RESTORE SOURCE POSITION
			SUB	A		;GET A ZERO
			LD	(IFLAG), A	;AND CLEAR IFLAG
			RET
		; CHARACTER INPUT
		GCHR	CALL	PV1		;DISPLAY USER PROMPT
			CALL	GLINE		;GET A LINE OF INPUT
			POP	AF
			CALL	LTA		;GET THE TEXT VARIABLE'S ADDRESS
			LD	B,35		;LENGTH IS 35
		Z1	LD	A, (DE)		;GET CHARACTER FROM INPUT BUFFER
			CP	CR		;TEST FOR END OF BUFFER
			JP Z,	Z2		;IF SO, END THE LINE
			DEC	BC		;TEST FOR END OF VARIABLE SPACE
			JP Z,	Z2		;IF SO, END THE LINE
			LD	(HL),A		;SAVE IN VARIABLE SPACE
			INC	HL		;NEXT CHARACTER IN VARIABLE
			INC	DE		;NEXT CHARACTER IN INPUT BUFFER
			JP	Z1		;COPY NEXT CHARACTER
		Z2	POP	DE		;RESTORE SOURCE POSITION
		Z3	LD	(HL),0xFF	;PAD BUFFER WITH NULL CHARACTERS
			INC	HL		;NEXT POSITION IN VARIABLE
			DEC	BC		;REDUCE COUNT TILL END
			JP P,	Z3		;KEEP GOING TILL VARIABLE IS FILLED
			RET
		;
		; LOOK'S LIKE HE CAN'T EVEN ENTER A SIMPLE NUMBER, CLEAN UP ANY STACK
		; HE MAY HAVE USED, AND LET HIM TAKE ANOTHER BLIND STAB AT THE KEYBOARD
		;
		INERR	LD	HL,IERMS	;GET NASTY MESSAGE
			CALL	PRINTM		;GIVE HIM THE BAD NEWS
			LD	HL, (TEMP)	;GET HIS OLD STACK BACK
			LD	SP, HL	
			JP	RETRY		;LET HIM TRY AGAIN
		;
		; DIMENSION, HE WANTS SOME ARRAY SPACE.. I SUPPOSE WE SHOULD GIVE IT TO HIM
		;
		DIM	LD	A,E		;GET ADDRESS OF OUR POSITION
			LD	(PP), A		;SAVE IN POSITION POINTER
		DIM0	LD	A, (DE)		;GET CHARACTER FROM SOURCE
			INC	DE		;ADVANCE TO NEXT
			CP	CR		;TEST FOR END OF LINE
			JP Z,	SYNT		;IF SO, TELL HIM TO STRAIGHTEN UP
			CP	')'		;TEST FOR START OF ARRAY DIMENSION
			JP NZ,	DIM0		;IF NOT, KEEP LOOKING
			DEC	DE		;BACK UP FOR EXPRESSION
			PUSH	DE		;SAVE BASIC PROGRAM COUNTER
			CALL	DOEXP		;EVALUATE ARRAY SIZE
			INC	HL		;ADD ONE ENTRY (ZERO ENTRY DOES EXIST)
			ADD	HL,HL		;DOUBLE BECAUSE THEY ARE 16 BIT'S
			DEC	DE		;BACK UP TO NAME
			LD	B,H		;COPY SIZE NEEDED
			LD	C,L		;INTO B AND C
			LD	HL, (LAST)	;GET FREE ADDRESS
			PUSH	HL		;SAVE FOR TABLE
		DLOOP	LD	(HL),0		;ZERO ARRAY BYTE
			INC	HL		;ADVANCE TO NEXT
			DEC	BC		;REDUCE COUNT
			LD	A,B		;GET HIGH BYTE OF REMAINING TO DO
			OR	C		;TEST FOR NONE LEFT
			JP NZ,	DLOOP		;IF NOT, KEEP ZEROING
			LD	(LAST), HL	;SAVE NEXT FREE SPACE INDICATOR
			POP	HL		;GET ADDRESS OF ARRAY BACK
			LD	A, (DE)		;GET ARRAY NAME
			CALL	TABENT		;GET TABLE ENTRY
			LD	A,H		;GET HIGH ADDRESS
			LD	(BC), A		;PLACE IN TABLE
			INC	BC		;ADVANCE IN TABLE
			LD	A,L		;GET LOW ADDRESS
			LD	(BC), A		;PLACE IN TABLE
			POP	DE		;GET SOURCE POSITION BACK
			CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
			RET Z
			CP	','		;TEST FOR ANOTHER OPERAND
			JP Z,	DIM		;IF SO, KEEP GOING
			SUB	A		;CAUSE A SYNTAX ERROR BECAUSE WE ARE BAD
		;
		; LOCATES TABLE POSITION OF AN ARRAY
		;
		TABENT	CALL	VCHAR		;INSURE IT'S OK
			SUB	'A'		;CONVERT TO BINARY
			ADD	A,A		;X 2 FOR TWO BYTE ENTRIES
			LD	C,A		;SAVE IN C
			LD	A, (ARYLOC)	;GET ARRAY PAGE
			LD	B,A		;SAVE IN HIGH ZBYTE
			RET
		; LOOKS UP AN ARRAY VALUE
		ALOOK	CALL	DOEXP		;CALCULATE INDEX VALUE
			DEC	DE		;BACK UP PAST '['
			LD	A, (DE)		;GET VARIABLE NAME
			CALL	LOOKT		;FIND ADDRESS OF ENTRY
			LD	B,(HL)		;GET HIGH BYTE OF ENTRY
			INC	HL		;ADVANCE TO LOW BYTE
			LD	C,(HL)		;GET LOW BYTE OF ARRAY ENTRY
			LD	H,B		;TRANSFER RESULT TO .
			LD	L,C		;H AND L WHERE THEY ARE EXPECTED
			LD	A, (DE)		;GET VARIABLE NAME BACK
			CP	'@'		;TEST FOR MAGIC 'PEEK' ARRAY
			RET NZ			;IF NOT, WE ARE OK
			LD	L,H		;SET VALUE TO THAT OF FIRST BYTE
			LD	H,0		;AND ELIMINATE HIGH BYTE
			RET
		;
		; LOCATES ADDRESS OF AN ARRAY ENTRY IN THE ARRAY TABLE. INDEX IN HL
		;
		LOOKT	CP	'@'		;TEST FOR SPECIAL CASE
			RET Z			;IF SO, PEEK AT ADDRESS
			CALL	TABENT		;LOCATE TABLE ENTRY
			PUSH	DE		;SAVE BASIC PROGRAM COUNTER
			LD	A, (BC)		;GET FIRST BYTE
			LD	D,A		;COPY TO HIGH BYTE
			INC	BC		;ADVANCE TO NEXT
			LD	A, (BC)		;GET LOW BYTE
			LD	E,A		;COPY TO D
			ADD	HL,HL		;X TWO FOR TWO BYTE ENTRIES
			ADD	HL,DE		;ADD IN OFFSET FOR START OF ARRAY
			OR	D		;TEST FOR ADDRESS OF ZERO, = NOT DIMENSIONED
			POP	DE		;RESTORE PROGRAM COUNTER
			RET NZ			;NOT A DIMENSION ERROR, GO BACK
		;
		; EITHER HE'S TRIED TO INDEX A NON-ARRAY VARIABLE, TRIED TO INDEX A CHARACTER
		; VARIABLE WITH A VALUE GREATER THEN 34, OR HE'S PLOTTED OUTSIDE OF THE SCREEN
		; NO MATTER WHAT HE'S DONE, GIVE HIM A NASTY MESSAGE SO HE WON'T DO IT AGAIN
		;
		DIMERR	LD	HL,OVM		;ADDRESS OF NASTY MESSAGE
			JP	ERR		;GIVE IT TO HIM
		; LOCATES THE ADDRESS OF A CHARACTER (TEXT) VARIABLE
		LTA	SUB	0x41		;REDUCE TO SIMPLE BINARY
			CP	26		;TEST FOR VALID VARIABLE
			JP NC,	SYNT		;IF NOT, GET MAD
			LD	HL,VARS+25	;START OF CHARACTER VARIABLES (-37)
			LD	BC,37		;LENGTH OF CHARACTER VARIABLES
		V1	ADD	HL,BC		;OFFSET INTO TABLE
			DEC	A		;REDUCE VARIABLES WE HAVE TO GO
			JP P,	V1		;IF NOT FINISHED, KEEP OFFSETING
			RET
		;
		; IT'S A 'USR' COMMAND, FIND OUT WHAT HE WANT'S, PASS CONTROL  TO
		; HIS MACHINE LANGUAGE ROUTINE, AND GOD HELP HIM IF HE SCREW'S UP
		; BECAUSE WE CAN'T DO ANYTHING FOR HIM UNTIL HE RETURNS
		;
		USR	LD	HL,URET		;GET ON STACK (SO HE CAN 'RET' TO IT)
			PUSH	HL		;SAVE IN MACHINE STACK
			CALL	EXPR		;EVALUATE ADDRESS
			PUSH	HL		;SAVE ON STACK (SO WE CAN 'RET' TO IT)
			LD	A, (DE)		;GET NEXT CHARACTER
			CP	','		;TEST FOR MORE PARAMETERS
			JP NZ,	CSAV		;IF NOT, DONT EVALUATE
			INC	DE		;SKIP THE ','
			CALL	EXPR		;EVALUATE PARAMETER TO PASS
		; WHEN 'PUSHD' RETURNS, IT WILL EFFECT A JUMP TO HIS CODE
		CSAV	JP	PUSHD		;SAVE PROGRAM POSITION
		; IF WE GET HERE, HE MADE IT BACK IN ONE PIECE
		URET	CALL	POPD		;GET PROGRAM COUNTER BACK
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	','		;TEST FOR VARIABLE TO RECEIVE H-L
			RET NZ			;IF NOT, WE ARE DONE
			CALL	PARSE		;KEEP LOOKING
		;
		; STORES H-L INTO A INTEGER VARIABLE PASSED IN A
		;
		STOR	LD	B,HIGH VARS	;GET ADDRESS OF VARIABLE TABLE
			SUB	0x41		;CONVERT TO BINARY
			CP	26		;TEST FOR VALID VARIABLE NAME
			JP NC,	SYNT		;IF NOT, IT'S INVALID
			ADD	A,A		;DOUBLE BECAUSE THEY ARE 16 BIT ENTRIES
			LD	C,A		;PLACE IN C, MAKING COMPLETE ADDRESS
			LD	A,L		;GET LOW VALUE TO SAVE
			LD	(BC), A		;SAVE IN VARIABLE
			INC	BC		;NEXT BYTE OF VARIABLE
			LD	A,H		;GET HIGH BYTE
			LD	(BC), A		;SAVE IN VARIABLE
			RET
		;
		; RETERIVES CONTENTS OF A VARIABLE
		;
		LOOK	LD	B,HIGH VARS	;ADDRESS OF VARIABLES
			SUB	'A'		;CONVERT NAME TO BINARY
			ADD	A,A		;DOUBLE FOR 16 BIT ENTRIES
			LD	C,A		;MAKE COMPLETE ADDRESS
			LD	A, (BC)		;GET LOW BYTE
			LD	L,A		;PLACE IN L
			INC	BC		;NEXT BYTE OF VARIABLE
			LD	A, (BC)		;GET HIGH BYTE
			LD	H,A		;PLACE IN H
			RET
		;
		; IT'S AN 'ORDER', (HE THINKS HE KNOWS WHERE THERE IS SOME DATA)
		;
		ORDER	PUSH	DE		;SAVE OUR SOURCE POSITION
			CALL	FNDLIN		;GET ADDRESS OF THE LINE HE WANTS
			POP	DE		;RESTORE OUR POSITION
			PUSH	DE		;AND RESAVE OUR POSITION
			JP NZ,	BADLIN		;IF IT DOSN'T EXIST, THEN FORGET IT
			INC	HL		;SKIP FIRST TWO DIGITS OF LINE NUMBER
			INC	HL		;SKIP LAST TWO DIGITS OF LINE NUMBER
			INC	HL		;SKIP LENGTH BYTE
			EX	DE, HL	
			CALL	VERDAT		;GET STATEMENT FROM LINE
			LD	(DATA), HL	;SAVE DATA POINTER
			POP	DE		;RESTORE OUR LINE, (SO WE CAN TELL HIM)
			RET Z
		;
		; DATA ERROR... ATTEMPT TO READ FROM A LINE WITHOUT 'DATA' OR
		; ATTEMPT TO READ THE WRONG DATA TYPE. LET HIM IN ON IT
		;
		DERR	LD	HL,DTXT		;ADDRESS OF 'DATA' MESSAGE
			JP	SYNT+3		;DISPLAY IT
		;
		; IT'S A READ. (HE WANTS TO KNOW WHATS IN THAT DATA WE FOUND)
		;
		READ	CALL	VCHAR		;IS IT A VALID VARIABLE
			PUSH	AF
			INC	DE		;ADVANCE TO NEXT CHARACTER
			LD	A, (DE)		;GET NEXT CHARACTER
			CP	'$'		;IS IT A CHARACTER VARIABLE?
			JP Z,	CDAT		;IF SO, LOOK FOR CHARACTER DATA
		; NUMERIC DATA, FOR NUMERIC VARIABLE
			CALL	GETDAT		;GET NUMERIC DATA
			JP C,	DERR		;IF CHARACTER, IT A DATA TYPE ERROR
			POP	AF
			CALL	STOR		;STASH VALUE IN IT
			JP	MORDAT		;SEE IF HE WANT'S MORE DATA
		; CHARACTER DATA, FOR CHARACTER VARIABLE
		CDAT	INC	DE		;SKIP DOLLAR SIGN
			CALL	GETDAT		;GET DATA
			JP NC,	DERR		;IF NUMERIC, IT'S BAD
			POP	AF
			CALL	LTA		;FIND IT'S ADDRESS
			LD	BC,XBF		;DATA IS IN EXTRA BUFFER
			PUSH	DE		;SAVE SOURCE POSITION
			LD	E,35		;MOVE 35 CHARACTERS
		SL1	LD	A, (BC)		;GET CHARACTER FROM BUFFER. (DATA)
			LD	(HL),A		;STASH IT IN THE VARIABLE
			INC	BC		;SKIP TO THE NEXT CHARACTER IN THE BUFFER
			INC	HL		;SKIP TO THE NEXT POSITION IN VARIABLE
			DEC	E		;REDUCE COUNT OF HOW MANY TO MOVE
			JP NZ,	SL1		;IF NOT FINISHED, KEEP COPYING
			POP	DE		;RESTORE SOURCE POSITION
		; LOOK FOR MORE VARIABLES (OPERANDS) IN THE 'READ' STATEMENT
		MORDAT	CALL	PARSE1		;FIND NEXT NON-BLANK
			CP	','		;IF COMMA..
			RET NZ			;IF NOT, WE HAVE ALL THERE IS
			CALL	PARSE		;SKIP COMMA AND FIND VARIABLE NAME
			JP	READ		;GET MORE DATA FOR FOLLOWING VARIABLE
		; GETS DATA FROM THE DATA STATEMENTS, POINTED TO BY THE CURRENT READ POINTER
		GETDAT	LD	HL, (DATA)	;GET DATA POINTER
			LD	A,H		;SEE IF IT IS ZERO.
			OR	L		;WHICH INDICATES THAT IT WASN'T INITIALIZED
			JP Z,	DERR		;IF SO, IT'S A DATA ERROR
			PUSH	DE		;SAVE SOURCE POSIITION
			EX	DE, HL	
			CALL	EXPR		;EVALUATE THE DATA EXPRESSION
			PUSH	AF
		ENDAT	LD	A, (DE)		;GET NEXT CHARACTER FROM THE SOURCE
			CP	','		;TEST FOR MORE DATA
			JP Z,	COMA		;IF SO, WE ARE OK
			CP	':'		;TEST FOR END OF STATEMENT
			JP Z,	DAT1		;GO TO NEXT DATA STATEMENT
			INC	DE		;ADVANCE ONE CHARACTER
			CP	CR		;CARRIAGE RETURN?
			JP NZ,	ENDAT		;KEEP LOOKING IF NOT
		; HIT THE END OF A LINE, SKIP TO NEXT DATA STATEMENT
			INC	DE		;SKIP FIRST TWO DIGITS
			INC	DE		;SKIP SECOND TWO DIGITS
		DAT1	INC	DE		;SKIP LENGTH (OR ':' IF STMT)
			PUSH	HL		;SAVE H-L REG
			CALL	VERDAT		;CHECK FOR DATA STATEMENT
			EX	DE, HL	
			POP	HL		;RESTORE REGISTERS
			JP Z,	GDEND		;RETURN, WITH NEW DATA POINTER
			LD	DE,0xFFFF	;INDICATE NO MORE DATA STATEMENTS
		COMA	INC	DE		;SKIP THE COMMA
		GDEND	EX	DE, HL	
			LD	(DATA), HL	;SAVE IN POINTER
			EX	DE, HL	
			POP	AF
			POP	DE		;GET SOURCE POSITION BACK
			RET
		;
		; VERIFY THAT COMMAND WAS 'DATA'
		;
		VERDAT	CALL	PARSE1		;SKIP TO COMMAND
			EX	DE, HL	
			LD	DE,DATCMD	;POINT TO DATA COMMAND
		VER1	LD	A,E		;GET LOW ADDRESS
			CP	LOW (DATCMD+4)	;ARE WE AT END
			RET Z
			LD	A, (DE)		;GET CHR FROM TABLE
			INC	DE		;ADVANCE TO NEXT
			AND	0x7F		;INSURE IT'S CORRECT
			CP	(HL)		;DUZ IT MATCH?
			INC	HL		;NEXT IN DATA COMMAND
			JP Z,	VER1		;OK, TEST NEXT
			RET
		;
		; HE WANT'S TO KNOW HOW BIG IT IS... LETS FIGURE IT OUT AND LET HIM IN ON IT
		;
		SIZE	PUSH	DE		;SAVE PROGRAM POINTER
			CALL	GETEOF		;FIND THE END OF THE FILE
			LD	BC,NEGTEXT	;GET THE (NEGATIVE) FILE START ADDRESS
			ADD	HL,BC		;SUBTRACT FILE START FROM FILE END
			CALL	DECPRT		;DISPLAY VALUE IN DECIMAL
			LD	HL,SIMSG	;GET ' BYTES' MESSAGE
			POP	DE		;RESTORE PROGRAM POINTER
			JP	PRINTM		;TELL HIM WHAT IT IS
		; FINDS THE END OF THE FILE, HL=LAST BYTE OF PGM., A=FIRST FREE PAGE
		GETEOF	LD	HL,TEXT		;START AT THE BEGINING
			LD	A,255		;LOOKING FOR AN FF
		GLPX	CP	(HL)		;IS THIS IT?
			INC	HL		;ADVANCE TO NEXT
			JP NZ,	GLPX		;IF NOT IT, KEEP LOOKING
			DEC	HL		;POINT BACK TO 0xFF
			LD	A,H		;GET HIGH VALUE
			INC	A		;ADVANCE TO NEXT PAGE
			RET
		;
		; HE'S TRYING TO 'LOAD' SOMETHING, I WONDER IF HE HAS SOMETHING SAVED..
		;
		LOAD:	;CALL	TON		;TURN ON TAPE AND WAIT
		LOD1:	;CALL	GETR		;GET A RECORD
			;JP C,	LOD1		;KEEP GOING TILL WE HAVE IT ALL
			;CALL	TOFF		;SHUT TAPE OFF
			JP	RESV		;CLEAR VARIABLES AND GET A NEW COMMAND
		;
		; HE'S TRYING TO 'SAVE' SOMETHING..
		;
		SAVE	PUSH	DE		;SAVE PROGRAM POINTER
			LD	DE,TEXT		;GET ADDRESS OF TEXT
			LD	A, (DE)		;GET FIRST BYTE
			INC	A		;TEST FOR NO PROGRAM
			JP Z,	RUN		;IF SO, RUN WILL ABORT WITH ERROR
			CALL	GETEOF		;GET ENDING ADDRESS
			;CALL	TDUMP		;DUMP PROGRAM AND RETURN
			POP	DE		;RESTORE PROGRAM POINTER
			RET
		;
		;****************************************************************
		;                 EXPRESSION EVALUATION CODE
		;****************************************************************
		;
		; EVALUATES 16 BIT DECIMAL NUMBERS
		;
		EVAL	LD	BC,1		;MULTIPLIER IS ONE
			LD	H,B		;INITIALIZE
			LD	L,B		;STARTING RESULT TO ZERO
		ETOP	LD	A, (DE)		;GET DIGIT FROM SOURCE
			CALL	NUM		;TEST FOR INVALID DIGIT
			RET C			;IF SO, WE ARE FINISHED
			AND	0x0F		;CONVERT TO BINARY
		; ADD DIGIT TIMES MULTIPLIER IN B-C TO H-L
		ZLOOP	DEC	A		;REDUCE BY ONE
			JP M,	ESP1		;BEXIT WHEN EXAUSTED
			ADD	HL,BC		;ADD MULTIPLIER
			JP	ZLOOP		;CONTINUE TILL DONE
		; MULTIPLY MULTIPLIER (BC) BY 10
		ESP1	PUSH	HL		;SAVE H-L
			LD	H,B		;GET B-C INTO
			LD	L,C		;H-L SO WE CAN USE 'DAD'
			ADD	HL,BC		;BC=BC*2
			ADD	HL,HL		;BC=BC*4
			ADD	HL,BC		;BC=BC*5
			ADD	HL,HL		;BC=BC*10
			LD	B,H		;SAVE BACK INTO
			LD	C,L		;B-C REGISTER PAIR
			POP	HL		;RESTORE H-L
			DEC	DE		;REDUCE POINTER IN SOURCE
			JP	ETOP		;EVALUATE NEXT CHARACTER
		;
		; SUBROUTINE TESTS FOR VALID ASCII CHARACTERS
		;
		CHAR	CP	'A'		;TEST FOR < 'A'
			RET C			;RETURN SAYING IT'S BAD
			CP	'Z'+1		;TEST FOR >'Z'
			CCF			;INVERT LOGIC
			RET
		;
		; PARSES FORWARD, SEARCHING FOR FIRST NON-BLANK CHARACTER
		;
		PARSE	INC	DE		;ADVANCE IN SOURCE
		PARSE1	LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	' '		;TEST FOR SPACE
			JR Z,	PARSE		;KEEP LOOKING
			CP	':'		;TEST FOR END OF STATEMENT
			RET Z			;IF SO, RETURN WITH Z SET
			CP	CR		;TEST FOR END OF LINE
			RET
		;
		; SKIPS TO NEXT EXPRESSION OR COMMAND
		;
		SKIP	CALL	PARSE1		;ADVANCE TO NEXT NON-BLANK
			DEC	DE		;BACK UP TO POSITION
			LD	A,E		;GET LOW ORDER ADDRESS
			LD	(PP), A		;SAVE IN POSITION BYTE
		; LOOK FOR DELIMITER
		SKIP1	INC	DE		;ADVANCE TO NEXT
			LD	A, (DE)		;GET CHARACTER
			CP	':'		;TEST FOR DELIMITER
			RET Z			;IF SO, RETURN
			CP	','		;TEST FOR DELIMITER
			RET Z			;IF SO, RETURN
			CP	CR		;TEST FOR DELIMITER
			RET Z			;IF SO, RETURN
			CP	'"'		;TEST FOR QUOTE
			CALL Z,	SKPQUO		;IF SO, ADVANCE TO NEXT QUOTE
			JR	SKIP1		;KEEP LOOKING
		; FIND NEXT QUOTE IN SOURCE
		SKPQUO	INC	DE		;ADVANCE TO NEXT CHARACTER IN SOURCE
			LD	A, (DE)		;GET THE CHARACTER
			CP	'"'		;IS IT A QUOTE?
			RET Z			;IF SO, WE FOUND IT
			CP	CR		;IF IT A CARRIAGE RETUEN
			JR NZ,	SKPQUO		;IF NOT, OK
			JP	SYNT		;UNMATCHED QUOTES WHILE PARSING
		;
		; EVALUATES AN EXPRESSION POINTED TO BY D-E. RETURN WITH CARRY SET
		; INDICATES THAT EXPRESSION WAS A CHARACTER EXPRESSION
		;
		EXPR	CALL	SKIP		;ADVANCE TO END OF EXPRESSION
			PUSH	DE		;SAVE POINTER TO END
			CALL	DOEXP		;EVALUATE
			POP	DE		;RESTORE POINTER TO END OF EXPRESSION
			RET
		; CALCULATES EXPRESSION BACKWARDS (LIKE APL)
		DOEXP	DEC	DE		;BACK UP IN SOURCE
			CALL	FE		;GET CHARACTER FROM SOURCE
			CP	'$'		;TEST FOR CHARACTER VARIABLE
			JP Z,	CEXP		;IF SO, ITS A CHARACTER EXPRESSION
			CP	'"'		;TEST FOR QUOTE
			JP Z,	CEXP		;IF SO, IT'S A CHARACTER EXRESSION
			INC	DE		;ADVANCE
			LD	A,';'		;NULL OPERATOR TO START
		EGO1	PUSH	HL		;SAVE OLD VALUE
			PUSH	AF
			DEC	DE		;BACK UP TO VALUE
			CALL	FE		;GET CHARACTER FROM SOURCE
			CP	')'		;TEST FOR BRACKET
			JP Z,	BRKTS		;IF SO, RECURSE
			CP	']'		;TEST FOR ARRAY LOOKUP
			JP Z,	ARYL		;IF SO, LOOK UP ARRAY VALUE
			CALL	CHAR		;TEST FOR VARIABLE
			JP NC,	LOOKU		;IF SO, LOOK IT UP
			CP	'?'		;TEST FOR RANDOM NUMBER RETERIVAL
			JP Z,	RANDR		;GET RANDOM VALUE
			CP	'#'		;TEST FOR HEX CONSTANT
			JP Z,	HEXVL		;IF SO, GET HEV VALUE
			CALL	NUM		;TEST FOR A NUMBER
			JP C,	SYNT		;IF NOT, I DON'T KNOW WHAT HE'S DOING
		; DECIMAL NUMBER
		CALN	CALL	EVAL		;EVALUATE DECIMAL NUMBER
			JP	OLOOK		;LOOK FOR OPERATOR
		; HEX. NUMBER
		HEXVL	DEC	DE		;BACK UP IN SOURCE
			LD	A, (PP)		;GET ENDING POSITION
			CP	E		;TEST FOR PASSED THE LIMIT
			JP Z,	HEXGO		;IF SO, THATS IT
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CALL	NUM		;TEST FOR VALID DIGIT
			JP NC,	HEXVL		;KEEP GOING TILL WE GET TO START OF STRING
			SUB	'A'		;TEST FOR VALID LETTER
			CP	6		;OF 'A' TO 'F'
			JP C,	HEXVL		;IF SO, KEEP LOOKING
		HEXGO	LD	HL,0		;START WITH A ZERO
			LD	B,H		;FLAG TO SEE IF ANY DIGITS
			PUSH	DE		;SAVE POSITION IN SOURCE
		GETHX	INC	DE		;ADVANCE TO NEXT DIGIT OF HEX NUMBER
			LD	A, (DE)		;GET DIGIT
			CP	'#'		;TEST FOR END OF STRING
			JP Z,	HGON		;IF SO, WE ARE DONE
			LD	B,A		;SET FLAG SO WE KNOW WE GOT AT LEAST ONE DIGIT
			ADD	HL,HL		;SHIFT H-L
			ADD	HL,HL		;RIGHT IN ORDER
			ADD	HL,HL		;TO MAKE ROOM FOR
			ADD	HL,HL		;THE NEW DIGIT
			SUB	'0'		;REDUCE TO BINARY
			CP	10		;TEST FOR FURTHER REDUCTION NEEDED
			JP C,	HISG		;IF NOT, PROCESS
			SUB	7		;CONVERT LETTER TO BINARY
		HISG	OR	L		;ADD IN BOTTOM DIGIT OF RESULT
			LD	L,A		;REPLACE IN RESULT
			JP	GETHX		;GET NEXT DIGIT
		HGON	POP	DE		;GET POSITION IN SOURCE BACK
			LD	A,B		;GET FLAG
			AND	A		;TEST FOR DIGIT'S PROCESSED
			JP NZ,	OLOOK		;NO PROBLEM
			JP	SYNT		;'#' WITH NO DIGITS... ERROR
		; A ')' HAS BEEN DETECTED
		BRKTS	CALL	DOEXP		;RECURSE ON OURSELVES
			JP	DCLB		;CONTINUE WITH VALUE
		; LOOK UP AN ARRAY VALUE
		ARYL	POP	AF
			PUSH	AF
			CP	'='		;TEST FOR ASSIGNMENT
			CALL NZ, ALOOK		;IF NOT, GET VALUE
			JP	DCLB		;CONTINUE WITH VALUE
		; GET VARIABLE CONTENTS
		LOOKU	CALL	LOOK		;LOOK UP VALUE OF VARIABLE
		DCLB	DEC	DE		;BACK UP IN SOURCE
		OLOOK	POP	AF
			POP	BC		;GET OLD VALUE BACK
		; 16 BIT ADDITION
			CP	'+'		;TEST FOR ADDITION
			JP Z,	ADD		;IF SO, PERFORM ADD
		; SIXTEEN BIT SUBTRACTION
			CP	'-'		;TEST FOR SUBTRACTION
			JP NZ,	MULT		;NO, TRY MULTIPLICATION
			LD	A,B		;GET B
			CPL			;COMPLEMENT
			LD	B,A		;RESAVE
			LD	A,C		;GET C
			CPL			;COMPLEMENT
			LD	C,A		;RESAVE
			INC	BC		;ADD 1 GIVING TWO'S COMPLEMENT
		ADD	ADD	HL,BC		;ADD TO NEW VALUE
			JP	EGO		;CONTINUE
		; 16 BIT MULTIPLICATION
		MULT	CP	'*'		;TEST FOR MULTIPLY
			JP NZ,	DIV		;NO, TRY DIVIDE
			LD	A,B		;TEST OLD VALUE FOR ZERO
			OR	C		;AS IT IS A
			JP Z,	EGZ		;SPECIAL CASE
			CALL	DMULT		;PERFORM THE MULTIPLY
			JP	EGO		;AND CONTINUE
		; MULTIPLY SUBROUTINE (ALSO USED BY RANDOM NUMBER GENERATOR)
		DMULT	PUSH	DE		;SAVE POSITION IN SOURCE
			LD	DE,0		;START OUT WITH A ZERO
		MUL1	AND	A		;INSURE CARRY CLEAR
			LD	A,B		;GET B
			RRA			;ROTATE
			LD	B,A		;RESAVE
			LD	A,C		;GET C
			RRA			;ROTATE WITH CARRY
			LD	C,A		;REPLACE
			PUSH	AF
			OR	B		;TEST FOR B-C = ZER0
			JP Z,	MEXIT		;IF SO, WE ARE DONE
			POP	AF
			JP NC,	NOMAD		;NO ONE BIT, DON'T ADD
			EX	DE, HL	
			ADD	HL,DE		;ADD TO D-E
			EX	DE, HL	
		NOMAD	ADD	HL,HL		;SHIFT H-L RIGHT BY ONE BIT
			JP	MUL1		;KEEP GOING
		MEXIT	ADD	HL,DE		;ADD RESULT
			POP	AF
			POP	DE		;RESTORE SOURCE POSITION
			RET
		; 16 BIT DIVISION
		DIV	CP	'%'		;TEST FOR DIVIDE
			JP NZ,	FLOR		;NO, TRY FLOR
			LD	A,B		;TEST FOR AN OLD
			OR	C		;VALUE OF ZERO,
			JP Z,	DIVZE		;BECAUSE THAT IS  A BAD THING
			PUSH	DE		;SAVE SOURCE POSITION
			CALL	DODIV		;PERFORM DIVIDE OPERATION
			LD	(VARS+34), HL	;SET 'R' REMAINDER VARIABLE
			EX	DE, HL	
			POP	DE		;RESTORE SOURCE POSITION
			JP	EGO		;AND CARRY ON
		;
		; PERFORMS 16 BIT(HL) BY 16 BIT(BC) DIVIDE, RESULT IN DE, REM IN HL
		;
		DODIV	LD	A,B		;GET CONTENTS OV B
			CPL			;INVERT
			LD	B,A		;REPLECE
			LD	A,C		;GET CONTENTS IN C
			CPL			;INVERT
			LD	C,A		;REPLACE
			INC	BC		;COMPLETE TWO COMPLEMENT OPERATION
			EX	DE, HL	
			LD	HL,0		;ZERO HIGHER HALF
			CALL	DIVBYT		;PERFORM FIRST HALF
		DIVBYT	LD	A,D		;GET UPPER HALF
			LD	D,E		;SAVE LOWER HALF
			LD	E,8		;GET LOOP COUNT
		DIVTOP	ADD	HL,HL		;SHIFT LEFT
			JP C,	OVER1		;OVERFLOWED
			ADD	A,A		;SHIFT  RESULT
			JP NC,	SUBB		;IF NO CARRY, DON'T INC
			INC	HL		;ADVANCE UPPER VALUE
		SUBB	PUSH	HL		;SAVE VALUE
			ADD	HL,BC		;SUBTRACT LOWER HALF OF FRACTION
			JP C,	OKKK		;IF WRAP PAST ZERO
			POP	HL		;RESTORE VALUE
			JP	NXLP		;FINISH LOOP
		OKKK	INC	SP		;FIX UP
			INC	SP		;STACK
			INC	A		;ADVANCE RESULT
			JP	NXLP		;FINISH LOOP
		OVER1	ADC	A,A		;SHIFT RESULT, +1 FOR CARRY
			JP NC,	OVRSUB		;IF NO WRAP
			INC	HL		;INC. VALUE
		OVRSUB	ADD	HL,BC		;SUBTRACT LOWER
		NXLP	DEC	E		;REDUCE LOOP COUNTER
			JP NZ,	DIVTOP		;LOOP IF NOT FINISHED
			LD	E,A		;LOWER BYTE OF RESULT
			RET
		;
		; HE SHOULD KNOW THAT HE CAN'T DIVIDE BY ZERO, BUT JUST IN CASE...
		; WE WILL TELL HIM ANYWAY
		;
		DIVZE	LD	HL,DER		;ADDRESS OF 'DIVIDE BYE ZERO MESSAGE'
			JP	ERR		;HANDLE LIKE ANY OTHER ERROR
		; COMPARES H-L TO B-C, Z=1 IF HL=BC, C=1 IF HL<BC
		COMP	LD	A,H		;GET HIGH BYTE OF HL
			CP	B		;COMPARE WITH HIGH BYTE OF BC
			RET NZ			;IF NOT SAME, LOWER BYTE CAN BE IGNORED
			LD	A,L		;GET LOW BYTE OF HL
			CP	C		;COMPARE WITH LOW BYTE OF BC
			RET
		; FLOOR, RETURNS THE LESSER OF THE TWO NUMBERS
		FLOR:	CP	'\'		;IS IT FLOOR?
			JP NZ,	CEIL		;NO, TRY CEILING
			CALL	COMP		;COMPARE NEW TO OLD
			JP C,	EGO		;IF LESS, WE ARE OK (RESULT IS ALREADY IN HL)
		SWAP	LD	H,B		;MAKE OLD NUMBER..
			LD	L,C		;INTO THE NEW NUMBER..
			JP	EGO		;CONTINUE
		; CEILING, RETURNS THE GREATER OF THE TWO NUMBERS
		CEIL	CP	'/'		;IS IT CEILING?
			JP NZ,	LAND		;NO, TRY LOGICAL AND
			CALL	COMP		;COMPARE NEW AND OLD
			JP NC,	EGO		;IF GREATER, WE ARE OK (RESULT ALREADY IN HL)
			JP	SWAP		;MAKE OLD NEW AND CONTINUE
		; LOGICAL AND
		LAND	CP	'&'		;IF IT LOGICAL AND ?
			JP NZ,	LOR		;NO, TRY LOGICAL OR
			LD	A,B		;GET HIGH BYTE OF OLD
			AND	H		;AND WITH HIGH BYTE OF NEW
			LD	H,A		;AND REPLACE HIGH BYTE OF NEW
			LD	A,L		;GET LOW BYTE OF OLD
			AND	C		;AND WITH LOW BYTE OF NEW
			JP	CPYL		;CONTINUE
		; LOGICAL OR
		LOR	CP	'|'		;TEST FOR LOGICAL OR
			JP NZ,	GRTR		;NO, TRY GREATER THAN
			LD	A,H		;GET HIGH BYTE OF NEW
			OR	B		;OR WITH HIGH BYTE OF OLD
			LD	H,A		;AND REPLACE HIGH BYTE OF NEW
			LD	A,L		;GET LOW BYTE OF NEW
			OR	C		;OR WITH LOW BYTE OF OLD
		CPYL	LD	L,A		;AND REPLACE LOW BYTE OF NEW
			JP	EGO		;CONTINUE
		; GREATER THAN, RETURNS ONE OR ZERO
		GRTR	CP	'>'		;TEST FOR GREATER THAN
			JP NZ,	LETH		;IF NOT, TRY LESS THAN
			CALL	COMP		;COMPARE OLD AND NEW
			JP Z,	EGZ		;FALSE IF EQUAL
			JP C,	EGZ		;FALSE IF LESS THAN
			JP	EG1		;TRUE IF NOT LESS OR EQUAL
		; LESS THAN, RETURNS ONE OR ZERO
		LETH	CP	'<'		;IS IT LESS THAN?
			JP NZ,	ENOP		;NO, TRY NO-OP OPERATOR
			CALL	COMP		;COMPARE OLD AND NEW
			JP C,	EG1		;TRUE IF LESS
			JP	EGZ		;FALSE IF NOT LESS
		; NO-OP OPERATOR, RETURNS NEW VALUE ONLY
		ENOP	CP	';'		;IS IT NO-OP?
			JP Z,	EGO		;IF SO, DON'T DO ANYTHING
		; ASSIGNMENT, SET A VARIABLE'S VALUE
		ASST	CP	'='		;TEST FOR ASSIGNMENT
			JP NZ,	EQUAL		;IF NOT, TRY EQUALITY
			LD	(EFLAG), A	;SET ASSIGNMENT FLAG
			INC	DE		;BACK UP TO VARIABLE NAME
			LD	A, (DE)		;GET VARIABLE CHARACTER
			CP	']'		;TEST FOR ARRAY STORAGE
			JP Z,	ASTOR		;IF SO, STORE INTO ARRAY
			LD	H,B		;GET OLD VALUE
			LD	L,C		;INTO H-L (WHERE STORE WANTS THEM)
			CP	'?'		;TEST FOR SETTING RANDOM SEED
			JP Z,	SRSEED		;IF SO, SET THE SEED
			CALL	STOR		;STORE VALUE INTO VARIABLE
		STRT	DEC	DE		;STEP BACK FROM VARIABLE
			JP	EGO		;AND CONTINUE
		; SET THE RANDOM SEED
		SRSEED	LD	(SEED), HL	;SO WE CAN STORE IN SEED
			JP	STRT		;AND CONTINUE
		; SET THE VALUE OF AN ARRAY ELEMENT
		ASTOR	PUSH	HL		;SAVE H-L
			CALL	DOEXP		;CALCULATE INDEX VALUE
			DEC	DE		;BACK UP PAST '['
			LD	A, (DE)		;GET ARRAY NAME
			CALL	LOOKT		;LOOK UP IT'S ADDRESS IN THE TABLE
			LD	B,H		;GET ARRAY ADDRESS
			LD	C,L		;INTO B-C
			POP	HL		;RERSTORE H-L
			LD	A, (DE)		;GET ARRAY NAME BACK
			CP	'@'		;TEST FOR 'MAGIC', MEMORY REFERENCE
			JP Z,	STMEM		;IF SO, SET MEMORY LOCATION
			LD	A,H		;GET HIGH BYTE OF VALUE
			LD	(BC), A		;STASH IN ARRAY
			INC	BC		;POINT TO NEXT
		STMEM	LD	A,L		;GET LOW BYTE OF VALUE
			LD	(BC), A		;STASH IN ARRAY
			JP	STRT		;CONTINUE
		; TEST FOR EQUALITY.  ('==')
		EQUAL	SUB	0x81		;IS A '=='?
			JP NZ,	GEQL		;IF NOT, TRY GREATER OR EQUAL
			CALL	COMP		;COMPARE OLD AND NEW
			JP Z,	EG1		;TRUE IF EQUAL
			JP	EGZ		;FALSE IF NOT EQUAL
		; GREATER OR EQUAL.  ('>=')
		GEQL	DEC	A		;TEST FOR '>='?
			JP NZ,	LEQL		;NO, TRY LESS OR EQUAL
			CALL	COMP		;COMPARE OLD AND NEW
			JP C,	EGZ		;FALSE IF LESS THAN
			JP	EG1		;TRUE IF GREATER OR EQUAL
		; LESS OR EQUAL.  ('<=')
		LEQL	DEC	A		;TEST FOR '<='?
			JP NZ,	NEQL		;IF NOT, TRY NOT EQUAL
			CALL	COMP		;COMPARE OLD AND NEW
			JP Z,	EG1		;TRUE IF SAME
			JP C,	EG1		;TRUE IF LESS THAN
			JP	EGZ		;FALSE OTHERWISE
		; TEST FOR NOT EQUAL.  ('-=')
		NEQL	DEC	A		;IS IT '-='?
			JP NZ,	SYNT		;BEATS ME WHAT IT IS!
			CALL	COMP		;COMPARE OLD AND NEW
			JP Z,	EGZ		;IF SAME, FALSE
		; RETURN RESULT OF ONE
		EG1	LD	HL,1		;SET RESULT TO ONE
			JP	EGO		;PASS ON RESULT
		; RETURN RESULT OF ZERO
		EGZ	LD	HL,0		;SET RESULT TO ZERO
		; END OF OPERATION, GET NEXT OPERATOR
		EGO	CALL	FE		;GET NEXT CHARACTER
			RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT
			CP	'('		;ARE WE RETURNING FROM A NEST?
			;RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT	
			JR  NZ,	EGOP1
						;CHECK FOR FUNCTION				
			LD	A, (PP)		;GET ADDRESS OF BEGINNING OF LINE
			DEC	DE
			CP	E		;ARE WE THERE??
			JR  Z,	EGOF1
			DEC	DE
			CP	E		;ARE WE THERE??
			JR  Z,	EGOF2
			LD	A,(DE)
			CP	'I'
			JR NZ,	EGOF2
			INC	DE
			LD	A,(DE)					
			CP	'N'
			JR NZ,	EGOF1
			
			DEC	DE
			PUSH	BC
			LD	C,L
			IN	A,(C)
			POP	BC
			LD	L,A
			LD	H,0
			
			JR	EGOF0
			
		EGOF2	INC	DE
		EGOF1	INC	DE
		EGOF0	LD	A,'('
			CP	'('
			RET			;IF SO, BACK UP ONE LEVEL
			
		EGOP1	CP	'['		;FINISHED AN ARRAY INDEX EVALUATION?
			RET Z			;RETURN TO MAIN EXPRESSION
			CP	'='		;IF IT A MULTI-CHARACTER OPERATOR
			JP NZ,	EGO1		;IF NOT, DON'T PRE-EVALUATE
			DEC	DE		;BACK UP TO PRECEDING CHARACTER
			LD	A, (DE)		;GET PRECEDING CHARACTER
			CP	'='		;IS IT '=='?
			LD	B,0x81		;SET UNIQUE CODE
			JP Z,	EGO2		;IF '==' THEN WE HAVE IT
			INC	BC		;NEXT UNIQUE CODE
			CP	'>'		;IS IT '>='?
			JP Z,	EGO2		;IF SO, WE HAVE IT
			INC	BC		;NEXT UNIQUE CODE
			CP	'<'		;IS IT '<='?
			JP Z,	EGO2		;IF SO, WE HAVE IT
			INC	BC		;NEXT UNIQUE CODE
			CP	'-'		;IS IT '-='?
			JP Z,	EGO2		;IF SO, WE HAVE IT
			INC	DE		;WASN'T A TWO CHARACTER OPERATOR. BACK UP
			LD	A,'='		;MUST HAVE BEEN A SIMPLE '='
			JP	EGO1		;CONTINUE EVALUATING EXPRESSION
		EGO2	LD	A,B		;SET OPERATOR TO OUR UNIQUE CODE
			JP	EGO1		;AND CONTINUE EVALUATING EXPRESSION
		; FINDS NEXT CHARACTER IN EXPRESSION, SETS Z FLAG IF WE PASS THE BEGINNING
		FE	LD	A, (PP)		;GET ADDRESS OF BEGINNING OF LINE
			CP	E		;ARE WE THERE??
			RET Z			;IF SO, WE ARE FINISHED
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	' '		;IS A (USELESS) BLANK?
			RET NZ			;IF NOT, WE ARE FINISHED
			DEC	DE		;BACK UP ANOTHER CHARACTER
			JP	FE		;AND TRY AGAIN
		; CALCULATE A PSEUDO-RANDOM VALUE
		RANDR	LD	HL, (SEED)	;GET RANDOM SEED
			LD	A,H		;GET HIGH BYTE OF SEED
			AND	0xF7		;AND WITH HIGH MASK
			PUSH	AF
			LD	A,L		;GET LOW BYTE OF SEED
			AND	0x42		;AND WITH LOW BYTE OF MASK
			PUSH	AF
			POP	BC		;GET FLAGS IN C
			LD	A,C		;COPY TO A
			POP	BC		;GET FIRST SET OF FLAGS IN C
			XOR	C		;COMPUTE PARITY FOR ENTIRE WORD
			RRCA			;MOVE COMPUTED
			RRCA			;PARITY INTO
			RRCA			;THE CARRY FLAG
			CCF			;COMP, SO SHIFT IN 1 IF EVEN
			LD	A,L		;GET LOW BYTE OF SEED
			RLA			;SHIFT IN CARRY, OUT HIGH BIT
			LD	L,A		;RESAVE
			LD	A,H		;GET HIGH BYTE OF SEED
			RLA			;SHIFT IN CARRY (HIGH BIT OF OLD LOWER)
			LD	H,A		;RESAVE
			LD	(SEED), HL	;RESULT IS NEW SEED
			JP	DCLB		;KEEP GOING
		;
		; EVALUATES A CHARACTER EXPRESSION
		;
		CEXP	CALL	CLBF		;CLEAR EXTRA BUFFER
			INC	DE		;SKIP TO END OF EXPRESSION
			LD	A,'+'		;TO BEGIN, CONCATINATE A NULL STRING
		CG1	PUSH	AF
			CALL	PUSHB		;COPY NEW BUFFER INTO OLD BUFFER
			CALL	CLBF		;CLEAR THE NEW BUFFER
			DEC	DE		;BACK UP IN SOURCE
			CALL	FE		;GET CHARACTER AND TEST FOR END
			CP	'"'		;TEST FOR QUOTE
			JP Z,	CQ		;IF SO, HANDLE QUOTED STRING
			CP	'$'		;TEST FOR CHARACTER VARIABLE
			JP NZ,	SYNT		;IF NOT, IT'S NOT ANYTHING I RECOGNISE
		CV	DEC	DE		;BACK UP PAST DOLLAR SIGN
			LD	A, (DE)		;GET VARIABLE NAME
			CP	']'		;TEST FOR INDEX INTO CHARACTER VARIABLE
			JP Z,	CINDX		;GET INDEX VALUE
			CALL	LTA		;GET ADDRESS OF VARIABLE
			PUSH	DE		;SAVE SOURCE POSITION
			EX	DE, HL	
			DEC	DE		;BACK UP IN SOURCE
			JP	Q0		;SAVE VARIABLE IN NEW BUFFER
		; BACKUP TO PRECEDING QUOTE
		CQ	DEC	DE		;BACKUP IN SOURCE
			LD	A, (DE)		;GET CHARACTER FROM SOURCE
			CP	CR		;TEST FOR END OF LINE
			JP Z,	SYNT		;IF SO, THERE IS NO CLOSEING QUOTE
			CP	'"'		;TEST FOR CLOSEING QUOTE
			JP NZ,	CQ		;IF NO, KEEP LOOKING
			PUSH	DE		;SAVE ENDING POSITION
		Q0	LD	HL,XBF		;GET ADDRESS OF NEW (EXTRA) BUFFER
		Q1	INC	DE		;ADVANCE TO SOURCE OR VARIABLE CHARACTER
			LD	A, (DE)		;GET CHARACTER
			CP	'"'		;TEST FOR CLOSEING QUOTE
			JP Z,	Q2		;IF SO, STOP COPYING
			CP	0xFF		;TEST FOR END OF VARIABLE
			JP Z,	Q2		;IF SO, STOP COPYING
			LD	(HL),A		;SAVE IN BUFFER
			INC	HL		;ADVANCE IN BUFFER
			JP	Q1		;KEEP COPYING
		Q2	POP	DE		;GET POSITION BACK
		Q3	DEC	DE		;BACK UP TO OPERATOR
			POP	AF
			CP	'+'		;TEST FOR CONCATIONATION
			JP NZ,	Q5		;NO, TRY ASSIGNMENT
		; CONCATONATION. XBF=XBF+TB
		QPP	LD	BC,TB		;ADDRESS OF TEMPORARY BUFFER
		Q4	LD	A, (BC)		;GET CHARACTER FROM BUFFER
			LD	(HL),A		;MOVE TO BUFFER
			INC	BC		;ADVANCE IN OLD
			INC	HL		;ADVANCE IN NEW
			LD	A,C		;GET ADDRESS IN OLD
			CP	LOW (TB+35)		;TEST FOR OVER
			JP C,	Q4		;IF SO, STOP
			LD	HL, (XBF)	;GET CHARACTER FROM BUFFER
			LD	H,0		;SET HIGH BYTE TO ZERO
			JP	Q9		;CONTINUE
		; ASSIGNMENT
		Q5	CP	'='		;TEST FOR ASSIGNMENT
			JP NZ,	Q6		;IF NOT, TRY EQUALITY
			INC	DE		;SKIP TO VARIABLE NAME
			INC	DE		;SKIP TO DOLLARSIGN
			LD	A, (DE)		;GET DOLLARSIGN
			DEC	DE		;BACK UP TO VARIABLE NAME
			CP	'$'		;TEST FOR DOLLAR SIGN
			JP NZ,	SYNT		;IF NOT, THIS AIN'T NO CHARACTER VARIABLE
			LD	(EFLAG), A	;SET ASSIGNMENT FLAG
			LD	A, (DE)		;GET VARIABLE NAME
			DEC	DE		;BACK UP BAST NAME
			CALL	LTA		;GET IT'S ADDRESS
			JP	QPP		;COPY IT OVER
		; TEST FOR EQUALITY
		Q6	CP	0x81		;TEST FOR '=='
			JP NZ,	X0		;NO, TRY '=-'
			CALL	COMSTR		;COMPARE STRINGS
			JP	Q9		;CONTINUE
		; COMPARES STRINGS. SETS H-L TO 1 OR 0 IF EQUAL OR NOT EQUAL
		COMSTR	LD	BC,TB		;GET ADDRESS OF OLD STRING
			LD	HL,XBF		;ADDRESS OF NEW STRING
		Q7	LD	A, (BC)		;GET CHARACTER FROM OLD
			CP	(HL)		;TEST AGAINST NEW
			JP NZ,	Q8		;IF NOT, THEY ARE UNEQUAL
			INC	BC		;NEXT PLACE IN OLD
			INC	HL		;NEXT PLACE IN NEW
			INC	A		;TEST FOR END OF STRING
			JP NZ,	Q7		;IF NOT, CONTINUE TESTING
			LD	HL,1		;INDICATE THEY ARE EQUAL
			RET
		Q8	LD	HL,0		;INDICATE NOT EQUAL
			RET
		; NOT EQUAL .. '-='
		X0	CP	0x82		;TEST FOR '-='
			JP NZ,	SYNT		;BEATS ME, BUT IT ISN'T RIGHT
			CALL	COMSTR		;TEST STRINGS
			LD	A,L		;GET RESULT
			XOR	1		;AND COMPLEMENT IT
			LD	L,A		;REPLACE IN RESULT
		; GET NEXT STRING
		Q9	CALL	FE		;GET NEXT CHARACTER
			SCF			;INDICATE CHARACTER EXPRESSION
			RET Z			;IF END OF LINE, QUIT
			CP	'('		;TEST FOR END OF NUMERIC SUBSTRING
			RET Z			;QUIT, INDICATING NUMBERIC RESULT
			CP	'='		;TEST FOR EQUAL,ASSIGNMENT, OR NOT EQUALS
			JP NZ,	CG1		;NO, NO NEED TO TEST FURTHER
		QTST	DEC	DE		;BACK UP TO PREVIOUS CHARACTER
			LD	A, (DE)		;GET CHARACTER
			LD	B,A		;SAVE FOR COMPARISON
			CP	'='		;TEST FOR '=='
			LD	A,0x81		;INDICATE '=='
			JP Z,	CG1		;CONTINUE
			LD	A,B		;GET CHARACTER BACK
			CP	'-'		;TEST FOR '-='
			LD	A,0x82		;INDICATE '-='
			JP Z,	CG1		;CONTINUE
			INC	DE		;ADVANCE BACK TO PREVIOUS CHARACTER
			LD	A,'='		;INDICATE '='
			JP	CG1		;CONTINUE
		; CLEARS THE TEXT BUFFER
		CLBF	LD	HL,XBF		;GET ADDRESS OF BUFFER
			LD	A,40		;CLEAR FOR LENGTH OF 40
		CL2	LD	(HL),0xFF	;CLEAR TO NULL CHARACTER
			INC	HL		;NEXT POSITION IN BUFFER
			DEC	A		;REDUCE COUNT OF REMAINING
			JP NZ,	CL2		;KEEP GOING TILL WE ARE FINISHED
			RET
		; COPY'S NEW BUFFER INTO OLD BUFFER
		PUSHB	PUSH	DE		;SAVE POSITION IS SOURCE
			LD	DE,XBF		;GET ADDRESS OF NEW BUFFER
			LD	HL,TB		;GET ADDRESS OF OLD BUFFER
			LD	B,40		;COPY 40 CHARACTERS
		PU1	LD	A, (DE)		;GET CHARACTER FROM NEW
			LD	(HL),A		;SAVE IN OLD
			INC	HL		;NEXT POSITION IN OLD
			INC	DE		;NEXT POSITION IN NEW
			DEC	BC		;REDUCE COUNT
			JP NZ,	PU1		;KEEP GOING TILL 40 ARE MOVED
			POP	DE		;RESTORE POSITION IN SOURCE
			RET
		; INDEXED CHARACTER VARIABLE, EXTRACT A SINGLE CHARACTER
		CINDX	CALL	DOEXP		;EVALUATE INDEX EXPRESSION
			LD	A,L		;GET INDEX VALUE
			PUSH	AF
			DEC	DE		;BACK UP TO VARIABLE NAME
			LD	A, (DE)		;GET VARIABLE NAME
			CP	'@'		;TEST FOR 'MAGIC' CHR0x VARIABLE
			JP Z,	CHR		;IF SO, HANDLE SPECIAL CASE
			CALL	LTA		;GET TEXT VARIABLE ADDRESS
			POP	AF
			CP	35		;TEST FOR TOO BIG
			JP NC,	DIMERR		;IF SO, TELL HIM HE SCREWED UP
			LD	C,A		;GET INTO A DOUBLE PAIR
			ADD	HL,BC		;SO WE CAN DAD IT TO THE ADDRESS
			LD	A,(HL)		;AND GET THE CHARACTER
		FILBUF	LD	HL,XBF		;ADDRESS OF TEXT BUFFER
			LD	(HL),A		;PLACE CHARACTER THERE
			INC	HL		;BUMP TO NEXT POSITION
			JP	Q3		;AND FILL WITH NULLS
		;
		; 'MAGIC' CHARACTER ARRAY, RETURNS CHARACTER WITH VALUE OF IT'S INDEX
		;
		CHR	POP	AF
			JP	FILBUF		;SAVE IN BUFFER AND PAD WITH NULLS
			
		;*********************************************************************
		;                          PATCH I/O ROUTINES TO Z80MC
			
		CTRLC	CALL	BINCHR
			CP	3
			RET
		BGETCHR CALL	BINCHR
			JR C,	BGETCHR
			RET
		; END OF BASIC INTERPRETER CODE SECTION
		;	PAGE
		;
		;*********************************************************************
		;                          COMMAND TABLE
		;
		;   FORMAT IS:
		;               COMMAND WORDS, HIGH BIT SET ON LAST CHARACTER
		;               ADDRESS OF COMMAND PROCESSOR FOLLOWES
		;               ENTRY OF HEX 00 INDICATES LAST ENTRY IN TABLE (DEFAULT)
		;
		;*********************************************************************
		;
		; COMMANDS ALLOWED ONLY FROM WITHING A PROGRAM..
		PTAB	DB	'NEX'
			DB	'T'+0x80
			DW	NEXT
			DB	'THE'
			DB	'N'+0x80
			DW	THEN
			DB	'GOSU'
			DB	'B'+0x80
			DW	GOSUB
			DB	'RETUR'
			DB	'N'+0x80
			DW	RETURN
			DB	'FO'
			DB	'R'+0x80
			DW	FOR
			DB	'I'
			DB	'F'+0x80
			DW	IF
		DATCMD	DB	'DAT'
			DB	'A'+0x80
			DW	RNEXT
			DB	'LI'
			DB	'F'+0x80
			DW	LIF
		; COMMANDS ALLOWED FROM BOTH A PROGRAM, AND INTERACTIVE KEYBOARD ENTRY
		KTAB	DB	'GOT'
			DB	'O'+0x80
			DW	GOTO
			DB	'OU'
			DB	'T'+0x80	
			DW	OUTP
			DB	'LE'
			DB	'T'+0x80
			DW	LET
			DB	'PRIN'
			DB	'T'+0x80
			DW	BPRINT
			DB	'US'
			DB	'R'+0x80
			DW	USR
			DB	'REA'
			DB	'D'+0x80
			DW	READ
			DB	'PLO'
			DB	'T'+0x80
			DW	PLOT
			DB	'RE'
			DB	'M'+0x80
			DW	REM
			DB	'DI'
			DB	'M'+0x80
			DW	DIM
			DB	'RU'
			DB	'N'+0x80
			DW	RUN
			DB	'ORDE'
			DB	'R'+0x80
			DW	ORDER
			DB	'INPU'
			DB	'T'+0x80
			DW	INPUT
			DB	'CLEA'
			DB	'R'+0x80
			DW	CLEAR
			DB	'STO'
			DB	'P'+0x80
			DW	STOP
			DB	'EN'
			DB	'D'+0x80
			DW	INIT
			DB	'LIS'
			DB	'T'+0x80
			DW	LIST
			DB	'NE'
			DB	'W'+0x80
			DW	NEW
			DB	'SIZ'
			DB	'E'+0x80
			DW	SIZE
			DB	'LOA'
			DB	'D'+0x80
			DW	LOAD
			DB	'SAV'
			DB	'E'+0x80
			DW	SAVE
			DB	'EXI'
			DB	'T'+0x80
			DW	BEXIT
			DB	0		;UNRECOGNIZED COMMAND, ASSUME 'LET'
			DW	LET
		;
		;**************************************************************
		;                    STRINGS AND MESSAGES
		;**************************************************************
		;
		; ERROR MESSAGES..
		;
		DER	DB	'DIVIDE BY ZERO',0 ;DIVIDE BY ZERO
		IERMS	DB	'BAD DATA - RETRY',CR,LF,0 ;BAD RESPONSE TO INPUT STATEMENT
		CSTK	DB	'NESTING',0	;INVALID FOR/NEXT, GOSUB/RETURN NESTING
		LIN	DB	'LINE NUMBER',0	;GOTO, GOSUB, OR ORDER TO UNKNOWN LINE
		NP	DB	'NO PROGRAM',0	;RUN OR SAVE EMPTY PROGRAM
		INL	DB	' IN LINE ',0	;INDICATES LINE ERROR WAS IN
		SYN	DB	'SYNTAX',0	;DOES NOT FOLLOW SYNTAX RULES
		DTXT	DB	'DATA',0	;BAD LINE OR DATA TYPE
		OVM	DB	'DIMENSION',0	;TO MANY ARRAYS, ARGUMENT OUT OF RANGE
		;
		; INFORMATIONAL MESSAGES..
		;
		INTRO	DB	0x0C,' MICRO-BASIC COPYRIGHT 1983 BY DAVE DUNFIELD',CR,LF,0
		RDY	DB	'READY',CR,LF,0	;RREADY PROMPT
		STMSG	DB	'STOP',0	;INDICATES PROGRAM STOPPED
		EM	DB	' ERROR',0	;INDICATES ERROR OCCURED
		SIMSG	DB	' BYTES',CR,LF,0 ;DISPLAYED IN RESPONSE TO 'SIZE'
		ENDIT	EQU	$
		;	END	0
			
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;	Appendix_B	Future Use
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;	Appendix_C	RAM. System Ram allocation
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;                       ********      ***     **     **
		;                       *********    *****    ***   ***
		;                       **     **   *** ***   **** ****
		;                       **     **  ***   ***  *********
		;---------------------  ********   *********  ** *** **  ---------------------
		;---------------------  ********   *********  ** *** **  ---------------------
		;                       **  **     **     **  **     **
		;                       **   **    **     **  **     **
		;                       **    **   **     **  **     **
		;                       **     **  **     **  **     **
		RAM_LDRT	equ	0x8000
				ORG	0xFA00
;		LINE_BUFF	DS	128
;		LINE_BUFFEND	DS	2	;Room for CR,LF if needed
;		LI_FILESIZE	DS	4	;LINE INPUT FILE SIZE, counts down the bytes in the file as Lines are fetched
;		LI_SDBUFF_PTR	DS	2	;Pointer to Disk Buffer for next Line Read operation
;		LI_SDLOG_SEC	DS	2	;Logical Sector last read in Buffer
						;Read Hex File Performance counter
;		RHF_LINES	DS	2	;Line counter
		;----------------------------------------------------------------------------------------------------; RAM SPACE
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;----------------------------------------------------------------------------------------------------; RAM SPACE
		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		;Reserve space from 0xFB00 to FB1F for Stack
		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				ORG	0xFB00
;		StackTop	equ	$-2	; Stack = 0xFB00
;		STACKSPACE1	DS	40	;Stack space for ISR L1 calls  (Measured to only need 14 words, resv 20 words)
;		STACK_ISR1	EQU	$	;Points to top of stack
;		SP_ISR_SAVE	DS	2	;Space to save SP, Happens on first ISR call
;		HRAM_CODE	DS	ROM_CODE_LEN	;Code for Returning from ISR (may need to switch to RAM, so it must be here in High RAM)
;		ISR_DISPATCH	EQU	HRAM_CODE
;		ISR_RET		EQU	ISR_RET_OFF+HRAM_CODE ;Assign address in the HIGH RAM
;		GET_MEM		EQU	GET_MEM_OFF+HRAM_CODE ;Assign address in the HIGH RAM	
;		HR_EXE_GO	DS	HR_EXEC_GS_LEN	;Routine for Switching to RAM and Executing loaded program.
;		HERE1		EQU	$
			IF HERE1 > 0xFB80
			ENDIF
			
			;FREE RAM 25 BYTES
				ORG	0xFB80
		;SDFCB:
		FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
		FNAME		EQU	1	;DS 11	;+1  File name
		AFClus0		EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
		CRFClus		EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
		CAFClus		EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
		RFSec		EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
		SSOC		EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
		ABS_SEC		EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
		FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)
		;Warning: FCB's must never cross page boundaries.
;		SDISKA		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
;		SDISKB		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
;		SDISKC		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
;		SDISKD		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
		;
		;  ********   **     **  *********  *********  *********  ********
		;  *********  **     **  *********  *********  *********  *********
		;  **     **  **     **  **         **         **         **     **
		;  **     **  **     **  **         **         **         **     **
		;  ********   **     **  *******    *******    *******    ********
		;  ********   **     **  *******    *******    *******    ********
		;  **     **  **     **  **         **         **         **  **
		;  **     **  **     **  **         **         **         **   **
		;  *********  *********  **         **         *********  **    **
		;  ********    *******   **         **         *********  **     **
		;
				ORG	0xFC00
;		SD_RAM_BUFFER	DS	512	;FC00-FDFF 512 bytes of SD Sector Buffer space
;		RXBUFFER	DS	256	;FExx      256 bytes of RX Buffer space
		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				ORG	0xFF00
;		BIT_TABLE	DS	8
		;Warning: FCB's must never cross page boundaries.
;		FCB_PTR		DS	2	;Pointer to Current FCB
;		FAT_CLEAR	EQU	$	;Clear bytes of RAM after this point on FAT_INIT
;		GH_START	DS	2	;HEX File, start address
;		VIEW_FLAGS	DS	1	;View File Load;  File Open View
						;BIT .0=View HEX Load, display file while reading HEX file
						;    .1=GH_START Address has been set
						;    .6=View FILE SIZE during File Open
						;    .7=View File Name & Found or Not status durin File Open
;		LOGICAL_SEC	DS	2	;Logical Sector for next Read Operation (Input paramater for the File Read)
;		DIRTY_DATA	DS	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
;		SD_CARD_TYPE	DS	1	;SD CARD TYPE
;		SDC_STATUS	DS	1	;SD Status Code returned
;		SD_PARAM	DS	4	;32 bit address parameter for SD Commands
;		SD_PART_TYPE	DS	1	;SD PARTITION TYPE
;		SD_PART_BASE	DS	4	;SD PARTITION STARTING RECORD
;		SD_PART_SIZE	DS	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
;		BYTE_P_SEC	DS	2	;0x0B Bytes per Sector (Almost always 512)
;		SEC_PER_CLUS	DS	1	;0x0D
;		RESERVED_SEC	DS	2	;0x0E - 0x0F
;		FAT_COPIES	DS	1	;0x10
;		ROOTDIR_SIZE	DS	2	;0x11 - 0x12
;		FILESYS_SEC	DS	4	;0x13 - 0x14 or 0x20 - 0x23
;		HIDDEN_SEC	DS	4	;0x1C - 0x1F
;		SEC_PER_FAT	DS	2	;0x16 - 0x17
;		FAT1START	DS	4	;Calculated Sector to FAT1
;		DIR_SECTOR	DS	4	;Calculated Sector to Root Directory
;		DATASTART	DS	4	;Calculated Sector to Data Area
;		SEC_PTR		DS	4	;Sector Pointer, general use variable that holds the last sector read
;		ENT_COUNT	DS	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
;		FAT_CLR_LEN	EQU	$ - FAT_CLEAR
;		FILENAME	DS	8	;File Name
;		FILEEXT		DS	3	;File Extension
;		FILESIZE	DS	4	;File Size
;		DIVIDE_FUNC	DS	2	;Pointer to the Divide Function
;		DF_SHIFTCNT	DS	1	;Count of shifts required for Fast Divide
;		MUL8		DS	1	;8 bit multiplier
;		MOD_FUNC	DS	2	;Pointer to the Mod Function
;		MODMASK		DS	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector
;		IK_HEXL		DS	1	;IMON HEX INPUT
;		IK_HEXH		DS	1	;IMON HEX INPUT
;		HEX_SOURCE	DS	2	;Pointer to the HEX INPUT Source (FILE or Serial Port)
;			IF $ >= 0xFF78
;			ENDIF
;		;*** BEGIN COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
		RAMSIGNATURE	equ	0xFF78	;RAM signature
						;Following bytes are cleared on COLD BOOT
		RC_TYPE		equ	0xFF80	;(1) Type of Reset (WARNING, Next 7 RC counters must end with lsb bits = 001,010,011,100,101,110,111)
		RC_SOFT		equ	0xFF81	;(1) Count of Resets by SOFT F-E SWITCH
		RC_STEP		equ	0xFF82	;(1) Count of Resets by SINGLE STEP
		RC_CC		equ	0xFF83	;(1) Count of Resets by CTRL-C
		RC_HALT		equ	0xFF84	;(1) Count of Resets by HALT INSTRUCTION
		RC_F0		equ	0xFF85	;(1) Count of Resets by pressing F & 0 keys
		RC_RST0		equ	0xFF86	;(1) Count of Resets by RST 0 INSTRUCTION
		RC_HARD		equ	0xFF87	;(1) Count of Resets by UNKNOWN RESET LINE
		ABUSS		equ	0xFF88	;(2)
		RegPtr		equ	0xFF8A	;(1) Ptr to Registers
		IoPtr		equ	0xFF8B	;(1)  I/O Ptr
		RX_ERR_LDRT	equ	0xFF8C	;(1) Counts False Start Bits (Noise Flag)
		RX_ERR_STOP	equ	0xFF8D	;(1) Counts Missing Stop Bits (Framing Error)
		RX_ERR_OVR	equ	0xFF8E	;(1) Counts Overrun Errors
		CS_CLR_LEN	equ	0xFF8F-RC_TYPE
		ACE_BAUD	equ	0xFF8F	;(1) Baudrate of ACE, 12=9600
						;PUTCHAR_EXE and INCHAR_EXE *must be consecutive in this order*
		PUTCHAR_EXE	equ	0xFF90	;(2) PutChar Execution (Set for PC_LED, PC_BIT, PC_ACE or PC_BOTH)
		INCHAR_EXE	equ	0xFF92	;(2) InChar Execution (Set for IN_KEY, IN_BIT, IN_ACE or IN_BOTH)
		;*** END COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
		HW_SETIO	equ	0xFF94	;Serial IO selected, 01=Bit, 02=ACE, 03=BIT & ACE
		HW_LIST		equ	0xFF95	;Hardware List, 00=NO Boards, 01=FP Only, 02=SIO only, 03=FP & SIO
						;Saved Registers
		RSSP		equ	0xFF96	;Value of SP upon REGISTER SAVE
		RSAF		equ	0xFF98	;Value of AF upon REGISTER SAVE
		RSBC		equ	0xFF9A	;Value of BC upon REGISTER SAVE
		RSDE		equ	0xFF9C	;Value of DE upon REGISTER SAVE
		RSHL		equ	0xFF9E	;Value of HL upon REGISTER SAVE
		RPC		equ	0xFFA0	;Value of PC upon REGISTER SAVE
		RSIX		equ	0xFFA2	;Value of IX upon REGISTER SAVE
		RSIY		equ	0xFFA4	;Value of IY upon REGISTER SAVE
		RSIR		equ	0xFFA6	;Value of IR upon REGISTER SAVE
		RSAF2		equ	0xFFA8	;Value of AF' upon REGISTER SAVE
		RSBC2		equ	0xFFAA	;Value of BC' upon REGISTER SAVE
		RSDE2		equ	0xFFAC	;Value of DE' upon REGISTER SAVE
		RSHL2		equ	0xFFAE	;Value of HL' upon REGISTER SAVE
		UiVec		equ	0xFFB0	;(2) User Interrupt Vector
		;*** BEGIN WARM_BOOT_INIT (RAM that is to be initialized on every boot) ***
						;WARNING, Following 34 bytes must be consecutive in this order for Block Write
		BEEP_TO		equ	0xFFB2	;(1) Count down the beep (beep duration)
		ANBAR_DEF	equ	0xFFB3	;(1) Base setting for the Annunciator LED's (after current function times out)
		GET_REG		equ	0xFFB4	;(2) Get Reg Routine (in monitor mode, registers fetched from RAM)
		PUT_REG		equ	0xFFB6	;(2) Put Reg Routine
		CTRL_C_CHK	equ	0xFFB8	;(2) Vector for CTRL-C Checking
		LDISPMODE	equ	0xFFBA	;(2) Last Display Mode (Holds DISPMODE while in HEX Entry)
		DISPMODE	equ	0xFFBC	;(2) Display Routine
		KEY_EVENT	equ	0xFFBE	;(2) Routine to call upon Key Press (changes based on user actions, see KEY_EVENT_DISPATCH)
		IK_TIMER	equ	0xFFC0	;(1) IMON TIMEOUT
		KEYBFMODE	equ	0xFFC1	;(1) KEY INPUT MODE. 8F=HEX INPUT, 90=Shiftable
		DISPLABEL	equ	0xFFC2	;(1) Display Label Refresh
		IK_HEXST	equ	0xFFC3	;(1) IMON HEX Input State
		HEX_CURSOR	equ	0xFFC4	;(2) HEX Input Cursor location
		HEX_READY	equ	0xFFC6	;(2) HEX Input Ready
		LED_CURSOR	equ	0xFFC8	;(2) Cursor location for LED Put_Char
		RXBHEAD		equ	0xFFCA	;(2) RS-232 RX BUFFER HEAD
		RXBTAIL		equ	0xFFCC	;(2) RS-232 RX BUFFER TAIL
		INT_VEC		equ	0xFFCE	;(2) Vector to Interrupt ISR
		SCAN_PTR	equ	0xFFD0	;(2) SCAN_PTR points to next LED_DISPLAY byte to output (will always be 1 more
						;    than the current hardware column because hardware automatically advances)
		HALT_TEST	equ	0xFFD2	;(2) HALT_TEST
		;*** END WARM_BOOT_INIT (RAM BLOCK that is to be initialized on every boot) ***
		CLEARED_SPACE	equ	0xFFD4	;Bytes here and later are cleared upon init (some initialized seperately)
		CLEARED_LEN	equ	0xFFFF - CLEARED_SPACE + 1
		SDISPMODE	equ	0xFFD4	;(2)
		POS_BIT		equ	0xFFD6	;(1) BIT Bang RS232 Character position
		POS_ACE		equ	0xFFD7	;(1) ACE RS232 Character position
		ISR_FLAGS	equ	0xFFD8	;(1) Indicates how many levels the ISR has nested
		RRSTATE		equ	0xFFD9	;(1) RAM/ROM SELECT STATE (FOR RETURN FROM ISR)	
		XTIMER_TIC	equ	0xFFDA	;(1) Counts Down tics until Extended Timer ISR_EXXTIMER
		READ_RAMROM	equ	0xFFDB	;(1) Selected RAMROM for Monitor READ Operations.  Bit0 for RAM/ROM, Bits1-4 for Bank
		NMI_VEC		equ	0xFFDC	;(2) NMI VEC.  Not used
		CTRL_C_TIMER	equ	0xFFDE	;Count down the CTRL-C condition
		SOFT_RST_FLAG	equ	0xFFDF	;Flag a Soft Reset (F-E Keys, Single Step)
						;Display/Serial Comms
		LED_DISPLAY	equ	0xFFE0	;8 Bytes of LED Output bytes to Scan to hardware
		;8 Bytes			;Warning, LED_DISPLAY must be nibble aligned at E0 (XXE0)
		LED_ANBAR	equ	0xFFE7	;LED Annunciator Bar (Part of LED_DISPLAY Buffer)
						;.0 = x7 = BEEPER
						;.1 = x6 = Run Mode
						;.2 = x5 = Monitor Mode (Default Mode upon Power up)
						;.3 = x4 = Send Data to Output Port
						;.4 = x3 = Alter Memory/Register
						;.5 = x2 = Enter Memory Location
						;.6 = x1 = Enter Register
		KBCOLSAMPLED	equ	0xFFE8	;Columns Sampled
		KBPORTSAMPLE	equ	0xFFE9	;Input Port sampled only once on each scan, saved here
		KBHEXSAMPLE	equ	0xFFEA	;KEY SAMPLER Input HEX format
		KEYBSCANPV	equ	0xFFEB	;KEY Input HEX format
		KEYBSCANTIMER	equ	0xFFEC	;KEY Input TIMER
		KEY_PRES_EV	equ	0xFFED	;KEY INPUT LAST & Currently Processing
		KEY_PRES_RTN	equ	0xFFEE	;KEY LAST, for Return To Normal between strokes
		KEY_PRESSED	equ	0xFFEF	;(1) KEY PRESSED
		TicCounter	equ	0xFFF0	;Tic Counter
		;TicCounter	equ	0xFFF1	;
		ECHO_STATE	equ	0xFFF2	;Echo characters
		XMSEQ		equ	0xFFF3	;XMODEM SEQUENCE NUMBER
		XMTYPE		equ	0xFFF4	;XMODEM BLOCK TYPE (CRC/CS)
		SCAN_LED	equ	0xFFF5	;Holds the next LED output
		LED_DISPLAY_SB	equ	0xFFF6	;10 Bytes FFF6=Start BIT, 7,8,9,A,B,C,D,E=Data bits, F=Stop BIT
		;10 bytes	equ	0xFFFF	;Warning, LED_DISPLAY_TBL must be at this address (XXF6) Roll over to xx00 tested
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;	Appendix_D	HOOK LOCATIONS
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
				org	0x0042
;		VMAIN_MENU	JP	MAIN_MENU	;MONITOR
;		VPUT_CHAR	JP	PUT_CHAR	;PUT_CHAR
;		VGET_POS	JP	GET_POS		;Return the Position of the cursor on the line
;		VGET_CHAR	JP	GET_CHAR
;		VRX_COUNT	JP	RX_COUNT	;Count of Characters waiting in the RX Buffer
;		VIN_CHAR	JP	IN_CHAR		;Returns a char or C=1 if none.
;		VTIMED_GETCHAR	JP	TIMED_GETCHAR
;		VPRINT		JP	PRINT
;		VBEEP		JP	BEEP
;		VSET_ECHO	JP	SET_ECHO
;		VDELAY_C	JP	DELAY_C		;Loop based on C, 100mSEC
;		VDELAY_A	JP	DELAY_A		;Milli seconds based on A, requires FP board
;				org	0x006B
;		VPUT_VERSION	JP	PUT_VERSION
;		VPUT_HEX	JP	PUT_HEX
;		VPUT_BYTE	JP	PUT_BYTE
;		VPUT_BC		JP	PUT_BC
;		VPUT_DE		JP	PUT_DE
;		VPUT_HL		JP	PUT_HL
;		VPUT_SPACE	JP	PUT_SPACE
;		VPUT_NEW_LINE	JP	PUT_NEW_LINE
;		VGET_BYTE	JP	GET_BYTE
;		VGET_WORD	JP	GET_WORD	;DE
;		VGET_HEX	JP	GET_HEX
;		VCLEAR_BLOCK	JP	CLEAR_BLOCK	;CLEAR_BLOCK
;		VLD_HL_HL	JP	LD_HL_HL
;		VADD_HL_A	JP	ADD_HL_A
;		VMOV_32_HL	JP	MOV_32_HL	;Move (HL) to 32 bit register BCDE
;		VMOV_HL_32	JP	MOV_HL_32	;Move 32 bit register BCDE to (HL)
;		VADD_32_HL	JP	ADD_32_HL	;ADD (HL) to 32 bit register BCDE - (returns with HL changed to last byte)
;		VCMP_HL_32	JP	CMP_HL_32	;Compare BCDE with 32bit word at HL
;		VINC_32		JP	INC_32		;INC BCDE
;		VDEC_32		JP	DEC_32		;DEC BCDE
;		VTSTZ_32	JP	TSTZ_32		;TEST_ZERO BCDE
;		VASC2BIN	JP	ASC2BIN
;		VASC2HEX	JP	ASC2HEX
;		VHEX2ASC	JP	HEX2ASC		
;		VTO_UPPER	JP	TO_UPPER
;		VSET_IO		JP	SET_IO
;		VIC_KEY		JP	IC_KEY
;		VLED_UPDATE	JP	LED_UPDATE	;Turn ON/OFF LED UPDATE & KEY MON
;		VLED_GET_POS	JP	LED_GET_POS
;		VLED_SET_POS	JP	LED_SET_POS
;		VLED_HOME	JP	LED_HOME
;		VLED_PUT_CHAR	JP	PC_LED		;C = CHAR
;		VLED_PRINT	JP	LED_PRINT
;		VLED_PUT_BYTE	JP	LED_PUT_BYTE
;		VLED_PUT_HEX	JP	LED_PUT_HEX
;		VLED_CLEAR	JP	LED_CLEAR
;		VLED_RIGHT	JP	LED_RIGHT
;		VLED_LEFT	JP	LED_LEFT
;		VPRINT_FNAME	JP	PRINT_FILENAME
;		VINPUT_FNAME	JP	INPUT_FILENAME
;		VSD_OPEN	JP	SD_OPEN			;Copy FCB to filename then search & open
;		VSD_OPEN_FILENAME JP	SD_OPEN_FILENAME	;Copy Filename to FCB then search & open
;		VPRINT_DIR	JP	PRINT_DIR
;		VDISK_READ	JP	DISK_READ
;		VSD_READ_SEC	JP	SD_READ_SEC
;		VLINE_INPUT	JP	LINE_INPUT
				ENd
		;                       *********   *******    *********
		;                       *********  *********   *********
		;                       **         **     **   **
		;                       **         **     **   **
		;---------------------  *******    **     **   *******    ---------------------
		;---------------------  *******    **     **   *******    ---------------------
		;                       **         **     **   **
		;                       **         **     **   **
		;                       *********  *********   **
		;                       *********   *******    **
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;	Appendix_E	Z80 Instruction Reference
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
		;===================================================
		;Mnemonic	Cyc	Opcodes		Bytes
		;ADC A,(HL)	7	8E		1
		;ADC A,(IX+o)	19	DD 8E oo	3
		;ADC A,(IY+o)	19	FD 8E oo	3
		;ADC A,n	7      	CE nn        	2
		;ADC A,r	4	88+r		1
		;ADC A,IXp	8	DD 88+P		2
		;ADC A,IYp	8	FD 88+P		2
		;ADC HL,BC	15	ED 4A		2
		;ADC HL,DE	15	ED 5A		2
		;ADC HL,HL	15	ED 6A		2
		;ADC HL,sp	15	ED 7A		2
		;ADD A,(HL)	7	86		1
		;ADD A,(IX+o)	19	DD 86 oo	3
		;ADD A,(IY+o)	19	FD 86 oo	3
		;ADD A,n	7      	C6 nn		2
		;ADD A,r	4	80+r		1
		;ADD A,IXp      8      	DD 80+P		2
		;ADD A,IYp      8      	FD 80+P		2
		;ADD HL,BC	11	09		1
		;ADD HL,DE	11	19		1
		;ADD HL,HL	11	29		1
		;ADD HL,sp	11	39		1
		;ADD IX,BC	15	DD 09		2
		;ADD IX,DE	15	DD 19		2
		;ADD IX,IX	15	DD 29		2
		;ADD IX,sp	15	DD 39		2
		;ADD IY,BC	15	FD 09		2
		;ADD IY,DE	15	FD 19		2
		;ADD IY,IY	15	FD 29		2
		;ADD IY,sp	15	FD 39		2
		;AND (HL)	7	A6		1
		;AND (IX+o)	19	DD A6 oo	3
		;AND (IY+o)	19	FD A6 oo	3
		;AND n       	7      	E6 nn		2
		;AND r		4	A0+r		1
		;AND IXp        8      	DD A0+P		2
		;AND IYp        8      	FD A0+P		2
		;BIT B,(HL)	12	CB 46+8*B	2	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
		;BIT B,(IX+o)	20	DD CB oo 46+8*B	4	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
		;BIT B,(IY+o)	20	FD CB oo 46+8*B	4	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
		;BIT B,r	8	CB 40+8*B+r	2	Test BIT B (AND the BIT, but do not save), Z=1 if BIT tested is 0
		;CALL nn	17	CD nn nn	3
		;CALL C,nn	17/10	DC nn nn	3
		;CALL M,nn	17/10	FC nn nn	3
		;CALL NC,nn	17/10	D4 nn nn	3
		;CALL NZ,nn	17/10	C4 nn nn	3
		;CALL P,nn	17/10	F4 nn nn	3
		;CALL PE,nn	17/10	EC nn nn	3
		;CALL PO,nn	17/10	E4 nn nn	3
		;CALL Z,nn	17/10	CALL C, nn nn	3
		;CCF		4	3F		1
		;CP (HL)	7	BE		1
		;CP (IX+o)	19	DD BE oo	3
		;CP (IY+o)	19	FD BE oo	3
		;CP n        	7      	FE nn		2
		;CP r		4	B8+r		1
		;CP IXp        	8      	DD B8+P		2
		;CP IYp        	8      	FD B8+P        	2
		;CPD		16	ED A9		2
		;CPDR		21/16	ED B9		2
		;CP		16	ED A1		2
		;CPIR		21/16	ED B1		2
		;CPL		4	2F		1
		;DAA		4	27		1
		;DEC (HL)	11	35		1
		;DEC (IX+o)	23	DD 35 oo	3
		;DEC (IY+o)	23	FD 35 oo	3
		;DEC A		4	3D		1
		;DEC B		4	05		1
		;DEC BC		6	0B		1
		;DEC C		4	0D		1
		;DEC D		4	15		1
		;DEC DE		6	1B		1
		;DEC E		4	1D		1
		;DEC H		4	25		1
		;DEC HL		6	2B		1
		;DEC IX		10	DD 2B		2
		;DEC IY		10	FD 2B		2
		;DEC IXp        8      	DD 05+8*P	2
		;DEC IYp        8      	FD 05+8*q      	2
		;DEC L		4	2D		2
		;DEC sp		6	3B		1
		;DI		4	F3		1
		;DJNZ o		13/8	10 oo		2
		;EI		4	FB		1
		;EX (sp),HL	19	E3		1
		;EX (sp),IX	23	DD E3		2
		;EX (sp),IY	23	FD E3		2
		;EX AF,AF'	4	08		1
		;EX	DE,HL	4	EB		1
		;EXX		4	D9		1
		;HALT		4	76		1
		;IM 0		8	ED 46		2
		;IM 1		8	ED 56		2
		;IM 2		8	ED 5E		2
		;IN A,(C)	12	ED 78		2
		;IN A,(n)	11	db nn		2
		;IN B,(C)	12	ED 40		2
		;IN C,(C)	12	ED 48		2
		;IN D,(C)	12	ED 50		2
		;IN E,(C)	12	ED 58		2
		;IN H,(C)	12	ED 60		2
		;IN L,(C)	12	ED 68		2
		;IN F,(C)	12	ED 70		3
		;INC (HL)	11	34		1
		;INC (IX+o)	23	DD 34 oo	3
		;INC (IY+o)	23	FD 34 oo	3
		;INC A		4	3C		1
		;INC B		4	04		1
		;INC BC		6	03		1
		;INC C		4	0C		1
		;INC D		4	14		1
		;INC DE		6	13		1
		;INC E		4	1C		1
		;INC H		4	24		1
		;INC HL		6	23		1
		;INC IX		10	DD 23		2
		;INC IY		10	FD 23		2
		;INC IXp        8      	DD 04+8*P	2
		;INC IYp       	8      	FD 04+8*q      	2
		;INC L		4	2C		1
		;INC sp		6	33		1
		;IND		16	ED AA		2
		;INDR		21/16	ED BA		2
		;INI		16	ED A2		2
		;INIR		21/16	ED B2		2
		;JP nn		10	C3 nn nn	3	Jump Absolute
		;JP (HL)	4	E9		1
		;JP (IX)	8	DD E9		2
		;JP (IY)	8	FD E9		2
		;JP C,nn	10	DA nn nn	3
		;JP M,nn	10	FA nn nn	3
		;JP NC,nn	10	D2 nn nn	3
		;JP NZ,nn	10	C2 nn nn	3
		;JP P,nn	10	F2 nn nn	3
		;JP PE,nn	10	EA nn nn	3
		;JP PO,nn	10	E2 nn nn	3
		;JP Z,nn	10	CA nn nn	3
		;JR o		12	18 oo		2	Jump Relative
		;JR C,o		12/7	38 oo		2
		;JR NC,o	12/7	30 oo		2
		;JR NZ,o	12/7	20 oo		2
		;JR Z,o		12/7	28 oo		2
		;LD (BC),A	7	02		1
		;LD (DE),A	7	12		1
		;LD (HL),n      10     	36 nn		2
		;LD (HL),r	7	70+r		1
		;LD (IX+o),n    19     	DD 36 oo nn	4
		;LD (IX+o),r	19	DD 70+r oo	3
		;LD (IY+o),n    19     	FD 36 oo nn	4
		;LD (IY+o),r	19	FD 70+r oo	3
		;LD (nn),A	13	32 nn nn	3
		;LD (nn),BC	20	ED 43 nn nn	4
		;LD (nn),DE	20	ED 53 nn nn	4
		;LD (nn),HL	16	22 nn nn	3
		;LD (nn),IX	20	DD 22 nn nn	4
		;LD (nn),IY	20	FD 22 nn nn	4
		;LD (nn),sp	20	ED 73 nn nn	4
		;LD A,(BC)	7	0A		1
		;LD A,(DE)	7	1A		1
		;LD A,(HL)	7	7E		1
		;LD A,(IX+o)	19	DD 7E oo	3
		;LD A,(IY+o)	19	FD 7E oo	3
		;LD A,(nn)	13	3A nn nn	3
		;LD A,n        	7     	3E nn		2
		;LD A,r		4	78+r		1
		;LD A,IXp       8      	DD 78+P        	2
		;LD A,IYp       8      	FD 78+P        	2
		;LD A,I		9	ED 57		2
		;LD A,R		9	ED 5F		2
		;LD B,(HL)	7	46		1
		;LD B,(IX+o)	19	DD 46 oo	3
		;LD B,(IY+o)	19	FD 46 oo	3
		;LD B,n        	7      	06 nn		2
		;LD B,r		4	40+r		1
		;LD B,IXp       8      	DD 40+P		2
		;LD B,IYp       8     	FD 40+P        	2
		;LD BC,(nn)	20	ED 4B nn nn	4
		;LD BC,nn	10	01 nn nn	3
		;LD C,(HL)	7	4E		1
		;LD C,(IX+o)	19	DD 4E oo	3
		;LD C,(IY+o)	19	FD 4E oo	3
		;LD C,n        	7      	0E nn        	2
		;LD C,r		4	48+r		1
		;LD C,IXp       8      	DD 48+P        	2
		;LD C,IYp       8      	FD 48+P		2
		;LD D,(HL)	7	56		1
		;LD D,(IX+o)	19	DD 56 oo	3
		;LD D,(IY+o)	19	FD 56 oo	3
		;LD D,n        	7      	16 nn		2
		;LD D,r		4	50+r		1
		;LD D,IXp       8      	DD 50+P        	2
		;LD D,IYp       8      	FD 50+P        	2
		;LD DE,(nn)	20	ED 5B nn nn	4
		;LD DE,nn	10	11 nn nn	3
		;LD E,(HL)	7	5E		1
		;LD E,(IX+o)	19	DD 5E oo	3
		;LD E,(IY+o)	19	FD 5E oo	3
		;LD E,n        	7      	1E nn        	2
		;LD E,r		4	58+r		1
		;LD E,IXp       8      	DD 58+P        	2
		;LD E,IYp       8      	FD 58+P        	2
		;LD H,(HL)	7	66		1
		;LD H,(IX+o)	19	DD 66 oo	3
		;LD H,(IY+o)	19	FD 66 oo	3
		;LD H,n        	7      	26 nn		2
		;LD H,r		4	60+r		1
		;LD HL,(nn)	16	2A nn nn	5
		;LD HL,nn	10	21 nn nn	3
		;LD I,A		9	ED 47		2
		;LD IX,(nn)	20	DD 2A nn nn	4
		;LD IX,nn	14	DD 21 nn nn	4
		;LD IXh,n       11     	DD 26 nn 	2
		;LD IXh,P       8     	DD 60+P		2
		;LD IXl,n       11     	DD 2E nn 	2
		;LD IXl,P       8     	DD 68+P		2
		;LD IY,(nn)	20	FD 2A nn nn	4
		;LD IY,nn	14	FD 21 nn nn	4
		;LD IYh,n       11     	FD 26 nn 	2
		;LD IYh,q       8     	FD 60+P		2
		;LD IYl,n       11     	FD 2E nn 	2
		;LD IYl,q       8     	FD 68+P		2
		;LD L,(HL)	7	6E		1
		;LD L,(IX+o)	19	DD 6E oo	3
		;LD L,(IY+o)	19	FD 6E oo	3
		;LD L,n       	7     	2E nn		2
		;LD L,r		4	68+r		1
		;LD R,A		9	ED 4F		2
		;LD sp,(nn)	20	ED 7B nn nn	4
		;LD sp,HL	6	F9		1
		;LD sp,IX	10	DD F9		2
		;LD sp,IY	10	FD F9		2
		;LD sp,nn	10	31 nn nn	3
		;LDD		16	ED A8		2
		;LDDR		21/16	ED B8		2
		;LDI		16	ED A0		2
		;LDIR		21/16	ED B0		2
		;MULUB A,r 		ED C1+8*r 	2
		;MULUW HL,BC		ED C3 		2
		;MULUW HL,sp		ED F3 		2
		;NEG		8	ED 44		2
		;NOP		4	00		1
		;OR (HL)	7	B6		1
		;OR (IX+o)	19	DD B6 oo	3
		;OR (IY+o)	19	FD B6 oo	3
		;OR n       	7     	F6 nn		2
		;OR r		4	B0+r		1
		;OR IXp       	8     	DD B0+P		2
		;OR IYp       	8     	FD B0+P		2
		;OTDR		21/16	ED BB		2
		;OTIR		21/16	ED B3		2
		;OUT (C),A	12	ED 79		2
		;OUT (C),B	12	ED 41		2
		;OUT (C),C	12	ED 49		2
		;OUT (C),D	12	ED 51		2
		;OUT (C),E	12	ED 59		2
		;OUT (C),H	12	ED 61		2
		;OUT (C),L	12	ED 69		2
		;OUT (n),A	11	D3 nn		2
		;OUTD		16	ED AB		2
		;OUTI		16	ED A3		2
		;POP AF		10	F1		1
		;POP BC		10	C1		1
		;POP DE		10	D1		1
		;POP HL		10	E1		1
		;POP IX		14	DD E1		2
		;POP IY		14	FD E1		2
		;PUSH AF	11	F5		1
		;PUSH BC	11	C5		1
		;PUSH DE	11	D5		1
		;PUSH HL	11	E5		1
		;PUSH IX	15	DD E5		2
		;PUSH IY	15	FD E5		2
		;RES B,(HL)	15	CB 86+8*B	2	Reset BIT B (clear BIT)
		;RES B,(IX+o)	23	DD CB oo 86+8*B	4	Reset BIT B (clear BIT)
		;RES B,(IY+o)	23	FD CB oo 86+8*B	4	Reset BIT B (clear BIT)
		;RES B,r	8	CB 80+8*B+r	2	Reset BIT B (clear BIT)
		;RET		10	C9		1
		;RET C		11/5	D8		1
		;RET M		11/5	F8		1
		;RET NC		11/5	D0		1
		;RET NZ		11/5	C0		1
		;RET P		11/5	F0		1
		;RET PE		11/5	E8		1
		;RET PO		11/5	E0		1
		;RET Z		11/5	C8		1
		;RETI		14	ED 4D		2
		;RETN		14	ED 45		2
		;RL (HL)	15	CB 16		2  	9 BIT rotate left through Carry
		;RL (IX+o)	23	DD CB oo 16	4	9 BIT rotate left through Carry
		;RL (IY+o)	23	FD CB oo 16	4	9 BIT rotate left through Carry
		;RL r       	8     	CB 10+r		2	9 BIT rotate left through Carry
		;RLA		4	17		1	9 BIT rotate left through Carry
		;RLC (HL)	15	CB 06		2	8 BIT rotate left, C=msb
		;RLC (IX+o)	23	DD CB oo 06	4	8 BIT rotate left, C=msb
		;RLC (IY+o)	23	FD CB oo 06	4	8 BIT rotate left, C=msb
		;RLC r		8	CB 00+r		2	8 BIT rotate left, C=msb
		;RLCA		4	07		1	8 BIT rotate left, C=msb
		;RLD		18	ED 6F		2	3 nibble rotate, A3-0 to (HL)3-0, (HL)3-0 to (HL)7-4, (HL)7-4 to A3-0
		;RR (HL)	15	CB 1E		2	9 BIT rotate right through Carry
		;RR (IX+o)	23	DD CB oo 1E	4	9 BIT rotate right through Carry
		;RR (IY+o)	23	FD CB oo 1E	4	9 BIT rotate right through Carry
		;RR r       	8     	CB 18+r		2	9 BIT rotate right through Carry
		;RRA		4	1F		1	9 BIT rotate right through Carry
		;RRCA (HL)	15	CB 0E		2	8 BIT rotate right, C=lsb
		;RRCA (IX+o)	23	DD CB oo 0E	4	8 BIT rotate right, C=lsb
		;RRCA (IY+o)	23	FD CB oo 0E	4	8 BIT rotate right, C=lsb
		;RRCA r		8	CB 08+r		2	8 BIT rotate right, C=lsb
		;RRCAA		4	0F		1	8 BIT rotate right, C=lsb
		;RRD		18	ED 67		2	3 nibble rotate, A3-0 to (HL)7-4, (HL)7-4 to (HL)3-0, (HL)3-0 to A3-0
		;RST 0		11	C7		1
		;RST 8H		11	CF		1
		;RST 10H	11	D7		1
		;RST 18H	11	DF		1
		;RST 20H	11	E7		1
		;RST 28H	11	EF		1
		;RST 30H	11	F7		1
		;RST 38H	11	FF		1
		;SBC A,(HL)	7	9E		1
		;SBC A,(IX+o)	19	DD 9E oo	3
		;SBC A,(IY+o)	19	FD 9E oo	3
		;SBC A,n	7	DE nn		2
		;SBC A,r	4	98+r		1
		;SBC A,IXp      8     	DD 98+P		2
		;SBC A,IYp      8     	FD 98+P		2
		;SBC HL,BC	15	ED 42		2
		;SBC HL,DE	15	ED 52		2
		;SBC HL,HL	15	ED 62		2
		;SBC HL,sp	15	ED 72		2
		;SCF		4	37		1	Set Carry
		;SET B,(HL)	15	CB C6+8*B	2	Set BIT B (0-7)
		;SET B,(IX+o)	23	DD CB oo C6+8*B	4	Set BIT B (0-7)
		;SET B,(IY+o)	23	FD CB oo C6+8*B	4	Set BIT B (0-7)
		;SET B,r	8	CB C0+8*B+r	2	Set BIT B (0-7)
		;SLA (HL)	15	CB 26		2	9 BIT shift left, C=msb, lsb=0
		;SLA (IX+o)	23	DD CB oo 26	4	9 BIT shift left, C=msb, lsb=0
		;SLA (IY+o)	23	FD CB oo 26	4	9 BIT shift left, C=msb, lsb=0
		;SLA r		8	CB 20+r		2	9 BIT shift left, C=msb, lsb=0
		;SRA (HL)	15	CB 2E		2	8 BIT shift right, C=lsb, msb=msb (msb does not change)
		;SRA (IX+o)	23	DD CB oo 2E	4	8 BIT shift right, C=lsb, msb=msb (msb does not change)
		;SRA (IY+o)	23	FD CB oo 2E	4	8 BIT shift right, C=lsb, msb=msb (msb does not change)
		;SRA r		8	CB 28+r		2	8 BIT shift right, C=lsb, msb=msb (msb does not change)
		;SRL (HL)	15	CB 3E		2	8 BIT shift right, C=lsb, msb=0
		;SRL (IX+o)	23	DD CB oo 3E	4	8 BIT shift right, C=lsb, msb=0
		;SRL (IY+o)	23	FD CB oo 3E	4	8 BIT shift right, C=lsb, msb=0
		;SRL r		8	CB 38+r		2	8 BIT shift right, C=lsb, msb=0
		;SUB (HL)	7	96		1
		;SUB (IX+o)	19	DD 96 oo	3
		;SUB (IY+o)	19	FD 96 oo	3
		;SUB n       	7     	D6 nn		2
		;SUB r		4	90+r		1
		;SUB IXp       	8     	DD 90+P		2
		;SUB IYp       	8     	FD 90+P		2
		;XOR (HL)	7	AE		1
		;XOR (IX+o)	19	DD AE oo	3
		;XOR (IY+o)	19	FD AE oo	3
		;XOR n       	7     	EE nn		2
		;XOR r       	4     	A8+r		1
		;XOR IXp       	8     	DD A8+P		2
		;XOR IYp       	8     	FD A8+P		2
		;
		;variables used:
		;
		; B = 3-BIT value
		; n = 8-BIT value
		; nn= 16-BIT value
		; o = 8-BIT offset (2-complement)
		; r = Register. This can be A, B, C, D, E, H, L OR (HL). Add to the last byte of the opcode:
		;
		;		Register	Register bits value
		;		A		7
		;		B		0
		;		C		1
		;		D		2
		;		E		3
		;		H		4
		;		L		5
		;		(HL)		6
		;
		; P = The high OR low part of the IX OR IY register: (IXh, IXl, IYh, IYl). Add to the last byte of the opcode:
		;
		;		Register	Register bits value
		;		A		7
		;		B		0
		;		C		1
		;		D		2
		;		E		3
		;		IXh (IYh)	4
		;		IXl (IYl)	5
						
		   ABFND              2B86    ABF_GOODHEX        27C6
		   ABS_SEC            0018 E  ABUSS              FF88 E
		E  ACE_BAUD0          00C8 E  ACE_BAUD1          00C9 E
		E  ACE_LCR            00CB E  ACE_MSR            00CE E
		E  ACE_RESET          00C7 E  ACE_SCRATCH        00CF E
		   ACE_STATUS         00CD E  ACK                0006 E
		   ADD_32_HL          274F    ADD_HL_A           0E45
		E  ALOOK              2F89    ANBAR_DEF          FFB3 E
		   ARYLOC             81FD E  ASC2BIN            27BD
		   ASST               32C8    ASTOR              32EB
		   AUTO_BOOT_GO       03C1    AUTO_BOOT_LP       03B6
		   BADLIN             2D68    BADLN              2ACD
		   BEEP               27CC    BEEP_TO            FFB2 E
		E  BGETCHR            34ED    BINCHR             0051 E
		E  BITS_Q3            00C3 E  BIT_MARCH          1244
		   BOOT_SDVIEW        1D37    BPRINT             2E8D
		E  BPUTNL             0080 E  BPUTSP             007D E
		   BUFF               8000 E  BYTEMARCH2         11D7
		   CAFCLUS            0010 E  CALN               3175
		   CAN                0018 E  CDAT               3037
		   CEXP               33CC    CG1                33D2
		   CH3_R2             2789    CH3_R3             278A
		   CHK_RESET          0194    CHR                34E3
		   CL2                34A8    CLBF               34A3
		   CLEARED_LEN        002C E  CLEARED_SPACE      FFD4 E
		   CLEAR_LINE_BUFF    1EB5    CLRARY             2CCD
		   CMD1               2A65    CMDL               2A52
		   CMP_DE_HL          278C    CMP_FILENAME       215E
		   CMP_STRING         217B    COLD_START         01A5
		   COMP               3265    COMSTR             3459
		   CP_HL_DE           0B0B    CQ                 33F7
		E  CRC_UPC            10F7    CRC_UPDATE         10D2
		E  CS                 81FA E  CSAV               2FDA
		E  CSTK               35C1    CS_CLR_LEN         000F E
		   CTRL_C_CHK         FFB8 E  CTRL_C_CHK_OFF     1831
		   CTRL_C_IN_Q        1821    CTRL_C_RET         17AE
		   CTRL_C_TIMER       FFDE E  CURSOR             80FB E
		   CVL1               2CC6    CVLP               2CB9
		   DATA               8238 E  DATASTART          FF39
		   DBS_LP             272B    DC1                0011 E
		E  DCLB               31CC    DD_NEXT            1D9F
		   DECP1              2EB7    DECPRT             2EB2
		   DEC_32NB           276C    DEL                2BB6
		   DELAY_A            0E3A    DELAY_C            0E2C
		   DELETE             007F E  DELLP              2BBF
		   DER                359F    DERR               3019
		   DGC_DOT            143C    DGC_RET            1443
		   DIM0               2F42    DIMERR             2FAF
		   DIR_SECTOR         FF35    DISK_READ          2183
		E  DISPMODE           FFBC E  DISP_RRBANK        087A
		   DIV16BY8           2712    DIV16BY8SPC        270F
		   DIV16BY8_SK        2721    DIVBYSHIFT         2727
		   DIVIDE_FUNC        FF52    DIVTOP             323B
		   DLE                0010 E  DLOOP              2F5C
		   DL_P1E             0AD4    DL_P1L             0AC1
		   DL_P2K1            0AF8    DL_P2K2            0AFE
		   DL_PSE2            0AED    DL_PSL2            0AE3
		   DODIV              3229    DOEXP              313E
		   DO_DIR             1D46    DO_HALT_TEST       16E8
		   DRSS_LP            2283    DRSS_SHIFT         228B
		   DR_1               21AE    DR_BIGGER_CLUS     21F4
		   DR_NEW_SEC         21CB    DR_READ_IT         22D0
		   DR_SEEK_1          2236    DR_SEEK_DONE       2264
		   DR_SEEK_LP         21FF    DTXT               35F1
		   ECHO_STATE         FFF2 E  EDBUF              8100 E
		   EFLAG              8237 E  EG1                333A
		   EGO1               314F    EGO2               339C
		   EGOF1              336D    EGOF2              336C
		   EGZ                3340    ELOOP              2B9E
		   ENDAT              306B    ENDIT              364D E
		   ENT_COUNT          FF41    EOF                2C4E
		E  EOT                0004 E  EQUAL              3305
		   ESP1               30EE    ETOP               30DF
		   EXEC_RAM_2F8       0185    EXPR               3135
		   FAT_CLEAR          FF0A E  FAT_CLR_LEN        0039 E
		   FB_LP              0C17    FCB_PTR            FF08
		   FILBUF             34DB    FILEEXT            FF4B
		   FILESIZE           FF4E    FILESYS_SEC        FF27
		   FILL_BT            0146    FINTO              2D84
		   FLOR               326B    FNAME              0001 E
		   FOR                2D7B    FSIZE              001C E
		   FSTAT              0000 E  FTHEN              2E1B
		   GB_1               0D57    GB_2               0D6B
		   GB_RET1            0D6E    GCHR               2F0C
		   GEQL               3313    GETDAT             305D
		   GETHEXFILE         0E4F    GETHX              3196
		   GET_BYTE           0D4C    GET_CHAR           13DC
		   GET_CHAR_NE        13D6    GET_CONTINUE       0A82
		   GET_HEX            0D95    GET_MEM            FB45 E
		E  GET_POS            13C9    GET_REG            FFB4 E
		   GET_REGNAME        0C2E    GET_REG_MON        0C71
		   GET_STRING         2792    GET_WORD           0D79
		   GF0                2B6D    GF1                2B6C
		   GF3                2B7A    GFIND              2B67
		   GHC_NOT_RET        0DB6    GHC_NRET           0DBA
		   GH_EXEC            202D    GH_EXEC_GO         2054
		   GH_START           FF0A    GIN1               2B95
		   GLINE              2AD0    GLPD               2D53
		   GLPX               30C0    GO                 2C89
		   GOTCMD             2A6F    GOTDEF             2A6E
		   GO_BASIC           2A00    GO_EXEC            0B71
		   GO_SD_CARD         1C8F    GO_SINGLE          1A3C
		E  GRR_SUB            0CC1    GRR_SUB_AF         0CC7
		   GRR_SUB_BC         0CCF    GRR_SUB_BCA        0CF8
		   GRR_SUB_DEA        0CFD    GRR_SUB_HL         0CD5
		   GRR_SUB_IR         0CEC    GRR_SUB_IX         0CE4
		   GRR_SUB_PC         0CDD    GRR_TBL            0CA1
		   GRUB               2B58    GSC_INIT           1C90
		   GS_OK              1A6A    GS_SEQ             10C4
		   HALT_TEST          FFD2 E  HERE1              FB5B E
		   HEX2ASC            0E0F    HEX2IN_PTR         1974
		   HEX2OUT_PORT       198B    HEX2OUT_PTR        197A
		   HEXGO              3191    HEXVL              317B
		E  HEX_READY          FFC6 E  HEX_SOURCE         FF5B
		   HIDDEN_SEC         FF2B    HISG               31AB
		   HRAM_CODE          FB2A    HR_EXEC_GO_SUB     207E
		E  HR_EXE_GO          FB53    HW_LIST            FF95 E
		E  ICMA_IO            1ACB    ICMA_REG           1AC4
		   ICMB_REG           1AE5    ICMD0              1893
		   ICMD1              1997    ICMD2              1997
		   ICMD4              1997    ICMD4_EXEC         184B
		   ICMD6              19B4    ICMD7              1A2C
		   ICMDB              1AD2    ICMDD              1AFD
		   ICMD_AMEM          1B06    ICMD_BREAK         17FC
		   ICMD_BYTE          1934    ICMD_BYTE2         1965
		   ICMD_IO_OUT        1B46    ICMD_REG           1B25
		   ICMD_SR_OK         1AF0    ICMD_WORD          18C6
		   ICMD_WORD2         1904    ICMD_WORDN1        18F0
		   IC_ACE             14CB    IC_BIT             1513
		   IC_KEY             14B6    IDDR_DISP          19E8
		   IDISP_IN           1BCC    IDISP_IN_DATA      1BE3
		   IDISP_MEM_DATA     1BB0    IDISP_OFF          1C28
		   IDISP_OUT_DATA     1C18    IDISP_REG          1B63
		   IDISP_RET          17DF    IDO_LP             1C30
		   IDRRC_RET          1A27    IDRRC_ROM          1A22
		   IERMS              35AE    IF                 2E16
		E  IKC_REFRESH        17CB    IKC_RESET_CMD      17BA
		   IKEY1_UP           1734    IKEYF_UP           1747
		   IKEYP_EVENT_DN     1775    IKEYP_NCOS         1759
		   IKEY_DONE          17DB    IKEY_NO_BEEP       17EC
		   IKR_QREFRESH       17D1    IK_HEXH            FF5A
		   IK_HEXST           FFC3 E  IK_KEYDN_EVENT     1792
		   IK_NOKEY_EVENT     17AA    IK_RTN             179C
		E  IL01               2BEA    IL02               2C0A
		   IMON_CMD           183E    IMON_TBL           1853
		E  INC_32             2760    IND                2B18
		   INIT               2A1D    INITFAT_C1_DONE    237D
		   INITFAT_C2_LP      238B    INITFAT_C3_0       23D5
		   INITFAT_C3_ERR     23BE    INITFAT_C3_LP      23A8
		   INITFAT_C3_LP3     23E7    INITFAT_C4_1       240D
		   INITFAT_C4_3       2428    INITFAT_C4_LP      2408
		   INITFAT_FAIL1      2450    INITFAT_PGOOD      2316
		   INITFAT_TFS_OK     2355    INIT_FAIL          25C5
		   INIT_SDCARD        2596    INIT_SYSTEM        0210
		   INLF               2ABD    INLN               2BDF
		   INP1               2EDF    INPUT              2ECB
		   INS                2BC7    INTRO              3600
		E  IN_CHAR            141D    IOCON              80FF E
		   IOPTR              FF8B E  IO_MSG             07CD
		   IRAMROMBANK_CHG    1A0F    IRXD_BAD           1681
		   IRXD_NB            1648    IRXD_NI            1650
		   IRXD_SAVE          1664    IRXD_STP           1657
		   IRXD_VS            1639    IRXD_WS            16A0
		   ISD_1              25D6    ISD_2              25F7
		   ISD_4              263A    ISD_5              266A
		   ISD_LP1            25BA    ISD_LP2            2624
		   ISINGLE            1A71    ISINGLE_DONE       1A98
		   ISR_DISPATCH       FB2A E  ISR_EXTIMER        16B5
		   ISR_EXXTIMER       1710    ISR_FLAGS          FFD8 E
		E  ISR_RET_OFF        0011 E  ISR_RXD            1637
		   IS_CRLF            2027    IS_LETTER          27B6
		E  KBHEXSAMPLE        FFEA E  KBPORTSAMPLE       FFE9 E
		E  KEYBSCANPV         FFEB E  KEYBSCANTIMER      FFEC E
		E  KEY_PRESSED        FFEF E  KEY_PRES_EV        FFED E
		E  KTAB               3522    LAND               3289
		E  LB_0               09F2    LB_1               09F8
		   LB_OUT             0A06    LB_RET             0A0F
		E  LD_HL_HL           0E4A    LEDL_LP            2813
		   LED_ANBAR          FFE7 E  LED_CLEAR          147C
		E  LED_DISPLAY        FFE0 E  LED_DISPLAY_SB     FFF6 E
		   LED_GET_POS        27E4    LED_HEX            2900
		   LED_HOME_PRINTI    1C86    LED_LEFT           2807
		   LED_PRINTI         1C89    LED_PRINT_LP       1C76
		   LED_PUT_BYTE       1C5C    LED_PUT_BYTE_HL    1C46
		   LED_PUT_HEX_HL     1C4F    LED_RIGHT          27F2
		   LED_SPLASH_TBL     027C    LED_UPDATE         27D4
		   LET                2DD2    LETH               32B5
		E  LIF                2E39    LIN                35C9
		   LINE_BUFF          FA00    LINE_BUFFEND       FA80
		   LIRET              2CAD    LIST               2C6B
		   LI_1B              1E78    LI_2               1E7C
		   LI_4               1E8C    LI_EOL             1E91
		   LI_GETDATA         1E9D    LI_LP              1E5E
		   LI_SDLOG_SEC       FA88    LI_TP              1E51
		   LOAD               30C9    LOAD_HIGH_RAM      281C
		   LOGICAL_SEC        FF0D    LOOK               2FF8
		   LOOKU              31C9    LOOP1              2AD7
		   LOOP_BACK_TEST     09B7    LOR                3296
		   LSTCHR             80F9 E  LTA                2FB5
		   MEM_DUMP           0A5F    MEM_DUMP_0         0A61
		   MEM_DUMP_PAGED     0A7E    MEM_EDIT           0B1D
		   MEM_ENTER_NEXTL    0A18    MEM_EXEC           0B43
		   MEN_CHK            0A2F    MEN_LP             0A1F
		   MEXIT              320F    ME_1               0B5D
		   MODBYMASK          2734    MODMASK            FF58
		   MORDAT             3051    MOVL               2B3D
		   MOV_HL_32          2744    MUL1               31F8
		   MULT               31E4    NAK                0015 E
		   NEW                2A15    NEXT               2DE1
		   NMI_VEC            FFDC E  NOMAD              320B
		   NOON               2D5E    NOTFND             2C46
		   NP                 35D5    NSTERR             2D75
		   NXLP               3259    OKKK               324D
		   OLOOK              31CD    ORDER              3004
		   OUTPR              2E8B    OVER1              3253
		   OVRSUB             3258    P                  8236 E
		   PARSE1             3104    PCA_LP             14E2
		   PCLC_LP            14A4    PCL_CTRL           1499
		   PCL_RETC           14AD    PC_0               1574
		   PC_10              15BD    PC_11              15C0
		   PC_13              15CF    PC_14              15D4
		   PC_16              15E2    PC_17              15EF
		   PC_19              15F9    PC_2               157B
		   PC_3               1583    PC_4               158C
		   PC_6               15A2    PC_7               15A7
		   PC_9               15B4    PC_ACE             14DC
		   PC_BOTH            146C    PC_LED             1486
		   PC_NCR             13FF    PC_NOFP            1556
		   PC_REDO            153D    PC_RET             161E
		   PERR               2A92    PLOT               2E44
		   POPD               2DC7    POPS               2DB4
		E  PORT_INP           0BFC    PORT_OUT           0C06
		   POS_ACE            FFD7 E  POS_BIT            FFD6 E
		   PRINS              2C92    PRINT              0DBD
		   PRINTI             0DCA    PRINTM             0057 E
		   PRINT_DIR          1D5A    PRINT_FILENAME     2100
		   PRINT_MENU         0479    PRINT_RET          0DC8
		   PSH2               2DAF    PTAB               34F3
		   PURGE              1426    PURRS_RET          0C8D
		   PURR_SUB_AFA       0D35    PURR_SUB_BC        0D0F
		   PURR_SUB_DE        0D12    PURR_SUB_DEA       0D3F
		   PURR_SUB_HLA       0D44    PURR_SUB_IR        0D2E
		   PURR_SUB_IY        0D2A    PURR_SUB_PC        0D20
		   PURR_TBL           0CB1    PUSHB              34B0
		   PUSHS              2DA9    PUTCHAR_EXE        FF90 E
		   PUT_3C_SPACES_L    0B12    PUT_BC             0DD8
		   PUT_CHAR           13E8    PUT_DE             0DE1
		   PUT_HL             0DEA    PUT_IOMSG          07BA
		   PUT_REG            FFB6 E  PUT_REGISTER       0C82
		   PUT_REG_RUN        0C91    PUT_SPACE          0E19
		   PV1                2EA5    PVH_0              08F8
		   PZ                 2EA8    Q0                 3404
		   Q2                 3418    Q3                 3419
		   Q5                 3435    Q6                 344E
		   Q8                 346E    Q9                 347E
		   QTST               348B    RAMROM             00C1 E
		E  RAMSIGN_LP         02EA    RAMSIG_LP          019B
		E  RAM_TEST           1100    RANDR              33AD
		E  RC_F0              FF85 E  RC_HALT            FF84 E
		E  RC_RST0            FF86 E  RC_SOFT            FF81 E
		E  RC_TYPE            FF80 E  RDY                3630
		   READ_HEX_EXEC      1EBE    READ_HEX_FILE      1EEF
		E  READ_SERIAL        0EC3    RECT               2B0E
		   REGORDER           0942    REGPTR             FF8A E
		   REG_MENU           0915    REM                2E15
		   RESET              2CDF    RESETLDRT          0100
		   RETRY              2EF2    RETURN             2D6E
		E  RFSEC              0012 E  RGON               2CFC
		   RHF_BYTE_LP2       1F46    RHF_DO             1F24
		   RHF_ERR_ON_LINE    1F89    RHF_LINE           1F2B
		   RHF_LOOP           1EFC    RHF_NOT_HEX        1F5B
		   RHF_OK2            1F74    RHF_OK3            1FA7
		   RHF_OK5            1FD7    RHF_OK6            2007
		   RLOOP              2D04    RM_2               0966
		   RM_4               0976    RM_5               098C
		   RM_DUMP_REG        09AB    RM_DUMP_REG_C      09AA
		   RM_LP              0921    RM_NOTALL          094F
		   RNEXT              2D13    ROM_CODE           2828
		E  ROOTDIR_SIZE       FF25    RPC                FFA0 E
		E  RS232_SPLASH       0316    RSAF               FF98 E
		E  RSBC               FF9A E  RSBC2              FFAA E
		E  RSDE2              FFAC E  RSHL               FF9E E
		E  RSIR               FFA6 E  RSIS_LP            0136
		   RSIX               FFA2 E  RSIY               FFA4 E
		E  RST38_LEN          0006 E  RS_CLP             0EC9
		   RS_LP              0ECB    RS_TIMEOUT         0EEB
		   RT1_LP1            112E    RT1_LP2            1130
		   RT1_LP4            1140    RT1_LP5            1145
		   RT1_LP7            115A    RT2_LP0            1183
		   RT2_LP2            118D    RT2_LP3            1193
		   RT2_NX1            11A8    RT3_LP1            1246
		   RT3_LP3            124F    RT3_LP4            1259
		   RT3_NX1            1273    RT4_LP0            11D9
		   RT4_LP2            11E0    RT4_LP3            11E9
		   RT4_LP5            11F8    RT4_LP6            11FD
		   RT4_LP8            1219    RT4_NX             1214
		   RT5_LP2            129C    RT5_LP3            12AB
		   RT5_NX2            12AF    RTHW_ADV           0160
		   RTHW_LP            0150    RTHW_OK            015D
		   RTHW_SIO_EXIT      017E    RT_FAIL1           12DE
		   RT_FAIL3           1324    RT_FAIL5           1346
		   RUN                2CEC    RXBHEAD            FFCA E
		E  RXBUFFER           FE00    RXC_ACE            14C0
		   RXC_BOTH           145D    RXC_DO             140A
		   RX_ERR_LDRT        FF8C E  RX_ERR_OVR         FF8E E
		E  R_CC               0345    R_COLD             0326
		   R_HALT             034E    R_HARD             0369
		   R_SOFT             0333    R_STEP             0340
		   SCAN_LED           FFF5 E  SCAN_PTR           FFD0 E
		E  SDCS               00C4 E  SDC_1              26A0
		   SDC_LP             26CA    SDC_MENU           1CE4
		   SDC_STATUS         FF11    SDFF_LP            20BB
		   SDISKB             FBA0    SDISKC             FBC0
		   SDISPMODE          FFD4 E  SDLF_LP            1D6F
		   SDO_RET            1E1D    SDTX               00C5 E
		   SDV_FOUND          20AA    SD_CARD_TYPE       FF10
		   SD_CMD             2690    SD_DELAY           268B
		   SD_DESELECT        2678    SD_FETCH           20D2
		   SD_LDIR1           20C6    SD_LDIRN           20DB
		   SD_OPEN_FILENAME   1DA4    SD_PARAM           FF12
		   SD_PART_SIZE       FF1B    SD_PART_TYPE       FF16
		   SD_READ_SEC        2491    SD_RS_0            24C8
		   SD_RS_FORCED       24AF    SD_RS_LP0          24BA
		   SD_RS_LP2          24DA    SD_SELECT          2683
		   SD_WRITE_SEC       24EF    SD_WR_FAIL         2552
		   SEC_PER_CLUS       FF21    SEC_PER_FAT        FF2F
		   SEED               81FE E  SET_BANK           0871
		   SET_IO             1382    SET_PARAM          256D
		   SIGT               823C E  SIMSG              3644
		   SIO_RET            13B5    SIO_ZERO           139C
		   SKIP               310F    SKIP1              3117
		   SKIP_TABLE1        02BC    SKIP_TABLE2        0377
		   SL1                3048    SOFT_RST_FLAG      FFDF E
		E  SPACE_GET_BYTE     0D49    SPACE_GET_WORD     0D76
		   SPI_RX             26D9    SPI_TX             26DB
		   SPLASH_VERSION     0374    SP_ISR_SAVE        FB28
		   SRSEED             32E5    SSOC               0014 E
		E  STACKSPACE1        FB00    STACKTOP           FAFE E
		E  STLIN              2AAF    STMEM              3300
		   STOP               2D2C    STOR               2FE7
		   SUBB               3244    SW2_ACE            07AC
		   SW2_BOTH           07B4    SWAP               3276
		   SYNT               2A7C    TABENT             2F7D
		E  TEMP               823E E  TEST_SIGNATURE     247E
		E  TGC_LP1            144A    TGC_LP2            144C
		   THEN               2D32    TICCOUNTER         FFF0 E
		   TIMED_GETCHAR      1447    TINC               0E26
		   TOP                2A2C    TO_UPPER           27AD
		   TSTZ_32            276E    UIVEC              FFB0 E
		   URET               2FDD    UR_NOTRAM          0865
		   UR_RET1            086E    USE_RAM            0831
		   USROUT             80FD E  V1                 2FC2
		   VADD_HL_A          0092    VARS               8200 E
		   VASC2HEX           00AD    VBEEP              005A
		   VCHAR              2A78    VCLEAR_BLOCK       008C
		   VDEC_32            00A4    VDELAY_A           0063
		   VDISK_READ         00EC    VER1               309B
		   VGET_BYTE          0083    VGET_CHAR          004B
		   VGET_POS           0048    VGET_WORD          0086
		   VIC_KEY            00B9    VIEW_FLAGS         FF0C
		   VINPUT_FNAME       00E0    VIN_CHAR           0051
		   VLED_CLEAR         00D4    VLED_GET_POS       00BF
		   VLED_LEFT          00DA    VLED_PRINT         00CB
		   VLED_PUT_CHAR      00C8    VLED_PUT_HEX       00D1
		   VLED_SET_POS       00C2    VLED_UPDATE        00BC
		   VMAIN_MENU         0042    VMOV_32_HL         0095
		   VPRINT             0057    VPRINT_DIR         00E9
		   VPUT_BC            0074    VPUT_BYTE          0071
		   VPUT_DE            0077    VPUT_HEX           006E
		   VPUT_NEW_LINE      0080    VPUT_SPACE         007D
		   VRX_COUNT          004E    VSD_OPEN           00E3
		   VSD_READ_SEC       00EF    VSET_ECHO          005D
		   VTIMED_GETCHAR     0054    VTO_UPPER          00B3
		   WAIT_NOT_BUSY      26EF    WARM_START         01CF
		   WHICH_PORT         07DA    WNB_0              2705
		   WNB_LP2            26F5    WP_NOACE           0806
		   WRITE_BLOCK        0C1D    WS_NOFP            01F8
		   X0                 3472    XBF                8064 E
		   XMDN_LP            0F11    XMGET_HDR          10AF
		   XMR_ACK            1099    XM
