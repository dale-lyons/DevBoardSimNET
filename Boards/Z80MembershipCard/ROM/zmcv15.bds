binary-debuggable-source
0000 0000 f zmcv15.asm
0000 0000 s ;Z80 Membership Card Firmware with SD support, Version 1.5, July 23, 2017
0000 0000 s ;File: ZMCv15.asm
0000 0000 s ;
0000 0000 s ;	MACRO 	VERSION_MSG
0000 0000 s ;	DB	CR,LF,"Z80 MEMBERSHIP CARD MICRO-SD, v1.5beta July 23, 2017",CR,LF,EOS
0000 0000 s ;	ENDM
0000 0000 s ;	Table of Contents
0000 0000 s ;	Preface_i	Acknowledgments, Revisions, notes
0000 0000 s ;	Preface_ii	Description, Operation
0000 0000 s ;	Preface_iii	Memory Mapping, I/O Mapping
0000 0000 s ;	Chapter_1	Page 0 interrupt & restart locations
0000 0000 s ;	Chapter_2	Startup Code
0000 0000 s ;	Chapter_3	Main Loop, MENU selection
0000 0000 s ;	Chapter_4	Menu operations. Loop back, Memory Enter/Dump/Execute, Port I/O
0000 0000 s ;	Chapter_5	Supporting routines. GET_BYTE, GET_WORD, PUT_BYTE, PUT_HL, PRINT, DELAY, GET/PUT_REGISTER
0000 0000 s ;	Chapter_6	Menu operations. ASCII HEXFILE TRANSFER
0000 0000 s ;	Chapter_7	Menu operations. XMODEM FILE TRANSFER
0000 0000 s ;	Chapter_8	Menu operations. RAM TEST
0000 0000 s ;	Chapter_9	Menu operations. DISASSEMBLER - Deleted
0000 0000 s ;	Chapter_10	BIOS.  PUT_CHAR (RS-232 & LED), GET_CHAR (RS-232), IN_KEY (Keyboard)
0000 0000 s ;	Chapter_11	ISR.  RS-232 Receive, LED & Keyboard scanning, Timer tic counting
0000 0000 s ;	Chapter_12	SD-CARD
0000 0000 s ;	Chapter_13	FILE operations
0000 0000 s ;	Chapter_14	FILE Support Routines
0000 0000 s ;	Chapter_15	SD Memory Card Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
0000 0000 s ;	Chapter_16	General Support Routines, 32 Bit stuff and other math
0000 0000 s ;	Chapter_17	High RAM routines
0000 0000 s ;	Appendix_A	LED FONT
0000 0000 s ;	Appendix_B	Future Use
0000 0000 s ;	Appendix_C	RAM. System Ram allocation (LED_Buffer, KEY_Status, RX Buffer, etc)
0000 0000 s ;	Appendix_D	HOOK LOCATIONS
0000 0000 s ;	Appendix_E	Z80 Instruction Reference
0000 0000 s 
0000 0000 s 
0000 0000 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0000 0000 s ;	Preface_i - Acknowledgments, Revisions, notes
0000 0000 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0000 0000 s ;
0000 0000 s ;Assemble using ver 2.0 of the ASMX assembler by Bruce Tomlin
0000 0000 s ;
0000 0000 s ;Command to assemble:
0000 0000 s ;
0000 0000 s ;   asmx20 -l -o -e -C Z80 ZMCv12.asm
0000 0000 s ;
0000 0000 s ;
0000 0000 s ;Z80 Membership Card hardware by Lee Hart.
0000 0000 s ;
0000 0000 s ;V1.x -Operation, Documentation and Consultation by Herb Johnson
0000 0000 s ;
0000 0000 s ;Firmware by Josh Bensadon. Date: Feb 10, 2014
0000 0000 s ;
0000 0000 s ;FP LED & Keyboard operation concepts adapted from the Heathkit H8 computer.
0000 0000 s ;
0000 0000 s ;Revision.
0000 0000 s ;
0000 0000 s ;
0000 0000 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0000 0000 s ;	Preface_ii - Description, Operation
0000 0000 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0000 0000 s ;
0000 0000 s ;- - - HARDWARE - - -
0000 0000 s ;
0000 0000 s ;The Hardware is comprised of up to three boards, the CPU board, SIO board and Front Panel (FP) board.
0000 0000 s ;
0000 0000 s ;CPU Board:
0000 0000 s ; Z80 CPU, 4Mhz Clock, 5V Regulator, 32K EPROM (w/firmware), 32K RAM, 8 bit input port, 8 bit output port
0000 0000 s ;
0000 0000 s ;SIO Board:
0000 0000 s ; Additional RAM, up to 512K bytes to bank switch the lower 32K ROM on CPU Board
0000 0000 s ; ACE 8250 UART with RS-232 or FTDI232 (5V TTL Level) connection
0000 0000 s ; Micro SD Card Slot
0000 0000 s ;
0000 0000 s ;Front Panel Board:
0000 0000 s ; Terminal for Power & RS-232 connection, Timer for 1mSec interrupt, LED Display Driver & Keyboard Matrix.
0000 0000 s ;
0000 0000 s ; LED Display: 7 x 7-Segment displays (d1 to d7) and 7 annunciator leds (x1 to x7) below the 7 digits.
0000 0000 s ;
0000 0000 s ;    d1   d2   d3   d4   d5   d6   d7
0000 0000 s ;    _    _    _    _    _    _    _
0000 0000 s ;   |_|  |_|  |_|  |_|  |_|  |_|  |_|
0000 0000 s ;   |_|  |_|  |_|  |_|  |_|  |_|  |_|
0000 0000 s ;    _   _      _   _     _   _     _
0000 0000 s ;    x1  x2     x3  x4    x5  x6    x7
0000 0000 s ;
0000 0000 s ; Keyboard: 16 keys labeled "0" to "F" designated as a HEX keyboard
0000 0000 s ; The "F" key is wired to a separate input line, so it can be used as a "Shift" key to produce an extended number of key codes.
0000 0000 s ; The "F" and "0" keys are also wired directly to an AND gate, so that pressing both these keys produces a HARD reset.
0000 0000 s ;
0000 0000 s ;- - - FIRMWARE - - -
0000 0000 s ;
0000 0000 s ;The Firmware provides a means to control the system through two interfaces.
0000 0000 s ;Control is reading/writing to memory, registers, I/O ports; having the Z80 execute programs in memory or halting execution.
0000 0000 s ;The two interfaces are:
0000 0000 s ; 1. The Keyboard and LED display
0000 0000 s ; 2. A terminal (or PC) connected at 9600,N,8,1 to the RS-232 port.
0000 0000 s ;
0000 0000 s ;- - - The Keyboard and LED display interface - - -
0000 0000 s ;
0000 0000 s ;While entering commands or data, the annunciator LED's will light according to the state of the operation or system as follows:
0000 0000 s ;
0000 0000 s ; x1 = Enter Register
0000 0000 s ; x2 = Enter Memory Location
0000 0000 s ; x3 = Alter Memory/Register
0000 0000 s ; x4 = Send Data to Output Port
0000 0000 s ; x5 = Monitor Mode (Default Mode upon Power up)
0000 0000 s ; x6 = Run Mode
0000 0000 s ; x7 = Beeper (on key press)
0000 0000 s ;
0000 0000 s ;Keyboard Functions:
0000 0000 s ;
0000 0000 s ; "F" & "0" - Force a HARD reset to the Z80 and restarts the system.  See System Starting for additional details.
0000 0000 s ;
0000 0000 s ; "0" - Display a Register.  x1 lights and you have a few seconds to select which register to display.
0000 0000 s ; "E" - Display Memory.  x2 lights and you have a few seconds to enter a memory location.
0000 0000 s ; "5" - Display Input Port.  x2 lights and you have a few seconds to enter a port address.
0000 0000 s ; "6" - Output Port. x2 lights and you have a few seconds to enter a port address,
0000 0000 s ;	then x4 lights and you can enter data to output, new data may be sent while x4 remains lit.
0000 0000 s ; "A" - Advance Display Element.  Advances to next Register, Memory address or Port address.
0000 0000 s ; "B" - Backup Display Element.  Backs up to previous Register, Memory address or Port address.
0000 0000 s ; "4" - Go. Preloads all the registers including the PC, thus causes execution at the current PC register.
0000 0000 s ; "7" - Single Step.
0000 0000 s ; "D" - Alter/Output.  Depending on the display, Selects a different Register, Memory Address, Port or Sends Port Output.
0000 0000 s ;	Note, "D" will only send to that Output Port, to change port, reuse Command 6.
0000 0000 s ; "F" & "E" - Does a SOFT reset when Running.
0000 0000 s ;
0000 0000 s ;
0000 0000 s ;- - - The Terminal interface - - -
0000 0000 s ;
0000 0000 s ;Through a Terminal, there are more features you can use.  Entering a question mark (?) or another unrecognized command will display a list of available commands.
0000 0000 s ;Most commands are easy to understand, given here are the few which could use a better explaination.
0000 0000 s ;
0000 0000 s ; C - Continous Dump.	Works like the D command but without pausing on the page boundaries.  This is to allow the text capturing of a dump.
0000 0000 s ;			The captured file can then be later sent back to the system by simply sending the text file through an ASCII upload.
0000 0000 s ; M - Multiple Input.	Allows the entering of data in a format that was previously sent & saved in an ASCII text file.
0000 0000 s ; R - Register.		Entering R without specifiying the register will display all the registers.
0000 0000 s ;			A specific register can be displayed or set if specified.  eg. R HL<CR>, R HL=1234<CR>
0000 0000 s ; T - Test RAM		Specify the first and last page to test, eg T 80 8F will test RAM from 8000 to 8FFF.
0000 0000 s ; X - Xmodem Transfers	Transfers a binary file through the XModem protocol.  Enter the command, then configure your PC to receive or send a file.
0000 0000 s ;			eg. X U 8000<CR> will transfer a file from your PC to the RAM starting at 8000 for the length of the file (rounded up to the next 128 byte block).
0000 0000 s ;			eg. X D 8000 0010 will transfer a file from RAM to your PC, starting at 8000 for 10 (16 decimal) blocks, hence file size = 2K.
0000 0000 s ; : - ASCII HEX Upload	The ":" character is not entered manually, it is part of the Intel HEX file you can upload through ASCII upload.
0000 0000 s ;			eg. While at the prompt, just instruct your terminal program to ASCII upload (or send text file) a .HEX file.
0000 0000 s ;
0000 0000 s ;
0000 0000 s ;- - - System Starting - - -
0000 0000 s ;When the Z80 starts execution of the firmware at 0000, all the registers are saved to memory for examination or modification.
0000 0000 s ;There are many ways the Z80 can come to execute at 0000.  The firmware tries to deterimine the cause of the start up and will respond differently.
0000 0000 s ;Regardless of why, the firmware first saves all the registers to RAM and saves the last Stack word *assuming* it was the PC.
0000 0000 s ;A test is done to check if the FP board or SIO board is present.
0000 0000 s ;-If there is no FP board, then the firmware will either RUN code in RAM @8002 (if there's a valid signature of 2F8 @8000) or HALT.
0000 0000 s ;Next, 8 bytes of RAM is tested & set for/with a signature.
0000 0000 s ;-If there isn't a signature, it is assumed the system is starting from a powered up condition (COLD Start), no further testing is done.
0000 0000 s ;When the signature is good (WARM Start), more tests are done as follows:
0000 0000 s ;Test Keyboard for "F"&"E" = Soft Reset from Keyboard
0000 0000 s ;Test Keyboard for "F"|"0" = Hard Reset from Keyboard
0000 0000 s ;Test Last instruction executed (assuming PC was on Stack) for RST 0 (C7) = Code Break
0000 0000 s ;Test RS-232 Buffer for Ctrl-C (03) = Soft Reset from Terminal
0000 0000 s ;If cause cannot be deterimined, it is assumed an external source asserted the RESET line.
0000 0000 s ;
0000 0000 s ;The Display will indicate the cause of reset as:
0000 0000 s ;	"COLD 00"  (Power up detected by lack of RAM Signature)
0000 0000 s ;	"SOFT ##"  (F-E keys pressed)
0000 0000 s ;	"STEP ##"  (Single Step)
0000 0000 s ;	"^C   ##"  (Ctrl-C)
0000 0000 s ;	"HALT ##"  (HALT Instruction executed)
0000 0000 s ;	"F-0  ##"  (F-0 Hard Reset)
0000 0000 s ;	"RST0 ##"  (RST0 Instruction executed)
0000 0000 s ;	"HARD ##"  (HARD Reset by other)
0000 0000 s ;
0000 0000 s ;Where the number after the reset shows the total number of resets.
0000 0000 s ;
0000 0000 s ;The PC will be changed to 8000 on Cold resets.
0000 0000 s ;
0000 0000 s ;
0000 0000 s ;- - - Firmware BIOS - - -
0000 0000 s ;
0000 0000 s ;There are routines which can be called from your program to access the RS-232 Bit banging interface, Keyboard or Display inteface or Timer interrupt services.
0000 0000 s ;
0000 0000 s ;Label		Addr.	Description
0000 0000 s ;Put_Char	xxxx	Sends the ASCII character in A to the RS-232 port or LED Display (no registers, including A, are affected)
0000 0000 s ;Put_HEX	xxxx	Converts the low nibble of A to an ASCII character 0 to F and sends to RS-232 or LED Display
0000 0000 s ;Put_Byte	xxxx	Converts/sends both high and low nibbles of A (sends 2 ASCII Character) to RS-232 or LED Display
0000 0000 s 
0000 0000 s ;Warning: FCB's must never cross page boundaries.
0000 0000 s 
0000 0000 s 
0000 0000 s 
0000 0000 s ; Z80 - Registers
0000 0000 s ;
0000 0000 s ; A F   A' F'
0000 0000 s ; B C   B' C'
0000 0000 s ; D E   D' E'
0000 0000 s ; H L   H' L'
0000 0000 s ;    I R
0000 0000 s ;    IX
0000 0000 s ;    IY
0000 0000 s ;    SP
0000 0000 s ;    PC
0000 0000 s 
0000 0000 s 
0000 0000 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0000 0000 s ;	Preface_iii- Memory Mapping, I/O Mapping
0000 0000 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0000 0000 s 
0000 0000 s ;String equates
0000 0000 s CR		equ	0x0D
0000 0000 s LF		equ	0x0A
0000 0000 s EOS		equ	0x00
0000 0000 s 
0000 0000 s 
0000 0000 s ;Memory Mapping
0000 0000 s ;
0000 0000 s ;0x0000 - 0x7FFF	EPROM or RAM (BANK SWITCHED)
0000 0000 s ;0x8000 - 0xFFFF	RAM
0000 0000 s 
0000 0000 s ; Notes on Z80MC CPU board.
0000 0000 s ; Memory Mapping
0000 0000 s ; Holding /ROM high will inhibit the ROM from being enabled on the Data bus.
0000 0000 s ; Holding /RAM high will inhibit the RAM from being enabled on the Data bus.
0000 0000 s ; /ROM is loosely pulled low on Memrq & A15 low (ie, ROM 0000-7FFF)
0000 0000 s ; /RAM is loosely pulled low on Memrq & A15 high (ie, RAM 8000-FFFF)
0000 0000 s ; 
0000 0000 s ; 
0000 0000 s ; Notes on Z80 SRS board.
0000 0000 s ; Memory (SDC-RAM)
0000 0000 s ; The RAM on the SD card and the /ROM signal for the CPU board are both generated by U4.
0000 0000 s ; The Y output is the value of the addressed Data input pin or Low if strobe (G) is high.
0000 0000 s ; The W output is always the inverted value of Y.
0000 0000 s ; Y goes to /ROM and W goes to RAM /CE.  
0000 0000 s ; Therefore, when Y is high /ROM is inhibited and RAM /CE is low
0000 0000 s ; When Y is low /ROM is unhindered (and ROM is allowed to be accessed on A15=0)
0000 0000 s ; 
0000 0000 s ; When NOT requesting any Memory operation, /MREQ=1, Y is LOW.  This is irrelevant to
0000 0000 s ; the CPU ROM and RAM, but it ensures that the SDC-RAM is NOT enabled.
0000 0000 s ; With A15=0:
0000 0000 s ;  >Reading, Y is controled by Q1 (0=ROM, 1=RAM)
0000 0000 s ;  >Writing, Y is high, thus SDC-RAM is enabled to accept the write
0000 0000 s ;  
0000 0000 s ; With A15=1:
0000 0000 s ;  >Reading or Writing, Y is low, thus SDC-RAM is disabled and CPU-RAM is enabled
0000 0000 s  
0000 0000 s 
0000 0000 s ; Notes on Z80MC CPU board.
0000 0000 s ; I/O Mapping
0000 0000 s ; /OUT is loosely pulled low on A7 low, A6 high, A5 low and /WR low  (ie, 40-5F)
0000 0000 s ; /IN  is loosely pulled low on A7 low, A6 high, A5 low and /RD low  (ie, 40-5F)
0000 0000 s ;I/O
0000 0000 s ;0x40	Input/Output
0000 0000 s ;	Output bits	*Any write to output will clear /INT AND advance the Scan/Column Counter U2A.
0000 0000 s ;	0 = Segment D OR LED7       --4--
0000 0000 s ;	1 = Segment E OR LED6      2|   |3
0000 0000 s ;	2 = Segment F OR LED5       |   |
0000 0000 s ;	3 = Segment B OR LED4       --5--
0000 0000 s ;	4 = Segment A OR LED3      1|   |6
0000 0000 s ;	5 = Segment G OR LED2       |   |
0000 0000 s ;	6 = Segment C OR LED1       --0--
0000 0000 s ;	7 = RS-232 TXD (Bit Banged) = 1 when line idle, 0=start BIT
0000 0000 s ;
0000 0000 s ;	Input Bits
0000 0000 s ;	0 = Column Counter BIT 0 (Display AND Keyboard)
0000 0000 s ;	1 = Column Counter BIT 1 (Display AND Keyboard)
0000 0000 s ;	2 = Column Counter BIT 2 (Display AND Keyboard)
0000 0000 s ;	3 = 0 when Keys 0-7 are pressed (otherwise = 1), Row 0
0000 0000 s ;	4 = 0 when Keys 8-E are pressed (otherwise = 1), Row 1
0000 0000 s ;	5 = 1 when Key F is pressed (otherwise = 0), Key F is separate so it may be used as A Shift Key
0000 0000 s ;	6 = 1 when U2B causes an interrupt, Timer Interrupt (Send Output to reset)
0000 0000 s ;	7 = RS-232 RXD (Bit Banged) = 1 when not connected OR line idle, 0=first start BIT
0000 0000 s ;
0000 0000 s ;	Bit 5 allows Key F to be read separately to act as A "Shift" key when needed.
0000 0000 s ;	Bits 0-2 can be read to ascertain the Display Column currently being driven.
0000 0000 s ;
0000 0000 s ; Notes on Z80 SIO board.
0000 0000 s ; I/O 
0000 0000 s ; C0-C8, write single bit (D0) to BIT LATCH U5.
0000 0000 s ; C0=Q0 SPI_CLK
0000 0000 s ; C1=Q1 BANK 0=ROM, 1=RAM
0000 0000 s ; C2=Q2
0000 0000 s ; C3=Q3
0000 0000 s ; C4=Q4 SD /CS
0000 0000 s ; C5=Q5 SD MOSI
0000 0000 s ; C6=Q6 
0000 0000 s ; C7=Q7 ACE MASTER RESET (1=RESET UART)
0000 0000 s ; 
0000 0000 s ; Q0  SPI_CLK
0000 0000 s ; 0   HIGH (Always)
0000 0000 s ; 1   LOW and PULSED HIGH BY I/O 88  (NO NEED TO I/O TWICE HIGH/LOW FOR A PULSE)
0000 0000 s ;
0000 0000 s ;
0000 0000 s ; IN C0 = SD Clock Pulse
0000 0000 s ;  
0000 0000 s ; 	LD	A,1
0000 0000 s ; 	OUT	(0xC0),A	;ENABLE CLK LOW
0000 0000 s ; 	
0000 0000 s ; 				;SINGLE I/O TO PULSE SPI_CLK
0000 0000 s ; 	IN	A,(0xC0)	;PULSE SPI_CLK HIGH WITH A SINGLE I/O
0000 0000 s ; 
0000 0000 s ; 
0000 0000 s ; C8-CF, write/read bytes to 8250 UART
0000 0000 s ; C8 TXBUFFER/RXBUFFER
0000 0000 s ; C9 Interrupt enable reg
0000 0000 s ; CA Interrupt ID reg
0000 0000 s ; CB Line  Control Reg (LCR) word len, stop bits, parity
0000 0000 s ; CC Modem Control Reg (MCR) 0, 0, 0, Loop, OUT2, OUT1, RTS, DTR
0000 0000 s ; CD Line Status Reg (LSR) TX/RX Buffer Empty
0000 0000 s ; CE Modem Status Reg (MSR) DCD, RI, DSR, CTS, DDCD, TERI, DDSR, DCTS
0000 0000 s ; CF Scratch Register (SCR) General read/write
0000 0000 s ; 
0000 0000 s ; Outputs in Modem Control Reg B (MCR) control the High 4 address bits of the
0000 0000 s ; extended RAM. These 4 bits are inverted and on a MR, the outputs all go high.
0000 0000 s ; CC.0  /DTR  B15
0000 0000 s ; CC.1  /RTS  B16
0000 0000 s ; CC.2  /OUT1 B17
0000 0000 s ; CC.3  /OUT2 B18
0000 0000 s ; 
0000 0000 s ; Inputs from Modem Status Reg 
0000 0000 s ; CE.7  /DCD  MISO (Inverted Data from SD Card)
0000 0000 s ; 
0000 0000 s ; Inputs from Line Status Register indicate UART condition
0000 0000 s ; CD.0  Data Read 1=RX Data ready to read
0000 0000 s ; CD.5  Data TX Holding Register Empty 1=Empty (ie ok to send next byte) Mask 0x20
0000 0000 s ;
0000 0000 s 
0000 0000 s Port40		equ	0x40	;LED DISPLAY, RS-232 TXD/RXD AND KEYBOARD
0000 0000 s 
0000 0000 s 				;U5 - 74LS259 Bit Addressable Latch
0000 0000 s SDCLK		equ	0xC0	;SD Clk and Clk Pulse
0000 0000 s RAMROM		equ	0xC1	;RAM /ROM selection
0000 0000 s BITS_Q2		equ	0xC2	;PIN 6
0000 0000 s BITS_Q3		equ	0xC3	;PIN 7
0000 0000 s SDCS		equ	0xC4	;SD Card /CS
0000 0000 s SDTX		equ	0xC5	;SD Card TX Data
0000 0000 s GREEN_LED	equ	0xC6	;GREEN_LED, PIN 11
0000 0000 s ACE_RESET	equ	0xC7	;ACE Reset
0000 0000 s 
0000 0000 s ACE_DATA	equ	0xC8	;ACE TX and RX register
0000 0000 s ACE_BAUD0	equ	0xC8	;ACE Baudrate Low
0000 0000 s ACE_BAUD1	equ	0xC9	;ACE Baudrate High
0000 0000 s ACE_LCR		equ	0xCB	;ACE Word len/bit setup
0000 0000 s ACE_OUT		equ	0xCC	;ACE RAM Bank Selection.  Lower 4 bits map to Bank Select.
0000 0000 s ACE_STATUS	equ	0xCD	;ACE RX/TX status
0000 0000 s ACE_MSR		equ	0xCE	;ACE Modem Status Register
0000 0000 s ACE_SCRATCH	equ	0xCF	;ACE Scratch Register (not used, because not available on all UARTs)
0000 0000 s 
0000 0000 s ;	Chapter_1	Page 0 interrupt & restart locations
0000 0000 s ;
0000 0000 s ;                        *******    *******    *******    *******
0000 0000 s ;                       *********  *********  *********  *********
0000 0000 s ;                       **     **  **     **  **     **  **     **
0000 0000 s ;                       **     **  **     **  **     **  **     **
0000 0000 s ;---------------------  **     **  **     **  **     **  **     **  ---------------------
0000 0000 s ;---------------------  **     **  **     **  **     **  **     **  ---------------------
0000 0000 s ;                       **     **  **     **  **     **  **     **
0000 0000 s ;                       **     **  **     **  **     **  **     **
0000 0000 s ;                       *********  *********  *********  *********
0000 0000 s ;                        *******    *******    *******    *******
0000 0000 s 
0000 0000 s 
0000 0000 s 		org	0x0000
0000 0000 s 					; Z80 CPU LDRTS HERE
0000 0000 d f3
0000 0000 u 01 01
0000 0000 s 		DI			; Disable Interrupts
0001 0001 d c30001
0001 0001 u 03 01
0001 0001 s 		JP	RESETLDRT
0004 0004 s 
0008 0008 s 		org	0x0008		; RST	0x08
0008 0008 d c9
0008 0008 u 01 01
0008 0008 s 		RET
0009 0009 s 
0010 0010 s 		org	0x0010		; RST	0x10
0010 0010 d c9
0010 0010 u 01 01
0010 0010 s 		RET
0011 0011 s 		
0018 0018 s 		org	0x0018		; RST	0x18
0018 0018 d c9
0018 0018 u 01 01
0018 0018 s 		RET
0019 0019 s 		
0020 0020 s 		org	0x0020		; RST	0x20
0020 0020 d c9
0020 0020 u 01 01
0020 0020 s 		RET
0021 0021 s 
0028 0028 s 		org	0x0028		; RST	0x28
0028 0028 d c9
0028 0028 u 01 01
0028 0028 s 		RET
0029 0029 s 
0030 0030 s 		org	0x0030		; RST	0x30
0030 0030 d c9
0030 0030 u 01 01
0030 0030 s 		RET
0031 0031 s 
0031 0031 s ;Interrupts:
0031 0031 s ;The Serial bit banger uses an interrupt on the fall of the start bit, therefore we must count
0031 0031 s ;clock cycles to the data bits.  Interrupts can happen in the middle of any instruction.  
0031 0031 s ;With most common instructions being between 4 and 16 tc, the count starts at 10 tc
0031 0031 s ;An Interrupt is really a RST 38 instruction (with 2 extra wait cycles)
0031 0031 s 		;Previous Instruction	;10
0031 0031 s 		;RST	0x38		;13  (11 + 2 wait cycles)
0038 0038 s 		org	0x0038
0038 0038 d 08
0038 0038 u 01 01
0038 0038 s 		EX	AF,AF'		;4
0039 0039 d d9
0039 0039 u 01 01
0039 0039 s 		EXX			;4
003a 003a d 2aceff
003a 003a u 03 01
003a 003a s 		LD	HL,(INT_VEC)	;16 Typical Calls are to ISR_DISPATCH
003d 003d d e9
003d 003d u 01 01
003d 003d s 		JP	(HL)		;4
003e 003e s 
003e 003e s RST38_LEN	EQU	$-0x0038
003e 003e s 
003e 003e s ;What the stack looks like on Interrupts...
003e 003e s ;
003e 003e s ;OLD-STACK    ISR-STACK
003e 003e s ;   PC	
003e 003e s ;		HL
003e 003e s ;		AF
003e 003e s ;SP		PC	(Call to ISR_DISPATCH from High Ram Dispatch)
003e 003e s ;		PC	(Call to GET_REGISTER from ISR)
003e 003e s 
0066 0066 s 		org	0x0066		; NMI Service Routine
0066 0066 d e5
0066 0066 u 01 01
0066 0066 s 		PUSH	HL
0067 0067 d 2adcff
0067 0067 u 03 01
0067 0067 s 		LD	HL,(NMI_VEC)
006a 006a d e9
006a 006a u 01 01
006a 006a s 		JP	(HL)
006b 006b s ;NMI_VEC:	RETN			;
006b 006b s 
006b 006b s 
006b 006b s 
006b 006b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
006b 006b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
006b 006b s ;	Chapter_2	Startup Code
006b 006b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
006b 006b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
006b 006b s 
0100 0100 s 		ORG	0x0100
0100 0100 s ;-------------------------------------------------------------------------------- RESET LDRTUP CODE
0100 0100 s RESETLDRT:
0100 0100 s ;Save Registers & SET sp
0100 0100 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0100 0100 d ed56
0100 0100 u 02 01
0100 0100 s 		IM	1		; Interrupts cause RST 0x38
0102 0102 s 
0102 0102 s 					;No need to select ROM, we are already here.
0102 0102 d 229eff
0102 0102 u 03 01
0102 0102 s 		LD	(RSHL),HL
0105 0105 s 
0105 0105 d e1
0105 0105 u 01 01
0105 0105 s 		POP	HL		;Fetch PC
0106 0106 d 22a0ff
0106 0106 u 03 01
0106 0106 s 		LD	(RPC),HL	;Save the PC
0109 0109 d ed7396ff
0109 0109 u 04 01
0109 0109 s 		LD	(RSSP),SP	;Save the SP
010d 010d s 
010d 010d d 319eff
010d 010d u 03 01
010d 010d s 		LD	SP,RSDE+2	;Set Stack to save registers DE,BC,AF
0110 0110 d d5
0110 0110 u 01 01
0110 0110 s 		PUSH	DE
0111 0111 d c5
0111 0111 u 01 01
0111 0111 s 		PUSH	BC
0112 0112 d f5
0112 0112 u 01 01
0112 0112 s 		PUSH	AF
0113 0113 s 
0113 0113 d 3e01
0113 0113 u 02 01
0113 0113 s 		LD	A,1
0115 0115 d d3c7
0115 0115 u 02 01
0115 0115 s 		OUT	(ACE_RESET),A	;RESET ACE
0117 0117 s 
0117 0117 d 08
0117 0117 u 01 01
0117 0117 s 		EX	AF,AF'		;Save Alternate register set
0118 0118 d d9
0118 0118 u 01 01
0118 0118 s 		EXX			;Save Alternate register set
0119 0119 d 31b0ff
0119 0119 u 03 01
0119 0119 s 		LD	SP,RSHL2+2	;Set Stack to save registers HL',DE',BC',AF'
011c 011c d e5
011c 011c u 01 01
011c 011c s 		PUSH	HL
011d 011d d d5
011d 011d u 01 01
011d 011d s 		PUSH	DE
011e 011e d c5
011e 011e u 01 01
011e 011e s 		PUSH	BC
011f 011f d f5
011f 011f u 01 01
011f 011f s 		PUSH	AF
0120 0120 d 08
0120 0120 u 01 01
0120 0120 s 		EX	AF,AF'
0121 0121 d d9
0121 0121 u 01 01
0121 0121 s 		EXX
0122 0122 s 
0122 0122 d ed57
0122 0122 u 02 01
0122 0122 s 		LD	A,I		;Fetch IR
0124 0124 d 47
0124 0124 u 01 01
0124 0124 s 		LD	B,A
0125 0125 d ed5f
0125 0125 u 02 01
0125 0125 s 		LD	A,R
0127 0127 d 4f
0127 0127 u 01 01
0127 0127 s 		LD	C,A
0128 0128 d c5
0128 0128 u 01 01
0128 0128 s 		PUSH	BC		;Save IR
0129 0129 s 
0129 0129 d fde5
0129 0129 u 02 01
0129 0129 s 		PUSH	IY
012b 012b d dde5
012b 012b u 02 01
012b 012b s 		PUSH	IX
012d 012d s 
012d 012d d 31fefa
012d 012d u 03 01
012d 012d s 		LD	SP, StackTop	; Stack = 0xFF80 (Next Stack Push Location = 0xFF7F,0xFF7E)
0130 0130 s 
0130 0130 s 
0130 0130 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0130 0130 s ;Save Input State, Set default Output state
0130 0130 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0130 0130 s 
0130 0130 d 0e40
0130 0130 u 02 01
0130 0130 s 		LD	C,Port40	;Select I/O Port
0132 0132 d 1e80
0132 0132 u 02 01
0132 0132 s 		LD	E,0x80		;Advance Column		
0134 0134 d 0608
0134 0134 u 02 01
0134 0134 s 		LD	B,8		; 8 Tries to get to Column 0
0136 0136 d ed59
0136 0136 u 02 01
0136 0136 s RSIS_LP		OUT	(C),E		; Clear LED Display & Set RS-232 TXD to inactive state
0138 0138 d ed78
0138 0138 u 02 01
0138 0138 s 		IN	A,(C)		;Fetch Column
013a 013a d 57
013a 013a u 01 01
013a 013a s 		LD	D,A		;Save IN D (For RESET Test)
013b 013b d e607
013b 013b u 02 01
013b 013b s 		AND	7		;Mask Column only
013d 013d d 2802
013d 013d u 02 01
013d 013d s 		JR   Z,	RSIS_OK		;When 0, exit Test Loop
013f 013f d 10f5
013f 013f u 02 01
013f 013f s 		DJNZ	RSIS_LP
0141 0141 s RSIS_OK					;Input State upon reset saved IN Register D
0141 0141 s 
0141 0141 s 
0141 0141 d 2100ff
0141 0141 u 03 01
0141 0141 s 		LD	HL,BIT_TABLE	;BIT_TABLE = 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80
0144 0144 d 3e01
0144 0144 u 02 01
0144 0144 s 		LD	A,1
0146 0146 d 77
0146 0146 u 01 01
0146 0146 s FILL_BT		LD	(HL),A
0147 0147 d 23
0147 0147 u 01 01
0147 0147 s 		INC	HL
0148 0148 d 07
0148 0148 u 01 01
0148 0148 s 		RLCA
0149 0149 d 30fb
0149 0149 u 02 01
0149 0149 s 		JR  NC,	FILL_BT
014b 014b s 
014b 014b s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
014b 014b s ;Test Hardware - FP Board Present?
014b 014b s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
014b 014b s 
014b 014b s 					;Verify FP board is present
014b 014b d 010018
014b 014b u 03 01
014b 014b s 		LD	BC,0x1800	; Several Loops through Column 0 proves FP board is working
014e 014e d 1e0a
014e 014e u 02 01
014e 014e s 		LD	E,10		; 10 Retries if not expected Column
0150 0150 s 
0150 0150 d db40
0150 0150 u 02 01
0150 0150 s RTHW_LP		IN	A,(Port40)	;Fetch Column
0152 0152 d e607
0152 0152 u 02 01
0152 0152 s 		AND	7
0154 0154 d b9
0154 0154 u 01 01
0154 0154 s 		CP	C
0155 0155 d ca5d01
0155 0155 u 03 01
0155 0155 s 		JP  Z,	RTHW_OK		;Jump if Column = expected value
0158 0158 s 
0158 0158 d 1d
0158 0158 u 01 01
0158 0158 s 		DEC	E		;If not expected, count the errors.
0159 0159 d 280c
0159 0159 u 02 01
0159 0159 s 		JR  Z,	RTHW_EXIT	;If error chances down to zero, there's no FP
015b 015b d 1803
015b 015b u 02 01
015b 015b s 		JR	RTHW_ADV
015d 015d s 
015d 015d d 0c
015d 015d u 01 01
015d 015d s RTHW_OK		INC	C		; Advance expected value
015e 015e d cb99
015e 015e u 02 01
015e 015e s 		RES	3,C		; Limit expected value to 0-7
0160 0160 d 3e80
0160 0160 u 02 01
0160 0160 s RTHW_ADV	LD	A,0x80		;Advance Column
0162 0162 d d340
0162 0162 u 02 01
0162 0162 s 		OUT	(Port40),A	; Clear LED Display & Set RS-232 TXD to inactive state
0164 0164 d 10ea
0164 0164 u 02 01
0164 0164 s 		DJNZ	RTHW_LP
0166 0166 d 5f
0166 0166 u 01 01
0166 0166 s 		LD	E,A
0167 0167 s RTHW_EXIT				;E=80 FP present, (D still holding input state)
0167 0167 s 					;E=00 NO FP
0167 0167 s 
0167 0167 s 
0167 0167 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0167 0167 s ;Test Hardware - SIO Board Present?
0167 0167 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0167 0167 s 
0167 0167 d af
0167 0167 u 01 01
0167 0167 s 		XOR	A
0168 0168 d d3c7
0168 0168 u 02 01
0168 0168 s 		OUT	(ACE_RESET),A	;Cancel RESET of ACE
016a 016a s 		
016a 016a d 0600
016a 016a u 02 01
016a 016a s 		LD	B,0		;Count 256 times	
016c 016c d 3e80
016c 016c u 02 01
016c 016c s 		LD	A,0x80		;Set baud rate
016e 016e d d3cb
016e 016e u 02 01
016e 016e s 		OUT	(ACE_LCR),A
0170 0170 s 
0170 0170 d 78
0170 0170 u 01 01
0170 0170 s RTHW_SIOT_LP	LD	A,B		;Use the counter to test for the presence 
0171 0171 d d3c8
0171 0171 u 02 01
0171 0171 s 		OUT	(ACE_BAUD0),A	;of the ACE SCRATCH Register
0173 0173 d dbc8
0173 0173 u 02 01
0173 0173 s 		IN	A,(ACE_BAUD0)
0175 0175 d b8
0175 0175 u 01 01
0175 0175 s 		CP	B
0176 0176 d 2006
0176 0176 u 02 01
0176 0176 s 		JR NZ,	RTHW_SIO_EXIT
0178 0178 d 10f6
0178 0178 u 02 01
0178 0178 s 		DJNZ	RTHW_SIOT_LP
017a 017a d 1c
017a 017a u 01 01
017a 017a s 		INC	E		;All tests OK, Advance E so the LSD is 1
017b 017b d cd7d26
017b 017b u 03 01
017b 017b s 		CALL	SD_DESELECT	;DISABLE SD CARD, LED's OFF
017e 017e d 7b
017e 017e u 01 01
017e 017e s RTHW_SIO_EXIT	LD	A,E
017f 017f d 07
017f 017f u 01 01
017f 017f s 		RLCA
0180 0180 d 3295ff
0180 0180 u 03 01
0180 0180 s 		LD	(HW_LIST),A	;Save HW List
0183 0183 s 					;00 NO Boards
0183 0183 s 					;01 FP only
0183 0183 s 					;02 SIO only
0183 0183 s 					;03 FP & SIO
0183 0183 s 
0183 0183 s 
0183 0183 d 180f
0183 0183 u 02 01
0183 0183 s 		JR 	CHK_RESET	;Ignore EXEC_RAM_2F8
0185 0185 s 
0185 0185 s ;		OR	A
0185 0185 s ;		JR NZ,	CHK_RESET	;Jump if any board is present
0185 0185 s 
0185 0185 s 
0185 0185 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0185 0185 s ;Execute RAM program if NO FP Board Present
0185 0185 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0185 0185 s 					;If scan counter not running, then either Execute RAM OR HALT
0185 0185 d 2a0080
0185 0185 u 03 01
0185 0185 s EXEC_RAM_2F8	LD	HL,(0x8000)	;Address of RAM Valid Signature
0188 0188 d 01f802
0188 0188 u 03 01
0188 0188 s 		LD	BC,0x2F8	;(FP board probably not present)
018b 018b d af
018b 018b u 01 01
018b 018b s 		XOR	A		;Verify RAM valid with 2F8 signature at 0x8000
018c 018c d ed42
018c 018c u 02 01
018c 018c s 		SBC	HL,BC
018e 018e d ca0280
018e 018e u 03 01
018e 018e s 		JP	Z,0x8002	;Execute RAM
0191 0191 d c39101
0191 0191 u 03 01
0191 0191 s 		JP	$		;Or HALT
0194 0194 s 
0194 0194 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0194 0194 s ;Determine Reason for RESET ie entering Monitor Mode (D=Key Input from save state section)
0194 0194 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0194 0194 s 					;Determine why the CPU is executing A RESET.
0194 0194 s 					;  -Power on (RAM signature will be wrong)
0194 0194 s 					;  -F-0 Reset Switch (one of the switches will still be pressed)
0194 0194 s 					;  -RST 0 (look for C7 at previous location given by stack)
0194 0194 s 					;  -External /RESET OR User program branches to 0000
0194 0194 s 					;
0194 0194 s 					;RC_TYPE
0194 0194 s 					;0	COLD RESET (NO RAM SIGNATURE)
0194 0194 s 					;1	F-E Soft Reset (SOFT_RST_FLAG = FE)
0194 0194 s 					;2	Single Step (SOFT_RST_FLAG = D1)
0194 0194 s 					;3	<Ctrl>-C (SOFT_RST_FLAG = CC)
0194 0194 s 					;4	HALT (SOFT_RST_FLAG = 76)
0194 0194 s 					;5	F-0 (F or 0 key on FP still down)
0194 0194 s 					;6	RST0 ( M(PC-1) = C7)
0194 0194 s 					;7	HARD RESET (Default if SOFT_RST_FLAG not set)
0194 0194 s 
0194 0194 s 					;Test RAM Signature for Cold Start Entry
0194 0194 d 2178ff
0194 0194 u 03 01
0194 0194 s CHK_RESET	LD	HL,RAMSIGNATURE		
0197 0197 d 3ef0
0197 0197 u 02 01
0197 0197 s 		LD	A,0xF0		;First signature byte expected
0199 0199 d 0608
0199 0199 u 02 01
0199 0199 s 		LD	B,8		;#bytes in signature (loop)
019b 019b d be
019b 019b u 01 01
019b 019b s RAMSIG_LP	CP	(HL)
019c 019c d 2007
019c 019c u 02 01
019c 019c s 		JR  NZ,	COLD_START
019e 019e d 2c
019e 019e u 01 01
019e 019e s 		INC	L
019f 019f d d60f
019f 019f u 02 01
019f 019f s 		SUB	0xF
01a1 01a1 d 10f8
01a1 01a1 u 02 01
01a1 01a1 s 		DJNZ	RAMSIG_LP
01a3 01a3 d 182a
01a3 01a3 u 02 01
01a3 01a3 s 		JR	WARM_START
01a5 01a5 s 
01a5 01a5 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
01a5 01a5 d 2180ff
01a5 01a5 u 03 01
01a5 01a5 s COLD_START	LD	HL,RC_TYPE
01a8 01a8 d 060f
01a8 01a8 u 02 01
01a8 01a8 s 		LD	B,CS_CLR_LEN
01aa 01aa d cd100c
01aa 01aa u 03 01
01aa 01aa s 		CALL	CLEAR_BLOCK
01ad 01ad s 
01ad 01ad s 		;DB	0		;(RC_TYPE)
01ad 01ad s 		;DB	0		;(RC_SOFT)
01ad 01ad s 		;DB	0		;(RC_STEP)
01ad 01ad s 		;DB	0		;(RC_CC)
01ad 01ad s 		;DB	0		;(RC_HALT)
01ad 01ad s 		;DB	0		;(RC_F0)
01ad 01ad s 		;DB	0		;(RC_RST0)
01ad 01ad s 		;DB	0		;(RC_HARD)
01ad 01ad s 		;DB	0		;(RegPtr)
01ad 01ad s 		;DW	0		;(ABUSS)
01ad 01ad s 		;DB	0		;(IoPtr)
01ad 01ad s 		;DB	0		;(RX_ERR_LDRT)
01ad 01ad s 		;DB	0		;(RX_ERR_STOP)
01ad 01ad s 		;DB	0		;(RX_ERR_OVR)
01ad 01ad s 		
01ad 01ad d 3e0c
01ad 01ad u 02 01
01ad 01ad s 		LD	A,12
01af 01af d 328fff
01af 01af u 03 01
01af 01af s 		LD	(ACE_BAUD),A
01b2 01b2 s 
01b2 01b2 d 21ff17
01b2 01b2 u 03 01
01b2 01b2 s 		LD	HL,UiVec_RET
01b5 01b5 d 22b0ff
01b5 01b5 u 03 01
01b5 01b5 s 		LD	(UiVec),HL
01b8 01b8 s 
01b8 01b8 d 3a95ff
01b8 01b8 u 03 01
01b8 01b8 s 		LD	A,(HW_LIST)	;Fetch HW List
01bb 01bb d e603
01bb 01bb u 02 01
01bb 01bb s 		AND	3		;00 NO FP
01bd 01bd d 4f
01bd 01bd u 01 01
01bd 01bd s 		LD	C,A		;01 FP only
01be 01be d cd8613
01be 01be u 03 01
01be 01be s 		CALL	SET_IO		;02 SIO only
01c1 01c1 s 					;03 SIO & FP
01c1 01c1 s 		
01c1 01c1 d 21fcfa
01c1 01c1 u 03 01
01c1 01c1 s 		LD	HL,StackTop-2
01c4 01c4 d 2296ff
01c4 01c4 u 03 01
01c4 01c4 s 		LD	(RSSP),HL
01c7 01c7 d 210080
01c7 01c7 u 03 01
01c7 01c7 s 		LD	HL,RAM_LDRT
01ca 01ca d 22a0ff
01ca 01ca u 03 01
01ca 01ca s 		LD	(RPC),HL
01cd 01cd d 1841
01cd 01cd u 02 01
01cd 01cd s 		JR	INIT_SYSTEM
01cf 01cf s 
01cf 01cf s 					;Determine Warm Start condition
01cf 01cf s 					;Input: Various tests
01cf 01cf s 					;(D=Key Input from save state section)
01cf 01cf s 					;Output: HL=Pointer to Reset Codes (RC_????)
01cf 01cf d 2181ff
01cf 01cf u 03 01
01cf 01cf s WARM_START	LD	HL,RC_SOFT	;HL=RC_SOFT
01d2 01d2 d 3adfff
01d2 01d2 u 03 01
01d2 01d2 s 		LD	A,(SOFT_RST_FLAG)
01d5 01d5 d fefe
01d5 01d5 u 02 01
01d5 01d5 s 		CP	0xFE		;'FE' is the keyboard code for holding F & E
01d7 01d7 d 282b
01d7 01d7 u 02 01
01d7 01d7 s 		JR  Z,	WS_SET
01d9 01d9 d 2c
01d9 01d9 u 01 01
01d9 01d9 s 		INC	L		;HL=RC_STEP
01da 01da d fed1
01da 01da u 02 01
01da 01da s 		CP	0xD1		;'D1' is the code for Do One step
01dc 01dc d 2826
01dc 01dc u 02 01
01dc 01dc s 		JR  Z,	WS_SET
01de 01de d 2c
01de 01de u 01 01
01de 01de s 		INC	L		;HL=RC_CC
01df 01df d fecc
01df 01df u 02 01
01df 01df s 		CP	0xCC		;'CC' is the code for <Ctrl>-C
01e1 01e1 d 2821
01e1 01e1 u 02 01
01e1 01e1 s 		JR  Z,	WS_SET
01e3 01e3 d 2c
01e3 01e3 u 01 01
01e3 01e3 s 		INC	L		;HL=RC_HALT
01e4 01e4 d fe76
01e4 01e4 u 02 01
01e4 01e4 s 		CP	0x76		;'76' is the code and opcode for HALT
01e6 01e6 d 281c
01e6 01e6 u 02 01
01e6 01e6 s 		JR  Z,	WS_SET
01e8 01e8 d 2c
01e8 01e8 u 01 01
01e8 01e8 s 		INC	L		;HL=RC_F0
01e9 01e9 s 		
01e9 01e9 d 3a95ff
01e9 01e9 u 03 01
01e9 01e9 s 		LD	A,(HW_LIST)
01ec 01ec d 1f
01ec 01ec u 01 01
01ec 01ec s 		RRA
01ed 01ed d 3009
01ed 01ed u 02 01
01ed 01ed s 		JR  NC,	WS_NOFP
01ef 01ef s 		
01ef 01ef d 7a
01ef 01ef u 01 01
01ef 01ef s 		LD	A,D		;Fetch Input of Column 0
01f0 01f0 d cb6f
01f0 01f0 u 02 01
01f0 01f0 s 		BIT	5,A		;
01f2 01f2 d 2010
01f2 01f2 u 02 01
01f2 01f2 s 		JR NZ,	WS_SET		;Jump if F switch pressed
01f4 01f4 d cb5f
01f4 01f4 u 02 01
01f4 01f4 s 		BIT	3,A		;
01f6 01f6 d 280c
01f6 01f6 u 02 01
01f6 01f6 s 		JR  Z,	WS_SET		;Jump if 0 switch pressed
01f8 01f8 s 		
01f8 01f8 d 2c
01f8 01f8 u 01 01
01f8 01f8 s WS_NOFP		INC	L		;HL=RC_RST0
01f9 01f9 d ed5ba0ff
01f9 01f9 u 04 01
01f9 01f9 s 		LD	DE,(RPC)
01fd 01fd d 1b
01fd 01fd u 01 01
01fd 01fd s 		DEC	DE
01fe 01fe d 1a
01fe 01fe u 01 01
01fe 01fe s 		LD	A,(DE)
01ff 01ff d fec7
01ff 01ff u 02 01
01ff 01ff s 		CP	0xC7		;Did we get here by a RESTART 0 instruction?
0201 0201 d 2801
0201 0201 u 02 01
0201 0201 s 		JR  Z,	WS_SET		;Jump if RST 0 Instruction
0203 0203 d 2c
0203 0203 u 01 01
0203 0203 s 		INC	L		;HL=RC_HARD
0204 0204 s 
0204 0204 d 7d
0204 0204 u 01 01
0204 0204 s WS_SET		LD	A,L		;Low address of Pointer & 7 = Reset code type
0205 0205 d 32dfff
0205 0205 u 03 01
0205 0205 s 		LD	(SOFT_RST_FLAG),A ;Nuke flag until next time
0208 0208 d e607
0208 0208 u 02 01
0208 0208 s 		AND	7
020a 020a d 3280ff
020a 020a u 03 01
020a 020a s 		LD	(RC_TYPE),A
020d 020d d cd260e
020d 020d u 03 01
020d 020d s 		CALL	TINC		;Advance the reset counter
0210 0210 s 
0210 0210 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0210 0210 s ;Init all System RAM, enable interrupts
0210 0210 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0210 0210 d 2100fe
0210 0210 u 03 01
0210 0210 s INIT_SYSTEM	LD	HL,RXBUFFER
0213 0213 d 0600
0213 0213 u 02 01
0213 0213 s 		LD	B,0
0215 0215 d cd100c
0215 0215 u 03 01
0215 0215 s 		CALL	CLEAR_BLOCK
0218 0218 s 
0218 0218 d 21d4ff
0218 0218 u 03 01
0218 0218 s 		LD	HL,CLEARED_SPACE
021b 021b d 062c
021b 021b u 02 01
021b 021b s 		LD	B,CLEARED_LEN
021d 021d d cd100c
021d 021d u 03 01
021d 021d s 		CALL	CLEAR_BLOCK
0220 0220 s 
0220 0220 d 2abcff
0220 0220 u 03 01
0220 0220 s 		LD	HL,(DISPMODE)
0223 0223 d 22d4ff
0223 0223 u 03 01
0223 0223 s 		LD	(SDISPMODE),HL
0226 0226 s 
0226 0226 d cd1d0c
0226 0226 u 03 01
0226 0226 s 		CALL	WRITE_BLOCK
0229 0229 d b2ff
0229 0229 u 02 02
0229 0229 s 		DW	BEEP_TO		;Where to write
022b 022b d 2200
022b 022b u 02 02
022b 022b s 		DW	34		;Bytes to write
022d 022d d 01
022d 022d u 01 02
022d 022d s 		DB	1		;(BEEP_TO)
022e 022e d 84
022e 022e u 01 02
022e 022e s 		DB	0x84		;(ANBAR_DEF) = MON MODE
022f 022f d 710c
022f 022f u 02 02
022f 022f s 		DW	GET_REG_MON	;(GET_REG)
0231 0231 d 860c
0231 0231 u 02 02
0231 0231 s 		DW	PUT_REG_MON	;(PUT_REG)
0233 0233 d b217
0233 0233 u 02 02
0233 0233 s 		DW	CTRL_C_RET	;(CTRL_C_CHK)
0235 0235 d e317
0235 0235 u 02 02
0235 0235 s 		DW	IDISP_RET	;(LDISPMODE)
0237 0237 d e317
0237 0237 u 02 02
0237 0237 s 		DW	IDISP_RET	;(DISPMODE)
0239 0239 d 4218
0239 0239 u 02 02
0239 0239 s 		DW	IMON_CMD	;(KEY_EVENT) Initialize to Command Mode
023b 023b d 01
023b 023b u 01 02
023b 023b s 		DB	1		;(IK_TIMER)
023c 023c d 90
023c 023c u 01 02
023c 023c s 		DB	0x90		;(KEYBFMODE) HEX Keyboard Mode (F on release)
023d 023d d 01
023d 023d u 01 02
023d 023d s 		DB	1		;(DISPLABEL)
023e 023e d ff
023e 023e u 01 02
023e 023e s 		DB	-1		;(IK_HEXST)
023f 023f d e0ff
023f 023f u 02 02
023f 023f s 		DW	LED_DISPLAY	;(HEX_CURSOR) @d1
0241 0241 d 2019
0241 0241 u 02 02
0241 0241 s 		DW	HEX2ABUSS	;(HEX_READY)
0243 0243 d e0ff
0243 0243 u 02 02
0243 0243 s 		DW	LED_DISPLAY	;(LED_CURSOR)
0245 0245 d 00fe
0245 0245 u 02 02
0245 0245 s 		DW	RXBUFFER	;(RXBHEAD)
0247 0247 d 00fe
0247 0247 u 02 02
0247 0247 s 		DW	RXBUFFER	;(RXBTAIL)
0249 0249 d 2afb
0249 0249 u 02 02
0249 0249 s 		DW	ISR_DISPATCH	;(INT_VEC)
024b 024b d e0ff
024b 024b u 02 02
024b 024b s 		DW	LED_DISPLAY	;(SCAN_PTR)
024d 024d d ec16
024d 024d u 02 02
024d 024d s 		DW	DO_HALT_TEST	;(HALT_TEST)
024f 024f s 
024f 024f d 3e80
024f 024f u 02 01
024f 024f s 		LD	A,0x80		;Advance Column / Clear Counter for Interrupt
0251 0251 d d340
0251 0251 u 02 01
0251 0251 s 		OUT	(Port40),A	; Clear LED Display & Set RS-232 TXD to inactive state
0253 0253 d cd2a0e
0253 0253 u 03 01
0253 0253 s 		CALL	DELAY_100mS
0256 0256 s 
0256 0256 d 217c02
0256 0256 u 03 01
0256 0256 s 		LD	HL,LED_SPLASH_TBL
0259 0259 d 3a80ff
0259 0259 u 03 01
0259 0259 s 		LD	A,(RC_TYPE)
025c 025c d 07
025c 025c u 01 01
025c 025c s 		RLCA
025d 025d d 07
025d 025d u 01 01
025d 025d s 		RLCA
025e 025e d 07
025e 025e u 01 01
025e 025e s 		RLCA
025f 025f d cd450e
025f 025f u 03 01
025f 025f s 		CALL	ADD_HL_A
0262 0262 d cd781c
0262 0262 u 03 01
0262 0262 s 		CALL	LED_PRINT
0265 0265 s 
0265 0265 d 3a80ff
0265 0265 u 03 01
0265 0265 s 		LD	A,(RC_TYPE)
0268 0268 d b7
0268 0268 u 01 01
0268 0268 s 		OR	A
0269 0269 d 280d
0269 0269 u 02 01
0269 0269 s 		JR  Z,	LSPLASH_CNT
026b 026b d 2180ff
026b 026b u 03 01
026b 026b s 		LD	HL, RC_TYPE	;Print count of reset type
026e 026e d cd450e
026e 026e u 03 01
026e 026e s 		CALL	ADD_HL_A
0271 0271 d 7e
0271 0271 u 01 01
0271 0271 s 		LD	A,(HL)
0272 0272 d 21e5ff
0272 0272 u 03 01
0272 0272 s 		LD	HL,LED_DISPLAY+5
0275 0275 d cd4a1c
0275 0275 u 03 01
0275 0275 s 		CALL	LED_PUT_BYTE_HL
0278 0278 d 3680
0278 0278 u 02 01
0278 0278 s LSPLASH_CNT	LD	(HL),0x80	;Annunciator LED's OFF
027a 027a s 
027a 027a d 1840
027a 027a u 02 01
027a 027a s 		JR	SKIP_TABLE1
027c 027c s 
027c 027c d 2d44454c41592d00
027c 027c u 08 02
027c 027c s LED_SPLASH_TBL	DB	"-DELAY-",EOS
0284 0284 d 536f667420202000
0284 0284 u 08 02
0284 0284 s 		DB	"Soft   ",EOS
028c 028c d 5374457020202000
028c 028c u 08 02
028c 028c s 		DB	"StEp   ",EOS
0294 0294 d 5e43202020202000
0294 0294 u 08 02
0294 0294 s 		DB	"^C     ",EOS
029c 029c d 48414c7420202000
029c 029c u 08 02
029c 029c s 		DB	"HALt   ",EOS
02a4 02a4 d 462d302020202000
02a4 02a4 u 08 02
02a4 02a4 s 		DB	"F-0    ",EOS
02ac 02ac d 5273743020202000
02ac 02ac u 08 02
02ac 02ac s 		DB	"Rst0   ",EOS
02b4 02b4 d 4841524420202000
02b4 02b4 u 08 02
02b4 02b4 s 		DB	"HARD   ",EOS
02bc 02bc s 
02bc 02bc s SKIP_TABLE1	
02bc 02bc s 		
02bc 02bc d cd7108
02bc 02bc u 03 01
02bc 02bc s 		CALL	SET_BANK	;Bank 0
02bf 02bf s 		
02bf 02bf d cd2128
02bf 02bf u 03 01
02bf 02bf s 		CALL	LOAD_HIGH_RAM	;Copy subroutines to HIGH RAM
02c2 02c2 s 
02c2 02c2 d cdf614
02c2 02c2 u 03 01
02c2 02c2 s 		CALL	ACE_SET_BAUD	;Set Baud & Word to saved setting (might have been changed from 9600)
02c5 02c5 s 
02c5 02c5 d fb
02c5 02c5 u 01 01
02c5 02c5 s 		EI			;************** Interrupts ON!!!!
02c6 02c6 s 
02c6 02c6 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
02c6 02c6 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
02c6 02c6 s ;	Chapter_3	Main Loop, RS-232 MONITOR, MENU selection
02c6 02c6 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
02c6 02c6 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
02c6 02c6 s 
02c6 02c6 d 3e80
02c6 02c6 u 02 01
02c6 02c6 s 		LD	A,0x80		;
02c8 02c8 d 32f5ff
02c8 02c8 u 03 01
02c8 02c8 s 		LD	(SCAN_LED),A
02cb 02cb d d340
02cb 02cb u 02 01
02cb 02cb s 		OUT	(Port40),A	;Reset Timer interrupt
02cd 02cd s 
02cd 02cd d 3a80ff
02cd 02cd u 03 01
02cd 02cd s 		LD	A,(RC_TYPE)
02d0 02d0 s 		;CALL	PRINTI
02d0 02d0 s 		;DB	CR,LF,"RT_TYPE=",EOS		
02d0 02d0 s 		;CALL	PUT_BYTE
02d0 02d0 d b7
02d0 02d0 u 01 01
02d0 02d0 s 		OR	A
02d1 02d1 d 201e
02d1 02d1 u 02 01
02d1 02d1 s 		JR NZ,	NOT_COLD
02d3 02d3 s 
02d3 02d3 d 0e14
02d3 02d3 u 02 01
02d3 02d3 s 		LD	C,20		;2 Seconds
02d5 02d5 d cd2c0e
02d5 02d5 u 03 01
02d5 02d5 s 		CALL	DELAY_C		;Delay in 100mSEC
02d8 02d8 s 
02d8 02d8 d cd8a1c
02d8 02d8 u 03 01
02d8 02d8 s 		CALL	LED_HOME_PRINTI
02db 02db d 434f4c4420303000
02db 02db u 08 02
02db 02db s 		DB	"COLD 00",EOS
02e3 02e3 s 		
02e3 02e3 d 2178ff
02e3 02e3 u 03 01
02e3 02e3 s 		LD	HL,RAMSIGNATURE
02e6 02e6 d 3ef0
02e6 02e6 u 02 01
02e6 02e6 s 		LD	A,0xF0		;First signature byte expected
02e8 02e8 d 0608
02e8 02e8 u 02 01
02e8 02e8 s 		LD	B,8		;#bytes in signature (loop)
02ea 02ea d 77
02ea 02ea u 01 01
02ea 02ea s RAMSIGN_LP	LD	(HL),A		;Save Signature
02eb 02eb d 2c
02eb 02eb u 01 01
02eb 02eb s 		INC	L
02ec 02ec d d60f
02ec 02ec u 02 01
02ec 02ec s 		SUB	0xF
02ee 02ee d 10fa
02ee 02ee u 02 01
02ee 02ee s 		DJNZ	RAMSIGN_LP
02f0 02f0 d af
02f0 02f0 u 01 01
02f0 02f0 s 		XOR	A
02f1 02f1 s 		
02f1 02f1 d 07
02f1 02f1 u 01 01
02f1 02f1 s NOT_COLD	RLCA
02f2 02f2 d 211603
02f2 02f2 u 03 01
02f2 02f2 s 		LD	HL,RS232_SPLASH
02f5 02f5 d cd450e
02f5 02f5 u 03 01
02f5 02f5 s 		CALL	ADD_HL_A
02f8 02f8 d cd4a0e
02f8 02f8 u 03 01
02f8 02f8 s 		CALL	LD_HL_HL
02fb 02fb d cd1f0e
02fb 02fb u 03 01
02fb 02fb s 		CALL	PUT_NEW_LINE		
02fe 02fe d cdbd0d
02fe 02fe u 03 01
02fe 02fe s 		CALL	PRINT
0301 0301 d 3a80ff
0301 0301 u 03 01
0301 0301 s 		LD	A,(RC_TYPE)
0304 0304 d b7
0304 0304 u 01 01
0304 0304 s 		OR	A
0305 0305 d 286d
0305 0305 u 02 01
0305 0305 s 		JR   Z,	SPLASH_VERSION
0307 0307 d 2180ff
0307 0307 u 03 01
0307 0307 s 		LD	HL, RC_TYPE	;Print count of reset type
030a 030a d cd450e
030a 030a u 03 01
030a 030a s 		CALL	ADD_HL_A
030d 030d d 7e
030d 030d u 01 01
030d 030d s 		LD	A,(HL)
030e 030e d cdf30d
030e 030e u 03 01
030e 030e s 		CALL	SPACE_PUT_BYTE
0311 0311 d cd1f09
0311 0311 u 03 01
0311 0311 s 		CALL	REG_DISP_ALL
0314 0314 d 1861
0314 0314 u 02 01
0314 0314 s 		JR	SKIP_TABLE2
0316 0316 s 
0316 0316 d 2603
0316 0316 u 02 02
0316 0316 s RS232_SPLASH	DW	R_COLD
0318 0318 d 3303
0318 0318 u 02 02
0318 0318 s 		DW	R_SOFT
031a 031a d 4003
031a 031a u 02 02
031a 031a s 		DW	R_STEP
031c 031c d 4503
031c 031c u 02 02
031c 031c s 		DW	R_CC
031e 031e d 4e03
031e 031e u 02 02
031e 031e s 		DW	R_HALT
0320 0320 d 5703
0320 0320 u 02 02
0320 0320 s 		DW	R_F0
0322 0322 d 6103
0322 0322 u 02 02
0322 0322 s 		DW	R_RST0
0324 0324 d 6903
0324 0324 u 02 02
0324 0324 s 		DW	R_HARD
0326 0326 s 
0326 0326 d 436f6c642053746172740d0a00
0326 0326 u 0d 02
0326 0326 s R_COLD		DB	"Cold Start",CR,LF,EOS
0333 0333 d 536f6674205265737461727400
0333 0333 u 0d 02
0333 0333 s R_SOFT		DB	"Soft Restart",EOS
0340 0340 d 5374657000
0340 0340 u 05 02
0340 0340 s R_STEP		DB	"Step",EOS
0345 0345 d 3c4374726c3e2d4300
0345 0345 u 09 02
0345 0345 s R_CC		DB	"<Ctrl>-C",EOS
034e 034e d 4350552048414c5400
034e 034e u 09 02
034e 034e s R_HALT		DB	"CPU HALT",EOS
0357 0357 d 462d3020526573657400
0357 0357 u 0a 02
0357 0357 s R_F0		DB	"F-0 Reset",EOS
0361 0361 d 3c427265616b3e00
0361 0361 u 08 02
0361 0361 s R_RST0		DB	"<Break>",EOS
0369 0369 d 4861726420526573657400
0369 0369 u 0b 02
0369 0369 s R_HARD		DB	"Hard Reset",EOS
0374 0374 s 
0374 0374 d cd9b08
0374 0374 u 03 01
0374 0374 s SPLASH_VERSION	CALL 	PUT_VERSION
0377 0377 s 
0377 0377 d 3a80ff
0377 0377 u 03 01
0377 0377 s SKIP_TABLE2	LD	A,(RC_TYPE)
037a 037a d fe02
037a 037a u 02 01
037a 037a s 		CP	2		;If returning from Single Step, restore Monitor Display
037c 037c d 2009
037c 037c u 02 01
037c 037c s 		JR NZ,	WB_NOT_STEP
037e 037e d 2ad4ff
037e 037e u 03 01
037e 037e s 		LD	HL,(SDISPMODE)
0381 0381 d 22baff
0381 0381 u 03 01
0381 0381 s 		LD	(LDISPMODE),HL
0384 0384 d 22bcff
0384 0384 u 03 01
0384 0384 s 		LD	(DISPMODE),HL
0387 0387 s WB_NOT_STEP	
0387 0387 s 
0387 0387 s 
0387 0387 s ;                 ******       *****      *****    *********
0387 0387 s ;                 *******     *******    *******   *********
0387 0387 s ;                 **    **   ***   ***  ***   ***     ***
0387 0387 s ;                 **    **   **     **  **     **     ***
0387 0387 s ;                 *******    **     **  **     **     ***
0387 0387 s ;                 *******    **     **  **     **     ***
0387 0387 s ;                 **    **   **     **  **     **     ***
0387 0387 s ;                 **    **   ***   ***  ***   ***     ***
0387 0387 s ;                 *******     *******    *******      ***
0387 0387 s ;                 ******       *****      *****       ***
0387 0387 s 
0387 0387 s 
0387 0387 s 
0387 0387 s 
0387 0387 d 3a80ff
0387 0387 u 03 01
0387 0387 s 		LD	A,(RC_TYPE)	;Auto boot option for cold start or RESET only
038a 038a d b7
038a 038a u 01 01
038a 038a s 		OR	A
038b 038b d 2804
038b 038b u 02 01
038b 038b s 		JR Z,	AUTO_BOOT_MENU
038d 038d d fe07
038d 038d u 02 01
038d 038d s 		CP	7
038f 038f d 2051
038f 038f u 02 01
038f 038f s 		JR NZ,	MAIN_MENU
0391 0391 s 
0391 0391 s 	;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
0391 0391 s 
0391 0391 d 3a95ff
0391 0391 u 03 01
0391 0391 s AUTO_BOOT_MENU	LD	A,(HW_LIST)	;Auto boot if no card or SD card
0394 0394 d b7
0394 0394 u 01 01
0394 0394 s 		OR	A
0395 0395 d 2804
0395 0395 u 02 01
0395 0395 s 		JR   Z,	AUTO_BOOT_DO
0397 0397 d e602
0397 0397 u 02 01
0397 0397 s 		AND	2
0399 0399 d 2847
0399 0399 u 02 01
0399 0399 s 		JR   Z,	MAIN_MENU	;No Option to boot from SD Card
039b 039b s 		
039b 039b d cdca0d
039b 039b u 03 01
039b 039b s AUTO_BOOT_DO	CALL	PRINTI		;Monitor Start, Display Welcome Message
039e 039e d 0d0a5072657373204d20666f72204d6f6e69746f7200
039e 039e u 16 02
039e 039e s 		DB	CR,LF,"Press M for Monitor",EOS
03b4 03b4 s 		
03b4 03b4 d 061e
03b4 03b4 u 02 01
03b4 03b4 s 		LD	B,30
03b6 03b6 d cd3214
03b6 03b6 u 03 01
03b6 03b6 s AUTO_BOOT_LP	CALL	DOT_GETCHAR	;C=1 if dots timed out or <TAB>, or C=0 and A=char
03b9 03b9 d 3806
03b9 03b9 u 02 01
03b9 03b9 s 		JR  C,	AUTO_BOOT_GO
03bb 03bb d fe4d
03bb 03bb u 02 01
03bb 03bb s 		CP	'M'
03bd 03bd d 2823
03bd 03bd u 02 01
03bd 03bd s 		JR  Z,	MAIN_MENU	;M? Go Monitor
03bf 03bf d 18f5
03bf 03bf u 02 01
03bf 03bf s 		JR	AUTO_BOOT_LP
03c1 03c1 s 		
03c1 03c1 d 2180ff
03c1 03c1 u 03 01
03c1 03c1 s AUTO_BOOT_GO	LD	HL,RC_TYPE	;Flag auto boot
03c4 03c4 d cbfe
03c4 03c4 u 02 01
03c4 03c4 s 		SET	7,(HL)		
03c6 03c6 d 3a95ff
03c6 03c6 u 03 01
03c6 03c6 s 		LD	A,(HW_LIST)	;Auto boot to BASIC if no board
03c9 03c9 d b7
03c9 03c9 u 01 01
03c9 03c9 s 		OR	A
03ca 03ca d ca002a
03ca 03ca u 03 01
03ca 03ca s 		JP   Z,	GO_BASIC
03cd 03cd d cd1d0c
03cd 03cd u 03 01
03cd 03cd s 		CALL	WRITE_BLOCK
03d0 03d0 d 43ff
03d0 03d0 u 02 02
03d0 03d0 s 		DW	FILENAME	;Where to write
03d2 03d2 d 0b00
03d2 03d2 u 02 02
03d2 03d2 s 		DW	11		;Bytes to write
03d4 03d4 d 5a38304d435f474f484558
03d4 03d4 u 0b 02
03d4 03d4 s 		DB	'Z80MC_GOHEX'
03df 03df d cd931c
03df 03df u 03 01
03df 03df s 		CALL	GO_SD_CARD	;Do a CALL, let any returns go to Monitor
03e2 03e2 s 		
03e2 03e2 s 		
03e2 03e2 s 		
03e2 03e2 s 
03e2 03e2 s ;************************************************************************************
03e2 03e2 s ;************************************************************************************
03e2 03e2 s ;************************************************************************************
03e2 03e2 s ;************************************************************************************
03e2 03e2 s ;
03e2 03e2 s ;
03e2 03e2 s ;                 ***        ***    *********    **       **     **       **
03e2 03e2 s ;                 ****      ****    *********    ***      **     **       **
03e2 03e2 s ;                 ** **    ** **    **           ****     **     **       **
03e2 03e2 s ;                 **  **  **  **    **           ** **    **     **       **
03e2 03e2 s ;                 **   ****   **    *******      **  **   **     **       **
03e2 03e2 s ;                 **    **    **    *******      **   **  **     **       **
03e2 03e2 s ;                 **          **    **           **    ** **     **       **
03e2 03e2 s ;                 **          **    **           **     ****     ***     ***
03e2 03e2 s ;                 **          **    *********    **      ***      ********* 
03e2 03e2 s ;                 **          **    *********    **       **        *****  
03e2 03e2 s 
03e2 03e2 s 
03e2 03e2 s ;Monitor
03e2 03e2 s ;Functions:
03e2 03e2 s ; -Dump, Edit & Execute Memory.
03e2 03e2 s ; -Input Port and Output Port.
03e2 03e2 s ; -RAM Test
03e2 03e2 s ; -ASCII Upload intel HEX file
03e2 03e2 s ; -XMODEM up/down load to Memory
03e2 03e2 s ;
03e2 03e2 s ; D XXXX YYYY	Dump memory from XXXX to YYYY
03e2 03e2 s ; E XXXX	Edit memory starting at XXXX (type an X and press enter to exit entry)
03e2 03e2 s ; G XXXX	GO starting at address XXXX (Monitor program address left on stack)
03e2 03e2 s ; I XX		Input from I/O port XX and display as hex
03e2 03e2 s ; O XX YY	Output to I/O port XX byte YY
03e2 03e2 s ; L		Loop back test
03e2 03e2 s ; X U XXXX	XMODEM Upload to memory at XXXX (CRC or CHECKSUM)
03e2 03e2 s ; X D XXXX CCCC	XMODEM Download from memory at XXXX for CCCC number of 128 byte blocks
03e2 03e2 s ; :ssHHLLttDDDDDD...CS   -ASCII UPLOAD Intel HEX file to Memory.  Monitor auto downloads with the reception of a colon.
03e2 03e2 s ; R XX YY	RAM TEST from pages XX to YY
03e2 03e2 s ; V		Report Version
03e2 03e2 s 
03e2 03e2 s 
03e2 03e2 s ;----------------------------------------------------------------------------------------------------; MAIN MENU
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
03e2 03e2 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
03e2 03e2 s ;----------------------------------------------------------------------------------------------------; MAIN MENU
03e2 03e2 s 
03e2 03e2 d 31fefa
03e2 03e2 u 03 01
03e2 03e2 s MAIN_MENU:	LD	SP, StackTop	; Reset Stack = 0xFF80
03e5 03e5 d af
03e5 03e5 u 01 01
03e5 03e5 s 		XOR	A
03e6 03e6 s 			
03e6 03e6 d 3243ff
03e6 03e6 u 03 01
03e6 03e6 s 		LD	(FILENAME),A	;Nuke any Auto Run
03e9 03e9 d 21e203
03e9 03e9 u 03 01
03e9 03e9 s 		LD	HL, MAIN_MENU	;Push Mainmenu onto stack as default return address
03ec 03ec d e5
03ec 03ec u 01 01
03ec 03ec s 		PUSH	HL
03ed 03ed s 		
03ed 03ed d cd2a14
03ed 03ed u 03 01
03ed 03ed s 		CALL	PURGE
03f0 03f0 s 		
03f0 03f0 d cdca0d
03f0 03f0 u 03 01
03f0 03f0 s 		CALL	PRINTI		;Monitor Start, Display Welcome Message
03f3 03f3 d 0d0a4d61696e204d656e75203e00
03f3 03f3 u 0e 02
03f3 03f3 s 		DB	CR,LF,"Main Menu >",EOS
0401 0401 s 		
0401 0401 d 3eff
0401 0401 u 02 01
0401 0401 s 		LD	A,0xFF
0403 0403 d cdd527
0403 0403 u 03 01
0403 0403 s 		CALL	SET_ECHO	;Echo on
0406 0406 s 
0406 0406 d cde013
0406 0406 u 03 01
0406 0406 s 		CALL 	GET_CHAR	;get char
0409 0409 s 
0409 0409 d fe31
0409 0409 u 02 01
0409 0409 s 		CP 	'1'
040b 040b d caa407
040b 040b u 03 01
040b 040b s 		JP Z,	SW2_BIT
040e 040e d fe32
040e 040e u 02 01
040e 040e s 		CP 	'2'
0410 0410 d caac07
0410 0410 u 03 01
0410 0410 s 		JP Z,	SW2_ACE
0413 0413 d fe33
0413 0413 u 02 01
0413 0413 s 		CP 	'3'
0415 0415 d cab407
0415 0415 u 03 01
0415 0415 s 		JP Z,	SW2_BOTH		
0418 0418 s 
0418 0418 d e65f
0418 0418 u 02 01
0418 0418 s 		AND 	0x5F		;to upper case
041a 041a d fe42
041a 041a u 02 01
041a 041a s 		CP 	'B'		;
041c 041c d ca002a
041c 041c u 03 01
041c 041c s 		JP Z, 	GO_BASIC	; B = GO BASIC
041f 041f d fe43
041f 041f u 02 01
041f 041f s 		CP 	'C'		;
0421 0421 d ca5f0a
0421 0421 u 03 01
0421 0421 s 		JP Z, 	MEM_DUMP	; C = Memory Dump (Continuous)
0424 0424 d fe44
0424 0424 u 02 01
0424 0424 s 		CP 	'D'		;
0426 0426 d ca7e0a
0426 0426 u 03 01
0426 0426 s 		JP Z, 	MEM_DUMP_PAGED	; D = Memory Dump
0429 0429 d fe45
0429 0429 u 02 01
0429 0429 s 		CP 	'E'
042b 042b d ca1d0b
042b 042b u 03 01
042b 042b s 		JP Z, 	MEM_EDIT	; E = Edit Memory
042e 042e d fe47
042e 042e u 02 01
042e 042e s 		CP 	'G'
0430 0430 d ca430b
0430 0430 u 03 01
0430 0430 s 		JP Z, 	MEM_EXEC	; G = Go (Execute at)
0433 0433 d fe48
0433 0433 u 02 01
0433 0433 s 		CP	'H'
0435 0435 d ca4f0e
0435 0435 u 03 01
0435 0435 s 		JP Z,	GETHEXFILE	; H = START HEX FILE LOAD
0438 0438 d fe49
0438 0438 u 02 01
0438 0438 s 		CP 	'I'
043a 043a d cafc0b
043a 043a u 03 01
043a 043a s 		JP Z, 	PORT_INP	; I = Input from Port
043d 043d d fe4c
043d 043d u 02 01
043d 043d s 		CP 	'L'
043f 043f d cab709
043f 043f u 03 01
043f 043f s 		JP Z,	LOOP_BACK_TEST	; L = Loop Back Test
0442 0442 d fe4d
0442 0442 u 02 01
0442 0442 s 		CP 	'M'
0444 0444 d ca150a
0444 0444 u 03 01
0444 0444 s 		JP Z,	MEM_ENTER	; M = ENTER INTO MEMORY
0447 0447 d fe4f
0447 0447 u 02 01
0447 0447 s 		CP 	'O'
0449 0449 d ca060c
0449 0449 u 03 01
0449 0449 s 		JP Z, 	PORT_OUT	; O = Output to port
044c 044c d fe50
044c 044c u 02 01
044c 044c s 		CP 	'P'
044e 044e d ca0b08
044e 044e u 03 01
044e 044e s 		JP Z,	PORT_SPEED	; P = Port Speed for ACE
0451 0451 d fe52
0451 0451 u 02 01
0451 0451 s 		CP 	'R'
0453 0453 d ca1509
0453 0453 u 03 01
0453 0453 s 		JP Z,	REG_MENU	; R = REGISTER OPERATIONS
0456 0456 d fe53
0456 0456 u 02 01
0456 0456 s 		CP 	'S'		;
0458 0458 d ca931c
0458 0458 u 03 01
0458 0458 s 		JP Z, 	GO_SD_CARD	; S = BOOT SD CARD
045b 045b d fe54
045b 045b u 02 01
045b 045b s 		CP 	'T'
045d 045d d ca0411
045d 045d u 03 01
045d 045d s 		JP Z,	RAM_TEST	; T = RAM TEST
0460 0460 d fe55
0460 0460 u 02 01
0460 0460 s 		CP 	'U'
0462 0462 d ca3108
0462 0462 u 03 01
0462 0462 s 		JP Z,	USE_RAM		; U = USE RAM/ROM
0465 0465 d fe56
0465 0465 u 02 01
0465 0465 s 		CP 	'V'
0467 0467 d ca9b08
0467 0467 u 03 01
0467 0467 s 		JP Z,	PUT_VERSION	; V = Version
046a 046a d fe57
046a 046a u 02 01
046a 046a s 		CP 	'W'
046c 046c d ca401a
046c 046c u 03 01
046c 046c s 		JP Z, 	GO_SINGLE	; W = Single Step
046f 046f d fe58
046f 046f u 02 01
046f 046f s 		CP 	'X'
0471 0471 d caee0e
0471 0471 u 03 01
0471 0471 s 		JP Z, 	XMODEM		; X = XMODEM
0474 0474 d fe59
0474 0474 u 02 01
0474 0474 s 		CP 	'Y'
0476 0476 d cada07
0476 0476 u 03 01
0476 0476 s 		JP Z,	WHICH_PORT	; Y = Display Which port
0479 0479 s 
0479 0479 d cdca0d
0479 0479 u 03 01
0479 0479 s PRINT_MENU	CALL 	PRINTI		;Display Help when input is invalid
047c 047c d 0d0a48454c50
047c 047c u 06 02
047c 047c s 		DB	CR,LF,"HELP"		
0482 0482 d 0d0a44205858585820595959592020202044756d70206d656d6f72792066726f6d205858585820746f2059595959
0482 0482 u 2e 02
0482 0482 s 		DB	CR,LF,"D XXXX YYYY    Dump memory from XXXX to YYYY"
04b0 04b0 d 0d0a432058585858205959595920202020436f6e74696e6f75732044756d7020286e6f20706175736529
04b0 04b0 u 2a 02
04b0 04b0 s 		DB	CR,LF,"C XXXX YYYY    Continous Dump (no pause)"
04da 04da d 0d0a45205858585820202020202020202045646974206d656d6f7279207374617274696e672061742058585858
04da 04da u 2d 02
04da 04da s 		DB	CR,LF,"E XXXX         Edit memory starting at XXXX"
0507 0507 d 0d0a4d20585858582059592e2e59592020456e746572206d616e7920627974657320696e746f206d656d6f72792061742058585858
0507 0507 u 35 02
0507 0507 s 		DB	CR,LF,"M XXXX YY..YY  Enter many bytes into memory at XXXX"
053c 053c d 0d0a47205b585858585d20202020202020474f20285043204f7074696f6e616c29
053c 053c u 21 02
053c 053c s 		DB	CR,LF,"G [XXXX]       GO (PC Optional)"
055d 055d d 0d0a57202020202020202020202020202053696e676c652053746570
055d 055d u 1c 02
055d 055d s 		DB	CR,LF,"W              Single Step"
0579 0579 d 0d0a492058582020202020202020202020496e7075742066726f6d20492f4f
0579 0579 u 1f 02
0579 0579 s 		DB	CR,LF,"I XX           Input from I/O"
0598 0598 d 0d0a4f20585820595920202020202020204f757470757420746f20492f4f
0598 0598 u 1e 02
0598 0598 s 		DB	CR,LF,"O XX YY        Output to I/O"
05b6 05b6 d 0d0a52207272205b3d78785d20202020205265676973746572
05b6 05b6 u 19 02
05b6 05b6 s 		DB	CR,LF,"R rr [=xx]     Register"
05cf 05cf d 0d0a4c20202020202020202020202020204c6f6f70206261636b2074657374
05cf 05cf u 1f 02
05cf 05cf s 		DB	CR,LF,"L              Loop back test"
05ee 05ee d 0d0a54205858205959202020202020202052414d20544553542066726f6d20706167657320585820746f205959
05ee 05ee u 2d 02
05ee 05ee s 		DB	CR,LF,"T XX YY        RAM TEST from pages XX to YY"
061b 061b d 0d0a56202020202020202020202020202056657273696f6e
061b 061b u 18 02
061b 061b s 		DB	CR,LF,"V              Version"
0633 0633 d 0d0a48202020202020202020202020202055504c4f414420496e74656c204845582066696c65
0633 0633 u 26 02
0633 0633 s 		DB	CR,LF,"H              UPLOAD Intel HEX file"
0659 0659 d 0d0a582055205858585820202020202020584d4f44454d2055706c6f616420746f206d656d6f72792061742058585858
0659 0659 u 30 02
0659 0659 s 		DB	CR,LF,"X U XXXX       XMODEM Upload to memory at XXXX"
0689 0689 d 0d0a582044205858585820434343432020584d4f44454d20446f776e6c6f61642066726f6d205858585820666f72204343434320236f6620313238206279746520626c6f636b73
0689 0689 u 47 02
0689 0689 s 		DB	CR,LF,"X D XXXX CCCC  XMODEM Download from XXXX for CCCC #of 128 byte blocks"
06d0 06d0 d 0d0a502020202020202020202020202020506f72742053706565642028414345204f6e6c7929
06d0 06d0 u 26 02
06d0 06d0 s 		DB	CR,LF,"P              Port Speed (ACE Only)"
06f6 06f6 d 0d0a312c322c332020202020202020202053776974636820436f6e736f6c6520496e707574
06f6 06f6 u 25 02
06f6 06f6 s 		DB	CR,LF,"1,2,3          Switch Console Input"
071b 071b d 0d0a5920202020202020202020202020204964656e7469667920506f7274
071b 071b u 1e 02
071b 071b s 		DB	CR,LF,"Y              Identify Port"
0739 0739 d 0d0a55202020202020202020202020202055736520524f4d206f722052414d2042414e4b
0739 0739 u 24 02
0739 0739 s 		DB	CR,LF,"U              Use ROM or RAM BANK"
075d 075d d 0d0a5320202020202020202020202020205344204341524420424f4f54
075d 075d u 1d 02
075d 075d s 		DB	CR,LF,"S              SD CARD BOOT"
077a 077a d 0d0a4220202020202020202020202020204241534943202d20444156452044554e4649454c44
077a 077a u 26 02
077a 077a s 		DB	CR,LF,"B              BASIC - DAVE DUNFIELD"
07a0 07a0 d 0d0a00
07a0 07a0 u 03 02
07a0 07a0 s 		DB	CR,LF,EOS
07a3 07a3 d c9
07a3 07a3 u 01 01
07a3 07a3 s 		RET
07a4 07a4 s 
07a4 07a4 s 
07a4 07a4 s ;1,2,3          Switch Console Input"
07a4 07a4 s 
07a4 07a4 s ;A
07a4 07a4 s ;B BASIC
07a4 07a4 s ;C Continous Dump (no pause)
07a4 07a4 s ;D Dump memory
07a4 07a4 s ;E Edit memory
07a4 07a4 s ;F
07a4 07a4 s ;G GO (PC Optional)
07a4 07a4 s ;H UPLOAD Intel HEX file
07a4 07a4 s ;I Input from I/O
07a4 07a4 s ;J
07a4 07a4 s ;K
07a4 07a4 s ;L Loop back test
07a4 07a4 s ;M Enter many bytes
07a4 07a4 s ;N
07a4 07a4 s ;O Output to I/O
07a4 07a4 s ;P Port Speed
07a4 07a4 s ;Q
07a4 07a4 s ;R Register
07a4 07a4 s ;S SD CARD BOOT
07a4 07a4 s ;T RAM TEST
07a4 07a4 s ;U Use ROM or RAM BANK
07a4 07a4 s ;V Version
07a4 07a4 s ;W Single Step
07a4 07a4 s ;X XMODEM
07a4 07a4 s ;Y Identify Port
07a4 07a4 s ;Z
07a4 07a4 s 
07a4 07a4 s 
07a4 07a4 s 
07a4 07a4 d 0e01
07a4 07a4 u 02 01
07a4 07a4 s SW2_BIT		LD	C,1
07a6 07a6 d cd8613
07a6 07a6 u 03 01
07a6 07a6 s 		CALL	SET_IO
07a9 07a9 d d8
07a9 07a9 u 01 01
07a9 07a9 s 		RET  C
07aa 07aa d 180e
07aa 07aa u 02 01
07aa 07aa s 		JR	PUT_IOMSG
07ac 07ac s 
07ac 07ac d 0e02
07ac 07ac u 02 01
07ac 07ac s SW2_ACE		LD	C,2
07ae 07ae d cd8613
07ae 07ae u 03 01
07ae 07ae s 		CALL	SET_IO
07b1 07b1 d d8
07b1 07b1 u 01 01
07b1 07b1 s 		RET  C
07b2 07b2 d 1806
07b2 07b2 u 02 01
07b2 07b2 s 		JR	PUT_IOMSG
07b4 07b4 s 
07b4 07b4 d 0e03
07b4 07b4 u 02 01
07b4 07b4 s SW2_BOTH	LD	C,3
07b6 07b6 d cd8613
07b6 07b6 u 03 01
07b6 07b6 s 		CALL	SET_IO
07b9 07b9 d d8
07b9 07b9 u 01 01
07b9 07b9 s 		RET  C
07ba 07ba s 
07ba 07ba d cd1f0e
07ba 07ba u 03 01
07ba 07ba s PUT_IOMSG	CALL	PUT_NEW_LINE
07bd 07bd d 3a94ff
07bd 07bd u 03 01
07bd 07bd s 		LD	A,(HW_SETIO)
07c0 07c0 d 3d
07c0 07c0 u 01 01
07c0 07c0 s 		DEC	A
07c1 07c1 d 07
07c1 07c1 u 01 01
07c1 07c1 s 		RLCA
07c2 07c2 d 07
07c2 07c2 u 01 01
07c2 07c2 s 		RLCA
07c3 07c3 d 21cd07
07c3 07c3 u 03 01
07c3 07c3 s 		LD	HL,IO_MSG
07c6 07c6 d cd450e
07c6 07c6 u 03 01
07c6 07c6 s 		CALL	ADD_HL_A
07c9 07c9 d cdbd0d
07c9 07c9 u 03 01
07c9 07c9 s 		CALL	PRINT
07cc 07cc d c9
07cc 07cc u 01 01
07cc 07cc s 		RET
07cd 07cd s 
07cd 07cd d 42495400
07cd 07cd u 04 02
07cd 07cd s IO_MSG		DB	"BIT",EOS
07d1 07d1 d 41434500
07d1 07d1 u 04 02
07d1 07d1 s 		DB	"ACE",EOS
07d5 07d5 d 424f544800
07d5 07d5 u 05 02
07d5 07d5 s 		DB	"BOTH",EOS
07da 07da s 
07da 07da s 
07da 07da d cd8a1c
07da 07da u 03 01
07da 07da s WHICH_PORT	CALL	LED_HOME_PRINTI		
07dd 07dd d 4c45442000
07dd 07dd u 05 02
07dd 07dd s 		DB	"LED ",EOS
07e2 07e2 d 3a94ff
07e2 07e2 u 03 01
07e2 07e2 s 		LD	A,(HW_SETIO)
07e5 07e5 d 47
07e5 07e5 u 01 01
07e5 07e5 s 		LD	B,A
07e6 07e6 d 0e01
07e6 07e6 u 02 01
07e6 07e6 s 		LD	C,1
07e8 07e8 d cd8613
07e8 07e8 u 03 01
07e8 07e8 s 		CALL	SET_IO
07eb 07eb d 3809
07eb 07eb u 02 01
07eb 07eb s 		JR C,	WP_NOBIT
07ed 07ed d cdca0d
07ed 07ed u 03 01
07ed 07ed s 		CALL	PRINTI		
07f0 07f0 d 0d0a42495400
07f0 07f0 u 06 02
07f0 07f0 s 		DB	CR,LF,"BIT",EOS
07f6 07f6 d 0e02
07f6 07f6 u 02 01
07f6 07f6 s WP_NOBIT	LD	C,2
07f8 07f8 d cd8613
07f8 07f8 u 03 01
07f8 07f8 s 		CALL	SET_IO
07fb 07fb d 3809
07fb 07fb u 02 01
07fb 07fb s 		JR C,	WP_NOACE
07fd 07fd d cdca0d
07fd 07fd u 03 01
07fd 07fd s 		CALL	PRINTI		
0800 0800 d 0d0a41434500
0800 0800 u 06 02
0800 0800 s 		DB	CR,LF,"ACE",EOS		
0806 0806 d 48
0806 0806 u 01 01
0806 0806 s WP_NOACE	LD	C,B
0807 0807 d cd8613
0807 0807 u 03 01
0807 0807 s 		CALL	SET_IO
080a 080a d c9
080a 080a u 01 01
080a 080a s 		RET
080b 080b s 
080b 080b d cdca0d
080b 080b u 03 01
080b 080b s PORT_SPEED	CALL	PRINTI		
080e 080e d 0d0a2830433d393630302920424155443a00
080e 080e u 12 02
080e 080e s 		DB	CR,LF,"(0C=9600) BAUD:",EOS
0820 0820 d 3a8fff
0820 0820 u 03 01
0820 0820 s 		LD	A,(ACE_BAUD)
0823 0823 d cdf60d
0823 0823 u 03 01
0823 0823 s 		CALL	PUT_BYTE
0826 0826 d cd490d
0826 0826 u 03 01
0826 0826 s 		CALL	SPACE_GET_BYTE
0829 0829 d d8
0829 0829 u 01 01
0829 0829 s 		RET  C
082a 082a d 328fff
082a 082a u 03 01
082a 082a s 		LD	(ACE_BAUD),A
082d 082d d cdf614
082d 082d u 03 01
082d 082d s 		CALL	ACE_SET_BAUD
0830 0830 d c9
0830 0830 u 01 01
0830 0830 s 		RET
0831 0831 s 
0831 0831 d cdca0d
0831 0831 u 03 01
0831 0831 s USE_RAM		CALL	PRINTI		
0834 0834 d 0d0a43757272656e746c79207573696e673a00
0834 0834 u 13 02
0834 0834 s 		DB	CR,LF,"Currently using:",EOS
0847 0847 d cd7a08
0847 0847 u 03 01
0847 0847 s 		CALL	DISP_RRBANK
084a 084a d cdca0d
084a 084a u 03 01
084a 084a s 		CALL	PRINTI		
084d 084d d 0d0a456e74657220302d462c522000
084d 084d u 0f 02
084d 084d s 		DB	CR,LF,"Enter 0-F,R ",EOS
085c 085c d cd950d
085c 085c u 03 01
085c 085c s 		CALL	GET_HEX
085f 085f d 3804
085f 085f u 02 01
085f 085f s 		JR   C,	UR_NOTRAM
0861 0861 d 07
0861 0861 u 01 01
0861 0861 s 		RLCA
0862 0862 d 3c
0862 0862 u 01 01
0862 0862 s 		INC	A
0863 0863 d 1806
0863 0863 u 02 01
0863 0863 s 		JR	UR_RET
0865 0865 d e65f
0865 0865 u 02 01
0865 0865 s UR_NOTRAM	AND	0x5F		;To upper case
0867 0867 d d652
0867 0867 u 02 01
0867 0867 s 		SUB	'R'		;If ='R', Use ROM (A=0)
0869 0869 d 2003
0869 0869 u 02 01
0869 0869 s 		JR  NZ,	UR_RET1		
086b 086b d 32dbff
086b 086b u 03 01
086b 086b s UR_RET		LD	(READ_RAMROM),A
086e 086e d cd7a08
086e 086e u 03 01
086e 086e s UR_RET1		CALL	DISP_RRBANK
0871 0871 d 3adbff
0871 0871 u 03 01
0871 0871 s SET_BANK	LD	A,(READ_RAMROM)
0874 0874 d 1f
0874 0874 u 01 01
0874 0874 s 		RRA
0875 0875 d e60f
0875 0875 u 02 01
0875 0875 s 		AND	0xF
0877 0877 d d3cc
0877 0877 u 02 01
0877 0877 s 		OUT	(ACE_OUT),A	;SET Bank
0879 0879 d c9
0879 0879 u 01 01
0879 0879 s 		RET
087a 087a s 				
087a 087a d 3adbff
087a 087a u 03 01
087a 087a s DISP_RRBANK	LD	A,(READ_RAMROM)
087d 087d d 1f
087d 087d u 01 01
087d 087d s 		RRA
087e 087e d 3012
087e 087e u 02 01
087e 087e s 		JR  NC,	DRR_ROM
0880 0880 d cdca0d
0880 0880 u 03 01
0880 0880 s 		CALL	PRINTI
0883 0883 d 2052414d2042414e4b3a00
0883 0883 u 0b 02
0883 0883 s 		DB	" RAM BANK:",EOS		
088e 088e d cd090e
088e 088e u 03 01
088e 088e s 		CALL	PUT_HEX
0891 0891 d c9
0891 0891 u 01 01
0891 0891 s 		RET
0892 0892 d cdca0d
0892 0892 u 03 01
0892 0892 s DRR_ROM		CALL	PRINTI
0895 0895 d 20524f4d00
0895 0895 u 05 02
0895 0895 s 		DB	" ROM",EOS
089a 089a d c9
089a 089a u 01 01
089a 089a s 		RET
089b 089b s 		
089b 089b s 
089b 089b s 
089b 089b s 
089b 089b s 		
089b 089b s 
089b 089b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
089b 089b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
089b 089b s ;	Chapter_4	Menu operations
089b 089b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
089b 089b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
089b 089b s 
089b 089b s ;=============================================================================
089b 089b s ;Display Version
089b 089b s ;-----------------------------------------------------------------------------
089b 089b d cdca0d
089b 089b u 03 01
089b 089b s PUT_VERSION	CALL	PRINTI
089e 089e d 0d0a5a3830204d454d424552534849502043415244204d4943524f2d53442c2076312e3562657461204a756c792032332c20323031370d0a00
089e 089e u 39 02
089e 089e s 	DB	CR,LF,"Z80 MEMBERSHIP CARD MICRO-SD, v1.5beta July 23, 2017",CR,LF,EOS
08d7 08d7 s ;		VERSION_MSG
08d7 08d7 d cdca0d
08d7 08d7 u 03 01
08d7 08d7 s 		CALL	PRINTI		
08da 08da d 48617264776172653a2000
08da 08da u 0b 02
08da 08da s 		DB	"Hardware: ",EOS	
08e5 08e5 d 3a95ff
08e5 08e5 u 03 01
08e5 08e5 s 		LD	A,(HW_LIST)	;00 NO FP
08e8 08e8 d cdf60d
08e8 08e8 u 03 01
08e8 08e8 s 		CALL	PUT_BYTE	;01 FP only
08eb 08eb d b7
08eb 08eb u 01 01
08eb 08eb s 		OR	A		;02 SIO only
08ec 08ec d 200a
08ec 08ec u 02 01
08ec 08ec s 		JR NZ,	PVH_0		;03 FP & SIO
08ee 08ee d cdca0d
08ee 08ee u 03 01
08ee 08ee s 		CALL	PRINTI		
08f1 08f1 d 204e6f6e6500
08f1 08f1 u 06 02
08f1 08f1 s 		DB	" None",EOS
08f7 08f7 d c9
08f7 08f7 u 01 01
08f7 08f7 s 		RET
08f8 08f8 s 		
08f8 08f8 d 0f
08f8 08f8 u 01 01
08f8 08f8 s PVH_0		RRCA
08f9 08f9 d 0e20
08f9 08f9 u 02 01
08f9 08f9 s 		LD	C,' '
08fb 08fb d 3009
08fb 08fb u 02 01
08fb 08fb s 		JR NC,	PVH_1
08fd 08fd d 0e2c
08fd 08fd u 02 01
08fd 08fd s 		LD	C,','
08ff 08ff d cdca0d
08ff 08ff u 03 01
08ff 08ff s 		CALL	PRINTI		
0902 0902 d 20465000
0902 0902 u 04 02
0902 0902 s 		DB	" FP",EOS
0906 0906 d 0f
0906 0906 u 01 01
0906 0906 s PVH_1		RRCA
0907 0907 d d0
0907 0907 u 01 01
0907 0907 s 		RET NC
0908 0908 d 79
0908 0908 u 01 01
0908 0908 s 		LD	A,C
0909 0909 d cdec13
0909 0909 u 03 01
0909 0909 s 		CALL	PUT_CHAR
090c 090c d cdca0d
090c 090c u 03 01
090c 090c s 		CALL	PRINTI		
090f 090f d 2053494f00
090f 090f u 05 02
090f 090f s 		DB	" SIO",EOS
0914 0914 d c9
0914 0914 u 01 01
0914 0914 s 		RET			
0915 0915 s 					
0915 0915 s 				
0915 0915 s 
0915 0915 s ;=============================================================================
0915 0915 s ;Register Display/Set
0915 0915 s ;-----------------------------------------------------------------------------
0915 0915 d cd190e
0915 0915 u 03 01
0915 0915 s REG_MENU	CALL	PUT_SPACE
0918 0918 d cde013
0918 0918 u 03 01
0918 0918 s 		CALL	GET_CHAR
091b 091b d fe0d
091b 091b u 02 01
091b 091b s 		CP	CR
091d 091d d 2030
091d 091d u 02 01
091d 091d s 		JR  NZ,	RM_NOTALL
091f 091f s 
091f 091f s ;12345678901234567890123456789012345678901234567890123456789012345678901234567890  80 COLUMNS
091f 091f s ;AF=xxxx  BC=xxxx  DE=xxxx  HL=xxxx  AF'=xxxx  BC'=xxxx  DE'=xxxx  HL'=xxxx
091f 091f s ;IX=xxxx  IY=xxxx  IR=xxxx  PC=xxxx  SP=xxxx
091f 091f s 
091f 091f s REG_DISP_ALL				;Dump ALL registers
091f 091f d 060d
091f 091f u 02 01
091f 091f s 		LD	B,13		;13 Registers to dump
0921 0921 d 214209
0921 0921 u 03 01
0921 0921 s RM_LP		LD	HL,REGORDER
0924 0924 d 78
0924 0924 u 01 01
0924 0924 s 		LD	A,B
0925 0925 d 3d
0925 0925 u 01 01
0925 0925 s 		DEC	A
0926 0926 d cd450e
0926 0926 u 03 01
0926 0926 s 		CALL	ADD_HL_A
0929 0929 d 7e
0929 0929 u 01 01
0929 0929 s 		LD	A,(HL)
092a 092a d b7
092a 092a u 01 01
092a 092a s 		OR	A
092b 092b d fc1f0e
092b 092b u 03 01
092b 092b s 		CALL M,	PUT_NEW_LINE
092e 092e d e60f
092e 092e u 02 01
092e 092e s 		AND	0xF
0930 0930 d cd2e0c
0930 0930 u 03 01
0930 0930 s 		CALL	GET_REGNAME
0933 0933 d cdbd0d
0933 0933 u 03 01
0933 0933 s 		CALL	PRINT
0936 0936 d cdab09
0936 0936 u 03 01
0936 0936 s 		CALL	RM_DUMP_REG
0939 0939 d cdca0d
0939 0939 u 03 01
0939 0939 s 		CALL	PRINTI
093c 093c d 202000
093c 093c u 03 02
093c 093c s 		DB	'  ',EOS
093f 093f d 10e0
093f 093f u 02 01
093f 093f s 		DJNZ	RM_LP
0941 0941 d c9
0941 0941 u 01 01
0941 0941 s 		RET
0942 0942 s 
0942 0942 d 00
0942 0942 u 01 02
0942 0942 s REGORDER	DB	0		;Registers to dump (Numbers shifted left)
0943 0943 d 05
0943 0943 u 01 02
0943 0943 s 		DB	5		;LSB will indicate a NEW LINE
0944 0944 d 08
0944 0944 u 01 02
0944 0944 s 		DB	8
0945 0945 d 07
0945 0945 u 01 02
0945 0945 s 		DB	7
0946 0946 d 86
0946 0946 u 01 02
0946 0946 s 		DB	6 + 0x80
0947 0947 d 0c
0947 0947 u 01 02
0947 0947 s 		DB	12
0948 0948 d 0b
0948 0948 u 01 02
0948 0948 s 		DB	11
0949 0949 d 0a
0949 0949 u 01 02
0949 0949 s 		DB	10
094a 094a d 89
094a 094a u 01 02
094a 094a s 		DB	9 + 0x80
094b 094b d 04
094b 094b u 01 02
094b 094b s 		DB	4
094c 094c d 03
094c 094c u 01 02
094c 094c s 		DB	3
094d 094d d 02
094d 094d u 01 02
094d 094d s 		DB	2
094e 094e d 81
094e 094e u 01 02
094e 094e s 		DB	1 + 0x80	;First Register to Dump
094f 094f s 
094f 094f d cdb227
094f 094f u 03 01
094f 094f s RM_NOTALL	CALL	TO_UPPER
0952 0952 d cdbb27
0952 0952 u 03 01
0952 0952 s 		CALL	IS_LETTER	;A contains first letter of register
0955 0955 d 382f
0955 0955 u 02 01
0955 0955 s 		JR  C,	RM_ERR		;abort if not a letter
0957 0957 d 5f
0957 0957 u 01 01
0957 0957 s 		LD	E,A		;E=first letter of register
0958 0958 d cde013
0958 0958 u 03 01
0958 0958 s 		CALL	GET_CHAR	;input 2nd letter of register
095b 095b d cdb227
095b 095b u 03 01
095b 095b s 		CALL	TO_UPPER
095e 095e d cdbb27
095e 095e u 03 01
095e 095e s 		CALL	IS_LETTER	;
0961 0961 d 3823
0961 0961 u 02 01
0961 0961 s 		JR  C,	RM_ERR		;Abort if 2nd char is not a letter
0963 0963 d 57
0963 0963 u 01 01
0963 0963 s 		LD	D,A		;D=2nd letter
0964 0964 s 
0964 0964 d 2e00
0964 0964 u 02 01
0964 0964 s 		LD	L,0
0966 0966 d cde013
0966 0966 u 03 01
0966 0966 s RM_2		CALL	GET_CHAR	;Get the 3rd char command
0969 0969 d fe27
0969 0969 u 02 01
0969 0969 s 		CP	0x27		;Apostrophe Char
096b 096b d 2004
096b 096b u 02 01
096b 096b s 		JR  NZ,	RM_3		;if 3rd char is apostrophe, 
096d 096d d 2e01
096d 096d u 02 01
096d 096d s 		LD	L,1		;L=1 if Alternate Register
096f 096f d 18f5
096f 096f u 02 01
096f 096f s 		JR	RM_2		;and loop back for a 4th char command
0971 0971 s 		
0971 0971 d cb1d
0971 0971 u 02 01
0971 0971 s RM_3		RR	L		;Put Alternate flag into CARRY
0973 0973 d f5
0973 0973 u 01 01
0973 0973 s 		PUSH	AF		;Save last key input before proceeding to Search for Register
0974 0974 s 
0974 0974 d 060d
0974 0974 u 02 01
0974 0974 s 		LD	B,13		;Loop through all 13 registers
0976 0976 d 78
0976 0976 u 01 01
0976 0976 s RM_4		LD	A,B
0977 0977 d 3d
0977 0977 u 01 01
0977 0977 s 		DEC	A		;adjust to base 0
0978 0978 d cd2e0c
0978 0978 u 03 01
0978 0978 s 		CALL	GET_REGNAME	;HL=PTR TO NAME
097b 097b d cd4a0e
097b 097b u 03 01
097b 097b s 		CALL	LD_HL_HL	;HL = ASCII name of Register
097e 097e d b7
097e 097e u 01 01
097e 097e s 		OR	A		;CLEAR CARRY
097f 097f d ed52
097f 097f u 02 01
097f 097f s 		SBC	HL,DE		;Test if DE=HL
0981 0981 d 2809
0981 0981 u 02 01
0981 0981 s 		JR  Z,	RM_5		;Jump if NAME FOUND
0983 0983 d 10f1
0983 0983 u 02 01
0983 0983 s 		DJNZ	RM_4
0985 0985 s 
0985 0985 d f1
0985 0985 u 01 01
0985 0985 s 		POP	AF
0986 0986 d 3e3f
0986 0986 u 02 01
0986 0986 s RM_ERR		LD	A,'?'		;Register Name not found
0988 0988 d cdec13
0988 0988 u 03 01
0988 0988 s 		CALL	PUT_CHAR
098b 098b d c9
098b 098b u 01 01
098b 098b s 		RET
098c 098c s 		
098c 098c d 48
098c 098c u 01 01
098c 098c s RM_5		LD	C,B		;C=Register Ptr
098d 098d d 0d
098d 098d u 01 01
098d 098d s 		DEC	C
098e 098e d f1
098e 098e u 01 01
098e 098e s 		POP	AF		;Restore saved command (and alternate register selection)
098f 098f d 57
098f 098f u 01 01
098f 098f s 		LD	D,A		;D=Command
0990 0990 d 3808
0990 0990 u 02 01
0990 0990 s 		JR  C,	RM_6		;Jump if Alternate (Selection would be correct)
0992 0992 d 79
0992 0992 u 01 01
0992 0992 s 		LD	A,C
0993 0993 d fe09
0993 0993 u 02 01
0993 0993 s 		CP	9
0995 0995 d 3803
0995 0995 u 02 01
0995 0995 s 		JR  C,	RM_6		;Jump if NOT Registers AF,BC,DE or HL
0997 0997 d d608
0997 0997 u 02 01
0997 0997 s 		SUB	8		;Subtract 8 to convert AF' to AF, etc
0999 0999 d 4f
0999 0999 u 01 01
0999 0999 s 		LD	C,A
099a 099a d 7a
099a 099a u 01 01
099a 099a s RM_6		LD	A,D		;RESUME Decoding command line
099b 099b d fe0d
099b 099b u 02 01
099b 099b s 		CP	CR		;if CR, dump Register
099d 099d d 280b
099d 099d u 02 01
099d 099d s 		JR  Z,	RM_DUMP_REG_C
099f 099f d fe3d
099f 099f u 02 01
099f 099f s 		CP	'='		;if '=', then Assign new value to Register
09a1 09a1 d 20e3
09a1 09a1 u 02 01
09a1 09a1 s 		JR  NZ,	RM_ERR
09a3 09a3 s 
09a3 09a3 d cd790d
09a3 09a3 u 03 01
09a3 09a3 s 		CALL	GET_WORD	;DE = Word from Command
09a6 09a6 d 79
09a6 09a6 u 01 01
09a6 09a6 s 		LD	A,C
09a7 09a7 d cd820c
09a7 09a7 u 03 01
09a7 09a7 s 		CALL	PUT_REGISTER
09aa 09aa s 
09aa 09aa d 79
09aa 09aa u 01 01
09aa 09aa s RM_DUMP_REG_C	LD	A,C
09ab 09ab d cdca0d
09ab 09ab u 03 01
09ab 09ab s RM_DUMP_REG	CALL	PRINTI
09ae 09ae d 3d00
09ae 09ae u 02 02
09ae 09ae s 		DB	'=',0
09b0 09b0 d cd6d0c
09b0 09b0 u 03 01
09b0 09b0 s 		CALL	GET_REGISTER
09b3 09b3 d cdea0d
09b3 09b3 u 03 01
09b3 09b3 s 		CALL	PUT_HL
09b6 09b6 d c9
09b6 09b6 u 01 01
09b6 09b6 s 		RET
09b7 09b7 s 
09b7 09b7 s 
09b7 09b7 s ;=============================================================================
09b7 09b7 s ;Loop back test
09b7 09b7 s ;-----------------------------------------------------------------------------
09b7 09b7 d 3e00
09b7 09b7 u 02 01
09b7 09b7 s LOOP_BACK_TEST	LD	A,0		;Turn off LED update & enable key entry
09b9 09b9 d cdd927
09b9 09b9 u 03 01
09b9 09b9 s 		CALL	LED_UPDATE
09bc 09bc s 
09bc 09bc d cdca0d
09bc 09bc u 03 01
09bc 09bc s 		CALL	PRINTI
09bf 09bf d 0d0a
09bf 09bf u 02 02
09bf 09bf s 		DB	CR,LF
09c1 09c1 d 4c4f4f50204241434b2c203c4573633e2d455849540d0a00
09c1 09c1 u 18 02
09c1 09c1 s 		DB	'LOOP BACK, <Esc>-EXIT',CR,LF,0
09d9 09d9 d cd8a1c
09d9 09d9 u 03 01
09d9 09d9 s 		CALL	LED_HOME_PRINTI
09dc 09dc d 4c4f4f5042414300
09dc 09dc u 08 02
09dc 09dc s 		DB	'LOOPBAC',0
09e4 09e4 d cd7714
09e4 09e4 u 03 01
09e4 09e4 s 		CALL	LED_HOME
09e7 09e7 s 		
09e7 09e7 s 		
09e7 09e7 d cd2114
09e7 09e7 u 03 01
09e7 09e7 s LOOP_BACK_LP	CALL	IN_CHAR	;Test for any RS-232 input
09ea 09ea d 3806
09ea 09ea u 02 01
09ea 09ea s 		JR   C,	LB_0	;Jump if no input
09ec 09ec d fe1b
09ec 09ec u 02 01
09ec 09ec s 		CP	27	;<Esc> to quit
09ee 09ee d 281f
09ee 09ee u 02 01
09ee 09ee s 		JR   Z,	LB_RET
09f0 09f0 d 1814
09f0 09f0 u 02 01
09f0 09f0 s 		JR	LB_OUT	;Display
09f2 09f2 s 		
09f2 09f2 d cdba14
09f2 09f2 u 03 01
09f2 09f2 s LB_0		CALL 	IC_KEY		;Test regular HEX input
09f5 09f5 d cae709
09f5 09f5 u 03 01
09f5 09f5 s 		JP   Z,	LOOP_BACK_LP	;
09f8 09f8 s 
09f8 09f8 d cb67
09f8 09f8 u 02 01
09f8 09f8 s LB_1		BIT	4,A
09fa 09fa d 2807
09fa 09fa u 02 01
09fa 09fa s 		JR   Z,	LB_2	;Jump if NOT shifted
09fc 09fc d f5
09fc 09fc u 01 01
09fc 09fc s 		PUSH	AF		;If Shifted, then output a carret before the key
09fd 09fd d 3e5e
09fd 09fd u 02 01
09fd 09fd s 		LD	A,'^'
09ff 09ff d cdec13
09ff 09ff u 03 01
09ff 09ff s 		CALL	Put_Char
0a02 0a02 d f1
0a02 0a02 u 01 01
0a02 0a02 s 		POP	AF
0a03 0a03 s 
0a03 0a03 d cd0f0e
0a03 0a03 u 03 01
0a03 0a03 s LB_2		CALL	HEX2ASC	;Convert Keypad input to ASCII
0a06 0a06 s 
0a06 0a06 d cdec13
0a06 0a06 u 03 01
0a06 0a06 s LB_OUT		CALL	PUT_CHAR
0a09 0a09 d 4f
0a09 0a09 u 01 01
0a09 0a09 s 		LD	C,A
0a0a 0a0a d cd8a14
0a0a 0a0a u 03 01
0a0a 0a0a s 		CALL	PC_LED
0a0d 0a0d d 18d8
0a0d 0a0d u 02 01
0a0d 0a0d s 		JR	LOOP_BACK_LP
0a0f 0a0f s 
0a0f 0a0f d 3e01
0a0f 0a0f u 02 01
0a0f 0a0f s LB_RET		LD	A,1
0a11 0a11 d cdd927
0a11 0a11 u 03 01
0a11 0a11 s 		CALL	LED_UPDATE
0a14 0a14 d c9
0a14 0a14 u 01 01
0a14 0a14 s 		RET
0a15 0a15 s 
0a15 0a15 s 
0a15 0a15 s ;=============================================================================
0a15 0a15 s ;MEMORY ENTER.  M XXXX YY..YY,  ENTERS AS MANY BYTES AS THERE ARE ON THE LINE.
0a15 0a15 s ;-----------------------------------------------------------------------------
0a15 0a15 d 010000
0a15 0a15 u 03 01
0a15 0a15 s MEM_ENTER	LD	BC,0		;Clear count
0a18 0a18 d cd790d
0a18 0a18 u 03 01
0a18 0a18 s MEM_ENTER_NEXTL	CALL	GET_WORD	;DE = Word from console, A=non-hex character following word (space)
0a1b 0a1b d fe20
0a1b 0a1b u 02 01
0a1b 0a1b s 		CP	' '	;Test delimiting character, must be a space
0a1d 0a1d d c0
0a1d 0a1d u 01 01
0a1d 0a1d s 		RET 	NZ		;Main Menu
0a1e 0a1e d eb
0a1e 0a1e u 01 01
0a1e 0a1e s 		EX	DE,HL		;HL = Start
0a1f 0a1f d cd4c0d
0a1f 0a1f u 03 01
0a1f 0a1f s MEN_LP		CALL	GET_BYTE	;A = Byte or A=non-hex character (Carry Set)
0a22 0a22 d 380b
0a22 0a22 u 02 01
0a22 0a22 s 		JR C,	MEN_CHK		;Jump if non-hex input
0a24 0a24 d 77
0a24 0a24 u 01 01
0a24 0a24 s 		LD	(HL),A		;else, save the byte
0a25 0a25 d 23
0a25 0a25 u 01 01
0a25 0a25 s 		INC	HL		;advance memory pointer
0a26 0a26 d 03
0a26 0a26 u 01 01
0a26 0a26 s 		INC	BC		;count bytes
0a27 0a27 d 18f6
0a27 0a27 u 02 01
0a27 0a27 s 		JR	MEN_LP		;repeat for next byte input
0a29 0a29 s 
0a29 0a29 d cdda13
0a29 0a29 u 03 01
0a29 0a29 s MEN_RET		CALL	GET_CHAR_NE	;ignore rest of line before returning to main menu
0a2c 0a2c d cdec13
0a2c 0a2c u 03 01
0a2c 0a2c s 		CALL	PUT_CHAR
0a2f 0a2f d fe0d
0a2f 0a2f u 02 01
0a2f 0a2f s MEN_CHK		CP	0x0D		;wait until we get the <CR>
0a31 0a31 d 2804
0a31 0a31 u 02 01
0a31 0a31 s 		JR Z,	MEN_1
0a33 0a33 d fe0a
0a33 0a33 u 02 01
0a33 0a33 s 		CP	0x0A		;wait until we get the <LF>
0a35 0a35 d 20f2
0a35 0a35 u 02 01
0a35 0a35 s 		JR NZ,	MEN_RET
0a37 0a37 d 3e04
0a37 0a37 u 02 01
0a37 0a37 s MEN_1		LD	A,4		;Wait up to 2 seconds for another M command or return to main menu
0a39 0a39 d cd4b14
0a39 0a39 u 03 01
0a39 0a39 s 		CALL	TIMED_GETCHAR	;
0a3c 0a3c d cdec13
0a3c 0a3c u 03 01
0a3c 0a3c s 		CALL	PUT_CHAR
0a3f 0a3f d fe4d
0a3f 0a3f u 02 01
0a3f 0a3f s 		CP	'M'		;If another M command comes in, process it
0a41 0a41 d 28d5
0a41 0a41 u 02 01
0a41 0a41 s 		JR Z,	MEM_ENTER_NEXTL
0a43 0a43 d fe0a
0a43 0a43 u 02 01
0a43 0a43 s 		CP	0x0A		;Skip LF
0a45 0a45 d 28f0
0a45 0a45 u 02 01
0a45 0a45 s 		JR Z,	MEN_1
0a47 0a47 d cdca0d
0a47 0a47 u 03 01
0a47 0a47 s 		CALL	PRINTI
0a4a 0a4a d 0d0a425954455320454e54455245443d00
0a4a 0a4a u 11 02
0a4a 0a4a s 		DB	CR,LF,"BYTES ENTERED=",EOS
0a5b 0a5b d cdd80d
0a5b 0a5b u 03 01
0a5b 0a5b s 		CALL	PUT_BC
0a5e 0a5e d c9
0a5e 0a5e u 01 01
0a5e 0a5e s 		RET			;If not, return to main menu prompt
0a5f 0a5f s 
0a5f 0a5f s 
0a5f 0a5f s ;=============================================================================
0a5f 0a5f s ;MEMORY DUMP - Continous
0a5f 0a5f s ;-----------------------------------------------------------------------------
0a5f 0a5f d 06ff
0a5f 0a5f u 02 01
0a5f 0a5f s MEM_DUMP:	LD	B,0xFF		;Continuous Dump, No pausing
0a61 0a61 d cd760d
0a61 0a61 u 03 01
0a61 0a61 s MEM_DUMP_0	CALL	SPACE_GET_WORD	;Input start address
0a64 0a64 d eb
0a64 0a64 u 01 01
0a64 0a64 s 		EX	DE,HL			;HL = Start
0a65 0a65 d cd760d
0a65 0a65 u 03 01
0a65 0a65 s 		CALL	SPACE_GET_WORD	;Input end address (DE = end)
0a68 0a68 s 
0a68 0a68 d cd1f0e
0a68 0a68 u 03 01
0a68 0a68 s MEM_DUMP_LP:	CALL	PUT_NEW_LINE
0a6b 0a6b d cdaa0a
0a6b 0a6b u 03 01
0a6b 0a6b s 		CALL	DUMP_LINE	;Dump 16 byte lines (advances HL)
0a6e 0a6e d c8
0a6e 0a6e u 01 01
0a6e 0a6e s 		RET Z			;RETURN WHEN HL=DE
0a6f 0a6f d cd2114
0a6f 0a6f u 03 01
0a6f 0a6f s 		CALL	IN_CHAR		;Exit on <Esc>
0a72 0a72 d fe1b
0a72 0a72 u 02 01
0a72 0a72 s 		CP	27
0a74 0a74 d c8
0a74 0a74 u 01 01
0a74 0a74 s 		RET	Z
0a75 0a75 d 7d
0a75 0a75 u 01 01
0a75 0a75 s 		LD	A,L
0a76 0a76 d b0
0a76 0a76 u 01 01
0a76 0a76 s 		OR	B
0a77 0a77 d 20ef
0a77 0a77 u 02 01
0a77 0a77 s 		JR  NZ,	MEM_DUMP_LP	;Dump 1 Page, then prompt for continue
0a79 0a79 d cd820a
0a79 0a79 u 03 01
0a79 0a79 s 		CALL	GET_CONTINUE
0a7c 0a7c d 18ea
0a7c 0a7c u 02 01
0a7c 0a7c s 		JR	MEM_DUMP_LP
0a7e 0a7e s ;=============================================================================
0a7e 0a7e s ;MEMORY DUMP - Paged
0a7e 0a7e s ;-----------------------------------------------------------------------------
0a7e 0a7e d 0600
0a7e 0a7e u 02 01
0a7e 0a7e s MEM_DUMP_PAGED	LD	B,0		;Paused Dump
0a80 0a80 d 18df
0a80 0a80 u 02 01
0a80 0a80 s 		JR	MEM_DUMP_0
0a82 0a82 s 
0a82 0a82 s ;-----------------------------------------------------------------------------
0a82 0a82 d cd1f0e
0a82 0a82 u 03 01
0a82 0a82 s GET_CONTINUE	CALL	PUT_NEW_LINE
0a85 0a85 d cdca0d
0a85 0a85 u 03 01
0a85 0a85 s 		CALL	PRINTI
0a88 0a88 d 507265737320616e79206b657920746f20636f6e74696e756500
0a88 0a88 u 1a 02
0a88 0a88 s 		DB	"Press any key to continue",EOS
0aa2 0aa2 d cde013
0aa2 0aa2 u 03 01
0aa2 0aa2 s 		CALL	GET_CHAR
0aa5 0aa5 d fe1b
0aa5 0aa5 u 02 01
0aa5 0aa5 s 		CP	27
0aa7 0aa7 d c0
0aa7 0aa7 u 01 01
0aa7 0aa7 s 		RET NZ
0aa8 0aa8 d e1
0aa8 0aa8 u 01 01
0aa8 0aa8 s 		POP	HL		;Scrap return address
0aa9 0aa9 d c9
0aa9 0aa9 u 01 01
0aa9 0aa9 s 		RET
0aaa 0aaa s 
0aaa 0aaa s 
0aaa 0aaa s ;-----------------------------------------------------------------------------
0aaa 0aaa s ;DUMP_LINE -- Dumps a line
0aaa 0aaa s ;xxx0:  <pre spaces> XX XX XX XX XX After spaces | ....ASCII....
0aaa 0aaa s ;-----------------------------------------------------------------------------
0aaa 0aaa d c5
0aaa 0aaa u 01 01
0aaa 0aaa s DUMP_LINE:	PUSH	BC		;+1
0aab 0aab d e5
0aab 0aab u 01 01
0aab 0aab s 		PUSH	HL		;+2 Save H for 2nd part of display
0aac 0aac d e5
0aac 0aac u 01 01
0aac 0aac s 		PUSH	HL		;+3 Start line with xxx0 address
0aad 0aad d 3e4d
0aad 0aad u 02 01
0aad 0aad s 		LD	A,'M'
0aaf 0aaf d cdec13
0aaf 0aaf u 03 01
0aaf 0aaf s 		CALL	Put_Char
0ab2 0ab2 d cdea0d
0ab2 0ab2 u 03 01
0ab2 0ab2 s 		CALL	PUT_HL		;Print Address
0ab5 0ab5 d cd190e
0ab5 0ab5 u 03 01
0ab5 0ab5 s 		CALL	PUT_SPACE
0ab8 0ab8 d e1
0ab8 0ab8 u 01 01
0ab8 0ab8 s 		POP	HL		;-3
0ab9 0ab9 d 7d
0ab9 0ab9 u 01 01
0ab9 0ab9 s 		LD	A,L
0aba 0aba d e60f
0aba 0aba u 02 01
0aba 0aba s 		AND	0x0F		;Fetch how many prespaces to print
0abc 0abc d 4f
0abc 0abc u 01 01
0abc 0abc s 		LD	C,A
0abd 0abd d 47
0abd 0abd u 01 01
0abd 0abd s 		LD	B,A		;Save count of prespaces for part 2 of display
0abe 0abe d cd110b
0abe 0abe u 03 01
0abe 0abe s 		CALL	PUT_3C_SPACES
0ac1 0ac1 s 
0ac1 0ac1 d cd45fb
0ac1 0ac1 u 03 01
0ac1 0ac1 s DL_P1L		CALL	GET_MEM
0ac4 0ac4 d cdf30d
0ac4 0ac4 u 03 01
0ac4 0ac4 s 		CALL	SPACE_PUT_BYTE
0ac7 0ac7 d cd0b0b
0ac7 0ac7 u 03 01
0ac7 0ac7 s 		CALL	CP_HL_DE
0aca 0aca d 2808
0aca 0aca u 02 01
0aca 0aca s 		JR Z,	DL_P1E
0acc 0acc d 23
0acc 0acc u 01 01
0acc 0acc s 		INC	HL
0acd 0acd d 7d
0acd 0acd u 01 01
0acd 0acd s 		LD	A,L
0ace 0ace d e60f
0ace 0ace u 02 01
0ace 0ace s 		AND	0x0F
0ad0 0ad0 d 20ef
0ad0 0ad0 u 02 01
0ad0 0ad0 s 		JR  NZ,	DL_P1L
0ad2 0ad2 d 1808
0ad2 0ad2 u 02 01
0ad2 0ad2 s 		JR	DL_P2
0ad4 0ad4 s 
0ad4 0ad4 d 7d
0ad4 0ad4 u 01 01
0ad4 0ad4 s DL_P1E		LD	A,L
0ad5 0ad5 d 2f
0ad5 0ad5 u 01 01
0ad5 0ad5 s 		CPL
0ad6 0ad6 d e60f
0ad6 0ad6 u 02 01
0ad6 0ad6 s 		AND	0x0F
0ad8 0ad8 d 4f
0ad8 0ad8 u 01 01
0ad8 0ad8 s 		LD	C,A
0ad9 0ad9 d cd110b
0ad9 0ad9 u 03 01
0ad9 0ad9 s 		CALL	PUT_3C_SPACES
0adc 0adc s 
0adc 0adc d cdca0d
0adc 0adc u 03 01
0adc 0adc s DL_P2		CALL	PRINTI		;Print Seperator between part 1 and part 2
0adf 0adf d 203b2000
0adf 0adf u 04 02
0adf 0adf s 		DB	" ; ",EOS
0ae3 0ae3 s 
0ae3 0ae3 d 78
0ae3 0ae3 u 01 01
0ae3 0ae3 s DL_PSL2		LD	A,B		;Print prespaces for part 2
0ae4 0ae4 d b7
0ae4 0ae4 u 01 01
0ae4 0ae4 s 		OR	A
0ae5 0ae5 d 2806
0ae5 0ae5 u 02 01
0ae5 0ae5 s 		JR Z,	DL_PSE2
0ae7 0ae7 d cd190e
0ae7 0ae7 u 03 01
0ae7 0ae7 s 		CALL	PUT_SPACE
0aea 0aea d 05
0aea 0aea u 01 01
0aea 0aea s 		DEC	B
0aeb 0aeb d 18f6
0aeb 0aeb u 02 01
0aeb 0aeb s 		JR	DL_PSL2
0aed 0aed s DL_PSE2
0aed 0aed d e1
0aed 0aed u 01 01
0aed 0aed s 		POP	HL		;-2
0aee 0aee d c1
0aee 0aee u 01 01
0aee 0aee s 		POP	BC		;-1
0aef 0aef d cd45fb
0aef 0aef u 03 01
0aef 0aef s DL_P2L		CALL	GET_MEM
0af2 0af2 d fe20
0af2 0af2 u 02 01
0af2 0af2 s 		CP	' '		;A - 20h	Test for Valid ASCII characters
0af4 0af4 d 3002
0af4 0af4 u 02 01
0af4 0af4 s 		JR NC,	DL_P2K1
0af6 0af6 d 3e2e
0af6 0af6 u 02 01
0af6 0af6 s 		LD	A,'.'				;Replace with . if not ASCII
0af8 0af8 d fe7f
0af8 0af8 u 02 01
0af8 0af8 s DL_P2K1		CP	0x7F		;A - 07Fh
0afa 0afa d 3802
0afa 0afa u 02 01
0afa 0afa s 		JR C,	DL_P2K2
0afc 0afc d 3e2e
0afc 0afc u 02 01
0afc 0afc s 		LD	A,'.'
0afe 0afe d cdec13
0afe 0afe u 03 01
0afe 0afe s DL_P2K2		CALL	Put_Char
0b01 0b01 s 
0b01 0b01 d cd0b0b
0b01 0b01 u 03 01
0b01 0b01 s 		CALL	CP_HL_DE
0b04 0b04 d c8
0b04 0b04 u 01 01
0b04 0b04 s 		RET Z
0b05 0b05 d 23
0b05 0b05 u 01 01
0b05 0b05 s 		INC	HL
0b06 0b06 d 7d
0b06 0b06 u 01 01
0b06 0b06 s 		LD	A,L
0b07 0b07 d e60f
0b07 0b07 u 02 01
0b07 0b07 s 		AND	0x0F
0b09 0b09 d 20e4
0b09 0b09 u 02 01
0b09 0b09 s 		JR  NZ,	DL_P2L
0b0b 0b0b s 
0b0b 0b0b s ;-----------------------------------------------------------------------------
0b0b 0b0b s ;Compare HL with DE
0b0b 0b0b s ;Exit:		Z=1 if HL=DE
0b0b 0b0b s ;		M=1 if DE > HL
0b0b 0b0b d 7c
0b0b 0b0b u 01 01
0b0b 0b0b s CP_HL_DE	LD	A,H
0b0c 0b0c d ba
0b0c 0b0c u 01 01
0b0c 0b0c s 		CP	D		;H-D
0b0d 0b0d d c0
0b0d 0b0d u 01 01
0b0d 0b0d s 		RET NZ			;M flag set if D > H
0b0e 0b0e d 7d
0b0e 0b0e u 01 01
0b0e 0b0e s 		LD	A,L
0b0f 0b0f d bb
0b0f 0b0f u 01 01
0b0f 0b0f s 		CP	E		;L-E
0b10 0b10 d c9
0b10 0b10 u 01 01
0b10 0b10 s 		RET
0b11 0b11 s 
0b11 0b11 s 
0b11 0b11 d 0c
0b11 0b11 u 01 01
0b11 0b11 s PUT_3C_SPACES	INC	C		;Print 3C Spaces
0b12 0b12 d 0d
0b12 0b12 u 01 01
0b12 0b12 s PUT_3C_SPACES_L	DEC	C		;Count down Prespaces
0b13 0b13 d c8
0b13 0b13 u 01 01
0b13 0b13 s 		RET Z
0b14 0b14 d cdca0d
0b14 0b14 u 03 01
0b14 0b14 s 		CALL	PRINTI		;Print pre spaces
0b17 0b17 d 20202000
0b17 0b17 u 04 02
0b17 0b17 s 		DB "   ",EOS
0b1b 0b1b d 18f5
0b1b 0b1b u 02 01
0b1b 0b1b s 		JR	PUT_3C_SPACES_L
0b1d 0b1d s 
0b1d 0b1d s 
0b1d 0b1d s ;-----------------------------------------------------------------------------
0b1d 0b1d s ;EDIT MEMORY
0b1d 0b1d s ;Edit memory from a starting address until X is pressed.
0b1d 0b1d s ;Display mem loc, contents, and results of write.
0b1d 0b1d s ;-----------------------------------------------------------------------------
0b1d 0b1d d cd760d
0b1d 0b1d u 03 01
0b1d 0b1d s MEM_EDIT:	CALL	SPACE_GET_WORD	;Input Address
0b20 0b20 d eb
0b20 0b20 u 01 01
0b20 0b20 s 		EX	DE,HL			;HL = Address to edit
0b21 0b21 d cd1f0e
0b21 0b21 u 03 01
0b21 0b21 s ME_LP		CALL	PUT_NEW_LINE
0b24 0b24 d cdea0d
0b24 0b24 u 03 01
0b24 0b24 s 		CALL	PUT_HL		;Print current contents of memory
0b27 0b27 d cd190e
0b27 0b27 u 03 01
0b27 0b27 s 		CALL	PUT_SPACE
0b2a 0b2a d 3e3a
0b2a 0b2a u 02 01
0b2a 0b2a s 		LD	A, ':'
0b2c 0b2c d cdec13
0b2c 0b2c u 03 01
0b2c 0b2c s 		CALL	Put_Char
0b2f 0b2f d cd45fb
0b2f 0b2f u 03 01
0b2f 0b2f s 		CALL	GET_MEM
0b32 0b32 d cdf30d
0b32 0b32 u 03 01
0b32 0b32 s 		CALL	SPACE_PUT_BYTE
0b35 0b35 d cd490d
0b35 0b35 u 03 01
0b35 0b35 s 		CALL	SPACE_GET_BYTE	;Input new value or Exit if invalid
0b38 0b38 d d8
0b38 0b38 u 01 01
0b38 0b38 s 		RET C			;Exit to Command Loop
0b39 0b39 d 77
0b39 0b39 u 01 01
0b39 0b39 s 		LD	(HL), A		;or Save new value
0b3a 0b3a d cd45fb
0b3a 0b3a u 03 01
0b3a 0b3a s 		CALL	GET_MEM
0b3d 0b3d d cdf30d
0b3d 0b3d u 03 01
0b3d 0b3d s 		CALL	SPACE_PUT_BYTE
0b40 0b40 d 23
0b40 0b40 u 01 01
0b40 0b40 s 		INC	HL		;Advance to next location
0b41 0b41 d 18de
0b41 0b41 u 02 01
0b41 0b41 s 		JR	ME_LP		;repeat input
0b43 0b43 s 
0b43 0b43 s 
0b43 0b43 s ;=============================================================================
0b43 0b43 s ;	MEM_EXEC - Execute at
0b43 0b43 s ;	Get an address and jump to it
0b43 0b43 s ;-----------------------------------------------------------------------------
0b43 0b43 d cd760d
0b43 0b43 u 03 01
0b43 0b43 s MEM_EXEC:	CALL	SPACE_GET_WORD	;Input address
0b46 0b46 d d25d0b
0b46 0b46 u 03 01
0b46 0b46 s 		JP NC,	ME_1		;Jump if no hex input
0b49 0b49 d fe1b
0b49 0b49 u 02 01
0b49 0b49 s 		CP	27
0b4b 0b4b d c8
0b4b 0b4b u 01 01
0b4b 0b4b s 		RET Z			;Exit if <ESC> pressed
0b4c 0b4c d ed53a0ff
0b4c 0b4c u 04 01
0b4c 0b4c s 		LD	(RPC),DE
0b50 0b50 s 
0b50 0b50 d cdca0d
0b50 0b50 u 03 01
0b50 0b50 s 		CALL	PRINTI
0b53 0b53 d 2050433d00
0b53 0b53 u 05 02
0b53 0b53 s 		DB	' PC=',EOS
0b58 0b58 d cde10d
0b58 0b58 u 03 01
0b58 0b58 s 		CALL	PUT_DE
0b5b 0b5b d 1803
0b5b 0b5b u 02 01
0b5b 0b5b s 		JR	GO_EXEC_T
0b5d 0b5d s 
0b5d 0b5d d fe0d
0b5d 0b5d u 02 01
0b5d 0b5d s ME_1		CP	13		;No hex input (user just typed G and something not HEX)
0b5f 0b5f d c0
0b5f 0b5f u 01 01
0b5f 0b5f s 		RET NZ			;Exit if NOT <CR> pressed
0b60 0b60 s 		
0b60 0b60 d 2a96ff
0b60 0b60 u 03 01
0b60 0b60 s GO_EXEC_T	LD	HL,(RSSP)	;20 Fetch SP
0b63 0b63 d 2b
0b63 0b63 u 01 01
0b63 0b63 s 		DEC	HL
0b64 0b64 d 2b
0b64 0b64 u 01 01
0b64 0b64 s 		DEC	HL
0b65 0b65 d 3eaa
0b65 0b65 u 02 01
0b65 0b65 s 		LD	A,0xAA
0b67 0b67 d 77
0b67 0b67 u 01 01
0b67 0b67 s 		LD	(HL),A
0b68 0b68 d be
0b68 0b68 u 01 01
0b68 0b68 s 		CP	(HL)
0b69 0b69 d 2070
0b69 0b69 u 02 01
0b69 0b69 s 		JR NZ,	GE_STACKFAIL
0b6b 0b6b d 2f
0b6b 0b6b u 01 01
0b6b 0b6b s 		CPL
0b6c 0b6c d 77
0b6c 0b6c u 01 01
0b6c 0b6c s 		LD	(HL),A
0b6d 0b6d d be
0b6d 0b6d u 01 01
0b6d 0b6d s 		CP	(HL)
0b6e 0b6e d 206b
0b6e 0b6e u 02 01
0b6e 0b6e s 		JR NZ,	GE_STACKFAIL
0b70 0b70 s 
0b70 0b70 d f3
0b70 0b70 u 01 01
0b70 0b70 s 		DI			;
0b71 0b71 d 3e82
0b71 0b71 u 02 01
0b71 0b71 s GO_EXEC		LD	A,0x82		;7  (ANBAR_DEF) = RUN MODE
0b73 0b73 d 32b3ff
0b73 0b73 u 03 01
0b73 0b73 s 		LD	(ANBAR_DEF),A	;13
0b76 0b76 d 217c0c
0b76 0b76 u 03 01
0b76 0b76 s 		LD	HL,GET_REG_RUN	;10
0b79 0b79 d 22b4ff
0b79 0b79 u 03 01
0b79 0b79 s 		LD	(GET_REG),HL	;16
0b7c 0b7c d 21910c
0b7c 0b7c u 03 01
0b7c 0b7c s 		LD	HL,PUT_REG_RUN	;10
0b7f 0b7f d 22b6ff
0b7f 0b7f u 03 01
0b7f 0b7f s 		LD	(PUT_REG),HL	;16
0b82 0b82 d 211718
0b82 0b82 u 03 01
0b82 0b82 s 		LD	HL,CTRL_C_TEST	;10
0b85 0b85 d 22b8ff
0b85 0b85 u 03 01
0b85 0b85 s 		LD	(CTRL_C_CHK),HL	;16
0b88 0b88 s 		
0b88 0b88 d 3ab3ff
0b88 0b88 u 03 01
0b88 0b88 s 		LD	A,(ANBAR_DEF)	;13 Refresh Display
0b8b 0b8b d 32e7ff
0b8b 0b8b u 03 01
0b8b 0b8b s 		LD	(LED_ANBAR),A	;13 
0b8e 0b8e s 					;\\\ 124
0b8e 0b8e s 
0b8e 0b8e d 08
0b8e 0b8e u 01 01
0b8e 0b8e s 		EX	AF,AF'		;4  Fetch Alternate register set
0b8f 0b8f d 31a8ff
0b8f 0b8f u 03 01
0b8f 0b8f s 		LD	SP,RSAF2	;10 Set Stack to get register AF'
0b92 0b92 d f1
0b92 0b92 u 01 01
0b92 0b92 s 		POP	AF		;10
0b93 0b93 d 08
0b93 0b93 u 01 01
0b93 0b93 s 		EX	AF,AF'		;4
0b94 0b94 d d9
0b94 0b94 u 01 01
0b94 0b94 s 		EXX			;4  Fetch Alternate register set
0b95 0b95 d ed4baaff
0b95 0b95 u 04 01
0b95 0b95 s 		LD	BC,(RSBC2)	;20
0b99 0b99 d ed5bacff
0b99 0b99 u 04 01
0b99 0b99 s 		LD	DE,(RSDE2)	;20
0b9d 0b9d d 2aaeff
0b9d 0b9d u 03 01
0b9d 0b9d s 		LD	HL,(RSHL2)	;20
0ba0 0ba0 d d9
0ba0 0ba0 u 01 01
0ba0 0ba0 s 		EXX			;4
0ba1 0ba1 s 
0ba1 0ba1 d ed4ba6ff
0ba1 0ba1 u 04 01
0ba1 0ba1 s 		LD	BC,(RSIR)	;20 Fetch IR
0ba5 0ba5 d 79
0ba5 0ba5 u 01 01
0ba5 0ba5 s 		LD	A,C		;4
0ba6 0ba6 d ed4f
0ba6 0ba6 u 02 01
0ba6 0ba6 s 		LD	R,A		;9
0ba8 0ba8 d 78
0ba8 0ba8 u 01 01
0ba8 0ba8 s 		LD	A,B		;4
0ba9 0ba9 d ed47
0ba9 0ba9 u 02 01
0ba9 0ba9 s 		LD	I,A		;9 
0bab 0bab s 					;\\\ 142
0bab 0bab s 					
0bab 0bab d 3ec3
0bab 0bab u 02 01
0bab 0bab s 		LD	A,0xC3		;7  Set Jump instruction
0bad 0bad d 3253fb
0bad 0bad u 03 01
0bad 0bad s 		LD	(HR_EXE_GO),A	;13
0bb0 0bb0 d 2aa0ff
0bb0 0bb0 u 03 01
0bb0 0bb0 s 		LD	HL,(RPC)	;16 Fetch PC
0bb3 0bb3 d 2254fb
0bb3 0bb3 u 03 01
0bb3 0bb3 s 		LD	(HR_EXE_GO+1),HL;16
0bb6 0bb6 s 
0bb6 0bb6 d 3198ff
0bb6 0bb6 u 03 01
0bb6 0bb6 s 		LD	SP,RSAF		;10 Set Stack to Fetch register AF
0bb9 0bb9 d f1
0bb9 0bb9 u 01 01
0bb9 0bb9 s 		POP	AF		;10
0bba 0bba s 
0bba 0bba d ed7b96ff
0bba 0bba u 04 01
0bba 0bba s 		LD	SP,(RSSP)	;20 Fetch SP
0bbe 0bbe d 33
0bbe 0bbe u 01 01
0bbe 0bbe s 		INC	SP		;6
0bbf 0bbf d 33
0bbf 0bbf u 01 01
0bbf 0bbf s 		INC	SP		;6
0bc0 0bc0 d 210000
0bc0 0bc0 u 03 01
0bc0 0bc0 s 		LD	HL,0		;10 Set Default return address as 0000 (Restart/Save Registers)
0bc3 0bc3 d e5
0bc3 0bc3 u 01 01
0bc3 0bc3 s 		PUSH	HL		;11   & Put on stack
0bc4 0bc4 s 					;\\\ 125
0bc4 0bc4 s 		
0bc4 0bc4 d ed4b9aff
0bc4 0bc4 u 04 01
0bc4 0bc4 s 		LD	BC,(RSBC)	;20
0bc8 0bc8 d ed5b9cff
0bc8 0bc8 u 04 01
0bc8 0bc8 s 		LD	DE,(RSDE)	;20
0bcc 0bcc d 2a9eff
0bcc 0bcc u 03 01
0bcc 0bcc s 		LD	HL,(RSHL)	;20
0bcf 0bcf d dd2aa2ff
0bcf 0bcf u 04 01
0bcf 0bcf s 		LD	IX,(RSIX)	;20
0bd3 0bd3 d fd2aa4ff
0bd3 0bd3 u 04 01
0bd3 0bd3 s 		LD	IY,(RSIY)	;20
0bd7 0bd7 s 
0bd7 0bd7 d fb
0bd7 0bd7 u 01 01
0bd7 0bd7 s 		EI			;4
0bd8 0bd8 d c353fb
0bd8 0bd8 u 03 01
0bd8 0bd8 s 		JP	HR_EXE_GO	;10 PC=(STACK)   
0bdb 0bdb s 		
0bdb 0bdb s ;HR_EXE_GO	JP	(RSPC)		;10 Final jump to code
0bdb 0bdb s 					;\\\ 124
0bdb 0bdb s 					;Total = 515
0bdb 0bdb s 
0bdb 0bdb d cdca0d
0bdb 0bdb u 03 01
0bdb 0bdb s GE_STACKFAIL	CALL	PRINTI
0bde 0bde d 20535441434b204e4f5420494e2052414d00
0bde 0bde u 12 02
0bde 0bde s 		DB	' STACK NOT IN RAM',EOS
0bf0 0bf0 d cd8a1c
0bf0 0bf0 u 03 01
0bf0 0bf0 s 		CALL	LED_HOME_PRINTI
0bf3 0bf3 d 5350204552522000
0bf3 0bf3 u 08 02
0bf3 0bf3 s 		DB	'SP ERR ',EOS
0bfb 0bfb d c9
0bfb 0bfb u 01 01
0bfb 0bfb s 		RET
0bfc 0bfc s 		
0bfc 0bfc s 
0bfc 0bfc s ;===============================================
0bfc 0bfc s ;Input from port, print contents
0bfc 0bfc d cd490d
0bfc 0bfc u 03 01
0bfc 0bfc s PORT_INP:	CALL	SPACE_GET_BYTE
0bff 0bff d 4f
0bff 0bff u 01 01
0bff 0bff s 		LD	C, A
0c00 0c00 d ed78
0c00 0c00 u 02 01
0c00 0c00 s 		IN	A,(C)
0c02 0c02 d cdf30d
0c02 0c02 u 03 01
0c02 0c02 s 		CALL	SPACE_PUT_BYTE
0c05 0c05 d c9
0c05 0c05 u 01 01
0c05 0c05 s 		RET
0c06 0c06 s 
0c06 0c06 s ;Get a port address, write byte out
0c06 0c06 d cd490d
0c06 0c06 u 03 01
0c06 0c06 s PORT_OUT:	CALL	SPACE_GET_BYTE
0c09 0c09 d 4f
0c09 0c09 u 01 01
0c09 0c09 s 		LD	C, A
0c0a 0c0a d cd490d
0c0a 0c0a u 03 01
0c0a 0c0a s 		CALL	SPACE_GET_BYTE
0c0d 0c0d d ed79
0c0d 0c0d u 02 01
0c0d 0c0d s 		OUT	(C),A
0c0f 0c0f d c9
0c0f 0c0f u 01 01
0c0f 0c0f s 		RET
0c10 0c10 s 
0c10 0c10 s 
0c10 0c10 s 
0c10 0c10 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0c10 0c10 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0c10 0c10 s ;	Chapter_5	Supporting routines. GET_BYTE, GET_WORD, PUT_BYTE, PUT_WORD
0c10 0c10 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0c10 0c10 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0c10 0c10 s 
0c10 0c10 s 
0c10 0c10 d 3600
0c10 0c10 u 02 01
0c10 0c10 s CLEAR_BLOCK	LD	(HL),0
0c12 0c12 d 23
0c12 0c12 u 01 01
0c12 0c12 s 		INC	HL
0c13 0c13 d 10fb
0c13 0c13 u 02 01
0c13 0c13 s 		DJNZ	CLEAR_BLOCK
0c15 0c15 d c9
0c15 0c15 u 01 01
0c15 0c15 s 		RET
0c16 0c16 s 
0c16 0c16 s ;-----------------------------------------------------------------------------------------------------
0c16 0c16 s ;	FILL_BLOCK, Fills a block of RAM with value in A
0c16 0c16 s ;	Input:	A = value
0c16 0c16 s ;		HL = Start Address
0c16 0c16 s ;		B = Length of Fill (MAX = 0 = 256 bytes)
0c16 0c16 s ;-----------------------------------------------------------------------------------------------------
0c16 0c16 d e5
0c16 0c16 u 01 01
0c16 0c16 s FILL_BLOCK	PUSH	HL
0c17 0c17 d 77
0c17 0c17 u 01 01
0c17 0c17 s FB_LP		LD	(HL),A
0c18 0c18 d 23
0c18 0c18 u 01 01
0c18 0c18 s 		INC	HL
0c19 0c19 d 10fc
0c19 0c19 u 02 01
0c19 0c19 s 		DJNZ	FB_LP
0c1b 0c1b d e1
0c1b 0c1b u 01 01
0c1b 0c1b s 		POP	HL
0c1c 0c1c d c9
0c1c 0c1c u 01 01
0c1c 0c1c s 		RET
0c1d 0c1d s 					;Critical Timing in effect for GO_EXEC
0c1d 0c1d d e3
0c1d 0c1d u 01 01
0c1d 0c1d s WRITE_BLOCK	EX	(SP),HL		;19 HL=PC Total = 137 + 21 * BC
0c1e 0c1e d d5
0c1e 0c1e u 01 01
0c1e 0c1e s 		PUSH	DE		;11
0c1f 0c1f d c5
0c1f 0c1f u 01 01
0c1f 0c1f s 		PUSH	BC		;11
0c20 0c20 d 5e
0c20 0c20 u 01 01
0c20 0c20 s 		LD	E,(HL)		;7
0c21 0c21 d 23
0c21 0c21 u 01 01
0c21 0c21 s 		INC	HL		;6
0c22 0c22 d 56
0c22 0c22 u 01 01
0c22 0c22 s 		LD	D,(HL)		;7
0c23 0c23 d 23
0c23 0c23 u 01 01
0c23 0c23 s 		INC	HL		;6
0c24 0c24 d 4e
0c24 0c24 u 01 01
0c24 0c24 s 		LD	C,(HL)		;7
0c25 0c25 d 23
0c25 0c25 u 01 01
0c25 0c25 s 		INC	HL		;6
0c26 0c26 d 46
0c26 0c26 u 01 01
0c26 0c26 s 		LD	B,(HL)		;7
0c27 0c27 d 23
0c27 0c27 u 01 01
0c27 0c27 s 		INC	HL		;6
0c28 0c28 d edb0
0c28 0c28 u 02 01
0c28 0c28 s 		LDIR			;21/16  21*BC-5
0c2a 0c2a d c1
0c2a 0c2a u 01 01
0c2a 0c2a s 		POP	BC		;10
0c2b 0c2b d d1
0c2b 0c2b u 01 01
0c2b 0c2b s 		POP	DE		;10
0c2c 0c2c d e3
0c2c 0c2c u 01 01
0c2c 0c2c s 		EX	(SP),HL		;19 PC=HL
0c2d 0c2d d c9
0c2d 0c2d u 01 01
0c2d 0c2d s 		RET			;10
0c2e 0c2e s 		
0c2e 0c2e d f5
0c2e 0c2e u 01 01
0c2e 0c2e s GET_REGNAME	PUSH	AF
0c2f 0c2f d 07
0c2f 0c2f u 01 01
0c2f 0c2f s 		RLCA
0c30 0c30 d 07
0c30 0c30 u 01 01
0c30 0c30 s 		RLCA
0c31 0c31 d 21390c
0c31 0c31 u 03 01
0c31 0c31 s 		LD	HL,REGNAMES
0c34 0c34 d cd450e
0c34 0c34 u 03 01
0c34 0c34 s 		CALL	ADD_HL_A
0c37 0c37 d f1
0c37 0c37 u 01 01
0c37 0c37 s 		POP	AF
0c38 0c38 d c9
0c38 0c38 u 01 01
0c38 0c38 s 		RET
0c39 0c39 s 
0c39 0c39 d 53502000
0c39 0c39 u 04 02
0c39 0c39 s REGNAMES	DB	'SP ',0		;0
0c3d 0c3d d 41462000
0c3d 0c3d u 04 02
0c3d 0c3d s 		DB	'AF ',0		;1
0c41 0c41 d 42432000
0c41 0c41 u 04 02
0c41 0c41 s 		DB	'BC ',0		;2
0c45 0c45 d 44452000
0c45 0c45 u 04 02
0c45 0c45 s 		DB	'DE ',0		;3
0c49 0c49 d 484c2000
0c49 0c49 u 04 02
0c49 0c49 s 		DB	'HL ',0		;4
0c4d 0c4d d 50432000
0c4d 0c4d u 04 02
0c4d 0c4d s 		DB	'PC ',0		;5
0c51 0c51 d 49582000
0c51 0c51 u 04 02
0c51 0c51 s 		DB	'IX ',0		;6
0c55 0c55 d 49592000
0c55 0c55 u 04 02
0c55 0c55 s 		DB	'IY ',0		;7
0c59 0c59 d 49522000
0c59 0c59 u 04 02
0c59 0c59 s 		DB	'IR ',0		;8
0c5d 0c5d d 41462700
0c5d 0c5d u 04 02
0c5d 0c5d s 		DB	'AF',0x27,0	;9
0c61 0c61 d 42432700
0c61 0c61 u 04 02
0c61 0c61 s 		DB	'BC',0x27,0	;10
0c65 0c65 d 44452700
0c65 0c65 u 04 02
0c65 0c65 s 		DB	'DE',0x27,0	;11
0c69 0c69 d 484c2700
0c69 0c69 u 04 02
0c69 0c69 s 		DB	'HL',0x27,0	;12
0c6d 0c6d s 
0c6d 0c6d d 2ab4ff
0c6d 0c6d u 03 01
0c6d 0c6d s GET_REGISTER	LD	HL,(GET_REG)	;16
0c70 0c70 d e9
0c70 0c70 u 01 01
0c70 0c70 s 		JP	(HL)		;4
0c71 0c71 s 
0c71 0c71 d 2196ff
0c71 0c71 u 03 01
0c71 0c71 s GET_REG_MON	LD	HL,RSSP		;
0c74 0c74 d 07
0c74 0c74 u 01 01
0c74 0c74 s 		RLCA
0c75 0c75 d cd450e
0c75 0c75 u 03 01
0c75 0c75 s 		CALL	ADD_HL_A	;17+18 HL=Where to find Register
0c78 0c78 d cd4a0e
0c78 0c78 u 03 01
0c78 0c78 s 		CALL	LD_HL_HL	;HL=(HL)
0c7b 0c7b d c9
0c7b 0c7b u 01 01
0c7b 0c7b s 		RET
0c7c 0c7c s 
0c7c 0c7c d 21a10c
0c7c 0c7c u 03 01
0c7c 0c7c s GET_REG_RUN	LD	HL,GRR_TBL	;10
0c7f 0c7f d c3940c
0c7f 0c7f u 03 01
0c7f 0c7f s 		JP	SHORTNWAY	;10
0c82 0c82 s 
0c82 0c82 d 2ab6ff
0c82 0c82 u 03 01
0c82 0c82 s PUT_REGISTER	LD	HL,(PUT_REG)
0c85 0c85 d e9
0c85 0c85 u 01 01
0c85 0c85 s 		JP	(HL)
0c86 0c86 s 
0c86 0c86 d 2196ff
0c86 0c86 u 03 01
0c86 0c86 s PUT_REG_MON	LD	HL,RSSP
0c89 0c89 d 07
0c89 0c89 u 01 01
0c89 0c89 s 		RLCA
0c8a 0c8a d cd450e
0c8a 0c8a u 03 01
0c8a 0c8a s 		CALL	ADD_HL_A	;HL=Where to find Register
0c8d 0c8d d 73
0c8d 0c8d u 01 01
0c8d 0c8d s PURRS_RET	LD	(HL),E
0c8e 0c8e d 23
0c8e 0c8e u 01 01
0c8e 0c8e s 		INC	HL
0c8f 0c8f d 72
0c8f 0c8f u 01 01
0c8f 0c8f s 		LD	(HL),D
0c90 0c90 d c9
0c90 0c90 u 01 01
0c90 0c90 s 		RET
0c91 0c91 s 
0c91 0c91 d 21b10c
0c91 0c91 u 03 01
0c91 0c91 s PUT_REG_RUN	LD	HL,PURR_TBL
0c94 0c94 s 					;40 to get here
0c94 0c94 d e60f
0c94 0c94 u 02 01
0c94 0c94 s SHORTNWAY	AND	0xF		;7
0c96 0c96 d cd450e
0c96 0c96 u 03 01
0c96 0c96 s 		CALL	ADD_HL_A	;14+18
0c99 0c99 d 7e
0c99 0c99 u 01 01
0c99 0c99 s 		LD	A,(HL)		;7
0c9a 0c9a d 21c10c
0c9a 0c9a u 03 01
0c9a 0c9a s 		LD	HL,GRR_SUB	;10
0c9d 0c9d d cd450e
0c9d 0c9d u 03 01
0c9d 0c9d s 		CALL	ADD_HL_A	;17+18
0ca0 0ca0 d e9
0ca0 0ca0 u 01 01
0ca0 0ca0 s VCALL_HL	JP	(HL)		;4  st=138
0ca1 0ca1 s 
0ca1 0ca1 d 00
0ca1 0ca1 u 01 02
0ca1 0ca1 s GRR_TBL		DB	0
0ca2 0ca2 d 06
0ca2 0ca2 u 01 02
0ca2 0ca2 s 		DB	GRR_SUB_AF - GRR_SUB
0ca3 0ca3 d 0e
0ca3 0ca3 u 01 02
0ca3 0ca3 s 		DB	GRR_SUB_BC - GRR_SUB
0ca4 0ca4 d 11
0ca4 0ca4 u 01 02
0ca4 0ca4 s 		DB	GRR_SUB_DE - GRR_SUB
0ca5 0ca5 d 14
0ca5 0ca5 u 01 02
0ca5 0ca5 s 		DB	GRR_SUB_HL - GRR_SUB
0ca6 0ca6 d 1c
0ca6 0ca6 u 01 02
0ca6 0ca6 s 		DB	GRR_SUB_PC - GRR_SUB
0ca7 0ca7 d 23
0ca7 0ca7 u 01 02
0ca7 0ca7 s 		DB	GRR_SUB_IX - GRR_SUB
0ca8 0ca8 d 27
0ca8 0ca8 u 01 02
0ca8 0ca8 s 		DB	GRR_SUB_IY - GRR_SUB
0ca9 0ca9 d 2b
0ca9 0ca9 u 01 02
0ca9 0ca9 s 		DB	GRR_SUB_IR - GRR_SUB
0caa 0caa d 32
0caa 0caa u 01 02
0caa 0caa s 		DB	GRR_SUB_AFA - GRR_SUB
0cab 0cab d 37
0cab 0cab u 01 02
0cab 0cab s 		DB	GRR_SUB_BCA - GRR_SUB
0cac 0cac d 3c
0cac 0cac u 01 02
0cac 0cac s 		DB	GRR_SUB_DEA - GRR_SUB
0cad 0cad d 41
0cad 0cad u 01 02
0cad 0cad s 		DB	GRR_SUB_HLA - GRR_SUB
0cae 0cae d 00
0cae 0cae u 01 02
0cae 0cae s 		DB	0
0caf 0caf d 00
0caf 0caf u 01 02
0caf 0caf s 		DB	0
0cb0 0cb0 d 00
0cb0 0cb0 u 01 02
0cb0 0cb0 s 		DB	0
0cb1 0cb1 s 
0cb1 0cb1 d 46
0cb1 0cb1 u 01 02
0cb1 0cb1 s PURR_TBL	DB	PURR_SUB_SP - GRR_SUB
0cb2 0cb2 d 47
0cb2 0cb2 u 01 02
0cb2 0cb2 s 		DB	PURR_SUB_AF - GRR_SUB
0cb3 0cb3 d 4e
0cb3 0cb3 u 01 02
0cb3 0cb3 s 		DB	PURR_SUB_BC - GRR_SUB
0cb4 0cb4 d 51
0cb4 0cb4 u 01 02
0cb4 0cb4 s 		DB	PURR_SUB_DE - GRR_SUB
0cb5 0cb5 d 58
0cb5 0cb5 u 01 02
0cb5 0cb5 s 		DB	PURR_SUB_HL - GRR_SUB
0cb6 0cb6 d 5f
0cb6 0cb6 u 01 02
0cb6 0cb6 s 		DB	PURR_SUB_PC - GRR_SUB
0cb7 0cb7 d 65
0cb7 0cb7 u 01 02
0cb7 0cb7 s 		DB	PURR_SUB_IX - GRR_SUB
0cb8 0cb8 d 69
0cb8 0cb8 u 01 02
0cb8 0cb8 s 		DB	PURR_SUB_IY - GRR_SUB
0cb9 0cb9 d 6d
0cb9 0cb9 u 01 02
0cb9 0cb9 s 		DB	PURR_SUB_IR - GRR_SUB
0cba 0cba d 74
0cba 0cba u 01 02
0cba 0cba s 		DB	PURR_SUB_AFA - GRR_SUB
0cbb 0cbb d 79
0cbb 0cbb u 01 02
0cbb 0cbb s 		DB	PURR_SUB_BCA - GRR_SUB
0cbc 0cbc d 7e
0cbc 0cbc u 01 02
0cbc 0cbc s 		DB	PURR_SUB_DEA - GRR_SUB
0cbd 0cbd d 83
0cbd 0cbd u 01 02
0cbd 0cbd s 		DB	PURR_SUB_HLA - GRR_SUB
0cbe 0cbe d 00
0cbe 0cbe u 01 02
0cbe 0cbe s 		DB	0
0cbf 0cbf d 00
0cbf 0cbf u 01 02
0cbf 0cbf s 		DB	0
0cc0 0cc0 d 00
0cc0 0cc0 u 01 02
0cc0 0cc0 s 		DB	0
0cc1 0cc1 s 
0cc1 0cc1 s 		;Stack holds:
0cc1 0cc1 s 		;SP	RETURN TO ISR	(CALL PUT_REG)
0cc1 0cc1 s 		;SP+2	RETURN TO VECTOR DISPATCH (CALL VCALL_HL)
0cc1 0cc1 s 		;SP+4	AF
0cc1 0cc1 s 		;SP+6	HL
0cc1 0cc1 s 		;
0cc1 0cc1 s 		;PREVIOUS STACK SAVED AT SP_ISR_SAVE
0cc1 0cc1 s 		;	RETURN TO MAIN CODE (PC)
0cc1 0cc1 s 		;
0cc1 0cc1 s 		
0cc1 0cc1 d 2a28fb
0cc1 0cc1 u 03 01
0cc1 0cc1 s GRR_SUB		LD	HL,(SP_ISR_SAVE)	;Get SP;True value of SP (prior to ISR)
0cc4 0cc4 d 23
0cc4 0cc4 u 01 01
0cc4 0cc4 s 		INC	HL
0cc5 0cc5 d 23
0cc5 0cc5 u 01 01
0cc5 0cc5 s 		INC	HL
0cc6 0cc6 d c9
0cc6 0cc6 u 01 01
0cc6 0cc6 s 		RET
0cc7 0cc7 d 210400
0cc7 0cc7 u 03 01
0cc7 0cc7 s GRR_SUB_AF	LD	HL,4		;Get AF
0cca 0cca d 39
0cca 0cca u 01 01
0cca 0cca s 		ADD	HL,SP
0ccb 0ccb d cd4a0e
0ccb 0ccb u 03 01
0ccb 0ccb s 		CALL	LD_HL_HL	;HL=(HL)
0cce 0cce d c9
0cce 0cce u 01 01
0cce 0cce s 		RET
0ccf 0ccf d c5
0ccf 0ccf u 01 01
0ccf 0ccf s GRR_SUB_BC	PUSH	BC
0cd0 0cd0 d e1
0cd0 0cd0 u 01 01
0cd0 0cd0 s 		POP	HL
0cd1 0cd1 d c9
0cd1 0cd1 u 01 01
0cd1 0cd1 s 		RET
0cd2 0cd2 d d5
0cd2 0cd2 u 01 01
0cd2 0cd2 s GRR_SUB_DE	PUSH	DE
0cd3 0cd3 d e1
0cd3 0cd3 u 01 01
0cd3 0cd3 s 		POP	HL
0cd4 0cd4 d c9
0cd4 0cd4 u 01 01
0cd4 0cd4 s 		RET
0cd5 0cd5 d 210600
0cd5 0cd5 u 03 01
0cd5 0cd5 s GRR_SUB_HL	LD	HL,6		;Get HL
0cd8 0cd8 d 39
0cd8 0cd8 u 01 01
0cd8 0cd8 s 		ADD	HL,SP
0cd9 0cd9 d cd4a0e
0cd9 0cd9 u 03 01
0cd9 0cd9 s 		CALL	LD_HL_HL	;HL=(HL)
0cdc 0cdc d c9
0cdc 0cdc u 01 01
0cdc 0cdc s 		RET
0cdd 0cdd d 2a28fb
0cdd 0cdd u 03 01
0cdd 0cdd s GRR_SUB_PC	LD	HL,(SP_ISR_SAVE) ;Get PC
0ce0 0ce0 d cd4a0e
0ce0 0ce0 u 03 01
0ce0 0ce0 s 		CALL	LD_HL_HL	;HL=(HL)
0ce3 0ce3 d c9
0ce3 0ce3 u 01 01
0ce3 0ce3 s 		RET
0ce4 0ce4 d dde5
0ce4 0ce4 u 02 01
0ce4 0ce4 s GRR_SUB_IX	PUSH	IX
0ce6 0ce6 d e1
0ce6 0ce6 u 01 01
0ce6 0ce6 s 		POP	HL
0ce7 0ce7 d c9
0ce7 0ce7 u 01 01
0ce7 0ce7 s 		RET
0ce8 0ce8 d fde5
0ce8 0ce8 u 02 01
0ce8 0ce8 s GRR_SUB_IY	PUSH	IY
0cea 0cea d e1
0cea 0cea u 01 01
0cea 0cea s 		POP	HL
0ceb 0ceb d c9
0ceb 0ceb u 01 01
0ceb 0ceb s 		RET
0cec 0cec d ed57
0cec 0cec u 02 01
0cec 0cec s GRR_SUB_IR	LD	A,I
0cee 0cee d 67
0cee 0cee u 01 01
0cee 0cee s 		LD	H,A
0cef 0cef d ed5f
0cef 0cef u 02 01
0cef 0cef s 		LD	A,R
0cf1 0cf1 d 6f
0cf1 0cf1 u 01 01
0cf1 0cf1 s 		LD	L,A
0cf2 0cf2 d c9
0cf2 0cf2 u 01 01
0cf2 0cf2 s 		RET
0cf3 0cf3 d 08
0cf3 0cf3 u 01 01
0cf3 0cf3 s GRR_SUB_AFA	EX	AF,AF'
0cf4 0cf4 d f5
0cf4 0cf4 u 01 01
0cf4 0cf4 s 		PUSH	AF
0cf5 0cf5 d 08
0cf5 0cf5 u 01 01
0cf5 0cf5 s 		EX	AF,AF'
0cf6 0cf6 d e1
0cf6 0cf6 u 01 01
0cf6 0cf6 s 		POP	HL
0cf7 0cf7 d c9
0cf7 0cf7 u 01 01
0cf7 0cf7 s 		RET
0cf8 0cf8 d d9
0cf8 0cf8 u 01 01
0cf8 0cf8 s GRR_SUB_BCA	EXX
0cf9 0cf9 d c5
0cf9 0cf9 u 01 01
0cf9 0cf9 s 		PUSH	BC
0cfa 0cfa d d9
0cfa 0cfa u 01 01
0cfa 0cfa s 		EXX
0cfb 0cfb d e1
0cfb 0cfb u 01 01
0cfb 0cfb s 		POP	HL
0cfc 0cfc d c9
0cfc 0cfc u 01 01
0cfc 0cfc s 		RET
0cfd 0cfd d d9
0cfd 0cfd u 01 01
0cfd 0cfd s GRR_SUB_DEA	EXX
0cfe 0cfe d d5
0cfe 0cfe u 01 01
0cfe 0cfe s 		PUSH	DE
0cff 0cff d d9
0cff 0cff u 01 01
0cff 0cff s 		EXX
0d00 0d00 d e1
0d00 0d00 u 01 01
0d00 0d00 s 		POP	HL
0d01 0d01 d c9
0d01 0d01 u 01 01
0d01 0d01 s 		RET
0d02 0d02 d d9
0d02 0d02 u 01 01
0d02 0d02 s GRR_SUB_HLA	EXX
0d03 0d03 d e5
0d03 0d03 u 01 01
0d03 0d03 s 		PUSH	HL
0d04 0d04 d d9
0d04 0d04 u 01 01
0d04 0d04 s 		EXX
0d05 0d05 d e1
0d05 0d05 u 01 01
0d05 0d05 s 		POP	HL
0d06 0d06 d c9
0d06 0d06 u 01 01
0d06 0d06 s 		RET
0d07 0d07 s 
0d07 0d07 s 
0d07 0d07 s 		;SP	RETURN TO ISR
0d07 0d07 s 		;SP+2	DE
0d07 0d07 s 		;SP+4	RETURN TO VECTOR DISPATCH (CALL VCALL_HL)
0d07 0d07 s 		;SP+6	RRSTATE
0d07 0d07 s 		;SP+8	AF
0d07 0d07 s 		;SP+10	HL
0d07 0d07 s 		;PREVIOUS STACK SAVED AT SP_ISR_SAVE
0d07 0d07 s 		;	RETURN TO MAIN CODE (PC)
0d07 0d07 s 
0d07 0d07 d c9
0d07 0d07 u 01 01
0d07 0d07 s PURR_SUB_SP	RET		;Do we really want to change the SP during RUN mode??? Suicide!
0d08 0d08 d 210800
0d08 0d08 u 03 01
0d08 0d08 s PURR_SUB_AF	LD	HL,8		;Get DE
0d0b 0d0b d 39
0d0b 0d0b u 01 01
0d0b 0d0b s 		ADD	HL,SP
0d0c 0d0c d c38d0c
0d0c 0d0c u 03 01
0d0c 0d0c s 		JP	PURRS_RET
0d0f 0d0f d d5
0d0f 0d0f u 01 01
0d0f 0d0f s PURR_SUB_BC	PUSH	DE
0d10 0d10 d c1
0d10 0d10 u 01 01
0d10 0d10 s 		POP	BC
0d11 0d11 d c9
0d11 0d11 u 01 01
0d11 0d11 s 		RET
0d12 0d12 d 210200
0d12 0d12 u 03 01
0d12 0d12 s PURR_SUB_DE	LD	HL,2		;10 Get DE
0d15 0d15 d 39
0d15 0d15 u 01 01
0d15 0d15 s 		ADD	HL,SP		;11
0d16 0d16 d c38d0c
0d16 0d16 u 03 01
0d16 0d16 s 		JP	PURRS_RET	;10  st=31
0d19 0d19 d 210a00
0d19 0d19 u 03 01
0d19 0d19 s PURR_SUB_HL	LD	HL,10		;Get HL
0d1c 0d1c d 39
0d1c 0d1c u 01 01
0d1c 0d1c s 		ADD	HL,SP
0d1d 0d1d d c38d0c
0d1d 0d1d u 03 01
0d1d 0d1d s 		JP	PURRS_RET
0d20 0d20 d 2a28fb
0d20 0d20 u 03 01
0d20 0d20 s PURR_SUB_PC	LD	HL,(SP_ISR_SAVE) ;Get PC
0d23 0d23 d c38d0c
0d23 0d23 u 03 01
0d23 0d23 s 		JP	PURRS_RET
0d26 0d26 d d5
0d26 0d26 u 01 01
0d26 0d26 s PURR_SUB_IX	PUSH	DE
0d27 0d27 d dde1
0d27 0d27 u 02 01
0d27 0d27 s 		POP	IX
0d29 0d29 d c9
0d29 0d29 u 01 01
0d29 0d29 s 		RET
0d2a 0d2a d d5
0d2a 0d2a u 01 01
0d2a 0d2a s PURR_SUB_IY	PUSH	DE
0d2b 0d2b d fde1
0d2b 0d2b u 02 01
0d2b 0d2b s 		POP	IY
0d2d 0d2d d c9
0d2d 0d2d u 01 01
0d2d 0d2d s 		RET
0d2e 0d2e d 7a
0d2e 0d2e u 01 01
0d2e 0d2e s PURR_SUB_IR	LD	A,D
0d2f 0d2f d ed47
0d2f 0d2f u 02 01
0d2f 0d2f s 		LD	I,A
0d31 0d31 d 7b
0d31 0d31 u 01 01
0d31 0d31 s 		LD	A,E
0d32 0d32 d ed4f
0d32 0d32 u 02 01
0d32 0d32 s 		LD	R,A
0d34 0d34 d c9
0d34 0d34 u 01 01
0d34 0d34 s 		RET
0d35 0d35 d d5
0d35 0d35 u 01 01
0d35 0d35 s PURR_SUB_AFA	PUSH	DE
0d36 0d36 d 08
0d36 0d36 u 01 01
0d36 0d36 s 		EX	AF,AF'
0d37 0d37 d f1
0d37 0d37 u 01 01
0d37 0d37 s 		POP	AF
0d38 0d38 d 08
0d38 0d38 u 01 01
0d38 0d38 s 		EX	AF,AF'
0d39 0d39 d c9
0d39 0d39 u 01 01
0d39 0d39 s 		RET
0d3a 0d3a d d5
0d3a 0d3a u 01 01
0d3a 0d3a s PURR_SUB_BCA	PUSH	DE
0d3b 0d3b d d9
0d3b 0d3b u 01 01
0d3b 0d3b s 		EXX
0d3c 0d3c d c1
0d3c 0d3c u 01 01
0d3c 0d3c s 		POP	BC
0d3d 0d3d d d9
0d3d 0d3d u 01 01
0d3d 0d3d s 		EXX
0d3e 0d3e d c9
0d3e 0d3e u 01 01
0d3e 0d3e s 		RET
0d3f 0d3f d d5
0d3f 0d3f u 01 01
0d3f 0d3f s PURR_SUB_DEA	PUSH	DE
0d40 0d40 d d9
0d40 0d40 u 01 01
0d40 0d40 s 		EXX
0d41 0d41 d d1
0d41 0d41 u 01 01
0d41 0d41 s 		POP	DE
0d42 0d42 d d9
0d42 0d42 u 01 01
0d42 0d42 s 		EXX
0d43 0d43 d c9
0d43 0d43 u 01 01
0d43 0d43 s 		RET
0d44 0d44 d d5
0d44 0d44 u 01 01
0d44 0d44 s PURR_SUB_HLA	PUSH	DE
0d45 0d45 d d9
0d45 0d45 u 01 01
0d45 0d45 s 		EXX
0d46 0d46 d e1
0d46 0d46 u 01 01
0d46 0d46 s 		POP	HL
0d47 0d47 d d9
0d47 0d47 u 01 01
0d47 0d47 s 		EXX
0d48 0d48 d c9
0d48 0d48 u 01 01
0d48 0d48 s 		RET
0d49 0d49 s 
0d49 0d49 s 
0d49 0d49 s ;=============================================================================
0d49 0d49 d cd190e
0d49 0d49 u 03 01
0d49 0d49 s SPACE_GET_BYTE	CALL	PUT_SPACE
0d4c 0d4c s 
0d4c 0d4c s ;=============================================================================
0d4c 0d4c s ;GET_BYTE -- Get byte from console as hex
0d4c 0d4c s ;
0d4c 0d4c s ;in:	Nothing
0d4c 0d4c s ;out:	A = Byte (if CY=0)  (last 2 hex characters)  Exit if Space Entered
0d4c 0d4c s ;	A = non-hex char input (if CY=1)
0d4c 0d4c s ;-----------------------------------------------------------------------------
0d4c 0d4c d cd950d
0d4c 0d4c u 03 01
0d4c 0d4c s GET_BYTE:	CALL	GET_HEX	;Get 1st HEX CHAR
0d4f 0d4f d 3006
0d4f 0d4f u 02 01
0d4f 0d4f s 		JR  NC,	GB_1
0d51 0d51 d fe20
0d51 0d51 u 02 01
0d51 0d51 s 		CP	' '		;Exit if not HEX CHAR (ignoring SPACE)
0d53 0d53 d 28f7
0d53 0d53 u 02 01
0d53 0d53 s 		JR Z,	GET_BYTE	;Loop back if first char is a SPACE
0d55 0d55 d 37
0d55 0d55 u 01 01
0d55 0d55 s 		SCF			;Set Carry
0d56 0d56 d c9
0d56 0d56 u 01 01
0d56 0d56 s 		RET			;or EXIT with delimiting char
0d57 0d57 d d5
0d57 0d57 u 01 01
0d57 0d57 s GB_1		PUSH	DE		;Process 1st HEX CHAR
0d58 0d58 d 07
0d58 0d58 u 01 01
0d58 0d58 s 		RLCA
0d59 0d59 d 07
0d59 0d59 u 01 01
0d59 0d59 s 		RLCA
0d5a 0d5a d 07
0d5a 0d5a u 01 01
0d5a 0d5a s 		RLCA
0d5b 0d5b d 07
0d5b 0d5b u 01 01
0d5b 0d5b s 		RLCA
0d5c 0d5c d e6f0
0d5c 0d5c u 02 01
0d5c 0d5c s 		AND	0xF0
0d5e 0d5e d 57
0d5e 0d5e u 01 01
0d5e 0d5e s 		LD	D,A
0d5f 0d5f d cd950d
0d5f 0d5f u 03 01
0d5f 0d5f s 		CALL	GET_HEX
0d62 0d62 d 3007
0d62 0d62 u 02 01
0d62 0d62 s 		JR  NC,	GB_2		;If 2nd char is HEX CHAR
0d64 0d64 d fe20
0d64 0d64 u 02 01
0d64 0d64 s 		CP	' '
0d66 0d66 d 2806
0d66 0d66 u 02 01
0d66 0d66 s 		JR Z,	GB_RET1
0d68 0d68 d 37
0d68 0d68 u 01 01
0d68 0d68 s 		SCF			;Set Carry
0d69 0d69 d d1
0d69 0d69 u 01 01
0d69 0d69 s 		POP	DE
0d6a 0d6a d c9
0d6a 0d6a u 01 01
0d6a 0d6a s 		RET			;or EXIT with delimiting char
0d6b 0d6b d b2
0d6b 0d6b u 01 01
0d6b 0d6b s GB_2		OR	D
0d6c 0d6c d d1
0d6c 0d6c u 01 01
0d6c 0d6c s 		POP	DE
0d6d 0d6d d c9
0d6d 0d6d u 01 01
0d6d 0d6d s 		RET
0d6e 0d6e d 7a
0d6e 0d6e u 01 01
0d6e 0d6e s GB_RET1		LD	A,D
0d6f 0d6f d 0f
0d6f 0d6f u 01 01
0d6f 0d6f s 		RRCA
0d70 0d70 d 0f
0d70 0d70 u 01 01
0d70 0d70 s 		RRCA
0d71 0d71 d 0f
0d71 0d71 u 01 01
0d71 0d71 s 		RRCA
0d72 0d72 d 0f
0d72 0d72 u 01 01
0d72 0d72 s 		RRCA
0d73 0d73 d b7
0d73 0d73 u 01 01
0d73 0d73 s GB_RET		OR	A
0d74 0d74 d d1
0d74 0d74 u 01 01
0d74 0d74 s 		POP	DE
0d75 0d75 d c9
0d75 0d75 u 01 01
0d75 0d75 s 		RET
0d76 0d76 s 
0d76 0d76 s 
0d76 0d76 s ;=============================================================================
0d76 0d76 d cd190e
0d76 0d76 u 03 01
0d76 0d76 s SPACE_GET_WORD	CALL	PUT_SPACE
0d79 0d79 s 
0d79 0d79 s ;=============================================================================
0d79 0d79 s ;GET_WORD -- Get word from console as hex (ignores initial spaces)
0d79 0d79 s ;
0d79 0d79 s ;in:	Nothing
0d79 0d79 s ;out:	c=1	A = non-hex char input (Typically Space, CR or ESC)
0d79 0d79 s ;		DE = Word
0d79 0d79 s ;out:	c=0	A = non-hex char input (No Word in DE)
0d79 0d79 s ;-----------------------------------------------------------------------------
0d79 0d79 d 110000
0d79 0d79 u 03 01
0d79 0d79 s GET_WORD:	LD	DE,0
0d7c 0d7c d cd950d
0d7c 0d7c u 03 01
0d7c 0d7c s 		CALL	GET_HEX	;Get 1st HEX CHAR ;out:	A = Value of HEX Char when CY=0
0d7f 0d7f s 							;	A = Received (non-hex) char when CY=1
0d7f 0d7f d 3006
0d7f 0d7f u 02 01
0d7f 0d7f s 		JR  NC,	GW_LP
0d81 0d81 d fe20
0d81 0d81 u 02 01
0d81 0d81 s 		CP	' '		;Exit if not HEX CHAR (ignoring SPACE)
0d83 0d83 d 28f4
0d83 0d83 u 02 01
0d83 0d83 s 		JR Z,	GET_WORD	;Loop back if first char is a SPACE
0d85 0d85 d b7
0d85 0d85 u 01 01
0d85 0d85 s 		OR	A		;Clear Carry
0d86 0d86 d c9
0d86 0d86 u 01 01
0d86 0d86 s 		RET			;or EXIT with delimiting char
0d87 0d87 d 5f
0d87 0d87 u 01 01
0d87 0d87 s GW_LP		LD	E,A		;Save first/combined char in E
0d88 0d88 d cd950d
0d88 0d88 u 03 01
0d88 0d88 s 		CALL	GET_HEX	;Get next char
0d8b 0d8b d d8
0d8b 0d8b u 01 01
0d8b 0d8b s 		RET C			;EXIT when a delimiting char is entered
0d8c 0d8c d eb
0d8c 0d8c u 01 01
0d8c 0d8c s 		EX	DE,HL		;Else, shift new HEX Char Value into DE
0d8d 0d8d d 29
0d8d 0d8d u 01 01
0d8d 0d8d s 		ADD	HL,HL		;Shift DE up 1 nibble
0d8e 0d8e d 29
0d8e 0d8e u 01 01
0d8e 0d8e s 		ADD	HL,HL
0d8f 0d8f d 29
0d8f 0d8f u 01 01
0d8f 0d8f s 		ADD	HL,HL
0d90 0d90 d 29
0d90 0d90 u 01 01
0d90 0d90 s 		ADD	HL,HL
0d91 0d91 d eb
0d91 0d91 u 01 01
0d91 0d91 s 		EX	DE,HL
0d92 0d92 d b3
0d92 0d92 u 01 01
0d92 0d92 s 		OR	E		;Combine new char with E
0d93 0d93 d 18f2
0d93 0d93 u 02 01
0d93 0d93 s 		JR	GW_LP
0d95 0d95 s 
0d95 0d95 s 
0d95 0d95 s 
0d95 0d95 s ;===============================================
0d95 0d95 s ;Get HEX CHAR
0d95 0d95 s ;in:	Nothing
0d95 0d95 s ;out:	A = Value of HEX Char when CY=0
0d95 0d95 s ;	A = Received (non-hex) char when CY=1
0d95 0d95 s ;-----------------------------------------------
0d95 0d95 d cde013
0d95 0d95 u 03 01
0d95 0d95 s GET_HEX:	CALL	GET_CHAR
0d98 0d98 s 		
0d98 0d98 s ;in:	A = CHAR
0d98 0d98 s ;out:	A = Value of HEX Char when CY=0
0d98 0d98 s ;	A = Received (non-hex) char when CY=1
0d98 0d98 d fe30
0d98 0d98 u 02 01
0d98 0d98 s ASC2HEX		CP	'0'
0d9a 0d9a d fab60d
0d9a 0d9a u 03 01
0d9a 0d9a s 		JP M,	GHC_NOT_RET
0d9d 0d9d d fe3a
0d9d 0d9d u 02 01
0d9d 0d9d s 		CP	'9'+1
0d9f 0d9f d faba0d
0d9f 0d9f u 03 01
0d9f 0d9f s 		JP M,	GHC_NRET
0da2 0da2 d fe41
0da2 0da2 u 02 01
0da2 0da2 s 		CP	'A'
0da4 0da4 d fab60d
0da4 0da4 u 03 01
0da4 0da4 s 		JP M,	GHC_NOT_RET
0da7 0da7 d fe47
0da7 0da7 u 02 01
0da7 0da7 s 		CP	'F'+1
0da9 0da9 d fab80d
0da9 0da9 u 03 01
0da9 0da9 s 		JP M,	GHC_ARET
0dac 0dac d fe61
0dac 0dac u 02 01
0dac 0dac s 		CP	'a'
0dae 0dae d fab60d
0dae 0dae u 03 01
0dae 0dae s 		JP M,	GHC_NOT_RET
0db1 0db1 d fe67
0db1 0db1 u 02 01
0db1 0db1 s 		CP	'f'+1
0db3 0db3 d fab80d
0db3 0db3 u 03 01
0db3 0db3 s 		JP M,	GHC_ARET
0db6 0db6 d 37
0db6 0db6 u 01 01
0db6 0db6 s GHC_NOT_RET	SCF
0db7 0db7 d c9
0db7 0db7 u 01 01
0db7 0db7 s 		RET
0db8 0db8 d d607
0db8 0db8 u 02 01
0db8 0db8 s GHC_ARET	SUB	07h
0dba 0dba d e60f
0dba 0dba u 02 01
0dba 0dba s GHC_NRET	AND	0Fh
0dbc 0dbc d c9
0dbc 0dbc u 01 01
0dbc 0dbc s 		RET
0dbd 0dbd s 		
0dbd 0dbd s 
0dbd 0dbd s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0dbd 0dbd s ;PRINT -- Print A null-terminated string @(HL)
0dbd 0dbd s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0dbd 0dbd d f5
0dbd 0dbd u 01 01
0dbd 0dbd s PRINT:		PUSH	AF
0dbe 0dbe d 7e
0dbe 0dbe u 01 01
0dbe 0dbe s PRINT_LP	LD	A, (HL)
0dbf 0dbf d 23
0dbf 0dbf u 01 01
0dbf 0dbf s 		INC	HL
0dc0 0dc0 d b7
0dc0 0dc0 u 01 01
0dc0 0dc0 s 		OR	A
0dc1 0dc1 d 2805
0dc1 0dc1 u 02 01
0dc1 0dc1 s 		JR Z,	PRINT_RET
0dc3 0dc3 d cdec13
0dc3 0dc3 u 03 01
0dc3 0dc3 s 		CALL	Put_Char
0dc6 0dc6 d 18f6
0dc6 0dc6 u 02 01
0dc6 0dc6 s 		JR	PRINT_LP
0dc8 0dc8 d f1
0dc8 0dc8 u 01 01
0dc8 0dc8 s PRINT_RET	POP	AF
0dc9 0dc9 d c9
0dc9 0dc9 u 01 01
0dc9 0dc9 s 		RET
0dca 0dca s 
0dca 0dca s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0dca 0dca s ;PRINT IMMEDIATE
0dca 0dca s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0dca 0dca d e3
0dca 0dca u 01 01
0dca 0dca s PRINTI:		EX	(SP),HL	;HL = Top of Stack
0dcb 0dcb d cdbd0d
0dcb 0dcb u 03 01
0dcb 0dcb s 		CALL	PRINT
0dce 0dce d e3
0dce 0dce u 01 01
0dce 0dce s 		EX	(SP),HL	;Move updated return address back to stack
0dcf 0dcf d c9
0dcf 0dcf u 01 01
0dcf 0dcf s 		RET
0dd0 0dd0 s 
0dd0 0dd0 s ;===============================================
0dd0 0dd0 s ;PRINT B-LENGTH
0dd0 0dd0 s ;-----------------------------------------------
0dd0 0dd0 d 7e
0dd0 0dd0 u 01 01
0dd0 0dd0 s PRINTB:		LD	A, (HL)
0dd1 0dd1 d cdec13
0dd1 0dd1 u 03 01
0dd1 0dd1 s 		CALL	PUT_CHAR
0dd4 0dd4 d 23
0dd4 0dd4 u 01 01
0dd4 0dd4 s 		INC	HL
0dd5 0dd5 d 10f9
0dd5 0dd5 u 02 01
0dd5 0dd5 s 		DJNZ	PRINTB
0dd7 0dd7 d c9
0dd7 0dd7 u 01 01
0dd7 0dd7 s 		RET
0dd8 0dd8 s 
0dd8 0dd8 s ;===============================================
0dd8 0dd8 s ;PUT_BC Prints BC Word
0dd8 0dd8 s ;-----------------------------------------------
0dd8 0dd8 d 78
0dd8 0dd8 u 01 01
0dd8 0dd8 s PUT_BC:		LD	A, B
0dd9 0dd9 d cdf60d
0dd9 0dd9 u 03 01
0dd9 0dd9 s 		CALL	PUT_BYTE
0ddc 0ddc d 79
0ddc 0ddc u 01 01
0ddc 0ddc s 		LD	A, C
0ddd 0ddd d cdf60d
0ddd 0ddd u 03 01
0ddd 0ddd s 		CALL	PUT_BYTE
0de0 0de0 d c9
0de0 0de0 u 01 01
0de0 0de0 s 		RET
0de1 0de1 s 
0de1 0de1 s ;===============================================
0de1 0de1 s ;PUT_DE Prints DE Word
0de1 0de1 s ;-----------------------------------------------
0de1 0de1 d 7a
0de1 0de1 u 01 01
0de1 0de1 s PUT_DE:		LD	A, D
0de2 0de2 d cdf60d
0de2 0de2 u 03 01
0de2 0de2 s 		CALL	PUT_BYTE
0de5 0de5 d 7b
0de5 0de5 u 01 01
0de5 0de5 s 		LD	A, E
0de6 0de6 d cdf60d
0de6 0de6 u 03 01
0de6 0de6 s 		CALL	PUT_BYTE
0de9 0de9 d c9
0de9 0de9 u 01 01
0de9 0de9 s 		RET
0dea 0dea s 
0dea 0dea s ;===============================================
0dea 0dea s ;PUT_HL Prints HL Word
0dea 0dea s ;-----------------------------------------------
0dea 0dea d 7c
0dea 0dea u 01 01
0dea 0dea s PUT_HL:		LD	A, H
0deb 0deb d cdf60d
0deb 0deb u 03 01
0deb 0deb s 		CALL	PUT_BYTE
0dee 0dee d 7d
0dee 0dee u 01 01
0dee 0dee s 		LD	A, L
0def 0def d cdf60d
0def 0def u 03 01
0def 0def s 		CALL	PUT_BYTE
0df2 0df2 d c9
0df2 0df2 u 01 01
0df2 0df2 s 		RET
0df3 0df3 s 
0df3 0df3 s 
0df3 0df3 s ;===============================================
0df3 0df3 s ;SPACE_PUT_BYTE -- Output (SPACE) & byte to console as hex
0df3 0df3 s ;
0df3 0df3 s ;pre:	A register contains byte to be output
0df3 0df3 s ;post:	Destroys A
0df3 0df3 s ;-----------------------------------------------
0df3 0df3 d cd190e
0df3 0df3 u 03 01
0df3 0df3 s SPACE_PUT_BYTE	CALL	PUT_SPACE
0df6 0df6 s 		
0df6 0df6 s ;===============================================
0df6 0df6 s ;PUT_BYTE -- Output byte to console as hex
0df6 0df6 s ;
0df6 0df6 s ;pre:	A register contains byte to be output
0df6 0df6 s ;-----------------------------------------------
0df6 0df6 d f5
0df6 0df6 u 01 01
0df6 0df6 s PUT_BYTE:	PUSH	AF
0df7 0df7 d f5
0df7 0df7 u 01 01
0df7 0df7 s 		PUSH	AF
0df8 0df8 d 0f
0df8 0df8 u 01 01
0df8 0df8 s 		RRCA
0df9 0df9 d 0f
0df9 0df9 u 01 01
0df9 0df9 s 		RRCA
0dfa 0dfa d 0f
0dfa 0dfa u 01 01
0dfa 0dfa s 		RRCA
0dfb 0dfb d 0f
0dfb 0dfb u 01 01
0dfb 0dfb s 		RRCA
0dfc 0dfc d e60f
0dfc 0dfc u 02 01
0dfc 0dfc s 		AND	0x0F
0dfe 0dfe d cd090e
0dfe 0dfe u 03 01
0dfe 0dfe s 		CALL	PUT_HEX
0e01 0e01 d f1
0e01 0e01 u 01 01
0e01 0e01 s 		POP	AF
0e02 0e02 d e60f
0e02 0e02 u 02 01
0e02 0e02 s 		AND	0x0F
0e04 0e04 d cd090e
0e04 0e04 u 03 01
0e04 0e04 s 		CALL	PUT_HEX
0e07 0e07 d f1
0e07 0e07 u 01 01
0e07 0e07 s 		POP	AF
0e08 0e08 d c9
0e08 0e08 u 01 01
0e08 0e08 s 		RET
0e09 0e09 s 
0e09 0e09 s ;===============================================
0e09 0e09 s ;PUT_HEX -- Convert nibble to ASCII char
0e09 0e09 s ;-----------------------------------------------
0e09 0e09 d cd0f0e
0e09 0e09 u 03 01
0e09 0e09 s PUT_HEX:	CALL	HEX2ASC
0e0c 0e0c d c3ec13
0e0c 0e0c u 03 01
0e0c 0e0c s 		JP	Put_Char
0e0f 0e0f s 
0e0f 0e0f s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0e0f 0e0f s ;HEX2ASC - Convert nibble to ASCII char
0e0f 0e0f s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0e0f 0e0f d e60f
0e0f 0e0f u 02 01
0e0f 0e0f s HEX2ASC:	AND	0xF
0e11 0e11 d c630
0e11 0e11 u 02 01
0e11 0e11 s 		ADD	A,0x30
0e13 0e13 d fe3a
0e13 0e13 u 02 01
0e13 0e13 s 		CP	0x3A
0e15 0e15 d d8
0e15 0e15 u 01 01
0e15 0e15 s 		RET C
0e16 0e16 d c607
0e16 0e16 u 02 01
0e16 0e16 s 		ADD	A,0x7
0e18 0e18 d c9
0e18 0e18 u 01 01
0e18 0e18 s 		RET
0e19 0e19 s 
0e19 0e19 s 
0e19 0e19 s ;===============================================
0e19 0e19 s ;PUT_SPACE -- Print a space to the console
0e19 0e19 s ;
0e19 0e19 s ;pre: none
0e19 0e19 s ;post: 0x20 printed to console
0e19 0e19 s ;-----------------------------------------------
0e19 0e19 d cdca0d
0e19 0e19 u 03 01
0e19 0e19 s PUT_SPACE:	CALL	PRINTI
0e1c 0e1c d 2000
0e1c 0e1c u 02 02
0e1c 0e1c s 		DB	' ',EOS
0e1e 0e1e d c9
0e1e 0e1e u 01 01
0e1e 0e1e s 		RET
0e1f 0e1f s 
0e1f 0e1f s ;===============================================
0e1f 0e1f s ;PUT_NEW_LINE -- Start a new line on the console
0e1f 0e1f s ;
0e1f 0e1f s ;pre: none
0e1f 0e1f s ;post: 
0e1f 0e1f s ;-----------------------------------------------
0e1f 0e1f d cdca0d
0e1f 0e1f u 03 01
0e1f 0e1f s PUT_NEW_LINE:	CALL	PRINTI
0e22 0e22 d 0d0a00
0e22 0e22 u 03 02
0e22 0e22 s 		DB	CR,LF,EOS
0e25 0e25 d c9
0e25 0e25 u 01 01
0e25 0e25 s 		RET
0e26 0e26 s 
0e26 0e26 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0e26 0e26 s ;Terminal Increment byte at (HL).  Do not pass 0xFF
0e26 0e26 d 34
0e26 0e26 u 01 01
0e26 0e26 s TINC:		INC	(HL)
0e27 0e27 d c0
0e27 0e27 u 01 01
0e27 0e27 s 		RET	NZ
0e28 0e28 d 35
0e28 0e28 u 01 01
0e28 0e28 s 		DEC	(HL)
0e29 0e29 d c9
0e29 0e29 u 01 01
0e29 0e29 s 		RET
0e2a 0e2a s 
0e2a 0e2a s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0e2a 0e2a d 0e01
0e2a 0e2a u 02 01
0e2a 0e2a s DELAY_100mS	LD	C,1
0e2c 0e2c d c5
0e2c 0e2c u 01 01
0e2c 0e2c s DELAY_C		PUSH	BC
0e2d 0e2d d 0600
0e2d 0e2d u 02 01
0e2d 0e2d s 		LD	B,0
0e2f 0e2f d c5
0e2f 0e2f u 01 01
0e2f 0e2f s DELAY_LP	PUSH	BC
0e30 0e30 d 10fe
0e30 0e30 u 02 01
0e30 0e30 s 		DJNZ	$		;13   * 256 / 4 = 832uSec
0e32 0e32 d c1
0e32 0e32 u 01 01
0e32 0e32 s 		POP	BC
0e33 0e33 d 10fa
0e33 0e33 u 02 01
0e33 0e33 s 		DJNZ	DELAY_LP	;~100mSEC
0e35 0e35 d 0d
0e35 0e35 u 01 01
0e35 0e35 s 		DEC	C
0e36 0e36 d 20f7
0e36 0e36 u 02 01
0e36 0e36 s 		JR  NZ,	DELAY_LP	;*4 ~= 7mSec
0e38 0e38 d c1
0e38 0e38 u 01 01
0e38 0e38 s 		POP	BC
0e39 0e39 d c9
0e39 0e39 u 01 01
0e39 0e39 s 		RET
0e3a 0e3a s 
0e3a 0e3a s ;============================================================================
0e3a 0e3a s ;	Subroutine	Delay_A
0e3a 0e3a s ;
0e3a 0e3a s ;	Entry:	A = Millisecond count
0e3a 0e3a s ;============================================================================
0e3a 0e3a d e5
0e3a 0e3a u 01 01
0e3a 0e3a s DELAY_A:	PUSH	HL			; Save count
0e3b 0e3b d 21f0ff
0e3b 0e3b u 03 01
0e3b 0e3b s 		LD	HL,TicCounter
0e3e 0e3e d 86
0e3e 0e3e u 01 01
0e3e 0e3e s 		ADD	A,(HL)			; A = cycle count
0e3f 0e3f d be
0e3f 0e3f u 01 01
0e3f 0e3f s DlyLp		CP	(HL)			; Wait required TicCounter times
0e40 0e40 d c23f0e
0e40 0e40 u 03 01
0e40 0e40 s 		JP	NZ,DlyLp		;  loop if not done
0e43 0e43 d e1
0e43 0e43 u 01 01
0e43 0e43 s 		POP	HL
0e44 0e44 d c9
0e44 0e44 u 01 01
0e44 0e44 s 		RET
0e45 0e45 s 
0e45 0e45 s 
0e45 0e45 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0e45 0e45 d 85
0e45 0e45 u 01 01
0e45 0e45 s ADD_HL_A	ADD	A,L		;4
0e46 0e46 d 6f
0e46 0e46 u 01 01
0e46 0e46 s 		LD	L,A		;4
0e47 0e47 d d0
0e47 0e47 u 01 01
0e47 0e47 s 		RET NC			;10
0e48 0e48 d 24
0e48 0e48 u 01 01
0e48 0e48 s 		INC	H
0e49 0e49 d c9
0e49 0e49 u 01 01
0e49 0e49 s 		RET
0e4a 0e4a s 
0e4a 0e4a s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0e4a 0e4a d 7e
0e4a 0e4a u 01 01
0e4a 0e4a s LD_HL_HL	LD      A,(HL)		;7
0e4b 0e4b d 23
0e4b 0e4b u 01 01
0e4b 0e4b s 		INC     HL		;6
0e4c 0e4c d 66
0e4c 0e4c u 01 01
0e4c 0e4c s 		LD      H,(HL)		;7
0e4d 0e4d d 6f
0e4d 0e4d u 01 01
0e4d 0e4d s 		LD      L,A		;4
0e4e 0e4e d c9
0e4e 0e4e u 01 01
0e4e 0e4e s 		RET			;10
0e4f 0e4f s 
0e4f 0e4f s 
0e4f 0e4f s 
0e4f 0e4f s 
0e4f 0e4f s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0e4f 0e4f s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0e4f 0e4f s ;	Chapter_6	Menu operations. ASCII HEXFILE TRANSFER
0e4f 0e4f s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0e4f 0e4f s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0e4f 0e4f s ;----------------------------------------------------------------------------------------------------; ASCII HEXFILE TRANSFER
0e4f 0e4f d cdca0d
0e4f 0e4f u 03 01
0e4f 0e4f s GETHEXFILE	CALL	PRINTI
0e52 0e52 d 0d0a57414954494e4720464f5220484558205452414e5346455200
0e52 0e52 u 1b 02
0e52 0e52 s 		DB	CR,LF,"WAITING FOR HEX TRANSFER",EOS
0e6d 0e6d s 
0e6d 0e6d d 21c30e
0e6d 0e6d u 03 01
0e6d 0e6d s 		LD	HL,READ_SERIAL	;Set Serial Port as the source for the hex file
0e70 0e70 d 225bff
0e70 0e70 u 03 01
0e70 0e70 s 		LD	(HEX_SOURCE),HL
0e73 0e73 d 210cff
0e73 0e73 u 03 01
0e73 0e73 s 		LD	HL,VIEW_FLAGS	;Clear BIT .0= No View HEX Load
0e76 0e76 d cb86
0e76 0e76 u 02 01
0e76 0e76 s 		RES	0,(HL)
0e78 0e78 d cdf41e
0e78 0e78 u 03 01
0e78 0e78 s 		CALL	READ_HEX_FILE	;CY=1 ERROR encountered,  Z=0 Time Out
0e7b 0e7b d 202b
0e7b 0e7b u 02 01
0e7b 0e7b s 		JR  NZ,	GHENDTO
0e7d 0e7d d d8
0e7d 0e7d u 01 01
0e7d 0e7d s 		RET	C		;If Error, exit without displaying "Complete" message
0e7e 0e7e s 		
0e7e 0e7e d cdca0d
0e7e 0e7e u 03 01
0e7e 0e7e s 		CALL	PRINTI
0e81 0e81 d 0d0a484558205452414e5346455220434f4d504c4554452c204c494e45533d00
0e81 0e81 u 20 02
0e81 0e81 s 		DB	CR,LF,"HEX TRANSFER COMPLETE, LINES=",EOS
0ea1 0ea1 d 2a8afa
0ea1 0ea1 u 03 01
0ea1 0ea1 s 		LD	HL,(RHF_LINES)
0ea4 0ea4 d cdea0d
0ea4 0ea4 u 03 01
0ea4 0ea4 s 		CALL	PUT_HL
0ea7 0ea7 d c9
0ea7 0ea7 u 01 01
0ea7 0ea7 s 		RET
0ea8 0ea8 s 
0ea8 0ea8 d cdca0d
0ea8 0ea8 u 03 01
0ea8 0ea8 s GHENDTO		CALL	PRINTI
0eab 0eab d 0d0a484558205452414e534645522054494d454f555400
0eab 0eab u 17 02
0eab 0eab s 		DB	CR,LF,"HEX TRANSFER TIMEOUT",EOS
0ec2 0ec2 d c9
0ec2 0ec2 u 01 01
0ec2 0ec2 s 		RET
0ec3 0ec3 s 
0ec3 0ec3 s 		;FILL LINE_BUFF WITH A SINGLE LINE FROM SERIAL PORT
0ec3 0ec3 s 		;RETURN Z=0 IF TIMED OUT (RET NZ)		
0ec3 0ec3 d cdba1e
0ec3 0ec3 u 03 01
0ec3 0ec3 s READ_SERIAL	CALL	CLEAR_LINE_BUFF
0ec6 0ec6 s 
0ec6 0ec6 d 2100fa
0ec6 0ec6 u 03 01
0ec6 0ec6 s 		LD	HL, LINE_BUFF	;Data desination @HL
0ec9 0ec9 d 0602
0ec9 0ec9 u 02 01
0ec9 0ec9 s RS_CLP		LD	B,2		;Enable ':' search for 1st char
0ecb 0ecb s 		
0ecb 0ecb d 3e75
0ecb 0ecb u 02 01
0ecb 0ecb s RS_LP		LD	A,117		;20 Second Timeout for Get char
0ecd 0ecd d cd4b14
0ecd 0ecd u 03 01
0ecd 0ecd s 		CALL	TIMED_GETCHAR
0ed0 0ed0 d 3819
0ed0 0ed0 u 02 01
0ed0 0ed0 s 		JR  C, 	RS_TIMEOUT
0ed2 0ed2 d fe1b
0ed2 0ed2 u 02 01
0ed2 0ed2 s 		CP	27
0ed4 0ed4 d 2815
0ed4 0ed4 u 02 01
0ed4 0ed4 s 		JR  Z,	RS_TIMEOUT
0ed6 0ed6 s 
0ed6 0ed6 d fe3a
0ed6 0ed6 u 02 01
0ed6 0ed6 s 		CP	':'
0ed8 0ed8 d 2802
0ed8 0ed8 u 02 01
0ed8 0ed8 s 		JR  Z,	RS_COK
0eda 0eda d 10ed
0eda 0eda u 02 01
0eda 0eda s 		DJNZ	RS_CLP
0edc 0edc s 		
0edc 0edc d 0601
0edc 0edc u 02 01
0edc 0edc s RS_COK		LD	B,1		;Disable ':' search
0ede 0ede d 77
0ede 0ede u 01 01
0ede 0ede s 		LD	(HL),A
0edf 0edf d fe0d
0edf 0edf u 02 01
0edf 0edf s 		CP	CR		;Test for CR
0ee1 0ee1 d c8
0ee1 0ee1 u 01 01
0ee1 0ee1 s 		RET	Z			
0ee2 0ee2 d fe0a
0ee2 0ee2 u 02 01
0ee2 0ee2 s 		CP	LF		;Test if LF
0ee4 0ee4 d c8
0ee4 0ee4 u 01 01
0ee4 0ee4 s 		RET	Z
0ee5 0ee5 s 
0ee5 0ee5 d 23
0ee5 0ee5 u 01 01
0ee5 0ee5 s 		INC	HL		
0ee6 0ee6 d 7d
0ee6 0ee6 u 01 01
0ee6 0ee6 s 		LD	A,L
0ee7 0ee7 d fe80
0ee7 0ee7 u 02 01
0ee7 0ee7 s 		CP	LOW LINE_BUFFEND
0ee9 0ee9 d 20e0
0ee9 0ee9 u 02 01
0ee9 0ee9 s 		JR  NZ,	RS_LP
0eeb 0eeb s 		
0eeb 0eeb d af
0eeb 0eeb u 01 01
0eeb 0eeb s RS_TIMEOUT	XOR	A	;C=0,Z=1
0eec 0eec d 3d
0eec 0eec u 01 01
0eec 0eec s 		DEC	A	;Z=0
0eed 0eed d c9
0eed 0eed u 01 01
0eed 0eed s 		RET
0eee 0eee s 
0eee 0eee s 
0eee 0eee s 
0eee 0eee s 
0eee 0eee s 
0eee 0eee s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0eee 0eee s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0eee 0eee s ;	Chapter_7	Menu operations. XMODEM FILE TRANSFER
0eee 0eee s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0eee 0eee s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0eee 0eee s ;----------------------------------------------------------------------------------------------------; XMODEM ROUTINES
0eee 0eee s 
0eee 0eee s SOH	equ	1	;Start of Header
0eee 0eee s EOT	equ	4	;End of Transmission
0eee 0eee s ACK	equ	6
0eee 0eee s DLE	equ	16
0eee 0eee s DC1	equ	17	; (X-ON)
0eee 0eee s DC3	equ	19	; (X-OFF)
0eee 0eee s NAK	equ	21
0eee 0eee s ;SYN	equ	22
0eee 0eee s CAN	equ	24	;(Cancel)
0eee 0eee s 
0eee 0eee s ;---------------------------------------------------------------------------------
0eee 0eee s ;XMODEM MENU
0eee 0eee s ;ENTRY:	TOP OF LDCK HOLDS RETURN ADDRESS (EXIT MECHANDSM IF XMODEM IS CANCELLED)
0eee 0eee s ;---------------------------------------------------------------------------------
0eee 0eee d cd190e
0eee 0eee u 03 01
0eee 0eee s XMODEM		CALL	PUT_SPACE
0ef1 0ef1 d cde013
0ef1 0ef1 u 03 01
0ef1 0ef1 s 		CALL	GET_CHAR	;get char
0ef4 0ef4 d e65f
0ef4 0ef4 u 02 01
0ef4 0ef4 s 		AND	0x5F		;to upper case
0ef6 0ef6 d fe44
0ef6 0ef6 u 02 01
0ef6 0ef6 s 		CP	'D'
0ef8 0ef8 d 280a
0ef8 0ef8 u 02 01
0ef8 0ef8 s 		JR Z,	XMDN		; D = DOWNLOAD (from memory to serial port)
0efa 0efa d fe55
0efa 0efa u 02 01
0efa 0efa s 		CP	'U'
0efc 0efc d 2821
0efc 0efc u 02 01
0efc 0efc s 		JR Z,	XMUP		; U = UPLOAD (to memory from serial port)
0efe 0efe d cdca0d
0efe 0efe u 03 01
0efe 0efe s 		CALL 	PRINTI
0f01 0f01 d 3f00
0f01 0f01 u 02 02
0f01 0f01 s 		DB	"?",EOS
0f03 0f03 d c9
0f03 0f03 u 01 01
0f03 0f03 s 		RET
0f04 0f04 s 
0f04 0f04 s ;---------------------------------------------------------------------------------
0f04 0f04 s ;XMDN - XMODEM DOWNLOAD (send file from IMSAI to Terminal)
0f04 0f04 s ;INPUT STARTING ADDRESS AND COUNT OF BLOCKS (WORD)
0f04 0f04 s ;WAIT FOR 'C' OR NAK FROM HOST TO START CRC/CS TRANSFER
0f04 0f04 s ;---------------------------------------------------------------------------------
0f04 0f04 d cd760d
0f04 0f04 u 03 01
0f04 0f04 s XMDN		CALL	SPACE_GET_WORD	;Input Address
0f07 0f07 d eb
0f07 0f07 u 01 01
0f07 0f07 s 		EX	DE,HL		;HL = Address to SAVE DATA
0f08 0f08 d cd760d
0f08 0f08 u 03 01
0f08 0f08 s 		CALL	SPACE_GET_WORD	;Input #Blocks to Send
0f0b 0f0b s 					;DE = Count of Blocks
0f0b 0f0b s 
0f0b 0f0b d 7a
0f0b 0f0b u 01 01
0f0b 0f0b s 		LD	A,D
0f0c 0f0c d b3
0f0c 0f0c u 01 01
0f0c 0f0c s 		OR	E
0f0d 0f0d d c8
0f0d 0f0d u 01 01
0f0d 0f0d s 		RET Z			;Exit if Block Count = 0
0f0e 0f0e s 
0f0e 0f0e s 	;HL = Address of data to send from the IMSAI 8080
0f0e 0f0e s 	;DE = Count of Blocks to send.
0f0e 0f0e s 
0f0e 0f0e d cd2e0f
0f0e 0f0e u 03 01
0f0e 0f0e s 		CALL	XMS_INIT	;Starts the Seq, Sets the CS/CRC format
0f11 0f11 s 					;Cancelled Transfers will cause a RET
0f11 0f11 s 
0f11 0f11 d cd520f
0f11 0f11 u 03 01
0f11 0f11 s XMDN_LP		CALL	XMS_SEND	;Sends the packet @HL, Resends if NAK
0f14 0f14 s 					;Cancelled Transfers will cause a RET
0f14 0f14 d 1b
0f14 0f14 u 01 01
0f14 0f14 s 		DEC	DE
0f15 0f15 d 7a
0f15 0f15 u 01 01
0f15 0f15 s 		LD	A,D
0f16 0f16 d b3
0f16 0f16 u 01 01
0f16 0f16 s 		OR	E
0f17 0f17 d 20f8
0f17 0f17 u 02 01
0f17 0f17 s 		JR  NZ,	XMDN_LP
0f19 0f19 s 
0f19 0f19 d cda60f
0f19 0f19 u 03 01
0f19 0f19 s 		CALL	XMS_EOT		;Send End of Transmission
0f1c 0f1c d c32a14
0f1c 0f1c u 03 01
0f1c 0f1c s 		JP	PURGE
0f1f 0f1f s 
0f1f 0f1f s 
0f1f 0f1f s ;---------------------------------------------------------------------------------
0f1f 0f1f s ;XMUP - XMODEM UPLOAD (receive file from Terminal to IMSAI 8080)
0f1f 0f1f s ;INPUT STARTING ADDRESS
0f1f 0f1f s ;SEND 'C' OR NAK TO HOST TO START CRC/CS TRANSFER
0f1f 0f1f s ;---------------------------------------------------------------------------------
0f1f 0f1f d cd760d
0f1f 0f1f u 03 01
0f1f 0f1f s XMUP		CALL	SPACE_GET_WORD	;Input Address
0f22 0f22 d eb
0f22 0f22 u 01 01
0f22 0f22 s 		EX	DE,HL		;HL = Address to SAVE DATA
0f23 0f23 s 
0f23 0f23 s 	;HL = Address of data to send from the IMSAI 8080
0f23 0f23 s 
0f23 0f23 d cd0010
0f23 0f23 u 03 01
0f23 0f23 s 		CALL	XMR_INIT	;Starts the transfer & Receives first PACKET
0f26 0f26 s 					;Cancelled Transfers will cause a RET
0f26 0f26 s 
0f26 0f26 d cd3510
0f26 0f26 u 03 01
0f26 0f26 s XMUP_LP		CALL	XMR_RECV	;Receives the next packet @HL, Resends if NAK
0f29 0f29 s 					;Cancelled Transfers will cause a RET
0f29 0f29 d 38fb
0f29 0f29 u 02 01
0f29 0f29 s 		JR C,	XMUP_LP		;Jump until EOT Received
0f2b 0f2b d c32a14
0f2b 0f2b u 03 01
0f2b 0f2b s 		JP	PURGE
0f2e 0f2e s 
0f2e 0f2e s 
0f2e 0f2e s 
0f2e 0f2e s ;---------------------------------------------------------------------------------
0f2e 0f2e s ;INIT FOR SENDING XMODEM PROTOCOL, GET NAK OR 'C', SAVE THE XMTYPE
0f2e 0f2e s ;---------------------------------------------------------------------------------
0f2e 0f2e d 3e01
0f2e 0f2e u 02 01
0f2e 0f2e s XMS_INIT	LD	A,1		;First SEQ number
0f30 0f30 d 32f3ff
0f30 0f30 u 03 01
0f30 0f30 s 		LD	(XMSEQ),A
0f33 0f33 s 
0f33 0f33 d 0621
0f33 0f33 u 02 01
0f33 0f33 s 		LD	B,33		;33 retries for initiating the transfer
0f35 0f35 d 3e0a
0f35 0f35 u 02 01
0f35 0f35 s XMS_INIT_LP	LD	A,10		;GET CHAR, 5 SECONDS TIMEOUT (EXPECT C OR NAK)
0f37 0f37 d cd4b14
0f37 0f37 u 03 01
0f37 0f37 s 		CALL	TIMED_GETCHAR
0f3a 0f3a d da450f
0f3a 0f3a u 03 01
0f3a 0f3a s 		JP C,	XMS_INIT_RT	;Cancel if Host Timed out
0f3d 0f3d s 
0f3d 0f3d d fe15
0f3d 0f3d u 02 01
0f3d 0f3d s 		CP	NAK		;If NAK, Start Checksum Download
0f3f 0f3f d 2809
0f3f 0f3f u 02 01
0f3f 0f3f s 		JR Z,	XMS_DO
0f41 0f41 d fe43
0f41 0f41 u 02 01
0f41 0f41 s 		CP	'C'		;If C, Start CRC Download
0f43 0f43 d 2805
0f43 0f43 u 02 01
0f43 0f43 s 		JR Z,	XMS_DO
0f45 0f45 d 10ee
0f45 0f45 u 02 01
0f45 0f45 s XMS_INIT_RT	DJNZ	XMS_INIT_LP	;Count down Retries
0f47 0f47 d c3da0f
0f47 0f47 u 03 01
0f47 0f47 s 		JP	XM_CANCEL	;Cancel XModem if all retries exhausted
0f4a 0f4a s 
0f4a 0f4a d 32f4ff
0f4a 0f4a u 03 01
0f4a 0f4a s XMS_DO		LD	(XMTYPE),A
0f4d 0f4d d c9
0f4d 0f4d u 01 01
0f4d 0f4d s 		RET
0f4e 0f4e s 
0f4e 0f4e s ;---------------------------------------------------------------------------------
0f4e 0f4e s ;SEND A PACKET (RESEND UPON NAK)
0f4e 0f4e s ;---------------------------------------------------------------------------------
0f4e 0f4e d 0180ff
0f4e 0f4e u 03 01
0f4e 0f4e s XMS_RESEND	LD	BC,0xFF80
0f51 0f51 d 09
0f51 0f51 u 01 01
0f51 0f51 s 		ADD	HL,BC
0f52 0f52 d d5
0f52 0f52 u 01 01
0f52 0f52 s XMS_SEND	PUSH	DE
0f53 0f53 d 3e01
0f53 0f53 u 02 01
0f53 0f53 s 		LD	A,SOH		;SEND THE HEADER FOR CRC OR CHECKSUM
0f55 0f55 d cdec13
0f55 0f55 u 03 01
0f55 0f55 s 		CALL	Put_Char
0f58 0f58 d 3af3ff
0f58 0f58 u 03 01
0f58 0f58 s 		LD	A,(XMSEQ)
0f5b 0f5b d cdec13
0f5b 0f5b u 03 01
0f5b 0f5b s 		CALL	Put_Char
0f5e 0f5e d 2f
0f5e 0f5e u 01 01
0f5e 0f5e s 		CPL
0f5f 0f5f d cdec13
0f5f 0f5f u 03 01
0f5f 0f5f s 		CALL	Put_Char
0f62 0f62 d 110000
0f62 0f62 u 03 01
0f62 0f62 s 		LD	DE,0x0000	;Init DE=0000 (CRC Accumulator)
0f65 0f65 d 0e00
0f65 0f65 u 02 01
0f65 0f65 s 		LD	C,0		;Init C=00 (CS Accumulator)
0f67 0f67 d 0680
0f67 0f67 u 02 01
0f67 0f67 s 		LD	B,128		;Count 128 bytes per block
0f69 0f69 d cd45fb
0f69 0f69 u 03 01
0f69 0f69 s XMS_BLP		CALL	GET_MEM		;Fetch bytes to send  -------------------\
0f6c 0f6c d f5
0f6c 0f6c u 01 01
0f6c 0f6c s 		PUSH	AF
0f6d 0f6d d cdec13
0f6d 0f6d u 03 01
0f6d 0f6d s 		CALL	Put_Char	;Send them
0f70 0f70 d cdd610
0f70 0f70 u 03 01
0f70 0f70 s 		CALL	CRC_UPDATE	;Update the CRC
0f73 0f73 d f1
0f73 0f73 u 01 01
0f73 0f73 s 		POP	AF
0f74 0f74 d 81
0f74 0f74 u 01 01
0f74 0f74 s 		ADD	A,C		;Update the CS
0f75 0f75 d 4f
0f75 0f75 u 01 01
0f75 0f75 s 		LD	C,A
0f76 0f76 d 23
0f76 0f76 u 01 01
0f76 0f76 s 		INC	HL		;Advance to next byte in block
0f77 0f77 d 05
0f77 0f77 u 01 01
0f77 0f77 s 		DEC	B		;Count down bytes sent
0f78 0f78 d 20ef
0f78 0f78 u 02 01
0f78 0f78 s 		JR NZ,	XMS_BLP		;Loop back until 128 bytes are sent -----^
0f7a 0f7a d 3af4ff
0f7a 0f7a u 03 01
0f7a 0f7a s 		LD	A,(XMTYPE)
0f7d 0f7d d fe15
0f7d 0f7d u 02 01
0f7d 0f7d s 		CP	NAK		;If NAK, send Checksum
0f7f 0f7f d 2805
0f7f 0f7f u 02 01
0f7f 0f7f s 		JR Z,	XMS_CS		;----------------------v
0f81 0f81 d 7a
0f81 0f81 u 01 01
0f81 0f81 s 		LD	A,D		;else, Send the CRC next
0f82 0f82 d cdec13
0f82 0f82 u 03 01
0f82 0f82 s 		CALL	Put_Char
0f85 0f85 d 4b
0f85 0f85 u 01 01
0f85 0f85 s 		LD	C,E
0f86 0f86 d 79
0f86 0f86 u 01 01
0f86 0f86 s XMS_CS		LD	A,C		;----------------------/
0f87 0f87 d cdec13
0f87 0f87 u 03 01
0f87 0f87 s 		CALL	Put_Char
0f8a 0f8a s 					;Packet Sent, get Ack/Nak Response
0f8a 0f8a d 3e78
0f8a 0f8a u 02 01
0f8a 0f8a s 		LD	A,120		;GET CHAR, 60 SECONDS TIMEOUT (EXPECT C OR NAK)
0f8c 0f8c d cd4b14
0f8c 0f8c u 03 01
0f8c 0f8c s 		CALL	TIMED_GETCHAR
0f8f 0f8f d d1
0f8f 0f8f u 01 01
0f8f 0f8f s 		POP	DE
0f90 0f90 d 3848
0f90 0f90 u 02 01
0f90 0f90 s 		JR C,	XM_CANCEL	;Cancel download if no response within 45 seconds
0f92 0f92 d fe15
0f92 0f92 u 02 01
0f92 0f92 s 		CP	NAK
0f94 0f94 d 28b8
0f94 0f94 u 02 01
0f94 0f94 s 		JR Z,	XMS_RESEND	;Loop back to resend packet
0f96 0f96 d fe18
0f96 0f96 u 02 01
0f96 0f96 s 		CP	CAN
0f98 0f98 d 2840
0f98 0f98 u 02 01
0f98 0f98 s 		JR Z,	XM_CANCEL
0f9a 0f9a d fe06
0f9a 0f9a u 02 01
0f9a 0f9a s 		CP	ACK
0f9c 0f9c d 203c
0f9c 0f9c u 02 01
0f9c 0f9c s 		JR NZ,	XM_CANCEL
0f9e 0f9e s 
0f9e 0f9e d 3af3ff
0f9e 0f9e u 03 01
0f9e 0f9e s 		LD	A,(XMSEQ)
0fa1 0fa1 d 3c
0fa1 0fa1 u 01 01
0fa1 0fa1 s 		INC	A		;NEXT SEQ
0fa2 0fa2 d 32f3ff
0fa2 0fa2 u 03 01
0fa2 0fa2 s 		LD	(XMSEQ),A
0fa5 0fa5 d c9
0fa5 0fa5 u 01 01
0fa5 0fa5 s 		RET
0fa6 0fa6 s 
0fa6 0fa6 s 
0fa6 0fa6 s ;---------------------------------------------------------------------------------
0fa6 0fa6 s ;XMDN - DOWNLOAD XMODEM PACKET
0fa6 0fa6 s ;---------------------------------------------------------------------------------
0fa6 0fa6 d 3e04
0fa6 0fa6 u 02 01
0fa6 0fa6 s XMS_EOT		LD	A,EOT		;HANDLE THE END OF TRANSFER FOR CRC OR CHECKSUM
0fa8 0fa8 d cdec13
0fa8 0fa8 u 03 01
0fa8 0fa8 s 		CALL	Put_Char
0fab 0fab d 3e78
0fab 0fab u 02 01
0fab 0fab s 		LD	A,120		;GET CHAR, 60 SECONDS TIMEOUT (EXPECT C OR NAK)
0fad 0fad d cd4b14
0fad 0fad u 03 01
0fad 0fad s 		CALL	TIMED_GETCHAR
0fb0 0fb0 d 3828
0fb0 0fb0 u 02 01
0fb0 0fb0 s 		JR C,	XM_CANCEL
0fb2 0fb2 d fe15
0fb2 0fb2 u 02 01
0fb2 0fb2 s 		CP	NAK
0fb4 0fb4 d 28f0
0fb4 0fb4 u 02 01
0fb4 0fb4 s 		JR Z,	XMS_EOT
0fb6 0fb6 d fe06
0fb6 0fb6 u 02 01
0fb6 0fb6 s 		CP	ACK
0fb8 0fb8 d 2020
0fb8 0fb8 u 02 01
0fb8 0fb8 s 		JR NZ,	XM_CANCEL
0fba 0fba s 
0fba 0fba d cd2a14
0fba 0fba u 03 01
0fba 0fba s XM_DONE		CALL	PURGE
0fbd 0fbd d cdca0d
0fbd 0fbd u 03 01
0fbd 0fbd s 		CALL	PRINTI
0fc0 0fc0 d 0d0a5452414e5346455220434f4d504c4554455c725c6e00
0fc0 0fc0 u 18 02
0fc0 0fc0 s 		DB	CR,LF,"TRANSFER COMPLETE\r\n",EOS
0fd8 0fd8 d af
0fd8 0fd8 u 01 01
0fd8 0fd8 s 		XOR	A		;CLEAR A, CY
0fd9 0fd9 d c9
0fd9 0fd9 u 01 01
0fd9 0fd9 s 		RET
0fda 0fda s 
0fda 0fda s ;FINISHING CODE PRIOR TO LEAVING XMODEM
0fda 0fda d 3e18
0fda 0fda u 02 01
0fda 0fda s XM_CANCEL	LD	A,CAN
0fdc 0fdc d cdec13
0fdc 0fdc u 03 01
0fdc 0fdc s 		CALL	Put_Char
0fdf 0fdf d cdec13
0fdf 0fdf u 03 01
0fdf 0fdf s 		CALL	Put_Char
0fe2 0fe2 d cd2a14
0fe2 0fe2 u 03 01
0fe2 0fe2 s 		CALL	PURGE
0fe5 0fe5 d cdca0d
0fe5 0fe5 u 03 01
0fe5 0fe5 s 		CALL	PRINTI
0fe8 0fe8 d 5452414e534645522043414e43454c45445c725c6e00
0fe8 0fe8 u 16 02
0fe8 0fe8 s 		DB	"TRANSFER CANCELED\r\n",EOS
0ffe 0ffe d c1
0ffe 0ffe u 01 01
0ffe 0ffe s 		POP	BC		;SCRAP CALLING ROUTINE AND HEAD TO PARENT
0fff 0fff d c9
0fff 0fff u 01 01
0fff 0fff s 		RET
1000 1000 s 
1000 1000 s 
1000 1000 s 
1000 1000 s 
1000 1000 s 
1000 1000 s 
1000 1000 s ;---------------------------------------------------------------------------------
1000 1000 s ;START XMODEM RECEIVING and RECEIVE FIRST PACKET
1000 1000 s ;---------------------------------------------------------------------------------
1000 1000 d 1e14
1000 1000 u 02 01
1000 1000 s XMR_INIT	LD	E,20		;20 ATTEMPTS TO INITIATE XMODEM CRC TRANSFER
1002 1002 d 3e01
1002 1002 u 02 01
1002 1002 s 		LD	A,1		;EXPECTED SEQ NUMBER starts at 1
1004 1004 d 32f3ff
1004 1004 u 03 01
1004 1004 s 		LD	(XMSEQ),A
1007 1007 d cd2a14
1007 1007 u 03 01
1007 1007 s XMR_CRC		CALL	PURGE
100a 100a d 3e43
100a 100a u 02 01
100a 100a s 		LD	A,'C'		;Send C
100c 100c d 32f4ff
100c 100c u 03 01
100c 100c s 		LD	(XMTYPE),A	;Save as XM Type (CRC or CS)
100f 100f d cdec13
100f 100f u 03 01
100f 100f s 		CALL	Put_Char
1012 1012 d cdb310
1012 1012 u 03 01
1012 1012 s 		CALL	XMGET_HDR	;Await a packet
1015 1015 d 3038
1015 1015 u 02 01
1015 1015 s 		JR NC,	XMR_TSEQ	;Jump if first packet received
1017 1017 d 20c1
1017 1017 u 02 01
1017 1017 s 		JR NZ,	XM_CANCEL	;Cancel if there was a response that was not a header
1019 1019 d 1d
1019 1019 u 01 01
1019 1019 s 		DEC	E		;Otherwise, if no response, retry a few times
101a 101a d 20eb
101a 101a u 02 01
101a 101a s 		JR NZ,	XMR_CRC
101c 101c s 
101c 101c d 1e14
101c 101c u 02 01
101c 101c s 		LD	E,20		;20 ATTEMPTS TO INITIATE XMODEM CHECKSUM TRANSFER
101e 101e d cd2a14
101e 101e u 03 01
101e 101e s XMR_CS		CALL	PURGE
1021 1021 d 3e15
1021 1021 u 02 01
1021 1021 s 		LD	A,NAK		;Send NAK
1023 1023 d 32f4ff
1023 1023 u 03 01
1023 1023 s 		LD	(XMTYPE),A	;Save as XM Type (CRC or CS)
1026 1026 d cdec13
1026 1026 u 03 01
1026 1026 s 		CALL	Put_Char
1029 1029 d cdb310
1029 1029 u 03 01
1029 1029 s 		CALL	XMGET_HDR	;Await a packet
102c 102c d 3021
102c 102c u 02 01
102c 102c s 		JR NC,	XMR_TSEQ	;Jump if first packet received
102e 102e d 20aa
102e 102e u 02 01
102e 102e s 		JR NZ,	XM_CANCEL	;Cancel if there was a response that was not a header
1030 1030 d 1d
1030 1030 u 01 01
1030 1030 s 		DEC	E		;Otherwise, if no response, retry a few times
1031 1031 d 20eb
1031 1031 u 02 01
1031 1031 s 		JR NZ,	XMR_CS
1033 1033 d 18a5
1033 1033 u 02 01
1033 1033 s 		JR	XM_CANCEL	;Abort
1035 1035 s 
1035 1035 s 
1035 1035 s ;--------------------- XMODEM RECEIVE
1035 1035 s ;Entry:	XMR_TSEQ in the middle of the routine
1035 1035 s ;Pre:	C=1 (expected first block as received when negogiating CRC or Checksum)
1035 1035 s ;	HL=Memory to dump the file to
1035 1035 s ;Uses:	B to count the 128 bytes per block
1035 1035 s ;	C to track Block Number expected
1035 1035 s ;	DE as CRC (Within Loop) (D is destroyed when Getting Header)
1035 1035 s ;------------------------------------
1035 1035 d 3e06
1035 1035 u 02 01
1035 1035 s XMR_RECV	LD	A,ACK		;Send Ack to start Receiving next packet
1037 1037 d cdec13
1037 1037 u 03 01
1037 1037 s 		CALL	Put_Char
103a 103a d cdb310
103a 103a u 03 01
103a 103a s XMR_LP		CALL	XMGET_HDR
103d 103d d 3010
103d 103d u 02 01
103d 103d s 		JR NC,	XMR_TSEQ
103f 103f d e5
103f 103f u 01 01
103f 103f s 		PUSH	HL
1040 1040 d 2865
1040 1040 u 02 01
1040 1040 s 		JR Z,	XMR_NAK		;NACK IF TIMED OUT
1042 1042 d e1
1042 1042 u 01 01
1042 1042 s 		POP	HL
1043 1043 d fe04
1043 1043 u 02 01
1043 1043 s 		CP	EOT
1045 1045 d 2093
1045 1045 u 02 01
1045 1045 s 		JR NZ,	XM_CANCEL	;CANCEL IF CAN RECEIVED (OR JUST NOT EOT)
1047 1047 d 3e06
1047 1047 u 02 01
1047 1047 s 		LD	A,ACK
1049 1049 d cdec13
1049 1049 u 03 01
1049 1049 s 		CALL	Put_Char
104c 104c d c3ba0f
104c 104c u 03 01
104c 104c s 		JP	XM_DONE
104f 104f s 
104f 104f d 4f
104f 104f u 01 01
104f 104f s XMR_TSEQ	LD	C,A
1050 1050 d 3af3ff
1050 1050 u 03 01
1050 1050 s 		LD	A,(XMSEQ)
1053 1053 d b9
1053 1053 u 01 01
1053 1053 s 		CP	C		;CHECK IF THIS SEQ IS EXPECTED
1054 1054 d 280d
1054 1054 u 02 01
1054 1054 s 		JR Z,	XMR_SEQ_OK	;Jump if CORRECT SEQ
1056 1056 d 3d
1056 1056 u 01 01
1056 1056 s 		DEC	A		;Else test if Previous SEQ
1057 1057 d 32f3ff
1057 1057 u 03 01
1057 1057 s 		LD	(XMSEQ),A
105a 105a d b9
105a 105a u 01 01
105a 105a s 		CP	C
105b 105b d c2da0f
105b 105b u 03 01
105b 105b s 		JP NZ,	XM_CANCEL	;CANCEL IF SEQUENCE ISN'T PREVIOUS BLOCK
105e 105e d cd2a14
105e 105e u 03 01
105e 105e s 		CALL	PURGE		;ELSE, PURGE AND SEND ACK (ASSUMING PREVIOUS ACK WAS NOT RECEIVED)
1061 1061 d 183a
1061 1061 u 02 01
1061 1061 s 		JR	XMR_ACK
1063 1063 s 
1063 1063 d 0680
1063 1063 u 02 01
1063 1063 s XMR_SEQ_OK	LD	B,128		;128 BYTES PER BLOCK
1065 1065 d 0e00
1065 1065 u 02 01
1065 1065 s 		LD	C,0		;Clear Checksum
1067 1067 d 110000
1067 1067 u 03 01
1067 1067 s 		LD	DE,0x0000	;CLEAR CRC
106a 106a d e5
106a 106a u 01 01
106a 106a s 		PUSH	HL		;Save HL where block is to go
106b 106b d cd4914
106b 106b u 03 01
106b 106b s XMR_BLK_LP	CALL	TIMED1_GETCHAR
106e 106e d 3837
106e 106e u 02 01
106e 106e s 		JR C,	XMR_NAK
1070 1070 d 77
1070 1070 u 01 01
1070 1070 s 		LD	(HL),A		;SAVE DATA BYTE
1071 1071 d cdd610
1071 1071 u 03 01
1071 1071 s 		CALL	CRC_UPDATE
1074 1074 d 7e
1074 1074 u 01 01
1074 1074 s 		LD	A,(HL)		;Update checksum
1075 1075 d 81
1075 1075 u 01 01
1075 1075 s 		ADD	A,C
1076 1076 d 4f
1076 1076 u 01 01
1076 1076 s 		LD	C,A
1077 1077 d 23
1077 1077 u 01 01
1077 1077 s 		INC	HL		;ADVANCE
1078 1078 d 05
1078 1078 u 01 01
1078 1078 s 		DEC	B
1079 1079 d 20f0
1079 1079 u 02 01
1079 1079 s 		JR NZ,	XMR_BLK_LP
107b 107b s 					;After 128 byte packet, verify error checking byte(s)
107b 107b d 3af4ff
107b 107b u 03 01
107b 107b s 		LD	A,(XMTYPE)	;Determine if we are using CRC or Checksum
107e 107e d fe15
107e 107e u 02 01
107e 107e s 		CP	NAK		;If NAK, then use Checksum
1080 1080 d 2812
1080 1080 u 02 01
1080 1080 s 		JR Z,	XMR_CCS
1082 1082 d cd4914
1082 1082 u 03 01
1082 1082 s 		CALL	TIMED1_GETCHAR
1085 1085 d 3820
1085 1085 u 02 01
1085 1085 s 		JR C,	XMR_NAK
1087 1087 d ba
1087 1087 u 01 01
1087 1087 s 		CP	D
1088 1088 d 201d
1088 1088 u 02 01
1088 1088 s 		JR NZ,	XMR_NAK
108a 108a d cd4914
108a 108a u 03 01
108a 108a s 		CALL	TIMED1_GETCHAR
108d 108d d 3818
108d 108d u 02 01
108d 108d s 		JR C,	XMR_NAK
108f 108f d bb
108f 108f u 01 01
108f 108f s 		CP	E
1090 1090 d 2015
1090 1090 u 02 01
1090 1090 s 		JR NZ,	XMR_NAK
1092 1092 d 1809
1092 1092 u 02 01
1092 1092 s 		JR	XMR_ACK
1094 1094 s 
1094 1094 d cd4914
1094 1094 u 03 01
1094 1094 s XMR_CCS		CALL	TIMED1_GETCHAR
1097 1097 d daa710
1097 1097 u 03 01
1097 1097 s 		JP C,	XMR_NAK
109a 109a d b9
109a 109a u 01 01
109a 109a s 		CP	C
109b 109b d 200a
109b 109b u 02 01
109b 109b s 		JR NZ,	XMR_NAK
109d 109d s 
109d 109d s 		;If we were transfering to a FILE, this is where we would write the
109d 109d s 		;sector and reset HL to the same 128 byte sector buffer.
109d 109d s 		;CALL	WRITE_SECTOR
109d 109d s 
109d 109d s XMR_ACK		;LD	A,ACK		;The sending of the Ack is done by
109d 109d s 		;CALL	Put_Char	;the calling routine, to allow writes to disk
109d 109d d 3af3ff
109d 109d u 03 01
109d 109d s 		LD	A,(XMSEQ)
10a0 10a0 d 3c
10a0 10a0 u 01 01
10a0 10a0 s 		INC	A		;Advance to next SEQ BLOCK
10a1 10a1 d 32f3ff
10a1 10a1 u 03 01
10a1 10a1 s 		LD	(XMSEQ),A
10a4 10a4 d c1
10a4 10a4 u 01 01
10a4 10a4 s 		POP	BC
10a5 10a5 d 37
10a5 10a5 u 01 01
10a5 10a5 s 		SCF			;Carry set when NOT last packet
10a6 10a6 d c9
10a6 10a6 u 01 01
10a6 10a6 s 		RET
10a7 10a7 s 
10a7 10a7 d e1
10a7 10a7 u 01 01
10a7 10a7 s XMR_NAK		POP	HL		;Return HL to start of block
10a8 10a8 d cd2a14
10a8 10a8 u 03 01
10a8 10a8 s 		CALL	PURGE
10ab 10ab d 3e15
10ab 10ab u 02 01
10ab 10ab s 		LD	A,NAK
10ad 10ad d cdec13
10ad 10ad u 03 01
10ad 10ad s 		CALL	Put_Char
10b0 10b0 d c33a10
10b0 10b0 u 03 01
10b0 10b0 s 		JP	XMR_LP
10b3 10b3 s 
10b3 10b3 s 
10b3 10b3 s ;--------------------- XMODEM - GET HEADER
10b3 10b3 s ;
10b3 10b3 s ;pre:	Nothing
10b3 10b3 s ;post:	Carry Set: A=0, (Zero set) if Timeout
10b3 10b3 s ;	Carry Set: A=CAN (Not Zero) if Cancel received
10b3 10b3 s ;	Carry Set: A=EOT (Not Zero) if End of Tranmission received
10b3 10b3 s ;	Carry Clear and A = B = Seq if Header found and is good
10b3 10b3 s ;------------------------------------------
10b3 10b3 d 3e06
10b3 10b3 u 02 01
10b3 10b3 s XMGET_HDR	LD	A,6		;GET CHAR, 3 SECONDS TIMEOUT (EXPECT SOH)
10b5 10b5 d cd4b14
10b5 10b5 u 03 01
10b5 10b5 s 		CALL	TIMED_GETCHAR
10b8 10b8 d d8
10b8 10b8 u 01 01
10b8 10b8 s 		RET C			;Return if Timed out
10b9 10b9 d fe01
10b9 10b9 u 02 01
10b9 10b9 s 		CP	SOH		;TEST IF START OF HEADER
10bb 10bb d 280b
10bb 10bb u 02 01
10bb 10bb s 		JR Z,	GS_SEQ		;IF SOH RECEIVED, GET SEQ NEXT
10bd 10bd d fe04
10bd 10bd u 02 01
10bd 10bd s 		CP	EOT		;TEST IF END OF TRANSMISSION
10bf 10bf d 2804
10bf 10bf u 02 01
10bf 10bf s 		JR Z,	GS_ESC		;IF EOT RECEIVED, TERMINATE XMODEM
10c1 10c1 d fe18
10c1 10c1 u 02 01
10c1 10c1 s 		CP	CAN		;TEST IF CANCEL
10c3 10c3 d 20ee
10c3 10c3 u 02 01
10c3 10c3 s 		JR NZ,	XMGET_HDR
10c5 10c5 d b7
10c5 10c5 u 01 01
10c5 10c5 s GS_ESC		OR	A		;Clear Z flag (because A<>0)
10c6 10c6 d 37
10c6 10c6 u 01 01
10c6 10c6 s 		SCF
10c7 10c7 d c9
10c7 10c7 u 01 01
10c7 10c7 s 		RET
10c8 10c8 d cd4914
10c8 10c8 u 03 01
10c8 10c8 s GS_SEQ		CALL	TIMED1_GETCHAR	;GET SEQ CHAR
10cb 10cb d d8
10cb 10cb u 01 01
10cb 10cb s 		RET C			;Return if Timed out
10cc 10cc d 47
10cc 10cc u 01 01
10cc 10cc s 		LD	B,A		;SAVE SEQ
10cd 10cd d cd4914
10cd 10cd u 03 01
10cd 10cd s 		CALL	TIMED1_GETCHAR	;GET SEQ COMPLEMENT
10d0 10d0 d d8
10d0 10d0 u 01 01
10d0 10d0 s 		RET C			;Return if Timed out
10d1 10d1 d 2f
10d1 10d1 u 01 01
10d1 10d1 s 		CPL
10d2 10d2 d b8
10d2 10d2 u 01 01
10d2 10d2 s 		CP	B		;TEST IF SEQ VALID
10d3 10d3 d 20de
10d3 10d3 u 02 01
10d3 10d3 s 		JR NZ,	XMGET_HDR	;LOOP BACK AND TRY AGAIN IF HEADER INCORRECT (SYNC FRAME)
10d5 10d5 d c9
10d5 10d5 u 01 01
10d5 10d5 s 		RET
10d6 10d6 s 
10d6 10d6 s ;------------------------------------------ CRC_UPDATE
10d6 10d6 s ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
10d6 10d6 s ;Total Time=775 cycles = 388uSec
10d6 10d6 s ;In:	A  = New char to roll into CRC accumulator
10d6 10d6 s ;	DE = 16bit CRC accumulator
10d6 10d6 s ;Out:	DE = 16bit CRC accumulator
10d6 10d6 s ;------------------------------------------
10d6 10d6 s ;CRC_UPDATE	XOR	D		;4
10d6 10d6 s ;		LD	D,A		;5
10d6 10d6 s ;		PUSH	BC		;11
10d6 10d6 s ;		LD	B,8		;7	PRELOOP=27
10d6 10d6 s ;CRCU_LP	OR	A		;4	CLEAR CARRY
10d6 10d6 s ;		LD	A,E		;5
10d6 10d6 s ;		RLA			;4
10d6 10d6 s ;		LD	E,A		;5
10d6 10d6 s ;		LD	A,D		;5
10d6 10d6 s ;		RLA			;4
10d6 10d6 s ;		LD	D,A		;5
10d6 10d6 s ;		JP NC,	CRCU_NX		;10
10d6 10d6 s ;		LD	A,D		;5
10d6 10d6 s ;		XOR	0x10		;7
10d6 10d6 s ;		LD	D,A		;5
10d6 10d6 s ;		LD	A,E		;5
10d6 10d6 s ;		XOR	0x21		;7
10d6 10d6 s ;		LD	E,A		;5
10d6 10d6 s ;CRCU_NX	DEC	B		;5
10d6 10d6 s ;		JP NZ,	CRCU_LP		;10	LOOP=91*8 (WORSE CASE)
10d6 10d6 s ;		POP	BC		;10	POSTLOOP=20
10d6 10d6 s ;		RET			;10
10d6 10d6 s 
10d6 10d6 s 
10d6 10d6 s ;------------------------------------------ CRC_UPDATE
10d6 10d6 s ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
10d6 10d6 s ;Total Time=604 cycles = 302uSec MAX
10d6 10d6 s ;In:	A  = New char to roll into CRC accumulator
10d6 10d6 s ;	DE = 16bit CRC accumulator
10d6 10d6 s ;Out:	DE = 16bit CRC accumulator
10d6 10d6 s ;------------------------------------------
10d6 10d6 d eb
10d6 10d6 u 01 01
10d6 10d6 s CRC_UPDATE	EX	DE,HL			;4
10d7 10d7 d ac
10d7 10d7 u 01 01
10d7 10d7 s 		XOR	H		;4
10d8 10d8 d 67
10d8 10d8 u 01 01
10d8 10d8 s 		LD	H,A		;5
10d9 10d9 d 29
10d9 10d9 u 01 01
10d9 10d9 s 		ADD	HL,HL		;10	Shift HL Left 1
10da 10da d dcfb10
10da 10da u 03 01
10da 10da s 		CALL C,	CRC_UPC		;17 (10/61)
10dd 10dd d 29
10dd 10dd u 01 01
10dd 10dd s 		ADD	HL,HL		;10	Shift HL Left 2
10de 10de d dcfb10
10de 10de u 03 01
10de 10de s 		CALL C,	CRC_UPC		;17
10e1 10e1 d 29
10e1 10e1 u 01 01
10e1 10e1 s 		ADD	HL,HL		;10	Shift HL Left 3
10e2 10e2 d dcfb10
10e2 10e2 u 03 01
10e2 10e2 s 		CALL C,	CRC_UPC		;17
10e5 10e5 d 29
10e5 10e5 u 01 01
10e5 10e5 s 		ADD	HL,HL		;10	Shift HL Left 4
10e6 10e6 d dcfb10
10e6 10e6 u 03 01
10e6 10e6 s 		CALL C,	CRC_UPC		;17
10e9 10e9 d 29
10e9 10e9 u 01 01
10e9 10e9 s 		ADD	HL,HL		;10	Shift HL Left 5
10ea 10ea d dcfb10
10ea 10ea u 03 01
10ea 10ea s 		CALL C,	CRC_UPC		;17
10ed 10ed d 29
10ed 10ed u 01 01
10ed 10ed s 		ADD	HL,HL		;10	Shift HL Left 6
10ee 10ee d dcfb10
10ee 10ee u 03 01
10ee 10ee s 		CALL C,	CRC_UPC		;17
10f1 10f1 d 29
10f1 10f1 u 01 01
10f1 10f1 s 		ADD	HL,HL		;10	Shift HL Left 7
10f2 10f2 d dcfb10
10f2 10f2 u 03 01
10f2 10f2 s 		CALL C,	CRC_UPC		;17
10f5 10f5 d 29
10f5 10f5 u 01 01
10f5 10f5 s 		ADD	HL,HL		;10	Shift HL Left 8
10f6 10f6 d dcfb10
10f6 10f6 u 03 01
10f6 10f6 s 		CALL C,	CRC_UPC		;17
10f9 10f9 d eb
10f9 10f9 u 01 01
10f9 10f9 s 		EX	DE,HL			;4
10fa 10fa d c9
10fa 10fa u 01 01
10fa 10fa s 		RET			;10
10fb 10fb s 
10fb 10fb d 7c
10fb 10fb u 01 01
10fb 10fb s CRC_UPC		LD	A,H		;5
10fc 10fc d ee10
10fc 10fc u 02 01
10fc 10fc s 		XOR	0x10		;7
10fe 10fe d 67
10fe 10fe u 01 01
10fe 10fe s 		LD	H,A		;5
10ff 10ff d 7d
10ff 10ff u 01 01
10ff 10ff s 		LD	A,L		;5
1100 1100 d ee21
1100 1100 u 02 01
1100 1100 s 		XOR	0x21		;7
1102 1102 d 6f
1102 1102 u 01 01
1102 1102 s 		LD	L,A		;5
1103 1103 d c9
1103 1103 u 01 01
1103 1103 s 		RET			;10
1104 1104 s 
1104 1104 s 
1104 1104 s ;XModem implementation on 8080 Monitor (CP/M-80)
1104 1104 s ;
1104 1104 s ;Terminal uploads to 8080 system:
1104 1104 s ;-Terminal user enters command "XU aaaa"
1104 1104 s ;-8080 "drives" the protocol since it's the receiver
1104 1104 s ;-8080 sends <Nak> every 10 seconds until the transmitter sends a packet
1104 1104 s ;-if transmitter does not begin within 10 trys (100 seconds), 8080 aborts XMODEM
1104 1104 s ;-a packet is:
1104 1104 s ; <SOH> [seq] [NOT seq] [128 bytes of data] [checksum or CRC]
1104 1104 s ;
1104 1104 s ;<SOH> = 1 (Start of Header)
1104 1104 s ;<EOT> = 4 (End of Transmission)
1104 1104 s ;<ACK> = 6
1104 1104 s ;<DLE> = 16
1104 1104 s ;<DC1> = 17 (X-ON)
1104 1104 s ;<DC3> = 19 (X-OFF)
1104 1104 s ;<NAK> = 21
1104 1104 s ;<SYN> = 22
1104 1104 s ;<CAN> = 24 (Cancel)
1104 1104 s ;
1104 1104 s ;Checksum is the ModuLOW 256 sum of all 128 data bytes
1104 1104 s ;
1104 1104 s ;                                     <<<<<          [NAK]
1104 1104 s ;       [SOH][001][255][...][csum]    >>>>>
1104 1104 s ;                                     <<<<<          [ACK]
1104 1104 s ;       [SOH][002][254][...][csum]    >>>>>
1104 1104 s ;                                     <<<<<          [ACK]
1104 1104 s ;       [SOH][003][253][...][csum]    >>>>>
1104 1104 s ;                                     <<<<<          [ACK]
1104 1104 s ;       [EOT]                         >>>>>
1104 1104 s ;                                     <<<<<          [ACK]
1104 1104 s ;
1104 1104 s ;-if we get <EOT> then ACK and terminate XModem
1104 1104 s ;-if we get <CAN> then terminate XModem
1104 1104 s ;-if checksum invalid, then NAK
1104 1104 s ;-if seq number not correct as per [NOT seq], then NAK
1104 1104 s ;-if seq number = previous number, then ACK (But ignore block)
1104 1104 s ;-if seq number not the expected number, then <CAN><CAN> and terminate XModem
1104 1104 s ;-if data not received after 10 seconds, then NAK (inc Timeout Retry)
1104 1104 s ;-if timeout retry>10 then <CAN><CAN> and terminate XModem
1104 1104 s ;
1104 1104 s ;-To keep synchronized,
1104 1104 s ;  -Look for <SOH>, qualify <SOH> by checking the [seq] / [NOT seq]
1104 1104 s ;  -if no <SOH> found after 135 chars, then NAK
1104 1104 s ;
1104 1104 s ;-False EOT condtion
1104 1104 s ;  -NAK the first EOT
1104 1104 s ;  -if the next char is EOT again, then ACK and leave XModem
1104 1104 s ;
1104 1104 s ;-False <CAN>, expect a 2nd <CAN> ?
1104 1104 s ;
1104 1104 s ;-Using CRC, send "C" instead of <NAK> for the first packet
1104 1104 s ;  -Send "C" every 3 seconds for 3 tries, then degrade to checksums by sending <NAK>
1104 1104 s ;
1104 1104 s ;
1104 1104 s ;
1104 1104 s ;* The character-receive subroutine should be called with a
1104 1104 s ;parameter specifying the number of seconds to wait.  The
1104 1104 s ;receiver should first call it with a time of 10, then <nak> and
1104 1104 s ;try again, 10 times.
1104 1104 s ;  After receiving the <soh>, the receiver should call the
1104 1104 s ;character receive subroutine with a 1-second timeout, for the
1104 1104 s ;remainder of the message and the <cksum>.  Since they are sent
1104 1104 s ;as a continuous stream, timing out of this implies a serious
1104 1104 s ;like glitch that caused, say, 127 characters to be seen instead
1104 1104 s ;of 128.
1104 1104 s ;
1104 1104 s ;* When the receiver wishes to <nak>, it should call a "PURGE"
1104 1104 s ;subroutine, to wait for the line to clear.  Recall the sender
1104 1104 s ;tosses any characters in its UART buffer immediately upon
1104 1104 s ;completing sending a block, to ensure no glitches were mis-
1104 1104 s ;interpreted.
1104 1104 s ;  The most common technique is for "PURGE" to call the
1104 1104 s ;character receive subroutine, specifying a 1-second timeout,
1104 1104 s ;and looping back to PURGE until a timeout occurs.  The <nak> is
1104 1104 s ;then sent, ensuring the other end will see it.
1104 1104 s ;
1104 1104 s ;* You may wish to add code recommended by Jonh Mahr to your
1104 1104 s ;character receive routine - to set an error flag if the UART
1104 1104 s ;shows framing error, or overrun.  This will help catch a few
1104 1104 s ;more glitches - the most common of which is a hit in the high
1104 1104 s ;bits of the byte in two consecutive bytes.  The <cksum> comes
1104 1104 s ;out OK since counting in 1-byte produces the same result of
1104 1104 s ;adding 80H + 80H as with adding 00H + 00H.
1104 1104 s 
1104 1104 s 
1104 1104 s 
1104 1104 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1104 1104 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1104 1104 s ;	Chapter_8	Menu operations. RAM TEST
1104 1104 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1104 1104 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1104 1104 s ;----------------------------------------------------------------------------------------------------; RAM TEST
1104 1104 s ;B=START PAGE
1104 1104 s ;C=END PAGE
1104 1104 d cd490d
1104 1104 u 03 01
1104 1104 s RAM_TEST:	CALL	SPACE_GET_BYTE
1107 1107 d 47
1107 1107 u 01 01
1107 1107 s 		LD	B, A
1108 1108 d cd490d
1108 1108 u 03 01
1108 1108 s 		CALL	SPACE_GET_BYTE
110b 110b d 4f
110b 110b u 01 01
110b 110b s 		LD	C, A
110c 110c s 
110c 110c d 217c0c
110c 110c u 03 01
110c 110c s 		LD	HL,GET_REG_RUN
110f 110f d 22b4ff
110f 110f u 03 01
110f 110f s 		LD	(GET_REG),HL
1112 1112 d cd1c11
1112 1112 u 03 01
1112 1112 s 		CALL	RT_GO
1115 1115 d 21710c
1115 1115 u 03 01
1115 1115 s 		LD	HL,GET_REG_MON
1118 1118 d 22b4ff
1118 1118 u 03 01
1118 1118 s 		LD	(GET_REG),HL
111b 111b d c9
111b 111b u 01 01
111b 111b s 		RET
111c 111c s 
111c 111c s ;Page March Test.  1 Sec/K
111c 111c s ;
111c 111c s ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
111c 111c s ;   FOR H = B TO C
111c 111c s ;      PAGE(H) = E
111c 111c s ;   NEXT H
111c 111c s ;   FOR D = B TO C
111c 111c s ;      PAGE(D) = NOT E
111c 111c s ;      FOR H = B TO C
111c 111c s ;         A = E
111c 111c s ;         IF H = D THEN A = NOT E
111c 111c s ;         IF PAGE(H) <> A THEN ERROR1
111c 111c s ;      NEXT H
111c 111c s ;   NEXT D
111c 111c s ; NEXT E
111c 111c s ;
111c 111c s 
111c 111c d cdca0d
111c 111c u 03 01
111c 111c s RT_GO		CALL	PRINTI
111f 111f d 0d0a54455354494e472052414d00
111f 111f u 0e 02
111f 111f s 		DB	CR,LF,"TESTING RAM",EOS
112d 112d d 1eff
112d 112d u 02 01
112d 112d s 		LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
112f 112f s 
112f 112f s ;Clear/Set all pages
112f 112f d 60
112f 112f u 01 01
112f 112f s RT1_LP0		LD	H,B		;HL = BASE RAM ADDRESS
1130 1130 d 2e00
1130 1130 u 02 01
1130 1130 s 		LD	L,0
1132 1132 d 7b
1132 1132 u 01 01
1132 1132 s RT1_LP1		LD	A,E		;CLEAR A
1133 1133 d 2f
1133 1133 u 01 01
1133 1133 s 		CPL
1134 1134 d 77
1134 1134 u 01 01
1134 1134 s RT1_LP2		LD	(HL),A		;WRITE PAGE
1135 1135 d 2c
1135 1135 u 01 01
1135 1135 s 		INC	L
1136 1136 d 20fc
1136 1136 u 02 01
1136 1136 s 		JR NZ,	RT1_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
1138 1138 d 7c
1138 1138 u 01 01
1138 1138 s 		LD	A,H
1139 1139 d 24
1139 1139 u 01 01
1139 1139 s 		INC	H		;ADVANCE TO NEXT PAGE
113a 113a d b9
113a 113a u 01 01
113a 113a s 		CP	C		;COMPARE WITH END PAGE
113b 113b d 20f5
113b 113b u 02 01
113b 113b s 		JR NZ,	RT1_LP1		;LOOP UNTIL = END PAGE
113d 113d s 
113d 113d s ;March 1 PAGE through RAM
113d 113d d 50
113d 113d u 01 01
113d 113d s 		LD	D,B		;Begin with START PAGE
113e 113e s 
113e 113e s ;Write FF to page D
113e 113e d 62
113e 113e u 01 01
113e 113e s RT1_LP3		LD	H,D		;HL = Marched Page ADDRESS
113f 113f s 		;LD	L,0
113f 113f d cd7013
113f 113f u 03 01
113f 113f s 		CALL	ABORT_CHECK
1142 1142 s 
1142 1142 d 7a
1142 1142 u 01 01
1142 1142 s 		LD	A,D
1143 1143 d 2f
1143 1143 u 01 01
1143 1143 s 		CPL
1144 1144 s ;		OUT	FPLED
1144 1144 s 		;LD	A,E		;SET A
1144 1144 d 73
1144 1144 u 01 01
1144 1144 s RT1_LP4		LD	(HL),E		;WRITE PAGE
1145 1145 d 2c
1145 1145 u 01 01
1145 1145 s 		INC	L
1146 1146 d 20fc
1146 1146 u 02 01
1146 1146 s 		JR  NZ,	RT1_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
1148 1148 s 
1148 1148 s ;Test all pages for 0 (except page D = FF)
1148 1148 d 60
1148 1148 u 01 01
1148 1148 s 		LD	H,B		;HL = BASE RAM ADDRESS
1149 1149 s 		;LD	L,0
1149 1149 s 
1149 1149 d 7c
1149 1149 u 01 01
1149 1149 s RT1_LP5		LD	A,H		;IF H = D
114a 114a d ba
114a 114a u 01 01
114a 114a s 		CP	D
114b 114b d 7b
114b 114b u 01 01
114b 114b s 		LD	A,E		;THEN Value = FF
114c 114c d 2801
114c 114c u 02 01
114c 114c s 		JR Z,	RT1_LP6
114e 114e d 2f
114e 114e u 01 01
114e 114e s 		CPL			;ELSE Value = 00
114f 114f s 
114f 114f d be
114f 114f u 01 01
114f 114f s RT1_LP6		CP	(HL)		;TEST RAM
1150 1150 d c2e212
1150 1150 u 03 01
1150 1150 s 		JP NZ,	RT_FAIL1
1153 1153 d 2c
1153 1153 u 01 01
1153 1153 s 		INC	L
1154 1154 d 20f9
1154 1154 u 02 01
1154 1154 s 		JR NZ,	RT1_LP6		;LOOP TO QUICKLY TEST 1 PAGE
1156 1156 d 7c
1156 1156 u 01 01
1156 1156 s 		LD	A,H
1157 1157 d 24
1157 1157 u 01 01
1157 1157 s 		INC	H		;ADVANCE TO NEXT PAGE
1158 1158 d b9
1158 1158 u 01 01
1158 1158 s 		CP	C		;COMPARE WITH END PAGE
1159 1159 d 20ee
1159 1159 u 02 01
1159 1159 s 		JR NZ,	RT1_LP5		;LOOP UNTIL = END PAGE
115b 115b s 
115b 115b s ;Write 00 back to page D
115b 115b d 62
115b 115b u 01 01
115b 115b s 		LD	H,D		;HL = Marched Page ADDRESS
115c 115c s 		;LD	L,0
115c 115c d 7b
115c 115c u 01 01
115c 115c s 		LD	A,E
115d 115d d 2f
115d 115d u 01 01
115d 115d s 		CPL
115e 115e d 77
115e 115e u 01 01
115e 115e s RT1_LP7		LD	(HL),A		;WRITE PAGE
115f 115f d 2c
115f 115f u 01 01
115f 115f s 		INC	L
1160 1160 d 20fc
1160 1160 u 02 01
1160 1160 s 		JR NZ,	RT1_LP7		;LOOP TO QUICKLY WRITE 1 PAGE
1162 1162 s 
1162 1162 d 7a
1162 1162 u 01 01
1162 1162 s 		LD	A,D
1163 1163 d 14
1163 1163 u 01 01
1163 1163 s 		INC	D		;ADVANCE TO NEXT PAGE
1164 1164 d b9
1164 1164 u 01 01
1164 1164 s 		CP	C		;COMPARE WITH END PAGE
1165 1165 d 20d7
1165 1165 u 02 01
1165 1165 s 		JR NZ,	RT1_LP3		;LOOP UNTIL = END PAGE
1167 1167 s 
1167 1167 d 1c
1167 1167 u 01 01
1167 1167 s 		INC	E
1168 1168 d 28c5
1168 1168 u 02 01
1168 1168 s 		JR Z,	RT1_LP0
116a 116a s 
116a 116a d cdca0d
116a 116a u 03 01
116a 116a s 		CALL	PRINTI
116d 116d d 0d0a52414d2050414745204d415243482050415353454400
116d 116d u 18 02
116d 116d s 		DB	CR,LF,"RAM PAGE MARCH PASSED",EOS
1185 1185 s 
1185 1185 s 
1185 1185 s ;Byte March Test.  7 Sec/K
1185 1185 s ;
1185 1185 s ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
1185 1185 s ;   FOR H = B TO C
1185 1185 s ;      PAGE(H) = E
1185 1185 s ;      FOR D = 00 TO FF
1185 1185 s ;         PAGE(H).D = NOT E
1185 1185 s ;         FOR L=0 TO FF
1185 1185 s ;            IF PAGE(H).L <> E THEN
1185 1185 s ;               IF PAGE(H).L <> NOT E THEN ERROR2
1185 1185 s ;               IF L<>D THEN ERROR2
1185 1185 s ;            ENDIF
1185 1185 s ;         NEXT L
1185 1185 s ;      NEXT D
1185 1185 s ;   NEXT H
1185 1185 s ; NEXT E
1185 1185 s 
1185 1185 d 1eff
1185 1185 u 02 01
1185 1185 s 		LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
1187 1187 s 
1187 1187 s ;Clear/Set all pages
1187 1187 s 
1187 1187 d 60
1187 1187 u 01 01
1187 1187 s RT2_LP0		LD	H,B		;HL = BASE RAM ADDRESS
1188 1188 d 2e00
1188 1188 u 02 01
1188 1188 s RT2_LP1		LD	L,0
118a 118a d cd7013
118a 118a u 03 01
118a 118a s 		CALL	ABORT_CHECK
118d 118d s 
118d 118d d 7c
118d 118d u 01 01
118d 118d s 		LD	A,H
118e 118e d 2f
118e 118e u 01 01
118e 118e s 		CPL
118f 118f s ;		OUT	FPLED
118f 118f s 
118f 118f d 7b
118f 118f u 01 01
118f 118f s 		LD	A,E		;CLEAR A
1190 1190 d 2f
1190 1190 u 01 01
1190 1190 s 		CPL
1191 1191 d 77
1191 1191 u 01 01
1191 1191 s RT2_LP2		LD	(HL),A		;WRITE PAGE
1192 1192 d 2c
1192 1192 u 01 01
1192 1192 s 		INC	L
1193 1193 d 20fc
1193 1193 u 02 01
1193 1193 s 		JR NZ,	RT2_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
1195 1195 s 
1195 1195 s 
1195 1195 d 1600
1195 1195 u 02 01
1195 1195 s 		LD	D,0		;Starting with BYTE 00 of page
1197 1197 s 
1197 1197 d 6a
1197 1197 u 01 01
1197 1197 s RT2_LP3		LD	L,D		;Save at byte march ptr
1198 1198 d 7b
1198 1198 u 01 01
1198 1198 s 		LD	A,E		;SET A
1199 1199 d 77
1199 1199 u 01 01
1199 1199 s 		LD	(HL),A
119a 119a s 
119a 119a s 		;LD	A,E
119a 119a d 2f
119a 119a u 01 01
119a 119a s 		CPL			;CLEAR A
119b 119b d 2e00
119b 119b u 02 01
119b 119b s 		LD	L,0
119d 119d s 
119d 119d d be
119d 119d u 01 01
119d 119d s RT2_LP4		CP	(HL)		;TEST BYTE FOR CLEAR
119e 119e d 280c
119e 119e u 02 01
119e 119e s 		JR Z,	RT2_NX1
11a0 11a0 d 2f
11a0 11a0 u 01 01
11a0 11a0 s 		CPL			;SET A
11a1 11a1 d be
11a1 11a1 u 01 01
11a1 11a1 s 		CP	(HL)		;TEST BYTE FOR SET
11a2 11a2 d c20513
11a2 11a2 u 03 01
11a2 11a2 s 		JP NZ,	RT_FAIL2	;IF NOT FULLY SET, THEN DEFINITELY FAIL
11a5 11a5 d 7d
11a5 11a5 u 01 01
11a5 11a5 s 		LD	A,L		;ELSE CHECK WE ARE ON MARCHED BYTE
11a6 11a6 d ba
11a6 11a6 u 01 01
11a6 11a6 s 		CP	D
11a7 11a7 d c20513
11a7 11a7 u 03 01
11a7 11a7 s 		JP NZ,	RT_FAIL2
11aa 11aa d 7b
11aa 11aa u 01 01
11aa 11aa s 		LD	A,E		;CLEAR A
11ab 11ab d 2f
11ab 11ab u 01 01
11ab 11ab s 		CPL
11ac 11ac d 2c
11ac 11ac u 01 01
11ac 11ac s RT2_NX1		INC	L
11ad 11ad d 20ee
11ad 11ad u 02 01
11ad 11ad s 		JR NZ,	RT2_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
11af 11af s 
11af 11af d 6a
11af 11af u 01 01
11af 11af s 		LD	L,D		;Save at byte march ptr
11b0 11b0 d 7b
11b0 11b0 u 01 01
11b0 11b0 s 		LD	A,E
11b1 11b1 d 2f
11b1 11b1 u 01 01
11b1 11b1 s 		CPL			;CLEAR A
11b2 11b2 d 77
11b2 11b2 u 01 01
11b2 11b2 s 		LD	(HL),A
11b3 11b3 s 
11b3 11b3 d 14
11b3 11b3 u 01 01
11b3 11b3 s 		INC	D
11b4 11b4 d 20e1
11b4 11b4 u 02 01
11b4 11b4 s 		JR NZ,	RT2_LP3
11b6 11b6 s 
11b6 11b6 d 7c
11b6 11b6 u 01 01
11b6 11b6 s 		LD	A,H
11b7 11b7 d 24
11b7 11b7 u 01 01
11b7 11b7 s 		INC	H		;ADVANCE TO NEXT PAGE
11b8 11b8 d b9
11b8 11b8 u 01 01
11b8 11b8 s 		CP	C		;COMPARE WITH END PAGE
11b9 11b9 d 20cd
11b9 11b9 u 02 01
11b9 11b9 s 		JR NZ,	RT2_LP1		;LOOP UNTIL = END PAGE
11bb 11bb s 
11bb 11bb d 1c
11bb 11bb u 01 01
11bb 11bb s 		INC	E
11bc 11bc d 28c9
11bc 11bc u 02 01
11bc 11bc s 		JR Z,	RT2_LP0
11be 11be s 
11be 11be d cdca0d
11be 11be u 03 01
11be 11be s 		CALL	PRINTI
11c1 11c1 d 0d0a52414d2042595445204d4152434820312050415353454400
11c1 11c1 u 1a 02
11c1 11c1 s 		DB	CR,LF,"RAM BYTE MARCH 1 PASSED",EOS
11db 11db s 
11db 11db s ;26 Sec/K
11db 11db s 
11db 11db s BYTEMARCH2
11db 11db d 1eff
11db 11db u 02 01
11db 11db s 		LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
11dd 11dd s 
11dd 11dd d 1600
11dd 11dd u 02 01
11dd 11dd s RT4_LP0		LD	D,0		;Starting with BYTE 00 of page
11df 11df s 
11df 11df s ;CLEAR all pages
11df 11df s 
11df 11df d 60
11df 11df u 01 01
11df 11df s 		LD	H,B		;HL = BASE RAM ADDRESS
11e0 11e0 d 2e00
11e0 11e0 u 02 01
11e0 11e0 s 		LD	L,0
11e2 11e2 s 
11e2 11e2 d 7b
11e2 11e2 u 01 01
11e2 11e2 s RT4_LP1		LD	A,E		;CLEAR A
11e3 11e3 d 2f
11e3 11e3 u 01 01
11e3 11e3 s 		CPL
11e4 11e4 d 77
11e4 11e4 u 01 01
11e4 11e4 s RT4_LP2		LD	(HL),A		;WRITE PAGE
11e5 11e5 d 2c
11e5 11e5 u 01 01
11e5 11e5 s 		INC	L
11e6 11e6 d 20fc
11e6 11e6 u 02 01
11e6 11e6 s 		JR NZ,	RT4_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
11e8 11e8 s 
11e8 11e8 d 7c
11e8 11e8 u 01 01
11e8 11e8 s 		LD	A,H
11e9 11e9 d 24
11e9 11e9 u 01 01
11e9 11e9 s 		INC	H		;ADVANCE TO NEXT PAGE
11ea 11ea d b9
11ea 11ea u 01 01
11ea 11ea s 		CP	C		;COMPARE WITH END PAGE
11eb 11eb d 20f5
11eb 11eb u 02 01
11eb 11eb s 		JR NZ,	RT4_LP1		;LOOP UNTIL = END PAGE
11ed 11ed s 
11ed 11ed s 
11ed 11ed d cd7013
11ed 11ed u 03 01
11ed 11ed s RT4_LP3		CALL	ABORT_CHECK
11f0 11f0 d 7a
11f0 11f0 u 01 01
11f0 11f0 s 		LD	A,D
11f1 11f1 d 2f
11f1 11f1 u 01 01
11f1 11f1 s 		CPL
11f2 11f2 s ;		OUT	FPLED
11f2 11f2 s 
11f2 11f2 s 					;Write SET byte at "D" in every page
11f2 11f2 d 60
11f2 11f2 u 01 01
11f2 11f2 s 		LD	H,B		;HL = BASE RAM ADDRESS
11f3 11f3 d 6a
11f3 11f3 u 01 01
11f3 11f3 s 		LD	L,D		;Save at byte march ptr
11f4 11f4 d 73
11f4 11f4 u 01 01
11f4 11f4 s RT4_LP4		LD	(HL),E
11f5 11f5 s 
11f5 11f5 d 7c
11f5 11f5 u 01 01
11f5 11f5 s 		LD	A,H
11f6 11f6 d 24
11f6 11f6 u 01 01
11f6 11f6 s 		INC	H		;ADVANCE TO NEXT PAGE
11f7 11f7 d b9
11f7 11f7 u 01 01
11f7 11f7 s 		CP	C		;COMPARE WITH END PAGE
11f8 11f8 d 20fa
11f8 11f8 u 02 01
11f8 11f8 s 		JR NZ,	RT4_LP4		;LOOP UNTIL = END PAGE
11fa 11fa s 
11fa 11fa s 
11fa 11fa d 2e00
11fa 11fa u 02 01
11fa 11fa s 		LD	L,0
11fc 11fc s 
11fc 11fc d 60
11fc 11fc u 01 01
11fc 11fc s RT4_LP5		LD	H,B		;HL = BASE RAM ADDRESS
11fd 11fd d 7d
11fd 11fd u 01 01
11fd 11fd s 		LD	A,L
11fe 11fe d ba
11fe 11fe u 01 01
11fe 11fe s 		CP	D
11ff 11ff d 280d
11ff 11ff u 02 01
11ff 11ff s 		JR Z,	RT4_LP7		;Test for marked byte in all pages
1201 1201 s 
1201 1201 d 7b
1201 1201 u 01 01
1201 1201 s RT4_LP6		LD	A,E
1202 1202 d 2f
1202 1202 u 01 01
1202 1202 s 		CPL			;CLEAR A
1203 1203 d be
1203 1203 u 01 01
1203 1203 s 		CP	(HL)		;TEST BYTE FOR CLEAR
1204 1204 d c20513
1204 1204 u 03 01
1204 1204 s 		JP NZ,	RT_FAIL2
1207 1207 s 
1207 1207 d 7c
1207 1207 u 01 01
1207 1207 s 		LD	A,H
1208 1208 d 24
1208 1208 u 01 01
1208 1208 s 		INC	H		;ADVANCE TO NEXT PAGE
1209 1209 d b9
1209 1209 u 01 01
1209 1209 s 		CP	C		;COMPARE WITH END PAGE
120a 120a d 20f5
120a 120a u 02 01
120a 120a s 		JR NZ,	RT4_LP6		;LOOP UNTIL = END PAGE
120c 120c d 180a
120c 120c u 02 01
120c 120c s 		JR	RT4_NX
120e 120e s 
120e 120e d 7b
120e 120e u 01 01
120e 120e s RT4_LP7		LD	A,E
120f 120f d be
120f 120f u 01 01
120f 120f s 		CP	(HL)		;TEST BYTE FOR SET
1210 1210 d c20513
1210 1210 u 03 01
1210 1210 s 		JP NZ,	RT_FAIL2
1213 1213 s 
1213 1213 d 7c
1213 1213 u 01 01
1213 1213 s 		LD	A,H
1214 1214 d 24
1214 1214 u 01 01
1214 1214 s 		INC	H		;ADVANCE TO NEXT PAGE
1215 1215 d b9
1215 1215 u 01 01
1215 1215 s 		CP	C		;COMPARE WITH END PAGE
1216 1216 d 20f6
1216 1216 u 02 01
1216 1216 s 		JR NZ,	RT4_LP7		;LOOP UNTIL = END PAGE
1218 1218 s 
1218 1218 d 2c
1218 1218 u 01 01
1218 1218 s RT4_NX		INC	L
1219 1219 d 20e1
1219 1219 u 02 01
1219 1219 s 		JR NZ,	RT4_LP5
121b 121b s 
121b 121b s 					;Write CLEAR byte at "D" in every page
121b 121b d 60
121b 121b u 01 01
121b 121b s 		LD	H,B		;HL = BASE RAM ADDRESS
121c 121c d 6a
121c 121c u 01 01
121c 121c s 		LD	L,D		;Save at byte march ptr
121d 121d d 7b
121d 121d u 01 01
121d 121d s RT4_LP8		LD	A,E
121e 121e d 2f
121e 121e u 01 01
121e 121e s 		CPL
121f 121f d 77
121f 121f u 01 01
121f 121f s 		LD	(HL),A
1220 1220 s 
1220 1220 d 7c
1220 1220 u 01 01
1220 1220 s 		LD	A,H
1221 1221 d 24
1221 1221 u 01 01
1221 1221 s 		INC	H		;ADVANCE TO NEXT PAGE
1222 1222 d b9
1222 1222 u 01 01
1222 1222 s 		CP	C		;COMPARE WITH END PAGE
1223 1223 d 20f8
1223 1223 u 02 01
1223 1223 s 		JR NZ,	RT4_LP8		;LOOP UNTIL = END PAGE
1225 1225 s 
1225 1225 d 14
1225 1225 u 01 01
1225 1225 s 		INC	D
1226 1226 d 20c5
1226 1226 u 02 01
1226 1226 s 		JR NZ,	RT4_LP3
1228 1228 s 
1228 1228 s 
1228 1228 d 1c
1228 1228 u 01 01
1228 1228 s 		INC	E
1229 1229 d 28b2
1229 1229 u 02 01
1229 1229 s 		JR Z,	RT4_LP0
122b 122b s 
122b 122b d cdca0d
122b 122b u 03 01
122b 122b s 		CALL	PRINTI
122e 122e d 0d0a52414d2042595445204d4152434820322050415353454400
122e 122e u 1a 02
122e 122e s 		DB	CR,LF,"RAM BYTE MARCH 2 PASSED",EOS
1248 1248 s 
1248 1248 s 
1248 1248 s BIT_MARCH
1248 1248 s ;Bit March Test.  0.1 Sec/K
1248 1248 s 
1248 1248 d 1e01
1248 1248 u 02 01
1248 1248 s 		LD	E,01		;E selects the bit to march
124a 124a s 
124a 124a s ;Clear/Set all pages
124a 124a s 
124a 124a d 60
124a 124a u 01 01
124a 124a s RT3_LP1		LD	H,B		;HL = BASE RAM ADDRESS
124b 124b d 2e00
124b 124b u 02 01
124b 124b s 		LD	L,0
124d 124d s 
124d 124d d cd7013
124d 124d u 03 01
124d 124d s 		CALL	ABORT_CHECK
1250 1250 s 
1250 1250 d 7b
1250 1250 u 01 01
1250 1250 s 		LD	A,E		;Display bit pattern on LED PORT
1251 1251 d 2f
1251 1251 u 01 01
1251 1251 s 		CPL
1252 1252 s ;		OUT	FPLED
1252 1252 s 
1252 1252 d 7b
1252 1252 u 01 01
1252 1252 s RT3_LP2		LD	A,E		;FETCH MARCHING BIT PATTERN
1253 1253 d 77
1253 1253 u 01 01
1253 1253 s RT3_LP3		LD	(HL),A		;WRITE PAGE
1254 1254 d 2c
1254 1254 u 01 01
1254 1254 s 		INC	L
1255 1255 d 20fc
1255 1255 u 02 01
1255 1255 s 		JR NZ,	RT3_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
1257 1257 s 
1257 1257 d 7c
1257 1257 u 01 01
1257 1257 s 		LD	A,H
1258 1258 d 24
1258 1258 u 01 01
1258 1258 s 		INC	H		;ADVANCE TO NEXT PAGE
1259 1259 d b9
1259 1259 u 01 01
1259 1259 s 		CP	C		;COMPARE WITH END PAGE
125a 125a d 20f6
125a 125a u 02 01
125a 125a s 		JR NZ,	RT3_LP2		;LOOP UNTIL = END PAGE
125c 125c s 
125c 125c d 60
125c 125c u 01 01
125c 125c s 		LD	H,B		;HL = BASE RAM ADDRESS
125d 125d s ;		LD	L,0
125d 125d s 
125d 125d d 7b
125d 125d u 01 01
125d 125d s RT3_LP4		LD	A,E		;FETCH MARCHING BIT PATTERN
125e 125e d be
125e 125e u 01 01
125e 125e s RT3_LP5		CP	(HL)
125f 125f d c22813
125f 125f u 03 01
125f 125f s 		JP NZ,	RT_FAIL3
1262 1262 d 2c
1262 1262 u 01 01
1262 1262 s 		INC	L
1263 1263 d 20f9
1263 1263 u 02 01
1263 1263 s 		JR NZ,	RT3_LP5		;LOOP TO QUICKLY WRITE 1 PAGE
1265 1265 s 
1265 1265 d 7c
1265 1265 u 01 01
1265 1265 s 		LD	A,H
1266 1266 d 24
1266 1266 u 01 01
1266 1266 s 		INC	H		;ADVANCE TO NEXT PAGE
1267 1267 d b9
1267 1267 u 01 01
1267 1267 s 		CP	C		;COMPARE WITH END PAGE
1268 1268 d 20f3
1268 1268 u 02 01
1268 1268 s 		JR NZ,	RT3_LP4		;LOOP UNTIL = END PAGE
126a 126a s 
126a 126a s 
126a 126a s 					;0000 0010
126a 126a s 					;...
126a 126a s 					;1000 0000
126a 126a s 
126a 126a d 7b
126a 126a u 01 01
126a 126a s 		LD	A,E
126b 126b d 17
126b 126b u 01 01
126b 126b s 		RLA			;ROTATE THE 01 UNTIL 00
126c 126c d 7b
126c 126c u 01 01
126c 126c s 		LD	A,E
126d 126d d 07
126d 126d u 01 01
126d 126d s 		RLCA
126e 126e d 5f
126e 126e u 01 01
126e 126e s 		LD	E,A
126f 126f d fe01
126f 126f u 02 01
126f 126f s 		CP	1
1271 1271 d 2004
1271 1271 u 02 01
1271 1271 s 		JR NZ,	RT3_NX1
1273 1273 d 2f
1273 1273 u 01 01
1273 1273 s 		CPL			;INVERT ALL BITS
1274 1274 d 5f
1274 1274 u 01 01
1274 1274 s 		LD	E,A
1275 1275 d 18d3
1275 1275 u 02 01
1275 1275 s 		JR	RT3_LP1
1277 1277 d fefe
1277 1277 u 02 01
1277 1277 s RT3_NX1		CP	0xFE
1279 1279 d 20cf
1279 1279 u 02 01
1279 1279 s 		JR NZ,	RT3_LP1
127b 127b s 
127b 127b d cdca0d
127b 127b u 03 01
127b 127b s 		CALL	PRINTI
127e 127e d 0d0a52414d20424954204d415243482050415353454400
127e 127e u 17 02
127e 127e s 		DB	CR,LF,"RAM BIT MARCH PASSED",EOS
1295 1295 s 
1295 1295 s 
1295 1295 d 1e01
1295 1295 u 02 01
1295 1295 s 		LD	E,01		;E selects the start sequence
1297 1297 s 
1297 1297 s ;Clear/Set all pages
1297 1297 s 
1297 1297 d cd7013
1297 1297 u 03 01
1297 1297 s RT5_LP1		CALL	ABORT_CHECK
129a 129a s 
129a 129a d 7b
129a 129a u 01 01
129a 129a s 		LD	A,E		;Display bit pattern on LED PORT
129b 129b d 2f
129b 129b u 01 01
129b 129b s 		CPL
129c 129c s ;		OUT	FPLED
129c 129c s 
129c 129c d 60
129c 129c u 01 01
129c 129c s 		LD	H,B		;HL = BASE RAM ADDRESS
129d 129d d 2e00
129d 129d u 02 01
129d 129d s 		LD	L,0
129f 129f d 53
129f 129f u 01 01
129f 129f s 		LD	D,E
12a0 12a0 s 
12a0 12a0 d 14
12a0 12a0 u 01 01
12a0 12a0 s RT5_LP2		INC	D
12a1 12a1 d 2001
12a1 12a1 u 02 01
12a1 12a1 s 		JR NZ,	RT5_NX1
12a3 12a3 d 14
12a3 12a3 u 01 01
12a3 12a3 s 		INC	D
12a4 12a4 d 72
12a4 12a4 u 01 01
12a4 12a4 s RT5_NX1		LD	(HL),D		;WRITE PAGE
12a5 12a5 d 2c
12a5 12a5 u 01 01
12a5 12a5 s 		INC	L
12a6 12a6 d 20f8
12a6 12a6 u 02 01
12a6 12a6 s 		JR NZ,	RT5_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
12a8 12a8 s 
12a8 12a8 d 7c
12a8 12a8 u 01 01
12a8 12a8 s 		LD	A,H
12a9 12a9 d 24
12a9 12a9 u 01 01
12a9 12a9 s 		INC	H		;ADVANCE TO NEXT PAGE
12aa 12aa d b9
12aa 12aa u 01 01
12aa 12aa s 		CP	C		;COMPARE WITH END PAGE
12ab 12ab d 20f3
12ab 12ab u 02 01
12ab 12ab s 		JR NZ,	RT5_LP2		;LOOP UNTIL = END PAGE
12ad 12ad s 
12ad 12ad d 60
12ad 12ad u 01 01
12ad 12ad s 		LD	H,B		;HL = BASE RAM ADDRESS
12ae 12ae s 		;LD	L,0
12ae 12ae d 53
12ae 12ae u 01 01
12ae 12ae s 		LD	D,E
12af 12af s 
12af 12af d 14
12af 12af u 01 01
12af 12af s RT5_LP3		INC	D
12b0 12b0 d 2001
12b0 12b0 u 02 01
12b0 12b0 s 		JR NZ,	RT5_NX2
12b2 12b2 d 14
12b2 12b2 u 01 01
12b2 12b2 s 		INC	D
12b3 12b3 d 7a
12b3 12b3 u 01 01
12b3 12b3 s RT5_NX2		LD	A,D
12b4 12b4 d be
12b4 12b4 u 01 01
12b4 12b4 s 		CP	(HL)		;TEST
12b5 12b5 d c24a13
12b5 12b5 u 03 01
12b5 12b5 s 		JP NZ,	RT_FAIL5
12b8 12b8 d 2c
12b8 12b8 u 01 01
12b8 12b8 s 		INC	L
12b9 12b9 d 20f4
12b9 12b9 u 02 01
12b9 12b9 s 		JR NZ,	RT5_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
12bb 12bb s 
12bb 12bb d 7c
12bb 12bb u 01 01
12bb 12bb s 		LD	A,H
12bc 12bc d 24
12bc 12bc u 01 01
12bc 12bc s 		INC	H		;ADVANCE TO NEXT PAGE
12bd 12bd d b9
12bd 12bd u 01 01
12bd 12bd s 		CP	C		;COMPARE WITH END PAGE
12be 12be d 20ef
12be 12be u 02 01
12be 12be s 		JR NZ,	RT5_LP3		;LOOP UNTIL = END PAGE
12c0 12c0 s 
12c0 12c0 d 1c
12c0 12c0 u 01 01
12c0 12c0 s 		INC	E
12c1 12c1 d 20d4
12c1 12c1 u 02 01
12c1 12c1 s 		JR NZ,	RT5_LP1
12c3 12c3 s 
12c3 12c3 d cdca0d
12c3 12c3 u 03 01
12c3 12c3 s 		CALL	PRINTI
12c6 12c6 d 0d0a52414d2053455155454e434520544553542050415353454400
12c6 12c6 u 1b 02
12c6 12c6 s 		DB	CR,LF,"RAM SEQUENCE TEST PASSED",EOS
12e1 12e1 d c9
12e1 12e1 u 01 01
12e1 12e1 s 		RET
12e2 12e2 s 
12e2 12e2 d cdca0d
12e2 12e2 u 03 01
12e2 12e2 s RT_FAIL1	CALL	PRINTI
12e5 12e5 d 0d0a52414d204641494c45442050414745204d415243482041543a00
12e5 12e5 u 1c 02
12e5 12e5 s 		DB	CR,LF,"RAM FAILED PAGE MARCH AT:",EOS
1301 1301 d cdea0d
1301 1301 u 03 01
1301 1301 s 		CALL	PUT_HL
1304 1304 d c9
1304 1304 u 01 01
1304 1304 s 		RET
1305 1305 s 
1305 1305 d cdca0d
1305 1305 u 03 01
1305 1305 s RT_FAIL2	CALL	PRINTI
1308 1308 d 0d0a52414d204641494c45442042595445204d415243482041543a00
1308 1308 u 1c 02
1308 1308 s 		DB	CR,LF,"RAM FAILED BYTE MARCH AT:",EOS
1324 1324 d cdea0d
1324 1324 u 03 01
1324 1324 s 		CALL	PUT_HL
1327 1327 d c9
1327 1327 u 01 01
1327 1327 s 		RET
1328 1328 s 
1328 1328 d cdca0d
1328 1328 u 03 01
1328 1328 s RT_FAIL3	CALL	PRINTI
132b 132b d 0d0a52414d204641494c454420424954204d415243482041543a00
132b 132b u 1b 02
132b 132b s 		DB	CR,LF,"RAM FAILED BIT MARCH AT:",EOS
1346 1346 d cdea0d
1346 1346 u 03 01
1346 1346 s 		CALL	PUT_HL
1349 1349 d c9
1349 1349 u 01 01
1349 1349 s 		RET
134a 134a s 
134a 134a d cdca0d
134a 134a u 03 01
134a 134a s RT_FAIL5	CALL	PRINTI
134d 134d d 0d0a52414d204641494c45442053455155454e434520544553542041543a00
134d 134d u 1f 02
134d 134d s 		DB	CR,LF,"RAM FAILED SEQUENCE TEST AT:",EOS
136c 136c d cdea0d
136c 136c u 03 01
136c 136c s 		CALL	PUT_HL
136f 136f d c9
136f 136f u 01 01
136f 136f s 		RET
1370 1370 s 
1370 1370 d cd2114
1370 1370 u 03 01
1370 1370 s ABORT_CHECK	CALL	IN_CHAR
1373 1373 d d8
1373 1373 u 01 01
1373 1373 s 		RET C
1374 1374 d fe1b
1374 1374 u 02 01
1374 1374 s 		CP	27
1376 1376 d c0
1376 1376 u 01 01
1376 1376 s 		RET NZ
1377 1377 d e1
1377 1377 u 01 01
1377 1377 s 		POP	HL			;SCRAP RETURN ADDRESS AND GO TO PARENT ROUTINE
1378 1378 d cdca0d
1378 1378 u 03 01
1378 1378 s 		CALL	PRINTI
137b 137b d 0d0a41424f5254454400
137b 137b u 0a 02
137b 137b s 		DB	CR,LF,"ABORTED",EOS
1385 1385 d c9
1385 1385 u 01 01
1385 1385 s 		RET
1386 1386 s 
1386 1386 s 
1386 1386 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1386 1386 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1386 1386 s ;	Chapter_10	BIOS.
1386 1386 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1386 1386 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1386 1386 s ;SET_IO		Sets the IO pointed to by PUT_CHAR AND IN_CHAR
1386 1386 s ;GET_CHAR_NE	Uses IN_CHAR
1386 1386 s ;GET_CHAR	Uses IN_CHAR
1386 1386 s ;Put_Char	
1386 1386 s ;RX_COUNT	Returns count of bytes recieved
1386 1386 s ;IN_CHAR	Returns received char or CF=1 if no char
1386 1386 s ;PURGE		
1386 1386 s ;TIMED1_GETCHAR	
1386 1386 s ;TIMED_GETCHAR	
1386 1386 s ;
1386 1386 s ;RXC_BOTH	BOTH BIT AND ACE
1386 1386 s ;IC_BOTH		
1386 1386 s ;PC_BOTH		
1386 1386 s ;
1386 1386 s ;LED_HOME	LED
1386 1386 s ;IC_KEY		
1386 1386 s ;PC_LED		
1386 1386 s ;
1386 1386 s ;RXC_ACE	ACE	
1386 1386 s ;IC_ACE		
1386 1386 s ;PC_ACE		
1386 1386 s ;
1386 1386 s ;RXC_BIT	BITBANG	
1386 1386 s ;IC_BIT		
1386 1386 s ;PC_POS_UPDATE	
1386 1386 s ;PC_BIT		
1386 1386 s 
1386 1386 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1386 1386 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1386 1386 s ;----------------------------------------------------------------------------------------------------; CONSOLE BIOS
1386 1386 s 
1386 1386 s 
1386 1386 s 				;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
1386 1386 s 				;Input C: 00=BIT, 01=BIT, 02=ACE, 03=BOTH, 04=LED
1386 1386 d e5
1386 1386 u 01 01
1386 1386 s SET_IO		PUSH	HL
1387 1387 d d5
1387 1387 u 01 01
1387 1387 s 		PUSH	DE
1388 1388 d c5
1388 1388 u 01 01
1388 1388 s 		PUSH	BC		
1389 1389 d f5
1389 1389 u 01 01
1389 1389 s 		PUSH	AF
138a 138a d 2195ff
138a 138a u 03 01
138a 138a s 		LD	HL,HW_LIST	;Only set the new I/O if Hardware is present
138d 138d d 79
138d 138d u 01 01
138d 138d s 		LD	A,C
138e 138e d b7
138e 138e u 01 01
138e 138e s 		OR	A
138f 138f d 280f
138f 138f u 02 01
138f 138f s 		JR  Z,	SIO_ZERO	;Special case, No FP & No SIO
1391 1391 d a6
1391 1391 u 01 01
1391 1391 s 		AND	(HL)
1392 1392 d 4f
1392 1392 u 01 01
1392 1392 s 		LD	C,A
1393 1393 d 200d
1393 1393 u 02 01
1393 1393 s 		JR NZ,	SIO_OK
1395 1395 d 79
1395 1395 u 01 01
1395 1395 s 		LD	A,C		;Handle special LED case.
1396 1396 d 0f
1396 1396 u 01 01
1396 1396 s 		RRCA			;Shift LED (04) to FP hardware (01)
1397 1397 d 0f
1397 1397 u 01 01
1397 1397 s 		RRCA
1398 1398 d a6
1398 1398 u 01 01
1398 1398 s 		AND	(HL)
1399 1399 d 79
1399 1399 u 01 01
1399 1399 s 		LD	A,C
139a 139a d 2006
139a 139a u 02 01
139a 139a s 		JR NZ,	SIO_OK
139c 139c d f1
139c 139c u 01 01
139c 139c s 		POP	AF
139d 139d d 37
139d 139d u 01 01
139d 139d s 		SCF
139e 139e d 1819
139e 139e u 02 01
139e 139e s 		JR 	SIO_RET
13a0 13a0 s 		
13a0 13a0 d 0c
13a0 13a0 u 01 01
13a0 13a0 s SIO_ZERO	INC	C
13a1 13a1 d 3c
13a1 13a1 u 01 01
13a1 13a1 s 		INC	A
13a2 13a2 d 3294ff
13a2 13a2 u 03 01
13a2 13a2 s SIO_OK		LD	(HW_SETIO),A	;Save set IO configuration
13a5 13a5 d 0d
13a5 13a5 u 01 01
13a5 13a5 s 		DEC	C
13a6 13a6 d cb21
13a6 13a6 u 02 01
13a6 13a6 s 		SLA	C		;x2 for word
13a8 13a8 d cb21
13a8 13a8 u 02 01
13a8 13a8 s 		SLA	C		;x2 for 2 words
13aa 13aa d 0600
13aa 13aa u 02 01
13aa 13aa s 		LD	B,0
13ac 13ac d 21bd13
13ac 13ac u 03 01
13ac 13ac s 		LD	HL,IOD_TABLE
13af 13af d 09
13af 13af u 01 01
13af 13af s 		ADD	HL,BC
13b0 13b0 d 1190ff
13b0 13b0 u 03 01
13b0 13b0 s 		LD	DE,PUTCHAR_EXE
13b3 13b3 d 0e04
13b3 13b3 u 02 01
13b3 13b3 s 		LD	C,4
13b5 13b5 d edb0
13b5 13b5 u 02 01
13b5 13b5 s 		LDIR
13b7 13b7 d f1
13b7 13b7 u 01 01
13b7 13b7 s 		POP	AF
13b8 13b8 d b7
13b8 13b8 u 01 01
13b8 13b8 s 		OR	A		;CY=0
13b9 13b9 d c1
13b9 13b9 u 01 01
13b9 13b9 s SIO_RET		POP	BC
13ba 13ba d d1
13ba 13ba u 01 01
13ba 13ba s 		POP	DE
13bb 13bb d e1
13bb 13bb u 01 01
13bb 13bb s 		POP	HL
13bc 13bc d c9
13bc 13bc u 01 01
13bc 13bc s 		RET
13bd 13bd s 
13bd 13bd d 3815
13bd 13bd u 02 02
13bd 13bd s IOD_TABLE	DW	PC_BIT		;FP       (PUTCHAR_EXE)
13bf 13bf d 1715
13bf 13bf u 02 02
13bf 13bf s 		DW	IC_BIT		;FP       (INCHAR_EXE)
13c1 13c1 d e014
13c1 13c1 u 02 02
13c1 13c1 s 		DW	PC_ACE		;SIO      (PUTCHAR_EXE)
13c3 13c3 d cf14
13c3 13c3 u 02 02
13c3 13c3 s 		DW	IC_ACE		;SIO 	  (INCHAR_EXE)
13c5 13c5 d 7014
13c5 13c5 u 02 02
13c5 13c5 s 		DW	PC_BOTH		;FP & SIO (PUTCHAR_EXE)
13c7 13c7 d 6a14
13c7 13c7 u 02 02
13c7 13c7 s 		DW	IC_BOTH		;FP & SIO (INCHAR_EXE)
13c9 13c9 d 8a14
13c9 13c9 u 02 02
13c9 13c9 s 		DW	PC_LED		;LED      (PUTCHAR_EXE)
13cb 13cb d ba14
13cb 13cb u 02 02
13cb 13cb s 		DW	IC_KEY		;LED      (INCHAR_EXE)
13cd 13cd s 
13cd 13cd s 
13cd 13cd s 				;HW_SETIO: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
13cd 13cd d 3a94ff
13cd 13cd u 03 01
13cd 13cd s GET_POS		LD	A,(HW_SETIO)
13d0 13d0 d 0f
13d0 13d0 u 01 01
13d0 13d0 s 		RRCA
13d1 13d1 d 0f
13d1 13d1 u 01 01
13d1 13d1 s 		RRCA
13d2 13d2 d 3ad7ff
13d2 13d2 u 03 01
13d2 13d2 s 		LD	A,(POS_ACE)
13d5 13d5 d d8
13d5 13d5 u 01 01
13d5 13d5 s 		RET	C	;Exit with POS_ACE if ACE Selected
13d6 13d6 d 3ad6ff
13d6 13d6 u 03 01
13d6 13d6 s 		LD	A,(POS_BIT)
13d9 13d9 d c9
13d9 13d9 u 01 01
13d9 13d9 s 		RET
13da 13da s 
13da 13da s 
13da 13da s ;===============================================
13da 13da s ;GET_CHAR -- Get a char from the console NO ECHO
13da 13da s ;-----------------------------------------------
13da 13da s ;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
13da 13da d cd2114
13da 13da u 03 01
13da 13da s GET_CHAR_NE:	CALL	IN_CHAR
13dd 13dd d 38fb
13dd 13dd u 02 01
13dd 13dd s 		JR C,	GET_CHAR_NE
13df 13df d c9
13df 13df u 01 01
13df 13df s 		RET
13e0 13e0 s 
13e0 13e0 s ;===============================================
13e0 13e0 s ;GET_CHAR -- Get a char from the console
13e0 13e0 s ;-----------------------------------------------
13e0 13e0 d 3af2ff
13e0 13e0 u 03 01
13e0 13e0 s GET_CHAR:	LD	A,(ECHO_STATE)
13e3 13e3 d b7
13e3 13e3 u 01 01
13e3 13e3 s 		OR	A
13e4 13e4 d 28f4
13e4 13e4 u 02 01
13e4 13e4 s 		JR Z,	GET_CHAR_NE
13e6 13e6 d cdda13
13e6 13e6 u 03 01
13e6 13e6 s GET_CHAR_LP	CALL	GET_CHAR_NE
13e9 13e9 d fe20
13e9 13e9 u 02 01
13e9 13e9 s 		CP	' '	;Do not echo control chars
13eb 13eb d f8
13eb 13eb u 01 01
13eb 13eb s 		RET M
13ec 13ec s 		;RET		;ECHO THE CHAR
13ec 13ec s 				;FALL INTO PUT_CHAR
13ec 13ec s 
13ec 13ec s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
13ec 13ec s ;Send A byte to Bitbanged RS-232, ACE RS-232 or LED
13ec 13ec s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
13ec 13ec d f5
13ec 13ec u 01 01
13ec 13ec s PUT_CHAR:	PUSH	AF
13ed 13ed d c5
13ed 13ed u 01 01
13ed 13ed s 		PUSH	BC		;Save registers
13ee 13ee d d5
13ee 13ee u 01 01
13ee 13ee s 		PUSH	DE
13ef 13ef d e5
13ef 13ef u 01 01
13ef 13ef s 		PUSH	HL
13f0 13f0 d 4f
13f0 13f0 u 01 01
13f0 13f0 s 		LD	C,A		;Put character to send IN C for shifting
13f1 13f1 s 
13f1 13f1 d 2a90ff
13f1 13f1 u 03 01
13f1 13f1 s 		LD	HL,(PUTCHAR_EXE)
13f4 13f4 d cda00c
13f4 13f4 u 03 01
13f4 13f4 s 		CALL	VCALL_HL	;JP	(HL)
13f7 13f7 s 
13f7 13f7 d e1
13f7 13f7 u 01 01
13f7 13f7 s 		POP HL
13f8 13f8 d d1
13f8 13f8 u 01 01
13f8 13f8 s 		POP DE
13f9 13f9 d c1
13f9 13f9 u 01 01
13f9 13f9 s 		POP BC
13fa 13fa d f1
13fa 13fa u 01 01
13fa 13fa s 		POP AF
13fb 13fb d c9
13fb 13fb u 01 01
13fb 13fb s 		RET
13fc 13fc s 
13fc 13fc s ;Update position of PUT_CHAR (Used later to create aligned columns)
13fc 13fc d fe0d
13fc 13fc u 02 01
13fc 13fc s PC_POS_UPDATE	CP	13
13fe 13fe d 2003
13fe 13fe u 02 01
13fe 13fe s 		JR NZ,	PC_NCR
1400 1400 d 3600
1400 1400 u 02 01
1400 1400 s 		LD	(HL),0
1402 1402 d c9
1402 1402 u 01 01
1402 1402 s 		RET
1403 1403 d fe20
1403 1403 u 02 01
1403 1403 s PC_NCR		CP	' '
1405 1405 d f8
1405 1405 u 01 01
1405 1405 s 		RET M
1406 1406 d 34
1406 1406 u 01 01
1406 1406 s 		INC	(HL)
1407 1407 d c9
1407 1407 u 01 01
1407 1407 s 		RET
1408 1408 s 
1408 1408 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1408 1408 s ;RS-232 RX Buffer Count
1408 1408 d e5
1408 1408 u 01 01
1408 1408 s RX_COUNT	PUSH	HL
1409 1409 d cd0e14
1409 1409 u 03 01
1409 1409 s 		CALL	RXC_DO	;Create a routine without stack management
140c 140c d e1
140c 140c u 01 01
140c 140c s 		POP	HL
140d 140d d c9
140d 140d u 01 01
140d 140d s 		RET
140e 140e s 
140e 140e d 3a92ff
140e 140e u 03 01
140e 140e s RXC_DO		LD	A,(INCHAR_EXE)	;Test which INCHAR routine is active
1411 1411 d fe17
1411 1411 u 02 01
1411 1411 s 		CP	LOW IC_BIT
1413 1413 d ca0915
1413 1413 u 03 01
1413 1413 s 		JP Z,	RXC_BIT
1416 1416 d fecf
1416 1416 u 02 01
1416 1416 s 		CP	LOW IC_ACE
1418 1418 d cac414
1418 1418 u 03 01
1418 1418 s 		JP Z,	RXC_ACE
141b 141b d fe6a
141b 141b u 02 01
141b 141b s 		CP	LOW IC_BOTH
141d 141d d 2842
141d 141d u 02 01
141d 141d s 		JR Z,	RXC_BOTH
141f 141f d af
141f 141f u 01 01
141f 141f s 		XOR	A
1420 1420 d c9
1420 1420 u 01 01
1420 1420 s 		RET
1421 1421 s 
1421 1421 s 
1421 1421 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1421 1421 s ;Check for A byte
1421 1421 s ;	Exit:	C=0, A=Byte from Buffer
1421 1421 s ;		C=1, Buffer Empty, no byte
1421 1421 s ;		w/call, tcy if no byte = ACE:141, BIT:181, BOTH:269
1421 1421 d e5
1421 1421 u 01 01
1421 1421 s IN_CHAR:	PUSH	HL		;11
1422 1422 d 2a92ff
1422 1422 u 03 01
1422 1422 s 		LD	HL,(INCHAR_EXE)	;16
1425 1425 d cda00c
1425 1425 u 03 01
1425 1425 s 		CALL	VCALL_HL	;17 +4 +routine ACE=56, BIT=96, Both=32+ACE+BIT   JP (HL)
1428 1428 d e1
1428 1428 u 01 01
1428 1428 s 		POP HL			;10
1429 1429 d c9
1429 1429 u 01 01
1429 1429 s 		RET			;10
142a 142a s 
142a 142a s 
142a 142a s ;===============================================
142a 142a s ;PURGE - Clears all in coming bytes until the line is clear for a full 2 seconds
142a 142a s ;-----------------------------------------------
142a 142a d 3e01
142a 142a u 02 01
142a 142a s PURGE		LD	A,1	;1 seconds for time out
142c 142c d cd4b14
142c 142c u 03 01
142c 142c s 		CALL	TIMED_GETCHAR
142f 142f d 30f9
142f 142f u 02 01
142f 142f s 		JR NC,	PURGE
1431 1431 d c9
1431 1431 u 01 01
1431 1431 s 		RET
1432 1432 s 
1432 1432 s ;===============================================
1432 1432 s ;DOT_GETCHAR
1432 1432 s ;in:	B=Count of Dots
1432 1432 s ;out: 	C=1, No Char (Time Out)
1432 1432 s ;	C=0, A = Char
1432 1432 s ;-----------------------------------------------
1432 1432 d 3e01
1432 1432 u 02 01
1432 1432 s DOT_GETCHAR	LD	A,1
1434 1434 d cd4b14
1434 1434 u 03 01
1434 1434 s 		CALL	TIMED_GETCHAR	;C=0, A=Byte from Buffer; C=1, no byte
1437 1437 d 3807
1437 1437 u 02 01
1437 1437 s 		JR  C,	DGC_DOT
1439 1439 d fe09
1439 1439 u 02 01
1439 1439 s 		CP	9
143b 143b d 280a
143b 143b u 02 01
143b 143b s 		JR   Z,	DGC_RET
143d 143d d e65f
143d 143d u 02 01
143d 143d s 		AND 	0x5F		;to upper case
143f 143f d c9
143f 143f u 01 01
143f 143f s 		RET			;Return to check charcter
1440 1440 d 3e2e
1440 1440 u 02 01
1440 1440 s DGC_DOT		LD	A,'.'		;Put out some thinking dots
1442 1442 d cdec13
1442 1442 u 03 01
1442 1442 s 		CALL	PUT_CHAR
1445 1445 d 10eb
1445 1445 u 02 01
1445 1445 s 		DJNZ	DOT_GETCHAR
1447 1447 d 37
1447 1447 u 01 01
1447 1447 s DGC_RET		SCF
1448 1448 d c9
1448 1448 u 01 01
1448 1448 s 		RET
1449 1449 s 
1449 1449 s ;===============================================
1449 1449 s ;TIMED1_GETCHAR - Gets a character within 1 second
1449 1449 s ;-----------------------------------------------
1449 1449 d 3e02
1449 1449 u 02 01
1449 1449 s TIMED1_GETCHAR	LD	A,2
144b 144b s 
144b 144b s ;===============================================
144b 144b s ;TIMED_GETCHAR - Gets a character within a time limit
144b 144b s ;in:	A contains # of 1/2 seconds to wait before returning
144b 144b s ;out: 	C=1, No Char (Time Out)
144b 144b s ;	C=0, A = Char
144b 144b s ;-----------------------------------------------
144b 144b d d5
144b 144b u 01 01
144b 144b s TIMED_GETCHAR	PUSH	DE
144c 144c d c5
144c 144c u 01 01
144c 144c s 		PUSH	BC
144d 144d d 57
144d 144d u 01 01
144d 144d s 		LD	D,A
144e 144e d 0e0f
144e 144e u 02 01
144e 144e s TGC_LP1		LD	C,15		;B,C=Loop Count down until timeout
1450 1450 s 					;TEST FOR RX DATA
1450 1450 d cd2114
1450 1450 u 03 01
1450 1450 s TGC_LP2		CALL	IN_CHAR	;ACE:141, BIT:181, BOTH:269	
1453 1453 d d25e14
1453 1453 u 03 01
1453 1453 s 		JP NC,	TGC_RET	;10
1456 1456 d 10f8
1456 1456 u 02 01
1456 1456 s 		DJNZ	TGC_LP2	;13/8	;110 Cycles inner Loop time. 164*256/4 ~= 10 mSec
1458 1458 d 0d
1458 1458 u 01 01
1458 1458 s 		DEC	C	;5
1459 1459 d 20f5
1459 1459 u 02 01
1459 1459 s 		JR NZ,	TGC_LP2	;10
145b 145b d 15
145b 145b u 01 01
145b 145b s 		DEC	D
145c 145c d 20f0
145c 145c u 02 01
145c 145c s 		JR NZ,	TGC_LP1
145e 145e s ;		SCF		;CARRY STILL SET TO INDICATE TIME OUT
145e 145e d c1
145e 145e u 01 01
145e 145e s TGC_RET		POP	BC
145f 145f d d1
145f 145f u 01 01
145f 145f s 		POP	DE
1460 1460 d c9
1460 1460 u 01 01
1460 1460 s 		RET
1461 1461 s 
1461 1461 s 
1461 1461 s ;-----------------------   B O T H  I/O   -----------------------
1461 1461 s ;----------------------------------------------------------------
1461 1461 d cd0915
1461 1461 u 03 01
1461 1461 s RXC_BOTH	CALL	RXC_BIT
1464 1464 d 6f
1464 1464 u 01 01
1464 1464 s 		LD	L,A	
1465 1465 d cdc414
1465 1465 u 03 01
1465 1465 s 		CALL	RXC_ACE
1468 1468 d b5
1468 1468 u 01 01
1468 1468 s 		OR	L
1469 1469 d c9
1469 1469 u 01 01
1469 1469 s 		RET
146a 146a s 
146a 146a d cd1715
146a 146a u 03 01
146a 146a s IC_BOTH		CALL	IC_BIT		;17
146d 146d d d0
146d 146d u 01 01
146d 146d s 		RET	NC		;11/5 RETURN IF CHAR
146e 146e d 185f
146e 146e u 02 01
146e 146e s 		JR	IC_ACE		;10
1470 1470 s 
1470 1470 d cde014
1470 1470 u 03 01
1470 1470 s PC_BOTH		CALL	PC_ACE
1473 1473 d cd3815
1473 1473 u 03 01
1473 1473 s 		CALL	PC_BIT
1476 1476 d c9
1476 1476 u 01 01
1476 1476 s 		RET		
1477 1477 s 
1477 1477 s 
1477 1477 s ;-----------------------   L E D  I/O   -----------------------
1477 1477 s ;--------------------------------------------------------------
1477 1477 s ;
1477 1477 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1477 1477 s ;Select Put_Char Output
1477 1477 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1477 1477 d e5
1477 1477 u 01 01
1477 1477 s LED_HOME	PUSH	HL
1478 1478 d 21e0ff
1478 1478 u 03 01
1478 1478 s 		LD	HL,LED_DISPLAY
147b 147b d 22c8ff
147b 147b u 03 01
147b 147b s 		LD	(LED_CURSOR),HL
147e 147e d e1
147e 147e u 01 01
147e 147e s 		POP	HL
147f 147f d c9
147f 147f u 01 01
147f 147f s 		RET
1480 1480 s 		
1480 1480 d e5
1480 1480 u 01 01
1480 1480 s LED_CLEAR	PUSH	HL
1481 1481 d c5
1481 1481 u 01 01
1481 1481 s 		PUSH	BC
1482 1482 d 3e0c
1482 1482 u 02 01
1482 1482 s 		LD	A,0x0C
1484 1484 d cd8a14
1484 1484 u 03 01
1484 1484 s 		CALL	PC_LED
1487 1487 d c1
1487 1487 u 01 01
1487 1487 s 		POP	BC
1488 1488 d e1
1488 1488 u 01 01
1488 1488 s 		POP	HL
1489 1489 d c9
1489 1489 u 01 01
1489 1489 s 		RET
148a 148a s 		
148a 148a s 
148a 148a s ;Put_Char to LED Display, Char in C
148a 148a d 2ac8ff
148a 148a u 03 01
148a 148a s PC_LED		LD	HL,(LED_CURSOR)	;Point to LED Display Buffer
148d 148d d 79
148d 148d u 01 01
148d 148d s 		LD	A,C
148e 148e d fe20
148e 148e u 02 01
148e 148e s 		CP	0x20		;Test for Control/unprintable characters
1490 1490 d 380b
1490 1490 u 02 01
1490 1490 s 		JR  C,	PCL_CTRL
1492 1492 s 
1492 1492 d 0629
1492 1492 u 02 01
1492 1492 s 		LD	B,HIGH LED_FONT	;Set BC to point to LED FONT
1494 1494 d cbb9
1494 1494 u 02 01
1494 1494 s 		RES	7,C		;Ensure ASCII 0x20-0x7F only
1496 1496 d 0a
1496 1496 u 01 01
1496 1496 s 		LD	A,(BC)
1497 1497 d cbff
1497 1497 u 02 01
1497 1497 s 		SET	7,A		;Ensure TXbit is 1
1499 1499 d 77
1499 1499 u 01 01
1499 1499 s 		LD	(HL),A		;Save Character in LED_DISPLAY BUFFER
149a 149a d 2c
149a 149a u 01 01
149a 149a s 		INC	L
149b 149b d 1817
149b 149b u 02 01
149b 149b s 		JR	PCL_RET2
149d 149d s 
149d 149d d fe0c
149d 149d u 02 01
149d 149d s PCL_CTRL	CP	0x0C		;<NP>
149f 149f d 200d
149f 149f u 02 01
149f 149f s 		JR NZ,	PCLC_1
14a1 14a1 d 0608
14a1 14a1 u 02 01
14a1 14a1 s 		LD	B,8		;<NP> Clears LED Line
14a3 14a3 d 3e80
14a3 14a3 u 02 01
14a3 14a3 s 		LD	A,0x80
14a5 14a5 d 21e0ff
14a5 14a5 u 03 01
14a5 14a5 s 		LD	HL,LED_DISPLAY
14a8 14a8 d 77
14a8 14a8 u 01 01
14a8 14a8 s PCLC_LP		LD	(HL),A
14a9 14a9 d 2c
14a9 14a9 u 01 01
14a9 14a9 s 		INC	L
14aa 14aa d 10fc
14aa 14aa u 02 01
14aa 14aa s 		DJNZ	PCLC_LP
14ac 14ac d 1803
14ac 14ac u 02 01
14ac 14ac s 		JR	PCL_RETC
14ae 14ae s 
14ae 14ae d fe0d
14ae 14ae u 02 01
14ae 14ae s PCLC_1		CP	0x0D		;<CR>	Control characters:
14b0 14b0 d c0
14b0 14b0 u 01 01
14b0 14b0 s 		RET	NZ
14b1 14b1 d 21e0ff
14b1 14b1 u 03 01
14b1 14b1 s PCL_RETC	LD	HL,LED_DISPLAY	;<CR> Returns cursor to start of LED Line
14b4 14b4 d cb9d
14b4 14b4 u 02 01
14b4 14b4 s PCL_RET2	RES	3,L
14b6 14b6 d 22c8ff
14b6 14b6 u 03 01
14b6 14b6 s 		LD	(LED_CURSOR),HL
14b9 14b9 d c9
14b9 14b9 u 01 01
14b9 14b9 s 		RET
14ba 14ba s 
14ba 14ba s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
14ba 14ba s ;Keyboard Get A byte
14ba 14ba s ;All Keys are equal, but F works as a SHIFT on Press and F on release
14ba 14ba s ;Output:	Z=1, No Key Pressed
14ba 14ba s ;		Z=0, A=Key Pressed, bit 4 = Shift, ie, 0x97 = Shift-7
14ba 14ba s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
14ba 14ba d e5
14ba 14ba u 01 01
14ba 14ba s IC_KEY		PUSH	HL
14bb 14bb d 21efff
14bb 14bb u 03 01
14bb 14bb s 		LD	HL,KEY_PRESSED
14be 14be d 7e
14be 14be u 01 01
14be 14be s 		LD	A,(HL)
14bf 14bf d 3600
14bf 14bf u 02 01
14bf 14bf s 		LD	(HL),0
14c1 14c1 d e1
14c1 14c1 u 01 01
14c1 14c1 s 		POP	HL
14c2 14c2 d b7
14c2 14c2 u 01 01
14c2 14c2 s 		OR	A
14c3 14c3 d c9
14c3 14c3 u 01 01
14c3 14c3 s 		RET
14c4 14c4 s 
14c4 14c4 s 
14c4 14c4 s ;-----------------------   A C E  I/O   -----------------------
14c4 14c4 s ;--------------------------------------------------------------
14c4 14c4 s ;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
14c4 14c4 s 
14c4 14c4 d 3a94ff
14c4 14c4 u 03 01
14c4 14c4 s RXC_ACE		LD	A,(HW_SETIO)
14c7 14c7 d e602
14c7 14c7 u 02 01
14c7 14c7 s 		AND	2
14c9 14c9 d c8
14c9 14c9 u 01 01
14c9 14c9 s 		RET  Z
14ca 14ca d dbcd
14ca 14ca u 02 01
14ca 14ca s 		IN	A,(ACE_STATUS)
14cc 14cc d e601
14cc 14cc u 02 01
14cc 14cc s 		AND	1		
14ce 14ce d c9
14ce 14ce u 01 01
14ce 14ce s 		RET
14cf 14cf s 
14cf 14cf d 3a94ff
14cf 14cf u 03 01
14cf 14cf s IC_ACE		LD	A,(HW_SETIO)	;13
14d2 14d2 d e602
14d2 14d2 u 02 01
14d2 14d2 s 		AND	2		;4
14d4 14d4 d 37
14d4 14d4 u 01 01
14d4 14d4 s 		SCF			;4  C=1, Assume byte NOT available
14d5 14d5 d c8
14d5 14d5 u 01 01
14d5 14d5 s 		RET  Z			;11/5
14d6 14d6 d dbcd
14d6 14d6 u 02 01
14d6 14d6 s 		IN	A,(ACE_STATUS)	;11
14d8 14d8 d e601
14d8 14d8 u 02 01
14d8 14d8 s 		AND	1		;4
14da 14da d 37
14da 14da u 01 01
14da 14da s 		SCF			;4  C=1, Assume byte NOT available
14db 14db d c8
14db 14db u 01 01
14db 14db s 		RET Z			;11/5 Exit if byte not available C=1
14dc 14dc d dbc8
14dc 14dc u 02 01
14dc 14dc s 		IN	A,(ACE_DATA)
14de 14de d b7
14de 14de u 01 01
14de 14de s 		OR	A		;Exit with C=0
14df 14df d c9
14df 14df u 01 01
14df 14df s 		RET
14e0 14e0 s 
14e0 14e0 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
14e0 14e0 s ;Put Char ACE,  C=Char to send
14e0 14e0 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
14e0 14e0 d 3a94ff
14e0 14e0 u 03 01
14e0 14e0 s PC_ACE		LD	A,(HW_SETIO)
14e3 14e3 d e602
14e3 14e3 u 02 01
14e3 14e3 s 		AND	2
14e5 14e5 d c8
14e5 14e5 u 01 01
14e5 14e5 s 		RET  Z
14e6 14e6 d dbcd
14e6 14e6 u 02 01
14e6 14e6 s PCA_LP		IN	A,(ACE_STATUS)
14e8 14e8 d e620
14e8 14e8 u 02 01
14e8 14e8 s 		AND	0x20
14ea 14ea d 28fa
14ea 14ea u 02 01
14ea 14ea s 		JR Z,	PCA_LP
14ec 14ec d 79
14ec 14ec u 01 01
14ec 14ec s 		LD	A,C
14ed 14ed d d3c8
14ed 14ed u 02 01
14ed 14ed s 		OUT	(ACE_DATA),A
14ef 14ef d 21d7ff
14ef 14ef u 03 01
14ef 14ef s 		LD  	HL, POS_ACE
14f2 14f2 d cdfc13
14f2 14f2 u 03 01
14f2 14f2 s 		CALL	PC_POS_UPDATE
14f5 14f5 d c9
14f5 14f5 u 01 01
14f5 14f5 s 		RET
14f6 14f6 s 
14f6 14f6 d 3e80
14f6 14f6 u 02 01
14f6 14f6 s ACE_SET_BAUD	LD	A,0x80		;Set baud rate
14f8 14f8 d d3cb
14f8 14f8 u 02 01
14f8 14f8 s 		OUT	(ACE_LCR),A
14fa 14fa d 3a8fff
14fa 14fa u 03 01
14fa 14fa s 		LD	A,(ACE_BAUD)	;12=9600 baud
14fd 14fd d d3c8
14fd 14fd u 02 01
14fd 14fd s 		OUT	(ACE_BAUD0),A
14ff 14ff d af
14ff 14ff u 01 01
14ff 14ff s 		XOR	A
1500 1500 d d3c9
1500 1500 u 02 01
1500 1500 s 		OUT	(ACE_BAUD1),A
1502 1502 d 3e03
1502 1502 u 02 01
1502 1502 s 		LD	A,3		;Set 8 data bits, no parity, 1 stop
1504 1504 d d3cb
1504 1504 u 02 01
1504 1504 s 		OUT	(ACE_LCR),A
1506 1506 d dbc8
1506 1506 u 02 01
1506 1506 s 		IN	A,(ACE_DATA)	;Clear any rxd flag
1508 1508 d c9
1508 1508 u 01 01
1508 1508 s 		RET
1509 1509 s 
1509 1509 s 
1509 1509 s ;-----------------------   B I T  I/O   -----------------------
1509 1509 s ;--------------------------------------------------------------
1509 1509 d 3a94ff
1509 1509 u 03 01
1509 1509 s RXC_BIT		LD	A,(HW_SETIO)
150c 150c d e601
150c 150c u 02 01
150c 150c s 		AND	1
150e 150e d c8
150e 150e u 01 01
150e 150e s 		RET  Z		
150f 150f d 3acaff
150f 150f u 03 01
150f 150f s 		LD	A,(RXBHEAD)
1512 1512 d 21ccff
1512 1512 u 03 01
1512 1512 s 		LD	HL,RXBTAIL
1515 1515 d 96
1515 1515 u 01 01
1515 1515 s 		SUB	(HL)		
1516 1516 d c9
1516 1516 u 01 01
1516 1516 s 		RET
1517 1517 s 
1517 1517 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1517 1517 s ;RS-232 Get A byte
1517 1517 s ;	Exit:	C=0, A=Byte from Buffer
1517 1517 s ;		C=1, Buffer Empty, no byte
1517 1517 s ;		w/call, tcy=87 if no byte
1517 1517 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1517 1517 d 3a94ff
1517 1517 u 03 01
1517 1517 s IC_BIT		LD	A,(HW_SETIO)	;13
151a 151a d e601
151a 151a u 02 01
151a 151a s 		AND	1		;4
151c 151c d 37
151c 151c u 01 01
151c 151c s 		SCF			;4  C=1, Assume byte NOT available
151d 151d d c8
151d 151d u 01 01
151d 151d s 		RET  Z			;11/5
151e 151e d c5
151e 151e u 01 01
151e 151e s 		PUSH	BC		;11
151f 151f d 3acaff
151f 151f u 03 01
151f 151f s 		LD	A,(RXBHEAD)	;13 Test if TAIL=HEAD (=No bytes in buffer)
1522 1522 d 47
1522 1522 u 01 01
1522 1522 s 		LD	B,A		;4
1523 1523 d 3accff
1523 1523 u 03 01
1523 1523 s 		LD	A,(RXBTAIL)	;13
1526 1526 d a8
1526 1526 u 01 01
1526 1526 s 		XOR	B		;4 Check if byte(s) in receive buffer
1527 1527 d c1
1527 1527 u 01 01
1527 1527 s 		POP	BC		;10
1528 1528 d 37
1528 1528 u 01 01
1528 1528 s 		SCF			;4  C=1, Assume byte NOT available
1529 1529 d c8
1529 1529 u 01 01
1529 1529 s 		RET Z			;11 Exit if byte not available (ie TAIL=HEAD), C=1
152a 152a d e5
152a 152a u 01 01
152a 152a s 		PUSH	HL
152b 152b d f3
152b 152b u 01 01
152b 152b s 		DI
152c 152c d 2accff
152c 152c u 03 01
152c 152c s 		LD	HL,(RXBTAIL)
152f 152f d 2c
152f 152f u 01 01
152f 152f s 		INC	L
1530 1530 d 22ccff
1530 1530 u 03 01
1530 1530 s 		LD	(RXBTAIL),HL	;Tail = Tail + 1
1533 1533 d fb
1533 1533 u 01 01
1533 1533 s 		EI
1534 1534 d 7e
1534 1534 u 01 01
1534 1534 s 		LD	A,(HL)		;A = Byte from buffer (@ TAIL)
1535 1535 d e1
1535 1535 u 01 01
1535 1535 s 		POP	HL
1536 1536 d b7
1536 1536 u 01 01
1536 1536 s 		OR	A		;Exit with C=0
1537 1537 d c9
1537 1537 u 01 01
1537 1537 s 		RET
1538 1538 s 
1538 1538 s 
1538 1538 s ;Put_Char to RS232 BIT banger
1538 1538 s ;The bit banged byte to be sent is done through the msb of the LED Display Output byte.
1538 1538 s ;To simplify AND expedite the sending of those Display bytes (with the RS-232 BIT), the transmitted
1538 1538 s ;byte will be scattered in a secondary buffer that is 10 bytes (1 start, 8 data, 1 stop)
1538 1538 s ;This secondary buffer will have the transmitted bits mixed IN with the LED Display Bytes
1538 1538 s ;The Interrupt is disabled only at crucial moments, but otherwise left on to accept any characters
1538 1538 s ;received from the RS-232 line
1538 1538 d 21d6ff
1538 1538 u 03 01
1538 1538 s PC_BIT		LD  	HL, POS_BIT
153b 153b d cdfc13
153b 153b u 03 01
153b 153b s 		CALL	PC_POS_UPDATE
153e 153e d 21f6ff
153e 153e u 03 01
153e 153e s 		LD  	HL,LED_DISPLAY_SB
1541 1541 s 				;Copy 10 bytes from the LED_DISPLAY buffer (MOD 8) to the secondary buffer
1541 1541 d ed5bd0ff
1541 1541 u 04 01
1541 1541 s PC_REDO		LD  	DE,(SCAN_PTR)   ;SCAN_PTR holds the next LED BYTE @ OUTPUT.
1545 1545 d 43
1545 1545 u 01 01
1545 1545 s 		LD  	B,E		;Save SCAN_PTR for test if an Interrupt occurs
1546 1546 s 
1546 1546 d 3af5ff
1546 1546 u 03 01
1546 1546 s 		LD	A,(SCAN_LED)
1549 1549 d 77
1549 1549 u 01 01
1549 1549 s 		LD  	(HL),A
154a 154a d cbbe
154a 154a u 02 01
154a 154a s 		RES 	7,(HL)	;Configure Start BIT (msb) to be 0
154c 154c s 
154c 154c d 2c
154c 154c u 01 01
154c 154c s 		INC 	L
154d 154d s 				;Shift next 9 bits IN this loop,
154d 154d d 3a95ff
154d 154d u 03 01
154d 154d s PC_LP0		LD	A,(HW_LIST)	;Skip other buffer bytes if FP not present
1550 1550 d b7
1550 1550 u 01 01
1550 1550 s 		OR	A
1551 1551 d 3af5ff
1551 1551 u 03 01
1551 1551 s 		LD	A,(SCAN_LED)	;Save for next interrupt
1554 1554 d 2804
1554 1554 u 02 01
1554 1554 s 		JR  Z,	PC_NOFP
1556 1556 s 
1556 1556 d 1c
1556 1556 u 01 01
1556 1556 s 		INC 	E
1557 1557 d cb9b
1557 1557 u 02 01
1557 1557 s 		RES 	3,E		;Bound DE to the 8 bytes of LED_DISPLAY
1559 1559 d 1a
1559 1559 u 01 01
1559 1559 s 		LD  	A,(DE)
155a 155a s 		
155a 155a d 17
155a 155a u 01 01
155a 155a s PC_NOFP		RLA		;Bump OUT msb
155b 155b d cb09
155b 155b u 02 01
155b 155b s 		RRC 	C		;Fetch Data BIT (non destructive shifting incase of REDO)
155d 155d d cb1f
155d 155d u 02 01
155d 155d s 		RR  	A		;Shift IN Data BIT
155f 155f d 77
155f 155f u 01 01
155f 155f s 		LD  	(HL),A
1560 1560 d 2c
1560 1560 u 01 01
1560 1560 s 		INC 	L
1561 1561 d 20ea
1561 1561 u 02 01
1561 1561 s 		JR  	NZ,PC_LP0
1563 1563 s 
1563 1563 d 2d
1563 1563 u 01 01
1563 1563 s 		DEC 	L
1564 1564 d cbfe
1564 1564 u 02 01
1564 1564 s 		SET 	7,(HL)	;Stop Bit
1566 1566 s 
1566 1566 d 2ef6
1566 1566 u 02 01
1566 1566 s 		LD  	L,LOW LED_DISPLAY_SB  ;Restart Pointer to Secondary Buffer
1568 1568 s 
1568 1568 s 				;Test if SCAN_PTR Changed (due to ISR)
1568 1568 d 1e05
1568 1568 u 02 01
1568 1568 s 		LD  E,5		;Preload RX delay counter (incase of RX byte during TX)
156a 156a d 1680
156a 156a u 02 01
156a 156a s 		LD  D,0x80	;Preload RxD Register with A marker BIT (to count 8 data bits)
156c 156c s 
156c 156c d f3
156c 156c u 01 01
156c 156c s 		DI		;STOP INTERRUPTS HERE to see if SCAN_PTR has changed (due to Timer Interrupt)
156d 156d d 3ad0ff
156d 156d u 03 01
156d 156d s 		LD  A,(SCAN_PTR) ;Adjust working scan pointer (counted to 10 mod 8, so subtract 2 to restore)
1570 1570 d a8
1570 1570 u 01 01
1570 1570 s 		XOR B
1571 1571 d 2805
1571 1571 u 02 01
1571 1571 s 		JR  Z,PC_0
1573 1573 s 				;If SCAN_PTR changed, Redo the Secondary Buffer
1573 1573 d fb
1573 1573 u 01 01
1573 1573 s 		EI		;Allow Interrupts again while preparing Secondary Buffer
1574 1574 d cb01
1574 1574 u 02 01
1574 1574 s 		RLC C		;ADJUST Transmitted bits due to 9 bits shifted (back up 1 BIT)
1576 1576 d 18c9
1576 1576 u 02 01
1576 1576 s 		JR  PC_REDO
1578 1578 s ;- - - - - - - - - - - - - - - - - - - - - Transmit the BYTE here....(BYTE encoded in temp 10 byte LED buffer)
1578 1578 s ;1 Bit time at 9600 = 416.6666 cycles
1578 1578 s 
1578 1578 d 0e40
1578 1578 u 02 01
1578 1578 s PC_0		LD  C,Port40
157a 157a s 
157a 157a d 7e
157a 157a u 01 01
157a 157a s PC_1		LD  A,(HL)	;7	Send BIT
157b 157b d d340
157b 157b u 02 01
157b 157b s 		OUT (Port40),A	;11
157d 157d d 0608
157d 157d u 02 01
157d 157d s 		LD  B,8		;7
157f 157f s 
157f 157f d ed78
157f 157f u 02 01
157f 157f s PC_2		IN  A,(C)	;12	;While waiting, Poll for RX DATA Start bit
1581 1581 d f29f15
1581 1581 u 03 01
1581 1581 s 		JP  P,PC_5	;10 tc (Note 1.JP)
1584 1584 d 3a0000
1584 1584 u 03 01
1584 1584 s 		LD  A,(0)	;13 tc NOP
1587 1587 d 10f6
1587 1587 u 02 01
1587 1587 s PC_3		DJNZ PC_2	;13/8  ;48 IN loop (-5 on last itteration).  48 * 8 + 39 - 5 = 418 tc per BIT
1589 1589 s 
1589 1589 d 2c
1589 1589 u 01 01
1589 1589 s 		INC L		;4
158a 158a d c27a15
158a 158a u 03 01
158a 158a s 		JP  NZ,PC_1	;10	;39 TC Overhead to send BIT
158d 158d d c32216
158d 158d u 03 01
158d 158d s 		JP  PC_RET
1590 1590 s 
1590 1590 d cb38
1590 1590 u 02 01
1590 1590 s PC_4		SRL B		;4	If false start bit detected, Divide B by 2 and return to simple tx
1592 1592 d c28715
1592 1592 u 03 01
1592 1592 s 		JP  NZ,PC_3	;10
1595 1595 d 2c
1595 1595 u 01 01
1595 1595 s 		INC L		;4
1596 1596 d ca2216
1596 1596 u 03 01
1596 1596 s 		JP  Z,PC_RET	;10
1599 1599 d 7e
1599 1599 u 01 01
1599 1599 s 		LD  A,(HL)	;7	Send BIT
159a 159a d d340
159a 159a u 02 01
159a 159a s 		OUT (Port40),A	;11
159c 159c d c37f15
159c 159c u 03 01
159c 159c s 		JP  PC_2	;10
159f 159f s 
159f 159f s 
159f 159f s 				;Here an RX byte was detected while transmitting.
159f 159f s 				;Delay IN detection could be as much as 60tc, we will assume 1/2 (=30tc)
159f 159f s 				;We need to test Start Bit @ 208tc,
159f 159f s 				;We are juggling TX & RX. TX will occur earlier than BIT time due to shorter loop delay
159f 159f d 2c
159f 159f u 01 01
159f 159f s PC_5		INC  L		;4
15a0 15a0 d 05
15a0 15a0 u 01 01
15a0 15a0 s 		DEC  B		;4
15a1 15a1 d caab15
15a1 15a1 u 03 01
15a1 15a1 s 		JP Z,PC_7	;10
15a4 15a4 d cb20
15a4 15a4 u 02 01
15a4 15a4 s 		SLA  B		;8      Multiply B by 2 for 24 cycle loop
15a6 15a6 d 1d
15a6 15a6 u 01 01
15a6 15a6 s PC_6		DEC  E		;4	RxBit Timing
15a7 15a7 d 280f
15a7 15a7 u 02 01
15a7 15a7 s 		JR   Z,PC_9	;7/12   ;Either before OR after sending A BIT, we will branch OUT of loop here to check for RX Start Bit
15a9 15a9 d 10fb
15a9 15a9 u 02 01
15a9 15a9 s 		DJNZ PC_6	;13/8 tc TxBit Timing
15ab 15ab s 				;		24 tc Loop
15ab 15ab s ;TxBit
15ab 15ab d 060d
15ab 15ab u 02 01
15ab 15ab s PC_7	       	LD  B,13	;7
15ad 15ad d af
15ad 15ad u 01 01
15ad 15ad s 		XOR A		;4
15ae 15ae d b5
15ae 15ae u 01 01
15ae 15ae s 		OR  L		;4
15af 15af d 2804
15af 15af u 02 01
15af 15af s 		JR  Z,PC_8	;7/12	;Stop sending if L=0
15b1 15b1 d 7e
15b1 15b1 u 01 01
15b1 15b1 s 		LD  A,(HL)	;7	;39 to send next BIT
15b2 15b2 d d340
15b2 15b2 u 02 01
15b2 15b2 s 		OUT (Port40),A	;11
15b4 15b4 d 2c
15b4 15b4 u 01 01
15b4 15b4 s 		INC L		;4
15b5 15b5 d c3a615
15b5 15b5 u 03 01
15b5 15b5 s PC_8		JP  PC_6	;10 tc (Note 1.JP)
15b8 15b8 s 
15b8 15b8 s 				;Test if Start Bit is good (at ~1/2 BIT time)
15b8 15b8 d 1e05
15b8 15b8 u 02 01
15b8 15b8 s PC_9		LD  E,5		;7   E=5 incase we have a bad start bit and have to return to simple TX
15ba 15ba d ed78
15ba 15ba u 02 01
15ba 15ba s 		IN  A,(C)	;12  Re-TEST Start Bit at 1/2 bit time
15bc 15bc d fa9015
15bc 15bc u 03 01
15bc 15bc s 		JP  M,PC_4	;10  If Start BIT not verified, then return to simple TXD (return at point where we are Decrementing B to minimize diff)
15bf 15bf d 1e0f
15bf 15bf u 02 01
15bf 15bf s 		LD  E,15	;7   Adjust initial sampling delay (as per timing observed)
15c1 15c1 s 
15c1 15c1 s 
15c1 15c1 s 				;At this point, we have good start BIT, 1 OR more TX bits left to go...  here's where timing is accurate again
15c1 15c1 s 				;We will go through each TXbit AND RXBit once during the full BIT time.  So the time of these routines are added
15c1 15c1 d 1d
15c1 15c1 u 01 01
15c1 15c1 s PC_10		DEC E		;4
15c2 15c2 d 2814
15c2 15c2 u 02 01
15c2 15c2 s 		JR  Z,PC_14	;7/12
15c4 15c4 d 10fb
15c4 15c4 u 02 01
15c4 15c4 s PC_11		DJNZ PC_10	;13/8 tc    24Loop= 6uSec
15c6 15c6 s 
15c6 15c6 s 				; TX= S 0 1 2 3 4 5 6 7 S
15c6 15c6 s 				; RX=  S 0 1 2 3 4 5 6 7 S  <-It's possible to receive all 8 data bits before sending Stop Bit
15c6 15c6 s ;TxBit ;54tc to Send BIT
15c6 15c6 d af
15c6 15c6 u 01 01
15c6 15c6 s 		XOR A		;4
15c7 15c7 d b5
15c7 15c7 u 01 01
15c7 15c7 s 		OR  L		;4
15c8 15c8 d 2809
15c8 15c8 u 02 01
15c8 15c8 s 		JR  Z,PC_13	;7/12	;Stop sending if L=0
15ca 15ca d 7e
15ca 15ca u 01 01
15ca 15ca s 		LD  A,(HL)	;7
15cb 15cb d d340
15cb 15cb u 02 01
15cb 15cb s 		OUT (Port40),A	;11
15cd 15cd d 2c
15cd 15cd u 01 01
15cd 15cd s 		INC L		;4
15ce 15ce d 060d
15ce 15ce u 02 01
15ce 15ce s PC_12        	LD  B,13	;7     (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
15d0 15d0 d c3c115
15d0 15d0 u 03 01
15d0 15d0 s 		JP  PC_10	;10 tc (Note 1.JP)
15d3 15d3 s 
15d3 15d3 d 060d
15d3 15d3 u 02 01
15d3 15d3 s PC_13		LD  B,13	;7     (7tc NOP)
15d5 15d5 d c3ce15
15d5 15d5 u 03 01
15d5 15d5 s 		JP  PC_12	;10 tc (Note 1.JP)
15d8 15d8 s 
15d8 15d8 s ;RxBit ;51tc to Receive BIT
15d8 15d8 d db40
15d8 15d8 u 02 01
15d8 15d8 s PC_14		IN   A,(Port40)	;11	Fetch RXbit
15da 15da d 00
15da 15da u 01 01
15da 15da s 		NOP		;4
15db 15db d 07
15db 15db u 01 01
15db 15db s 		RLCA		;4	put IN CARRY
15dc 15dc d cb1a
15dc 15dc u 02 01
15dc 15dc s 		RR    D		;8	shift into RxD
15de 15de d 1e0d
15de 15de u 02 01
15de 15de s 		LD    E,13	;7      (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
15e0 15e0 d 3803
15e0 15e0 u 02 01
15e0 15e0 s 		JR C, PC_15	;7/12	;Test for marker BIT shifting OUT of D
15e2 15e2 d c3c415
15e2 15e2 u 03 01
15e2 15e2 s 		JP    PC_11	;10	RXBIT = 40tc
15e5 15e5 s 
15e5 15e5 d 00
15e5 15e5 u 01 01
15e5 15e5 s PC_15		NOP		;4
15e6 15e6 d 1d
15e6 15e6 u 01 01
15e6 15e6 s PC_16		DEC  E		;4
15e7 15e7 d 2814
15e7 15e7 u 02 01
15e7 15e7 s 		JR Z,PC_19	;7/12
15e9 15e9 d 10fb
15e9 15e9 u 02 01
15e9 15e9 s 		DJNZ PC_16	;13/8 tc    24Loop= 6uSec
15eb 15eb s 
15eb 15eb s 				; TX= S 0 1 2 3 4 5 6 7 S
15eb 15eb s 				; RX=  S 0 1 2 3 4 5 6 7 S  <-It's possible to receive all 8 data bits before sending Stop Bit
15eb 15eb s ;TxBit ;54tc to Send BIT
15eb 15eb d af
15eb 15eb u 01 01
15eb 15eb s 		XOR  A		;4
15ec 15ec d b5
15ec 15ec u 01 01
15ec 15ec s 		OR   L		;4
15ed 15ed d 2809
15ed 15ed u 02 01
15ed 15ed s 		JR Z,PC_18	;7/12	;Stop sending if L=0
15ef 15ef d 7e
15ef 15ef u 01 01
15ef 15ef s 		LD   A,(HL)	;7
15f0 15f0 d d340
15f0 15f0 u 02 01
15f0 15f0 s 		OUT (Port40),A	;11
15f2 15f2 d 2c
15f2 15f2 u 01 01
15f2 15f2 s 		INC  L		;4
15f3 15f3 d 060d
15f3 15f3 u 02 01
15f3 15f3 s PC_17        	LD   B,13	;7     (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
15f5 15f5 d c3e615
15f5 15f5 u 03 01
15f5 15f5 s 		JP   PC_16	;10 tc (Note 1.JP)
15f8 15f8 s 
15f8 15f8 d 060d
15f8 15f8 u 02 01
15f8 15f8 s PC_18		LD   B,13	;7     (7tc NOP)
15fa 15fa d c3f315
15fa 15fa u 03 01
15fa 15fa s 		JP   PC_17	;10 tc (Note 1.JP)
15fd 15fd s 
15fd 15fd s 
15fd 15fd s 
15fd 15fd s ;RxBit ;51tc to Receive BIT
15fd 15fd d db40
15fd 15fd u 02 01
15fd 15fd s PC_19		IN  A,(Port40)	;11	Fetch Stop BIT
15ff 15ff d 07
15ff 15ff u 01 01
15ff 15ff s 		RLCA		;4	put IN CARRY
1600 1600 d da0916
1600 1600 u 03 01
1600 1600 s 		JP C,PC_20
1603 1603 d 218dff
1603 1603 u 03 01
1603 1603 s 		LD   HL,RX_ERR_STOP
1606 1606 d cd260e
1606 1606 u 03 01
1606 1606 s 		CALL TINC
1609 1609 s 
1609 1609 d 7a
1609 1609 u 01 01
1609 1609 s PC_20		LD  A,D		;Fetch received byte to RX Buffer
160a 160a d 2acaff
160a 160a u 03 01
160a 160a s 		LD  HL,(RXBHEAD)
160d 160d d 2c
160d 160d u 01 01
160d 160d s 		INC L
160e 160e d 22caff
160e 160e u 03 01
160e 160e s 		LD  (RXBHEAD),HL ;Head = Head + 1
1611 1611 d 77
1611 1611 u 01 01
1611 1611 s 		LD  (HL),A	;Stuff into RX BUFFER
1612 1612 d 3accff
1612 1612 u 03 01
1612 1612 s 		LD  A,(RXBTAIL)
1615 1615 d bd
1615 1615 u 01 01
1615 1615 s 		CP  L
1616 1616 d 200a
1616 1616 u 02 01
1616 1616 s 		JR  NZ,PC_RET	;Jump if NOT Zero = No Over run error (Head <> Tail)
1618 1618 d 3c
1618 1618 u 01 01
1618 1618 s 		INC A		;Else
1619 1619 d 32ccff
1619 1619 u 03 01
1619 1619 s 		LD  (RXBTAIL),A	;Tail = Tail + 1
161c 161c d 218eff
161c 161c u 03 01
161c 161c s 		LD   HL,RX_ERR_OVR ;Count Over Run Error
161f 161f d cd260e
161f 161f u 03 01
161f 161f s 		CALL TINC
1622 1622 s 
1622 1622 d 3a95ff
1622 1622 u 03 01
1622 1622 s PC_RET		LD	A,(HW_LIST)	;Skip Resync if FP not present
1625 1625 d b7
1625 1625 u 01 01
1625 1625 s 		OR	A
1626 1626 d 2811
1626 1626 u 02 01
1626 1626 s 		JR  Z,	PC_RET1
1628 1628 s 
1628 1628 d db40
1628 1628 u 02 01
1628 1628 s 		IN	A,(Port40)	;Resync the SCAN_PTR
162a 162a d 3c
162a 162a u 01 01
162a 162a s 		INC	A
162b 162b d e607
162b 162b u 02 01
162b 162b s 		AND	7
162d 162d d f6e0
162d 162d u 02 01
162d 162d s 		OR  LOW LED_DISPLAY
162f 162f d 6f
162f 162f u 01 01
162f 162f s 		LD	L,A
1630 1630 d 32d0ff
1630 1630 u 03 01
1630 1630 s 		LD	(SCAN_PTR),A	;Save Scan Ptr @ Next Scan Output
1633 1633 d 26ff
1633 1633 u 02 01
1633 1633 s 		LD	H,HIGH SCAN_PTR
1635 1635 d 7e
1635 1635 u 01 01
1635 1635 s 		LD	A,(HL)
1636 1636 d 32f5ff
1636 1636 u 03 01
1636 1636 s 		LD	(SCAN_LED),A	;Save for next interrupt		
1639 1639 d fb
1639 1639 u 01 01
1639 1639 s PC_RET1		EI
163a 163a d c9
163a 163a u 01 01
163a 163a s 		RET
163b 163b s 
163b 163b s 
163b 163b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
163b 163b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
163b 163b s ;	Chapter_11	ISR.  RS-232 Receive, LED & Keyboard scanning, Timer tic counting
163b 163b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
163b 163b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
163b 163b s 
163b 163b s ;                       *********   *******    ********
163b 163b s ;                       *********  *********   *********
163b 163b s ;                          ***     **     **   **     **
163b 163b s ;                          ***     **          **     **
163b 163b s ;---------------------     ***     *******     ********   ---------------------
163b 163b s ;---------------------     ***       *******   ********   ---------------------
163b 163b s ;                          ***            **   **  **
163b 163b s ;                          ***     **     **   **   **
163b 163b s ;                       *********  *********   **    **
163b 163b s ;                       *********   *******    **     **
163b 163b s ;
163b 163b s ;
163b 163b s ;
163b 163b s ;The ISR will service either the Timer interrupt or Serial Data (bit banger) interrupt.
163b 163b s ;
163b 163b s ;The ISR will re-enable interrupts during Timer functions for re-entry to catch Serial Data.
163b 163b s ;
163b 163b s ;
163b 163b s ;The INT calls RST 38.  RST38 is the same in ROM or RAM.
163b 163b s ;
163b 163b s ;**RST38--------Switch to the Alternate Register set, jump to ISR_VEC (typcially ISR_DISPATCH)
163b 163b s ;**ISR_DISPATCH-Direct Select ROM, Check input port, jump to ISR_RXD (RS-232) or ISR_TIMER
163b 163b s ;**ISR_RXD------Bit Bang a byte, store in RXBUFFER, jump to ISR_RET
163b 163b s ;**ISR_TIMER----Output LED (Clears TIMER_INT), enter Extended Timer or jump to ISR_RET (If
163b 163b s ;		already executing the extended Timer)
163b 163b s ;ISR_EXTIMER----RAM/ROM state, set to ROM. Use ISR Stack, Undo Alternate Registers, EI, PUSH HL, AF
163b 163b s ;		Resync LED to scan, Do Halt Test (jump BREAK_RET), Run TicCounter (1mSec),
163b 163b s ;		Do extra extended timer to complete keypad scans every 32mSec or exit EXTIMER
163b 163b s ;ISR_EXXTIMER---Scan Keypad for events, do Keyevents as they occur to control LED output,
163b 163b s ;		update LED output, <Ctrl>-C Test (jump BREAK_RET), Call User Interrupt Vector
163b 163b s ;		Keypad Event F-E causes jump to BREAK_RET
163b 163b s ;		Single Step causes jump to BREAK_RET
163b 163b s ;ISR_EXTIMER_RET POP AF, HL. Restore Stack, Restore RAM/ROM state, Switch to Alternate Registers for RET
163b 163b s ;**ISR_RET------Select RAM/ROM state as tracked in Mainline code, Undo Alternate Registers, EI. RETI
163b 163b s ;BREAK_RET------Leaves the ISR to return to 0000 and restart the monitor.
163b 163b s 
163b 163b s ;** = ISR RUNNING ON ALTERNATE REGSITERS (**IROAR**)
163b 163b s 
163b 163b s ;
163b 163b s ;
163b 163b s ;	Normal timer interrupt takes 463 cycles  (??? outdated counts)
163b 163b s ;	42  ISR Vectoring & Redirection
163b 163b s ;	50  Timer Int Detection
163b 163b s ;	28  LED Refresh (Re-enable Interrupts)
163b 163b s ;	78  Resync & Prepare next LED Refresh value
163b 163b s ;	111 Halt Test
163b 163b s ;	38  TIC Counter
163b 163b s ;	21  Keyboard/Display maintenance required check
163b 163b s ;	41  User Interrupt Check
163b 163b s ;	34  ISR Exit
163b 163b s ;
163b 163b s ;	Occuring 8 out of 32 ISR's:
163b 163b s ;	82  Scanning non pressed keys
163b 163b s ;
163b 163b s ;	Occuring 1 out of 32 ISR's
163b 163b s ;	165 Processing non pressed keys
163b 163b s ;	97  Ctrl-C Checking
163b 163b s ;	67  Beeper Timer
163b 163b s ;	31  Cmd Expiration Timer
163b 163b s ;	262 Display Memory contents
163b 163b s ;	649 Display Register contents
163b 163b s ;
163b 163b s ;	24/32 ISR's = 463 cycles	= 11,112
163b 163b s ;	7/32  ISR's = 545 cycles    	=  3,815
163b 163b s ;	1/32  ISR's = 1,554 cycles	=  1,554 (Displaying Register)
163b 163b s ;	Total over 32 ISR's		= 16,481
163b 163b s ;	Average per ISR = 515 cycles
163b 163b s ;			= 128.75uS used every 1024uS interrupt cycle
163b 163b s ;			= 13% ISR Overhead (When Displaying Register)
163b 163b s ;
163b 163b s ;
163b 163b s ;
163b 163b s ;
163b 163b s ;
163b 163b s ;Note: A start bit can still hijack the ISR at Dispatch.
163b 163b s ;
163b 163b s ;A start bit happening anywhere in mainline code will take ~???tc to reach ISR_RXD
163b 163b s ;A start bit happening upon entry to ISR_DISPATCH (when doing timer int) will take ??tc to reach ISR_RXD
163b 163b s ;A start bit happening just past the ISR_DISPATCH window of opportunity will take 
163b 163b s ;
163b 163b s ;ISR_DISPATCH Sort out what is causing the interrupt
163b 163b s ;
163b 163b s 
163b 163b s 
163b 163b s ;- - - - - - - - - - - - - - RS-232 Receive BYTE
163b 163b s ;
163b 163b s ;1 Bit time at 9600 = 416.6666 cycles	;We get here ~25 to 200 tc (range = 175tc = 1/2 bit time)
163b 163b s ;**IROAR**
163b 163b d 2e02
163b 163b u 02 01
163b 163b s ISR_RXD		LD   L,2	;7
163d 163d d db40
163d 163d u 02 01
163d 163d s IRXD_VS		IN   A,(Port40)	;11	;Re-sample Start BIT @+7, +35tc
163f 163f d 07
163f 163f u 01 01
163f 163f s 		RLCA		;4	;(Actual sampling occurs 9 OR 10 tc later)
1640 1640 d 383e
1640 1640 u 02 01
1640 1640 s 		JR   C,IRXD_INC	;7/12
1642 1642 d 2d
1642 1642 u 01 01
1642 1642 s 		DEC  L		;4
1643 1643 d 20f8
1643 1643 u 02 01
1643 1643 s 		JR  NZ,IRXD_VS	;7/12
1645 1645 s 				;35tc per loop
1645 1645 s 				;@+68 when we come OUT of loop
1645 1645 s 				;
1645 1645 s 				;=~93tc to ~268tc  Middle = 180
1645 1645 s 				;
1645 1645 s 				;Must have a total delay of 1.5 bits 625 to reach middle of 1st data BIT
1645 1645 s 				;Total delay: 1.5 * 416 = 625tc
1645 1645 s 				;Next bit is at 417tc to 834tc
1645 1645 s 				;625-180 = Need another 445 Delay
1645 1645 s 		
1645 1645 s 
1645 1645 s 				;My cycle counting is off by at least 30uSec = 120tc
1645 1645 s 				;Changed 26 to 20.  20*16-5=315 (411-315=96)
1645 1645 s 
1645 1645 s 		
1645 1645 d 3e16
1645 1645 u 02 01
1645 1645 s 		LD   A,22	;7	;Delay loop after START Bit
1647 1647 d 3d
1647 1647 u 01 01
1647 1647 s 		DEC  A		;4
1648 1648 d 20fd
1648 1648 u 02 01
1648 1648 s 		JR   NZ,$-1	;12/7	Delay loop = 26 * 16 - 5 = 411
164a 164a s 
164a 164a s 
164a 164a s ;- - - - - - - - - - - - - - RS-232 Receive BYTE
164a 164a d 2e08
164a 164a u 02 01
164a 164a s 		LD   L,8	;7
164c 164c s 				;@624	;Loop through sampling 8 data bits
164c 164c s IRXD_NB		
164c 164c d db40
164c 164c u 02 01
164c 164c s 		IN   A,(Port40)	;11	;Sample BIT
164e 164e d 07
164e 164e u 01 01
164e 164e s 		RLCA		;4	;Get BIT
164f 164f d cb1c
164f 164f u 02 01
164f 164f s 		RR   H		;8	;Shift IN
1651 1651 d 2d
1651 1651 u 01 01
1651 1651 s 		DEC  L		;4	;Count down 8 bits
1652 1652 s 	;	JR   Z,IRXD_STP	;7/12	;Use this jump to test for STOP bit
1652 1652 s 
1652 1652 d 2814
1652 1652 u 02 01
1652 1652 s 		JR  Z,IRXD_SAVE	;7/12	Optional to finish receiving byte here AND ignore framing errors
1654 1654 s 				;	(Replace the previous condital jump with IRXD_SAVE destination).
1654 1654 s 
1654 1654 d 3e17
1654 1654 u 02 01
1654 1654 s IRXD_NI		LD  A,23	;7	;Delay loop between data bits
1656 1656 d 3d
1656 1656 u 01 01
1656 1656 s 		DEC A		;4
1657 1657 d 20fd
1657 1657 u 02 01
1657 1657 s 		JR  NZ,$-1	;12/7	;Delay loop = 16 * 23 + 53 - 5 = 416
1659 1659 d 18f1
1659 1659 u 02 01
1659 1659 s 		JR  IRXD_NB	;12	;Total Overhead = 53
165b 165b s 				;Time to get all data bits = 416 * 7 + 39 = 2951 (last BIT does not get full delay)
165b 165b s 				
165b 165b s 				;@3576  (we wish to sample stop BIT @3958) (need to delay another 382)				
165b 165b d 3e17
165b 165b u 02 01
165b 165b s IRXD_STP	LD  A,23	;7	;Delay loop before STOP BIT
165d 165d d 3d
165d 165d u 01 01
165d 165d s 		DEC A		;4
165e 165e d 20fd
165e 165e u 02 01
165e 165e s 		JR  NZ,$-1	;12/7	;Delay loop =
1660 1660 d db40
1660 1660 u 02 01
1660 1660 s 		IN  A,(Port40)	;11	;NOP for 11tc
1662 1662 d db40
1662 1662 u 02 01
1662 1662 s 		IN  A,(Port40)	;11	;Sample Stop BIT @3957
1664 1664 d b7
1664 1664 u 01 01
1664 1664 s 		OR  A		;4	;(Actual sampling occurs 9 OR 10 tc later)
1665 1665 d f28516
1665 1665 u 03 01
1665 1665 s 		JP  P,IRXD_BAD
1668 1668 s 
1668 1668 d 7c
1668 1668 u 01 01
1668 1668 s IRXD_SAVE	LD  A,H		;4	;Fetch received byte
1669 1669 d 2acaff
1669 1669 u 03 01
1669 1669 s 		LD  HL,(RXBHEAD) ;16	;Advance Head Ptr of RX Buffer, Head = Head + 1
166c 166c d 2c
166c 166c u 01 01
166c 166c s 		INC L		;4
166d 166d d 22caff
166d 166d u 03 01
166d 166d s 		LD  (RXBHEAD),HL ;16
1670 1670 d 77
1670 1670 u 01 01
1670 1670 s 		LD  (HL),A	;7	;Save Received byte into RX Buffer
1671 1671 s 		
1671 1671 s 		
1671 1671 s 
1671 1671 s 		
1671 1671 d 3accff
1671 1671 u 03 01
1671 1671 s 		LD  A,(RXBTAIL)	;13	;Test if buffer has over ran
1674 1674 d bd
1674 1674 u 01 01
1674 1674 s 		CP  L		;4	;If Tail = Head Then Tail = Tail + 1 & Flag overrun
1675 1675 d 2014
1675 1675 u 02 01
1675 1675 s 		JR NZ,IRXD_RESET ;Return if NO overrun error
1677 1677 s 				
1677 1677 d 3c
1677 1677 u 01 01
1677 1677 s 		INC A		;Lose A BYTE in buffer and count the overrun
1678 1678 d 32ccff
1678 1678 u 03 01
1678 1678 s 		LD  (RXBTAIL),A
167b 167b s 
167b 167b d 218eff
167b 167b u 03 01
167b 167b s 		LD   HL,RX_ERR_OVR
167e 167e d 1808
167e 167e u 02 01
167e 167e s 		JR 	IRXD_TINC
1680 1680 d 218cff
1680 1680 u 03 01
1680 1680 s IRXD_INC	LD   HL,RX_ERR_LDRT ;10
1683 1683 d 1803
1683 1683 u 02 01
1683 1683 s 		JR 	IRXD_TINC
1685 1685 d 218dff
1685 1685 u 03 01
1685 1685 s IRXD_BAD	LD  HL,RX_ERR_STOP
1688 1688 d cd260e
1688 1688 u 03 01
1688 1688 s IRXD_TINC	CALL TINC
168b 168b s 
168b 168b d 3a95ff
168b 168b u 03 01
168b 168b s IRXD_RESET	LD	A,(HW_LIST)	;Skip Resync if FP not present
168e 168e d b7
168e 168e u 01 01
168e 168e s 		OR	A
168f 168f d 2813
168f 168f u 02 01
168f 168f s 		JR  Z,	IRXD_WS
1691 1691 s 
1691 1691 d db40
1691 1691 u 02 01
1691 1691 s 		IN	A,(Port40)	;Resync the SCAN_PTR
1693 1693 d 3c
1693 1693 u 01 01
1693 1693 s 		INC	A
1694 1694 d e607
1694 1694 u 02 01
1694 1694 s 		AND	7
1696 1696 d f6e0
1696 1696 u 02 01
1696 1696 s 		OR  LOW LED_DISPLAY	;LED_DISPLAY is at xxEO (it's ok to overlap in this order)
1698 1698 d 32d0ff
1698 1698 u 03 01
1698 1698 s 		LD	(SCAN_PTR),A	;Save Scan Ptr @ Next Scan Output
169b 169b s 
169b 169b d 2ad0ff
169b 169b u 03 01
169b 169b s 		LD	HL,(SCAN_PTR)	;Fetch next byte to output
169e 169e d 7e
169e 169e u 01 01
169e 169e s 		LD	A,(HL)
169f 169f d d340
169f 169f u 02 01
169f 169f s 		OUT	(Port40),A	;Output ASAP to satisfy Interrupt Flag
16a1 16a1 d 32f5ff
16a1 16a1 u 03 01
16a1 16a1 s 		LD	(SCAN_LED),A	;Save for next interrupt
16a4 16a4 s 
16a4 16a4 d db40
16a4 16a4 u 02 01
16a4 16a4 s IRXD_WS		IN   	A,(Port40)	;11	;Sample BIT
16a6 16a6 d 07
16a6 16a6 u 01 01
16a6 16a6 s 		RLCA		;4	;Get BIT 
16a7 16a7 d 30fb
16a7 16a7 u 02 01
16a7 16a7 s 		JR  NC,	IRXD_WS		;Wait for STOP bit
16a9 16a9 s 
16a9 16a9 d c33bfb
16a9 16a9 u 03 01
16a9 16a9 s 		JP	ISR_RET
16ac 16ac s 
16ac 16ac s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Timer Tics
16ac 16ac s ;Refresh next LED Display
16ac 16ac s ;**IROAR**
16ac 16ac d 3af5ff
16ac 16ac u 03 01
16ac 16ac s ISR_TIMER	LD	A,(SCAN_LED)	;13 ZMC-Display Refresh / Reset Int
16af 16af d d340
16af 16af u 02 01
16af 16af s 		OUT	(Port40),A	;11 Output ASAP to satisfy Interrupt Flag
16b1 16b1 s 
16b1 16b1 d 21d8ff
16b1 16b1 u 03 01
16b1 16b1 s 		LD	HL,ISR_FLAGS	;10
16b4 16b4 d cb46
16b4 16b4 u 02 01
16b4 16b4 s 		BIT	0,(HL)		;12
16b6 16b6 d c23bfb
16b6 16b6 u 03 01
16b6 16b6 s 		JP  NZ,	ISR_RET		;10
16b9 16b9 s 
16b9 16b9 s ISR_EXTIMER	;Extended Timer Int.
16b9 16b9 s 					;If ISR NEST level = 0 then save the stack and run on ISR Stack
16b9 16b9 s 
16b9 16b9 d cbc6
16b9 16b9 u 02 01
16b9 16b9 s 		SET	0,(HL)		;ISR_FLAGS (Prevent addition entries to this routine)
16bb 16bb s 
16bb 16bb d ed7328fb
16bb 16bb u 04 01
16bb 16bb s 		LD	(SP_ISR_SAVE),SP ;20 ;ALTERNATE TIMER STACK
16bf 16bf d 3128fb
16bf 16bf u 03 01
16bf 16bf s 		LD	SP,STACK_ISR1	;10  ;ALTERNATE TIMER STACK
16c2 16c2 s 
16c2 16c2 d 2c
16c2 16c2 u 01 01
16c2 16c2 s 		INC	L		;RRSTATE
16c3 16c3 d cb06
16c3 16c3 u 02 01
16c3 16c3 s 		RLC	(HL)		;RRSTATE.0=0 Additional interrupts shall return to ROM
16c5 16c5 s 					;RRSTATE.1=RRSTATE.0 Save RAM/ROM selection for exit from this TIMER ISR
16c5 16c5 s 	
16c5 16c5 d 08
16c5 16c5 u 01 01
16c5 16c5 s 		EX	AF,AF'		;Revert to regular registers in the event of another interrupt.
16c6 16c6 d fb
16c6 16c6 u 01 01
16c6 16c6 s 		EI			;4  Allow RXD interrupts
16c7 16c7 d d9
16c7 16c7 u 01 01
16c7 16c7 s 		EXX
16c8 16c8 s 
16c8 16c8 s ;Time critical functions are over.  		
16c8 16c8 s ;We've entered an interrupt and want to stay in for a while to update the front panel.
16c8 16c8 s ;But we want serial interrupts to be allowed to continue
16c8 16c8 s ;Alternate registers have been relinquished for other Interrupts.
16c8 16c8 s ;Must Push our own.
16c8 16c8 s 
16c8 16c8 s ;On First entry here, we have a new stack, old stack is saved at SP_ISR_SAVE and return address is on the old stack
16c8 16c8 s 
16c8 16c8 d e5
16c8 16c8 u 01 01
16c8 16c8 s 		PUSH	HL
16c9 16c9 d f5
16c9 16c9 u 01 01
16c9 16c9 s 		PUSH	AF
16ca 16ca s 
16ca 16ca s 					;********************************* Tic counter - Advance
16ca 16ca d 2af0ff
16ca 16ca u 03 01
16ca 16ca s 		LD	HL,(TicCounter)	;16 Advance Timer Counter
16cd 16cd d 23
16cd 16cd u 01 01
16cd 16cd s 		INC	HL		;6
16ce 16ce d 22f0ff
16ce 16ce u 03 01
16ce 16ce s 		LD	(TicCounter),HL	;16
16d1 16d1 s 					;st=38
16d1 16d1 s 
16d1 16d1 d 3a95ff
16d1 16d1 u 03 01
16d1 16d1 s 		LD	A,(HW_LIST)	;Exit ISR if FP not present
16d4 16d4 d b7
16d4 16d4 u 01 01
16d4 16d4 s 		OR	A
16d5 16d5 d 2829
16d5 16d5 u 02 01
16d5 16d5 s 		JR  Z,	ISR_EXTIMER_RET
16d7 16d7 s 
16d7 16d7 s 					;********************************* SCAN RESYNC
16d7 16d7 d db40
16d7 16d7 u 02 01
16d7 16d7 s 		IN	A,(Port40)	;11 Resync the SCAN_PTR
16d9 16d9 d 3c
16d9 16d9 u 01 01
16d9 16d9 s 		INC	A		;4  Advance to next column to match column after next OUT
16da 16da d e607
16da 16da u 02 01
16da 16da s 		AND	7		;7
16dc 16dc d f6e0
16dc 16dc u 02 01
16dc 16dc s 		OR  LOW LED_DISPLAY	;7  LED_DISPLAY is at xxEO (it's ok to overlap in this order)
16de 16de d 32d0ff
16de 16de u 03 01
16de 16de s 		LD	(SCAN_PTR),A	;13 Save Scan Ptr @ Next Scan Output
16e1 16e1 d 2ad0ff
16e1 16e1 u 03 01
16e1 16e1 s 		LD	HL,(SCAN_PTR)	;16 Fetch next byte to output
16e4 16e4 d 7e
16e4 16e4 u 01 01
16e4 16e4 s 		LD	A,(HL)		;7
16e5 16e5 d 32f5ff
16e5 16e5 u 03 01
16e5 16e5 s 		LD	(SCAN_LED),A	;13 Save for next interrupt
16e8 16e8 s 					;st=78
16e8 16e8 s 
16e8 16e8 s 
16e8 16e8 s 					;********************************* HALT TEST
16e8 16e8 d 2ad2ff
16e8 16e8 u 03 01
16e8 16e8 s 		LD	HL,(HALT_TEST)	;Ignore HALT Test in SD Card Mode
16eb 16eb d e9
16eb 16eb u 01 01
16eb 16eb s 		JP	(HL)
16ec 16ec s DO_HALT_TEST
16ec 16ec d 2a28fb
16ec 16ec u 03 01
16ec 16ec s 		LD	HL,(SP_ISR_SAVE);10 Get PC
16ef 16ef d cd4a0e
16ef 16ef u 03 01
16ef 16ef s 		CALL	LD_HL_HL	;17+43
16f2 16f2 d 2b
16f2 16f2 u 01 01
16f2 16f2 s 		DEC	HL		;6
16f3 16f3 d 7e
16f3 16f3 u 01 01
16f3 16f3 s 		LD	A,(HL)		;7 Fetch Previous Instruction
16f4 16f4 d fe76
16f4 16f4 u 02 01
16f4 16f4 s 		CP	0x76		;7 Is HALT?
16f6 16f6 d ca0218
16f6 16f6 u 03 01
16f6 16f6 s 		JP  Z,	ICMD_BREAK_RET	;10
16f9 16f9 s 					;st=111
16f9 16f9 s SKIP_HALT_TEST
16f9 16f9 s 
16f9 16f9 s 
16f9 16f9 s ;Keyboard / Display Update / Keyboard Commands or Entry
16f9 16f9 s 					;********************************* KEYBOARD SCANNING
16f9 16f9 d 21daff
16f9 16f9 u 03 01
16f9 16f9 s 		LD	HL,XTIMER_TIC
16fc 16fc d 35
16fc 16fc u 01 01
16fc 16fc s 		DEC	(HL)
16fd 16fd d fa1417
16fd 16fd u 03 01
16fd 16fd s 		JP  M,	ISR_EXXTIMER
1700 1700 s 		
1700 1700 s ;*************************************************** EXIT THE EXTENDED (INTERRUPTABLE) ISR
1700 1700 s 
1700 1700 d f1
1700 1700 u 01 01
1700 1700 s ISR_EXTIMER_RET	POP	AF
1701 1701 d e1
1701 1701 u 01 01
1701 1701 s 		POP	HL
1702 1702 s 
1702 1702 d f3
1702 1702 u 01 01
1702 1702 s 		DI
1703 1703 d ed7b28fb
1703 1703 u 04 01
1703 1703 s 		LD	SP,(SP_ISR_SAVE) ;RESUME SAVED STACK
1707 1707 s 
1707 1707 d 08
1707 1707 u 01 01
1707 1707 s 		EX	AF,AF'		;Swap Registers for Jump Back
1708 1708 d d9
1708 1708 u 01 01
1708 1708 s 		EXX
1709 1709 s 
1709 1709 d 21d8ff
1709 1709 u 03 01
1709 1709 s 		LD	HL,ISR_FLAGS
170c 170c d cb86
170c 170c u 02 01
170c 170c s 		RES	0,(HL)		;Reset NEST level to 0
170e 170e s 
170e 170e d 2c
170e 170e u 01 01
170e 170e s 		INC	L		;RRSTATE
170f 170f d cb0e
170f 170f u 02 01
170f 170f s 		RRC	(HL)		;RRSTATE.0=RRSTATE.1 Restore RAM/ROM selection
1711 1711 d c33bfb
1711 1711 u 03 01
1711 1711 s 		JP	ISR_RET
1714 1714 s 
1714 1714 s ;Somewhere in High RAM...
1714 1714 s ;
1714 1714 s ;ISR_RET	LD	A,(RRSTATE)	;Restore RAM/ROM selection
1714 1714 s ;		OUT	(RAMROM),A
1714 1714 s ;		EX	AF,AF'		;Restore swapped Registers
1714 1714 s ;		EXX
1714 1714 s ;		EI
1714 1714 s ;		RETI			;Return to Mainline code
1714 1714 s 
1714 1714 s 
1714 1714 s ISR_EXXTIMER				;Extra Extended Timer (8 times every 32mSec)
1714 1714 s 
1714 1714 d db40
1714 1714 u 02 01
1714 1714 s 		IN	A,(Port40)	;11 Read KEY down & ScanPtr
1716 1716 d 21e9ff
1716 1716 u 03 01
1716 1716 s 		LD	HL,KBPORTSAMPLE	;10
1719 1719 d 77
1719 1719 u 01 01
1719 1719 s 		LD	(HL),A
171a 171a d e607
171a 171a u 02 01
171a 171a s 		AND	7
171c 171c d 6f
171c 171c u 01 01
171c 171c s 		LD	L,A		;HL->BIT_TABLE
171d 171d d 7e
171d 171d u 01 01
171d 171d s 		LD	A,(HL)
171e 171e d 2ee8
171e 171e u 02 01
171e 171e s 		LD	L,LOW KBCOLSAMPLED ;HL->KBCOLSAMPLED
1720 1720 d b6
1720 1720 u 01 01
1720 1720 s 		OR	(HL)
1721 1721 d 77
1721 1721 u 01 01
1721 1721 s 		LD	(HL),A		;Save bit map of columns sampled
1722 1722 s 				
1722 1722 d 23
1722 1722 u 01 01
1722 1722 s 		INC	HL		;HL->KBPORTSAMPLE
1723 1723 d 7e
1723 1723 u 01 01
1723 1723 s 		LD	A,(HL)
1724 1724 d e607
1724 1724 u 02 01
1724 1724 s 		AND	7
1726 1726 d cb5e
1726 1726 u 02 01
1726 1726 s 		BIT 	3,(HL)		;8  Test ROW-0
1728 1728 d 2005
1728 1728 u 02 01
1728 1728 s 		JR  NZ,	IKEY0_UP	;12 Jump if key UP
172a 172a d f680
172a 172a u 02 01
172a 172a s 		OR	0x80		;Flag a Key is down
172c 172c d 23
172c 172c u 01 01
172c 172c s 		INC	HL		;HL->KBHEXSAMPLE
172d 172d d 77
172d 172d u 01 01
172d 172d s 		LD	(HL),A		;Save HEX key
172e 172e d 2b
172e 172e u 01 01
172e 172e s 		DEC	HL		;HL->KBPORTSAMPLE
172f 172f s 		
172f 172f s 					;Sample input again for Row-1 test
172f 172f s IKEY0_UP
172f 172f d cb66
172f 172f u 02 01
172f 172f s 		BIT 	4,(HL)		;8 Test ROW-1
1731 1731 d 2005
1731 1731 u 02 01
1731 1731 s 		JR  NZ,	IKEY1_UP	;12 Jump if key UP
1733 1733 d f688
1733 1733 u 02 01
1733 1733 s 		OR	0x88		;Flag a key is down AND set bit 3 so key is between 8 and E
1735 1735 d 23
1735 1735 u 01 01
1735 1735 s 		INC	HL		;HL->KBHEXSAMPLE
1736 1736 d 77
1736 1736 u 01 01
1736 1736 s 		LD	(HL),A		;Save HEX key
1737 1737 d 2b
1737 1737 u 01 01
1737 1737 s 		DEC	HL		;HL->KBPORTSAMPLE
1738 1738 s 		
1738 1738 s IKEY1_UP		
1738 1738 s 					;   Test for all columns Scanned
1738 1738 d 2b
1738 1738 u 01 01
1738 1738 s 		DEC	HL		;HL->KBCOLSAMPLED 
1739 1739 d 7e
1739 1739 u 01 01
1739 1739 s 		LD	A,(HL)		;   *ALL keys scanned when KBCOLSAMPLED = 0xFF
173a 173a d 3c
173a 173a u 01 01
173a 173a s 		INC	A		;4
173b 173b d c2f617
173b 173b u 03 01
173b 173b s 		JP  NZ,	IKEY_SCAN_END	;10
173e 173e s 		
173e 173e d 77
173e 173e u 01 01
173e 173e s 		LD	(HL),A		;KBCOLSAMPLED = 0x00 for next Scan
173f 173f s 
173f 173f s ;- - - - - - - - - - - - - - - - - - - - - - - - 
173f 173f s ;Keys and Display update on Column 7 Only
173f 173f s 		
173f 173f d 23
173f 173f u 01 01
173f 173f s 		INC	HL		;HL->KBPORTSAMPLE
1740 1740 d cb6e
1740 1740 u 02 01
1740 1740 s 		BIT 	5,(HL)		;8  Test F KEY
1742 1742 d 2807
1742 1742 u 02 01
1742 1742 s 		JR  Z,	IKEYF_UP	;12 Jump if key UP
1744 1744 s 					;When F key is down, it can serve as either F or Shift.
1744 1744 s 					;
1744 1744 d 3ac1ff
1744 1744 u 03 01
1744 1744 s 		LD	A,(KEYBFMODE)	;Check the F MODE (shift key or HEX key)
1747 1747 d 23
1747 1747 u 01 01
1747 1747 s 		INC	HL		;HL->KBHEXSAMPLE
1748 1748 d b6
1748 1748 u 01 01
1748 1748 s 		OR	(HL)		;8F=HEX INPUT, 90=Shiftable
1749 1749 s 					;so when F is pressed:
1749 1749 s 					;  If 8F it overrides all the other keys and KBHEXSAMPLE=8F
1749 1749 s 					;  If 90 it OR's with KBHEXSAMPLE to become 9X where X is previous key held down
1749 1749 d 77
1749 1749 u 01 01
1749 1749 s 		LD	(HL),A		;Save HEX key
174a 174a d 2b
174a 174a u 01 01
174a 174a s 		DEC	HL		;HL->KBPORTSAMPLE
174b 174b s 		
174b 174b s IKEYF_UP
174b 174b s 
174b 174b s 
174b 174b s ;-Keyboard Scanning, only after scanning Column 7 we are here with the following:
174b 174b s ;	KeyPad	KBHEXSAMPLE
174b 174b s ;	no-key	0000 0000
174b 174b s ;	  0	1000 0000
174b 174b s ;	  1	1000 0001
174b 174b s ;	  2	1000 0010
174b 174b s ;	  3	1000 0011
174b 174b s ;	  4	1000 0100
174b 174b s ;	  5	1000 0101
174b 174b s ;	  6	1000 0110
174b 174b s ;	  7	1000 0111
174b 174b s ;	  8	1000 1000
174b 174b s ;	  9	1000 1001
174b 174b s ;	  A	1000 1010
174b 174b s ;	  B	1000 1011
174b 174b s ;	  C	1000 1100
174b 174b s ;	  D	1000 1101
174b 174b s ;	  E	1000 1110
174b 174b s ;	  F	1000 1111
174b 174b s ;	  ^F			1001 xxxx (xxxx=any key pressed during the scan from Column 0)
174b 174b s 
174b 174b d 23
174b 174b u 01 01
174b 174b s 		INC	HL		;HL->KBHEXSAMPLE
174c 174c d 7e
174c 174c u 01 01
174c 174c s 		LD	A,(HL)		;7  Get new HEX sample		
174d 174d d 3600
174d 174d u 02 01
174d 174d s 		LD	(HL),0		;10 Zero KBHEXSAMPLE for next scan
174f 174f d 21daff
174f 174f u 03 01
174f 174f s 		LD	HL,XTIMER_TIC
1752 1752 d 3614
1752 1752 u 02 01
1752 1752 s 		LD	(HL),20		;Start new Scan in 20 Tics
1754 1754 s 
1754 1754 s IKEY_DEBOUNCE	;A=current key scan or 0x00 for no key.
1754 1754 d 2aebff
1754 1754 u 03 01
1754 1754 s 		LD	HL,(KEYBSCANPV) ;16 Get previously saved scanned key and timer
1757 1757 d bd
1757 1757 u 01 01
1757 1757 s 		CP	L		;4
1758 1758 d 2803
1758 1758 u 02 01
1758 1758 s 		JR  Z,	IKEYP_NCOS	;12 Jump if NO Change of State
175a 175a d 2603
175a 175a u 02 01
175a 175a s 		LD	H,3		;Timer = 3 (Controls how sensitive the keyboard is to Key Inputs)
175c 175c d 6f
175c 175c u 01 01
175c 175c s 		LD	L,A		;Previous scan=current scan
175d 175d s 
175d 175d d 25
175d 175d u 01 01
175d 175d s IKEYP_NCOS	DEC	H		;4  Timer = Timer - 1
175e 175e d 22ebff
175e 175e u 03 01
175e 175e s 		LD	(KEYBSCANPV),HL	;16 Save previous scan & timer
1761 1761 d ca7317
1761 1761 u 03 01
1761 1761 s 		JP  Z,	IKEYP_EVENT	;10 Jump when Timer = 0
1764 1764 d f2ae17
1764 1764 u 03 01
1764 1764 s 		JP  P,	IK_NOKEY_EVENT	;10 Jump when Timer = 1 to 7F
1767 1767 s 					
1767 1767 s 					;When Timer underflows to FF, we can use the range from FF to 80
1767 1767 s 					;to perform time delayed auto repeat for the key.
1767 1767 s 					
1767 1767 d 3ed0
1767 1767 u 02 01
1767 1767 s 		LD	A,0xD0		;Sets when to repeat (closer to FF, faster)
1769 1769 d bc
1769 1769 u 01 01
1769 1769 s 		CP	H
176a 176a d c2ae17
176a 176a u 03 01
176a 176a s 		JP  NZ, IK_NOKEY_EVENT
176d 176d s 					;Timer then "lives" between D4 and D0 causing auto repeat of
176d 176d s 					;present key pressed (even if it's no key).
176d 176d s 		
176d 176d d 3ed4
176d 176d u 02 01
176d 176d s 		LD	A,0xD4		;Sets how fast to repeat (closer to "when to repeat" faster)
176f 176f d 32ecff
176f 176f u 03 01
176f 176f s 		LD	(KEYBSCANTIMER),A ;Save timer
1772 1772 d 7d
1772 1772 u 01 01
1772 1772 s 		LD	A,L		;Fetch keyscan
1773 1773 s 
1773 1773 s 
1773 1773 s IKEYP_EVENT	;A=current key scan or 0x00 for no key (either after debounce or as repeat)
1773 1773 d 21edff
1773 1773 u 03 01
1773 1773 s 		LD	HL,KEY_PRES_EV	;Point HL to previously saved/processed Key
1776 1776 d b7
1776 1776 u 01 01
1776 1776 s 		OR	A
1777 1777 d 280f
1777 1777 u 02 01
1777 1777 s 		JR  Z,	IK_KEYUP_EVENT
1779 1779 s 		
1779 1779 s IKEYP_EVENT_DN				;When A<>0, It's a KEY DOWN EVENT
1779 1779 d fe90
1779 1779 u 02 01
1779 1779 s 		CP	0x90		;Is it Shift key down?
177b 177b d c29617
177b 177b u 03 01
177b 177b s 		JP  NZ,	IK_KEYDN_EVENT	;Jump to process key down if it's NOT a shift key
177e 177e s 					;Special consideration given here for Shift Key down.
177e 177e s 
177e 177e d cb66
177e 177e u 02 01
177e 177e s 		BIT	4,(HL)		;Test bit 4 of KEY_PRES_EV (previously saved/processed key)
1780 1780 d 77
1780 1780 u 01 01
1780 1780 s 		LD	(HL),A		;Save the 0x90 to KEY_PRES_EV
1781 1781 s 					;Exit with just the Shift Key pressed (wait for the next shifted key to come in)
1781 1781 d cadf17
1781 1781 u 03 01
1781 1781 s 		JP  Z,	IKEY_DONE	;If previously saved key was not a shifted key, keep the 0x90
1784 1784 s 					;If shift key is held down long enough to repeat, it then becomes F key
1784 1784 d 3d
1784 1784 u 01 01
1784 1784 s 		DEC	A		;Otherwise, reduce the shift key to a simple "F" key (0x90 - 1 = 0x8F)
1785 1785 d c39617
1785 1785 u 03 01
1785 1785 s 		JP	IK_KEYDN_EVENT
1788 1788 s 
1788 1788 s IK_KEYUP_EVENT	;*************************************************** KEY UP EVENT
1788 1788 s 					;When A=0, It's a KEY UP EVENT
1788 1788 d 23
1788 1788 u 01 01
1788 1788 s 		INC	HL
1789 1789 d 3600
1789 1789 u 02 01
1789 1789 s 		LD	(HL),0
178b 178b d 2b
178b 178b u 01 01
178b 178b s 		DEC	HL
178c 178c d 7e
178c 178c u 01 01
178c 178c s 		LD	A,(HL)		;Fetch the previous key down code
178d 178d d fe90
178d 178d u 02 01
178d 178d s 		CP	0x90
178f 178f d c2df17
178f 178f u 03 01
178f 178f s 		JP  NZ,	IKEY_DONE	;Exit if not the shift key going up
1792 1792 s 					;Otherwise, if it was the Shift key going up....
1792 1792 d 3d
1792 1792 u 01 01
1792 1792 s 		DEC	A  ;90->8F	;replace it with a simple "F" key
1793 1793 s 		;JP	IK_KEYDN_EVENT	;and execute the key down event.
1793 1793 d 23
1793 1793 u 01 01
1793 1793 s 		INC	HL
1794 1794 d 77
1794 1794 u 01 01
1794 1794 s 		LD	(HL),A
1795 1795 d 2b
1795 1795 u 01 01
1795 1795 s 		DEC	HL
1796 1796 s 
1796 1796 s 
1796 1796 s IK_KEYDN_EVENT	;*************************************************** KEY DOWN EVENT
1796 1796 d 77
1796 1796 u 01 01
1796 1796 s 		LD	(HL),A		;Save Last Key Down (for Shift Testing)
1797 1797 d 23
1797 1797 u 01 01
1797 1797 s 		INC	HL
1798 1798 d be
1798 1798 u 01 01
1798 1798 s 		CP	(HL)
1799 1799 d 2805
1799 1799 u 02 01
1799 1799 s 		JR   Z,	IK_RTN
179b 179b d 34
179b 179b u 01 01
179b 179b s 		INC	(HL)
179c 179c d 35
179c 179c u 01 01
179c 179c s 		DEC	(HL)
179d 179d d 200f
179d 179d u 02 01
179d 179d s 		JR  NZ,	IK_NOKEY_EVENT
179f 179f d 77
179f 179f u 01 01
179f 179f s 		LD	(HL),A
17a0 17a0 s 
17a0 17a0 d 21e7ff
17a0 17a0 u 03 01
17a0 17a0 s IK_RTN		LD	HL,LED_ANBAR
17a3 17a3 d cbc6
17a3 17a3 u 02 01
17a3 17a3 s 		SET	0,(HL)		;ANBARLED 0 = BEEPER
17a5 17a5 d 21b2ff
17a5 17a5 u 03 01
17a5 17a5 s 		LD	HL,BEEP_TO
17a8 17a8 d cbce
17a8 17a8 u 02 01
17a8 17a8 s 		SET	1,(HL)		;Time out beep in 2 counts
17aa 17aa s 
17aa 17aa d 2abeff
17aa 17aa u 03 01
17aa 17aa s 		LD	HL,(KEY_EVENT)
17ad 17ad d e9
17ad 17ad u 01 01
17ad 17ad s 		JP	(HL)
17ae 17ae s ;KEY_EVENT_DISPATCH
17ae 17ae s ;Execute different routines based on Users actions.
17ae 17ae s ;Possible choices within this firmware include:
17ae 17ae s ;IMON_CMD	- Menu Command Input (default and initial setting).  Resets to this even upon IKC_RESET_CMD
17ae 17ae s ;ICMD0_R	- HEX Input Mode to select a Register (valid input is 0-12 for the 13 registers). Value saved in RegPtr.
17ae 17ae s ;ICMD_BYTE	- BYTE Input Mode. IK_HEXST tracks state machine of routine. IK_HEXH store the value.  Execute @HEX_READY when done.
17ae 17ae s ;ICMD_WORD	- WORD Input Mode. IK_HEXST tracks state machine of routine. IK_HEXH & IK_HEXL store the value.  Execute @HEX_READY when done.
17ae 17ae s ;ISET_PRESSED	- Saves Key Pressed for User, does not process any keys.
17ae 17ae s 
17ae 17ae s IK_NOKEY_EVENT	;*************************************************** NO KEY EVENT
17ae 17ae s 
17ae 17ae s 
17ae 17ae s 					;********************************* <Ctrl>-C Checking
17ae 17ae d 2ab8ff
17ae 17ae u 03 01
17ae 17ae s 		LD	HL,(CTRL_C_CHK)	;16 <Ctrl>-C check +77
17b1 17b1 d e9
17b1 17b1 u 01 01
17b1 17b1 s 		JP	(HL)		;4
17b2 17b2 s 					;st=97
17b2 17b2 s CTRL_C_RET
17b2 17b2 s 
17b2 17b2 d 21c0ff
17b2 17b2 u 03 01
17b2 17b2 s 		LD	HL,IK_TIMER	;10
17b5 17b5 d 7e
17b5 17b5 u 01 01
17b5 17b5 s 		LD	A,(HL)		;7 Time out any pending Monitor Input
17b6 17b6 d b7
17b6 17b6 u 01 01
17b6 17b6 s 		OR	A		;4
17b7 17b7 d cadf17
17b7 17b7 u 03 01
17b7 17b7 s 		JP Z,	IKEY_DONE	;10 st=31
17ba 17ba d 35
17ba 17ba u 01 01
17ba 17ba s 		DEC	(HL)
17bb 17bb d c2df17
17bb 17bb u 03 01
17bb 17bb s 		JP NZ,	IKEY_DONE
17be 17be s 
17be 17be s 					;IK Timer Expired Event
17be 17be s IKC_RESET_CMD				;Upon time out, return monitor to CMD input
17be 17be d 2abaff
17be 17be u 03 01
17be 17be s 		LD	HL,(LDISPMODE)
17c1 17c1 d 22bcff
17c1 17c1 u 03 01
17c1 17c1 s 		LD	(DISPMODE),HL
17c4 17c4 d 214218
17c4 17c4 u 03 01
17c4 17c4 s 		LD	HL,IMON_CMD
17c7 17c7 d 22beff
17c7 17c7 u 03 01
17c7 17c7 s 		LD	(KEY_EVENT),HL
17ca 17ca d 21c1ff
17ca 17ca u 03 01
17ca 17ca s 		LD	HL,KEYBFMODE	;Shiftable Keyboard
17cd 17cd d 3690
17cd 17cd u 02 01
17cd 17cd s 		LD	(HL),0x90
17cf 17cf s 
17cf 17cf d 3ab3ff
17cf 17cf u 03 01
17cf 17cf s IKC_REFRESH	LD	A,(ANBAR_DEF)	;Refresh Display
17d2 17d2 d 32e7ff
17d2 17d2 u 03 01
17d2 17d2 s 		LD	(LED_ANBAR),A
17d5 17d5 d 3eff
17d5 17d5 u 02 01
17d5 17d5 s IKR_QREFRESH	LD	A,-1
17d7 17d7 d 32c3ff
17d7 17d7 u 03 01
17d7 17d7 s 		LD	(IK_HEXST),A	;Zero HEX Input Sequencer
17da 17da d 3e01
17da 17da u 02 01
17da 17da s 		LD	A,1		;Force Quick Refresh of Label
17dc 17dc d 32c2ff
17dc 17dc u 03 01
17dc 17dc s 		LD	(DISPLABEL),A
17df 17df s 		;JP	IKEY_DONE
17df 17df s IKEY_DONE
17df 17df s 
17df 17df s 
17df 17df s 		;*************************************************** UP DATE LED DISPLAY
17df 17df d 2abcff
17df 17df u 03 01
17df 17df s 		LD	HL,(DISPMODE)	;16 +242 (for Display Memory)
17e2 17e2 d e9
17e2 17e2 u 01 01
17e2 17e2 s 		JP	(HL)		;4
17e3 17e3 s IDISP_RET
17e3 17e3 d 21b2ff
17e3 17e3 u 03 01
17e3 17e3 s 		LD	HL,BEEP_TO	;10
17e6 17e6 d 35
17e6 17e6 u 01 01
17e6 17e6 s 		DEC	(HL)		;11
17e7 17e7 d 2807
17e7 17e7 u 02 01
17e7 17e7 s 		JR Z,	IKEY_NO_BEEP	;10
17e9 17e9 d 21e7ff
17e9 17e9 u 03 01
17e9 17e9 s 		LD	HL,LED_ANBAR	;10  ANBARLED 0 = BEEPER
17ec 17ec d cbc6
17ec 17ec u 02 01
17ec 17ec s 		SET	0,(HL)		;15	BEEP ON WHEN BEEP_TO > 1
17ee 17ee d 1806
17ee 17ee u 02 01
17ee 17ee s 		JR	IKEY_SCAN_END
17f0 17f0 s 		
17f0 17f0 d 34
17f0 17f0 u 01 01
17f0 17f0 s IKEY_NO_BEEP	INC	(HL)		;11
17f1 17f1 d 21e7ff
17f1 17f1 u 03 01
17f1 17f1 s 		LD	HL,LED_ANBAR	;10
17f4 17f4 d cb86
17f4 17f4 u 02 01
17f4 17f4 s 		RES	0,(HL)		;15  ANBARLED 0 = BEEPER
17f6 17f6 s 					;st=67
17f6 17f6 s 					
17f6 17f6 s IKEY_SCAN_END	
17f6 17f6 s 
17f6 17f6 d 2ab0ff
17f6 17f6 u 03 01
17f6 17f6 s 		LD	HL,(UiVec)	;16  Do a User Interrupt Vector
17f9 17f9 d cda00c
17f9 17f9 u 03 01
17f9 17f9 s 		CALL	VCALL_HL
17fc 17fc d c30017
17fc 17fc u 03 01
17fc 17fc s 		JP	ISR_EXTIMER_RET
17ff 17ff s 
17ff 17ff d c9
17ff 17ff u 01 01
17ff 17ff s UiVec_RET	RET			;Default Return for UiVec
1800 1800 s 
1800 1800 d 3efe
1800 1800 u 02 01
1800 1800 s ICMD_BREAK	LD	A,0xFE
1802 1802 d 32dfff
1802 1802 u 03 01
1802 1802 s ICMD_BREAK_RET	LD	(SOFT_RST_FLAG),A	;FE=RESTART, D1=SINGLE STEP, F6=HALT, CC=<Ctrl>-C
1805 1805 d 3ab3ff
1805 1805 u 03 01
1805 1805 s 		LD	A,(ANBAR_DEF)	;Soft Restart only allowed while in Run Mode
1808 1808 d e602
1808 1808 u 02 01
1808 1808 s 		AND	2		;Run mode LED
180a 180a d cadf17
180a 180a u 03 01
180a 180a s 		JP  Z,	IKEY_DONE
180d 180d s 
180d 180d d f3
180d 180d u 01 01
180d 180d s 		DI
180e 180e d f1
180e 180e u 01 01
180e 180e s 		POP	AF
180f 180f d e1
180f 180f u 01 01
180f 180f s 		POP	HL
1810 1810 d ed7b28fb
1810 1810 u 04 01
1810 1810 s 		LD	SP,(SP_ISR_SAVE)
1814 1814 d c30000
1814 1814 u 03 01
1814 1814 s 		JP	0
1817 1817 s 		
1817 1817 d 2acaff
1817 1817 u 03 01
1817 1817 s CTRL_C_TEST	LD	HL,(RXBHEAD)	;16
181a 181a d 7e
181a 181a u 01 01
181a 181a s 		LD	A,(HL)		;7
181b 181b d 21deff
181b 181b u 03 01
181b 181b s 		LD	HL,CTRL_C_TIMER	;10
181e 181e d fe03
181e 181e u 02 01
181e 181e s 		CP	3		;7  Compare <Ctrl>-C
1820 1820 d ca2518
1820 1820 u 03 01
1820 1820 s 		JP  Z,	CTRL_C_IN_Q	;10
1823 1823 d 360a
1823 1823 u 02 01
1823 1823 s 		LD	(HL),10		;10
1825 1825 d 35
1825 1825 u 01 01
1825 1825 s CTRL_C_IN_Q	DEC	(HL)		;7
1826 1826 d c2b217
1826 1826 u 03 01
1826 1826 s 		JP  NZ,	CTRL_C_RET	;10  st=77
1829 1829 d 3ecc
1829 1829 u 02 01
1829 1829 s 		LD	A,0xCC
182b 182b d c30218
182b 182b u 03 01
182b 182b s 		JP	ICMD_BREAK_RET
182e 182e s 
182e 182e d 211718
182e 182e u 03 01
182e 182e s CTRL_C_CHK_ON	LD	HL,CTRL_C_TEST
1831 1831 d 22b8ff
1831 1831 u 03 01
1831 1831 s 		LD	(CTRL_C_CHK),HL
1834 1834 d c9
1834 1834 u 01 01
1834 1834 s 		RET
1835 1835 d 21b217
1835 1835 u 03 01
1835 1835 s CTRL_C_CHK_OFF	LD	HL,CTRL_C_RET
1838 1838 d 22b8ff
1838 1838 u 03 01
1838 1838 s 		LD	(CTRL_C_CHK),HL
183b 183b d c9
183b 183b u 01 01
183b 183b s 		RET
183c 183c s 
183c 183c s 
183c 183c s 
183c 183c s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
183c 183c s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
183c 183c s ;	Keyboard Monitor
183c 183c s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
183c 183c s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
183c 183c s 
183c 183c s ;============================================================================
183c 183c s ; No Keyboard activity, Save Key for User.
183c 183c d 32efff
183c 183c u 03 01
183c 183c s ISET_PRESSED	LD	(KEY_PRESSED),A
183f 183f d c3df17
183f 183f u 03 01
183f 183f s 		JP	IKEY_DONE
1842 1842 s 
1842 1842 s 
1842 1842 s ;============================================================================
1842 1842 s ;	IMON - Monitor Loop
1842 1842 s ;
1842 1842 s ; This is the main executive loop for the Front Panel Emulator, Dispatch the Command
1842 1842 s ;============================================================================
1842 1842 d 215718
1842 1842 u 03 01
1842 1842 s IMON_CMD	LD	HL,IMON_TBL
1845 1845 d e61f
1845 1845 u 02 01
1845 1845 s 		AND	0x1F
1847 1847 d 07
1847 1847 u 01 01
1847 1847 s 		RLCA			;X2
1848 1848 d cd450e
1848 1848 u 03 01
1848 1848 s 		CALL	ADD_HL_A
184b 184b d cd4a0e
184b 184b u 03 01
184b 184b s 		CALL	LD_HL_HL	; HL = (HL)
184e 184e d e9
184e 184e u 01 01
184e 184e s 		JP	(HL)
184f 184f s 
184f 184f d 21d8ff
184f 184f u 03 01
184f 184f s ICMD4_EXEC	LD	HL,ISR_FLAGS
1852 1852 d cb86
1852 1852 u 02 01
1852 1852 s 		RES	0,(HL)		;Reset NEST level to 0
1854 1854 d c3600b
1854 1854 u 03 01
1854 1854 s 		JP	GO_EXEC_T
1857 1857 s 
1857 1857 d 9718
1857 1857 u 02 02
1857 1857 s IMON_TBL	DW	ICMD0		;0 = Display Register
1859 1859 d df17
1859 1859 u 02 02
1859 1859 s 		DW	IKEY_DONE	;ICMD1
185b 185b d df17
185b 185b u 02 02
185b 185b s 		DW	IKEY_DONE	;ICMD2
185d 185d d df17
185d 185d u 02 02
185d 185d s 		DW	IKEY_DONE	;ICMD3
185f 185f d 4f18
185f 185f u 02 02
185f 185f s 		DW	ICMD4_EXEC	;4 = GO Execute
1861 1861 d 9b19
1861 1861 u 02 02
1861 1861 s 		DW	ICMD5		;5 = Input Port
1863 1863 d b819
1863 1863 u 02 02
1863 1863 s 		DW	ICMD6		;6 = Output Port
1865 1865 d 301a
1865 1865 u 02 02
1865 1865 s 		DW	ICMD7		;7 = Single Step
1867 1867 d df17
1867 1867 u 02 02
1867 1867 s 		DW	IKEY_DONE	;ICMD8
1869 1869 d dd19
1869 1869 u 02 02
1869 1869 s 		DW	IRAMROMBANK	;ICMD9
186b 186b d b51a
186b 186b u 02 02
186b 186b s 		DW	ICMDA		;A = Advance Element
186d 186d d d61a
186d 186d u 02 02
186d 186d s 		DW	ICMDB		;B = Backup Element
186f 186f d df17
186f 186f u 02 02
186f 186f s 		DW	IKEY_DONE	;ICMDC
1871 1871 d 011b
1871 1871 u 02 02
1871 1871 s 		DW	ICMDD		;D = Alter Element
1873 1873 d ad18
1873 1873 u 02 02
1873 1873 s 		DW	ICMDE		;E = Display Memory
1875 1875 d df17
1875 1875 u 02 02
1875 1875 s 		DW	IKEY_DONE	;ICMDF
1877 1877 d df17
1877 1877 u 02 02
1877 1877 s 		DW	IKEY_DONE	;ICMD10 (Shift-0 Can't happen, you get hard reset)
1879 1879 d df17
1879 1879 u 02 02
1879 1879 s 		DW	IKEY_DONE	;ICMD11
187b 187b d df17
187b 187b u 02 02
187b 187b s 		DW	IKEY_DONE	;ICMD12
187d 187d d df17
187d 187d u 02 02
187d 187d s 		DW	IKEY_DONE	;ICMD13
187f 187f d df17
187f 187f u 02 02
187f 187f s 		DW	IKEY_DONE	;ICMD14
1881 1881 d df17
1881 1881 u 02 02
1881 1881 s 		DW	IKEY_DONE	;ICMD15
1883 1883 d df17
1883 1883 u 02 02
1883 1883 s 		DW	IKEY_DONE	;ICMD16
1885 1885 d df17
1885 1885 u 02 02
1885 1885 s 		DW	IKEY_DONE	;ICMD17
1887 1887 d df17
1887 1887 u 02 02
1887 1887 s 		DW	IKEY_DONE	;ICMD18
1889 1889 d df17
1889 1889 u 02 02
1889 1889 s 		DW	IKEY_DONE	;ICMD19
188b 188b d dd19
188b 188b u 02 02
188b 188b s 		DW	IRAMROMBANK	;ICMD1A
188d 188d d df17
188d 188d u 02 02
188d 188d s 		DW	IKEY_DONE	;ICMD1B
188f 188f d df17
188f 188f u 02 02
188f 188f s 		DW	IKEY_DONE	;ICMD1C
1891 1891 d df17
1891 1891 u 02 02
1891 1891 s 		DW	IKEY_DONE	;ICMD1D
1893 1893 d 0018
1893 1893 u 02 02
1893 1893 s 		DW	ICMD_BREAK	;ICMD1E
1895 1895 d df17
1895 1895 u 02 02
1895 1895 s 		DW	IKEY_DONE	;ICMD1F (Shift-F Can't happen)
1897 1897 s 
1897 1897 s 
1897 1897 d cd1d0c
1897 1897 u 03 01
1897 1897 s ICMD0		CALL	WRITE_BLOCK	;0 = Display Register
189a 189a d baff
189a 189a u 02 02
189a 189a s 		DW	LDISPMODE	;Where to write
189c 189c d 0700
189c 189c u 02 02
189c 189c s 		DW	7		;Bytes to write
189e 189e d 671b
189e 189e u 02 02
189e 189e s 		DW	IDISP_REG	;(LDISPMODE)
18a0 18a0 d 671b
18a0 18a0 u 02 02
18a0 18a0 s 		DW	IDISP_REG	;(DISPMODE)
18a2 18a2 d ec1a
18a2 18a2 u 02 02
18a2 18a2 s 		DW	ICMD0_R		;(KEY_EVENT) Switch to HEX Input Mode
18a4 18a4 d 50
18a4 18a4 u 01 02
18a4 18a4 s 		DB	80		;(IK_TIMER)
18a5 18a5 d 21e7ff
18a5 18a5 u 03 01
18a5 18a5 s 		LD	HL,LED_ANBAR
18a8 18a8 d cbf6
18a8 18a8 u 02 01
18a8 18a8 s 		SET	6,(HL)		;ANBARLED 6 = Enter Register
18aa 18aa d c3df17
18aa 18aa u 03 01
18aa 18aa s 		JP	IKEY_DONE
18ad 18ad s 
18ad 18ad d cd1d0c
18ad 18ad u 03 01
18ad 18ad s ICMDE		CALL	WRITE_BLOCK	;E = Display Memory
18b0 18b0 d baff
18b0 18b0 u 02 02
18b0 18b0 s 		DW	LDISPMODE	;Where to write
18b2 18b2 d 0e00
18b2 18b2 u 02 02
18b2 18b2 s 		DW	14		;Bytes to write
18b4 18b4 d 9c1b
18b4 18b4 u 02 02
18b4 18b4 s 		DW	IDISP_MEM	;(LDISPMODE)
18b6 18b6 d 9c1b
18b6 18b6 u 02 02
18b6 18b6 s 		DW	IDISP_MEM	;(DISPMODE)
18b8 18b8 d ca18
18b8 18b8 u 02 02
18b8 18b8 s 		DW	ICMD_WORD	;(KEY_EVENT) Switch to HEX Input Mode
18ba 18ba d 50
18ba 18ba u 01 02
18ba 18ba s 		DB	80		;(IK_TIMER)
18bb 18bb d 8f
18bb 18bb u 01 02
18bb 18bb s 		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
18bc 18bc d 00
18bc 18bc u 01 02
18bc 18bc s 		DB	0		;(DISPLABEL)
18bd 18bd d ff
18bd 18bd u 01 02
18bd 18bd s 		DB	-1		;(IK_HEXST)
18be 18be d e0ff
18be 18be u 02 02
18be 18be s 		DW	LED_DISPLAY	;(HEX_CURSOR) @d1
18c0 18c0 d 2019
18c0 18c0 u 02 02
18c0 18c0 s 		DW	HEX2ABUSS	;(HEX_READY)
18c2 18c2 s 
18c2 18c2 d 21e7ff
18c2 18c2 u 03 01
18c2 18c2 s 		LD	HL,LED_ANBAR
18c5 18c5 d cbee
18c5 18c5 u 02 01
18c5 18c5 s 		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
18c7 18c7 d c3df17
18c7 18c7 u 03 01
18c7 18c7 s 		JP	IKEY_DONE
18ca 18ca s 
18ca 18ca s 
18ca 18ca d 2ac4ff
18ca 18ca u 03 01
18ca 18ca s ICMD_WORD	LD	HL,(HEX_CURSOR)
18cd 18cd d cd531c
18cd 18cd u 03 01
18cd 18cd s 		CALL	LED_PUT_HEX_HL
18d0 18d0 d 22c4ff
18d0 18d0 u 03 01
18d0 18d0 s 		LD	(HEX_CURSOR),HL
18d3 18d3 d 21c3ff
18d3 18d3 u 03 01
18d3 18d3 s 		LD	HL,IK_HEXST
18d6 18d6 d 34
18d6 18d6 u 01 01
18d6 18d6 s 		INC	(HL)
18d7 18d7 d 201b
18d7 18d7 u 02 01
18d7 18d7 s 		JR NZ,	ICMD_WORDN1	;Do 1st digit
18d9 18d9 s 
18d9 18d9 d 2abcff
18d9 18d9 u 03 01
18d9 18d9 s 		LD	HL,(DISPMODE)
18dc 18dc d 22baff
18dc 18dc u 03 01
18dc 18dc s 		LD	(LDISPMODE),HL
18df 18df d 21e317
18df 18df u 03 01
18df 18df s 		LD	HL,IDISP_RET
18e2 18e2 d 22bcff
18e2 18e2 u 03 01
18e2 18e2 s 		LD	(DISPMODE),HL	;No Display Update while HEX Input Mode
18e5 18e5 s 
18e5 18e5 d 2ac4ff
18e5 18e5 u 03 01
18e5 18e5 s 		LD	HL,(HEX_CURSOR)
18e8 18e8 d 3e81
18e8 18e8 u 02 01
18e8 18e8 s 		LD	A,0x81		;Underscore
18ea 18ea d 77
18ea 18ea u 01 01
18ea 18ea s 		LD	(HL),A		;Display X _
18eb 18eb d 2c
18eb 18eb u 01 01
18eb 18eb s 		INC	L
18ec 18ec d 77
18ec 18ec u 01 01
18ec 18ec s 		LD	(HL),A		;Display X _ _
18ed 18ed d 2c
18ed 18ed u 01 01
18ed 18ed s 		INC	L
18ee 18ee d 77
18ee 18ee u 01 01
18ee 18ee s 		LD	(HL),A		;Display X _ _ _
18ef 18ef d 215aff
18ef 18ef u 03 01
18ef 18ef s 		LD	HL,IK_HEXH	;HL=DIGITS 1&2
18f2 18f2 d 180d
18f2 18f2 u 02 01
18f2 18f2 s 		JR	ICMD_WORD1
18f4 18f4 s 
18f4 18f4 d 7e
18f4 18f4 u 01 01
18f4 18f4 s ICMD_WORDN1	LD	A,(HL)
18f5 18f5 d 215aff
18f5 18f5 u 03 01
18f5 18f5 s 		LD	HL,IK_HEXH	;HL=DIGITS 1&2
18f8 18f8 d 3d
18f8 18f8 u 01 01
18f8 18f8 s 		DEC	A
18f9 18f9 d 280d
18f9 18f9 u 02 01
18f9 18f9 s 		JR Z,	ICMD_WORD2	;Do 2nd digit
18fb 18fb d 2159ff
18fb 18fb u 03 01
18fb 18fb s 		LD	HL,IK_HEXL	;HL=DIGITS 3&4
18fe 18fe d 3d
18fe 18fe u 01 01
18fe 18fe s 		DEC	A
18ff 18ff d 2007
18ff 18ff u 02 01
18ff 18ff s 		JR NZ,	ICMD_WORD2
1901 1901 s 
1901 1901 d 3aedff
1901 1901 u 03 01
1901 1901 s ICMD_WORD1	LD	A,(KEY_PRES_EV)	;1st & 3rd DIGIT
1904 1904 d ed67
1904 1904 u 02 01
1904 1904 s 		RRD
1906 1906 d 1807
1906 1906 u 02 01
1906 1906 s 		JR	ICMD_WORD_RET
1908 1908 s 
1908 1908 d ed67
1908 1908 u 02 01
1908 1908 s ICMD_WORD2	RRD			;2nd & 4th DIGIT
190a 190a d 3aedff
190a 190a u 03 01
190a 190a s 		LD	A,(KEY_PRES_EV)
190d 190d d ed6f
190d 190d u 02 01
190d 190d s 		RLD
190f 190f s 
190f 190f d 3ea0
190f 190f u 02 01
190f 190f s ICMD_WORD_RET	LD	A,160
1911 1911 d 32c0ff
1911 1911 u 03 01
1911 1911 s 		LD	(IK_TIMER),A	;Set Time out on Register Selection
1914 1914 d 3ac3ff
1914 1914 u 03 01
1914 1914 s 		LD	A,(IK_HEXST)	;Advance to next DspMod
1917 1917 d fe03
1917 1917 u 02 01
1917 1917 s 		CP	3
1919 1919 d c2df17
1919 1919 u 03 01
1919 1919 s 		JP NZ,	IKEY_DONE
191c 191c d 2ac6ff
191c 191c u 03 01
191c 191c s 		LD	HL,(HEX_READY)
191f 191f d e9
191f 191f u 01 01
191f 191f s 		JP	(HL)
1920 1920 s 
1920 1920 d 2a59ff
1920 1920 u 03 01
1920 1920 s HEX2ABUSS	LD	HL,(IK_HEXL)
1923 1923 d 2288ff
1923 1923 u 03 01
1923 1923 s 		LD	(ABUSS),HL
1926 1926 d c3be17
1926 1926 u 03 01
1926 1926 s 		JP	IKC_RESET_CMD
1929 1929 s 
1929 1929 d 3a8aff
1929 1929 u 03 01
1929 1929 s HEX2REG		LD	A,(RegPtr)	;Select Register
192c 192c d d5
192c 192c u 01 01
192c 192c s 		PUSH	DE
192d 192d d ed5b59ff
192d 192d u 04 01
192d 192d s 		LD	DE,(IK_HEXL)
1931 1931 d cd820c
1931 1931 u 03 01
1931 1931 s 		CALL	PUT_REGISTER
1934 1934 d d1
1934 1934 u 01 01
1934 1934 s 		POP	DE
1935 1935 d c3be17
1935 1935 u 03 01
1935 1935 s 		JP	IKC_RESET_CMD
1938 1938 s 
1938 1938 s 
1938 1938 d 2ac4ff
1938 1938 u 03 01
1938 1938 s ICMD_BYTE	LD	HL,(HEX_CURSOR)
193b 193b d cd531c
193b 193b u 03 01
193b 193b s 		CALL	LED_PUT_HEX_HL
193e 193e d 22c4ff
193e 193e u 03 01
193e 193e s 		LD	(HEX_CURSOR),HL		
1941 1941 d 21c3ff
1941 1941 u 03 01
1941 1941 s 		LD	HL,IK_HEXST
1944 1944 d 34
1944 1944 u 01 01
1944 1944 s 		INC	(HL)
1945 1945 d 2022
1945 1945 u 02 01
1945 1945 s 		JR NZ,	ICMD_BYTE2	;Do 1st digit
1947 1947 s 
1947 1947 d 2abcff
1947 1947 u 03 01
1947 1947 s 		LD	HL,(DISPMODE)
194a 194a d 22baff
194a 194a u 03 01
194a 194a s 		LD	(LDISPMODE),HL
194d 194d d 21e317
194d 194d u 03 01
194d 194d s 		LD	HL,IDISP_RET
1950 1950 d 22bcff
1950 1950 u 03 01
1950 1950 s 		LD	(DISPMODE),HL	;No Display Update while HEX Input Mode
1953 1953 s 
1953 1953 d 2ac4ff
1953 1953 u 03 01
1953 1953 s 		LD	HL,(HEX_CURSOR)
1956 1956 d 3e81
1956 1956 u 02 01
1956 1956 s 		LD	A,0x81		;Underscore
1958 1958 d 77
1958 1958 u 01 01
1958 1958 s 		LD	(HL),A		;Display X _
1959 1959 s 
1959 1959 d 215aff
1959 1959 u 03 01
1959 1959 s 		LD	HL,IK_HEXH	;HL=DIGITS 1&2
195c 195c d 3aedff
195c 195c u 03 01
195c 195c s 		LD	A,(KEY_PRES_EV)	;1st DIGIT
195f 195f d ed67
195f 195f u 02 01
195f 195f s 		RRD
1961 1961 d 3ea0
1961 1961 u 02 01
1961 1961 s 		LD	A,160
1963 1963 d 32c0ff
1963 1963 u 03 01
1963 1963 s 		LD	(IK_TIMER),A	;Set Time out on Register Selection
1966 1966 d c3df17
1966 1966 u 03 01
1966 1966 s 		JP 	IKEY_DONE
1969 1969 s 
1969 1969 d 215aff
1969 1969 u 03 01
1969 1969 s ICMD_BYTE2	LD	HL,IK_HEXH	;HL=DIGITS 1&2
196c 196c d ed67
196c 196c u 02 01
196c 196c s 		RRD			;2nd DIGIT
196e 196e d 3aedff
196e 196e u 03 01
196e 196e s 		LD	A,(KEY_PRES_EV)
1971 1971 d ed6f
1971 1971 u 02 01
1971 1971 s 		RLD
1973 1973 d 7e
1973 1973 u 01 01
1973 1973 s 		LD	A,(HL)
1974 1974 d 2ac6ff
1974 1974 u 03 01
1974 1974 s 		LD	HL,(HEX_READY)
1977 1977 d e9
1977 1977 u 01 01
1977 1977 s 		JP	(HL)
1978 1978 s 
1978 1978 d 328bff
1978 1978 u 03 01
1978 1978 s HEX2IN_Ptr	LD	(IoPtr),A	;Save Byte input to IoPtr
197b 197b d c3be17
197b 197b u 03 01
197b 197b s 		JP	IKC_RESET_CMD
197e 197e s 
197e 197e d 328bff
197e 197e u 03 01
197e 197e s HEX2OUT_Ptr	LD	(IoPtr),A	;Save Byte input to IoPtr
1981 1981 d c34a1b
1981 1981 u 03 01
1981 1981 s 		JP	ICMD_IO_OUT
1984 1984 s 
1984 1984 d 2a88ff
1984 1984 u 03 01
1984 1984 s HEX2MEM		LD	HL,(ABUSS)
1987 1987 d 77
1987 1987 u 01 01
1987 1987 s 		LD	(HL),A
1988 1988 d 23
1988 1988 u 01 01
1988 1988 s 		INC	HL
1989 1989 d 2288ff
1989 1989 u 03 01
1989 1989 s 		LD	(ABUSS),HL
198c 198c d c30a1b
198c 198c u 03 01
198c 198c s 		JP	ICMD_AMEM
198f 198f s 
198f 198f d c5
198f 198f u 01 01
198f 198f s HEX2OUT_PORT	PUSH	BC
1990 1990 d 47
1990 1990 u 01 01
1990 1990 s 		LD	B,A
1991 1991 d 3a8bff
1991 1991 u 03 01
1991 1991 s 		LD	A,(IoPtr)
1994 1994 d 4f
1994 1994 u 01 01
1994 1994 s 		LD	C,A
1995 1995 d ed41
1995 1995 u 02 01
1995 1995 s 		OUT	(C),B
1997 1997 d c1
1997 1997 u 01 01
1997 1997 s 		POP	BC
1998 1998 d c34a1b
1998 1998 u 03 01
1998 1998 s 		JP	ICMD_IO_OUT
199b 199b s 
199b 199b s ICMD1
199b 199b s ICMD2
199b 199b s ICMD3
199b 199b s ICMD4
199b 199b s 
199b 199b d cd1d0c
199b 199b u 03 01
199b 199b s ICMD5		CALL	WRITE_BLOCK
199e 199e d baff
199e 199e u 02 02
199e 199e s 		DW	LDISPMODE	;Where to write
19a0 19a0 d 0e00
19a0 19a0 u 02 02
19a0 19a0 s 		DW	14		;Bytes to write
19a2 19a2 d d01b
19a2 19a2 u 02 02
19a2 19a2 s 		DW	IDISP_IN	;(LDISPMODE)
19a4 19a4 d d01b
19a4 19a4 u 02 02
19a4 19a4 s 		DW	IDISP_IN	;(DISPMODE)
19a6 19a6 d 3819
19a6 19a6 u 02 02
19a6 19a6 s 		DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
19a8 19a8 d 50
19a8 19a8 u 01 02
19a8 19a8 s 		DB	80		;(IK_TIMER)
19a9 19a9 d 8f
19a9 19a9 u 01 02
19a9 19a9 s 		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
19aa 19aa d 00
19aa 19aa u 01 02
19aa 19aa s 		DB	0		;(DISPLABEL)
19ab 19ab d ff
19ab 19ab u 01 02
19ab 19ab s 		DB	-1		;(IK_HEXST)
19ac 19ac d e2ff
19ac 19ac u 02 02
19ac 19ac s 		DW	LED_DISPLAY+2	;(HEX_CURSOR) @d3
19ae 19ae d 7819
19ae 19ae u 02 02
19ae 19ae s 		DW	HEX2IN_Ptr	;(HEX_READY)
19b0 19b0 s 
19b0 19b0 d 21e7ff
19b0 19b0 u 03 01
19b0 19b0 s 		LD	HL,LED_ANBAR
19b3 19b3 d cbee
19b3 19b3 u 02 01
19b3 19b3 s 		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
19b5 19b5 d c3df17
19b5 19b5 u 03 01
19b5 19b5 s 		JP	IKEY_DONE
19b8 19b8 s 
19b8 19b8 d cd1d0c
19b8 19b8 u 03 01
19b8 19b8 s ICMD6		CALL	WRITE_BLOCK
19bb 19bb d baff
19bb 19bb u 02 02
19bb 19bb s 		DW	LDISPMODE	;Where to write
19bd 19bd d 0e00
19bd 19bd u 02 02
19bd 19bd s 		DW	14		;Bytes to write
19bf 19bf d 051c
19bf 19bf u 02 02
19bf 19bf s 		DW	IDISP_OUT	;(LDISPMODE)
19c1 19c1 d 051c
19c1 19c1 u 02 02
19c1 19c1 s 		DW	IDISP_OUT	;(DISPMODE)
19c3 19c3 d 3819
19c3 19c3 u 02 02
19c3 19c3 s 		DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
19c5 19c5 d 50
19c5 19c5 u 01 02
19c5 19c5 s 		DB	80		;(IK_TIMER)
19c6 19c6 d 8f
19c6 19c6 u 01 02
19c6 19c6 s 		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
19c7 19c7 d 00
19c7 19c7 u 01 02
19c7 19c7 s 		DB	0		;(DISPLABEL)
19c8 19c8 d ff
19c8 19c8 u 01 02
19c8 19c8 s 		DB	-1		;(IK_HEXST)
19c9 19c9 d e2ff
19c9 19c9 u 02 02
19c9 19c9 s 		DW	LED_DISPLAY+2	;(HEX_CURSOR) @d3
19cb 19cb d 7e19
19cb 19cb u 02 02
19cb 19cb s 		DW	HEX2OUT_Ptr	;(HEX_READY)
19cd 19cd s 
19cd 19cd d 21e5ff
19cd 19cd u 03 01
19cd 19cd s 		LD	HL,LED_DISPLAY+5
19d0 19d0 d 3680
19d0 19d0 u 02 01
19d0 19d0 s 		LD	(HL),0x80	;Blank d6
19d2 19d2 d 2c
19d2 19d2 u 01 01
19d2 19d2 s 		INC	L
19d3 19d3 d 3680
19d3 19d3 u 02 01
19d3 19d3 s 		LD	(HL),0x80	;Blank d7
19d5 19d5 d 21e7ff
19d5 19d5 u 03 01
19d5 19d5 s 		LD	HL,LED_ANBAR
19d8 19d8 d cbee
19d8 19d8 u 02 01
19d8 19d8 s 		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
19da 19da d c3df17
19da 19da u 03 01
19da 19da s 		JP	IKEY_DONE
19dd 19dd s 
19dd 19dd s 
19dd 19dd s 
19dd 19dd d cd1d0c
19dd 19dd u 03 01
19dd 19dd s IRAMROMBANK	CALL	WRITE_BLOCK
19e0 19e0 d bcff
19e0 19e0 u 02 02
19e0 19e0 s 		DW	DISPMODE	;Where to write
19e2 19e2 d 0500
19e2 19e2 u 02 02
19e2 19e2 s 		DW	5		;Bytes to write
19e4 19e4 d e317
19e4 19e4 u 02 02
19e4 19e4 s 		DW	IDISP_RET	;(DISPMODE)
19e6 19e6 d 131a
19e6 19e6 u 02 02
19e6 19e6 s 		DW	IRAMROMBANK_CHG	;(KEY_EVENT) Switch to BYTE Input Mode
19e8 19e8 d 50
19e8 19e8 u 01 02
19e8 19e8 s 		DB	80		;(IK_TIMER)
19e9 19e9 s 		
19e9 19e9 d 3adbff
19e9 19e9 u 03 01
19e9 19e9 s 		LD	A,(READ_RAMROM)
19ec 19ec d 1f
19ec 19ec u 01 01
19ec 19ec s IDDR_DISP	RRA
19ed 19ed d d3cc
19ed 19ed u 02 01
19ed 19ed s 		OUT	(ACE_OUT),A	;SET Bank
19ef 19ef d 3014
19ef 19ef u 02 01
19ef 19ef s 		JR  NC,	IDRR_ROM
19f1 19f1 d cd8a1c
19f1 19f1 u 03 01
19f1 19f1 s 		CALL	LED_HOME_PRINTI
19f4 19f4 d 72616d2020202000
19f4 19f4 u 08 02
19f4 19f4 s 		DB	'ram    ',EOS
19fc 19fc d 21e4ff
19fc 19fc u 03 01
19fc 19fc s 		LD	HL,LED_DISPLAY+4
19ff 19ff d cd531c
19ff 19ff u 03 01
19ff 19ff s 		CALL	LED_PUT_HEX_HL
1a02 1a02 d c3df17
1a02 1a02 u 03 01
1a02 1a02 s 		JP	IKEY_DONE
1a05 1a05 s 		
1a05 1a05 d cd8a1c
1a05 1a05 u 03 01
1a05 1a05 s IDRR_ROM	CALL	LED_HOME_PRINTI
1a08 1a08 d 726f6d2020202000
1a08 1a08 u 08 02
1a08 1a08 s 		DB	'rom    ',EOS
1a10 1a10 d c3df17
1a10 1a10 u 03 01
1a10 1a10 s 		JP	IKEY_DONE
1a13 1a13 s 
1a13 1a13 s ;SET_BANK	
1a13 1a13 d 3e50
1a13 1a13 u 02 01
1a13 1a13 s IRAMROMBANK_CHG	LD	A,80
1a15 1a15 d 32c0ff
1a15 1a15 u 03 01
1a15 1a15 s 		LD	(IK_TIMER),A
1a18 1a18 d 3adbff
1a18 1a18 u 03 01
1a18 1a18 s 		LD	A,(READ_RAMROM)
1a1b 1a1b d 1f
1a1b 1a1b u 01 01
1a1b 1a1b s 		RRA
1a1c 1a1c d 3008
1a1c 1a1c u 02 01
1a1c 1a1c s 		JR  NC,	IDRRC_ROM
1a1e 1a1e d 3c
1a1e 1a1e u 01 01
1a1e 1a1e s 		INC	A
1a1f 1a1f d cb67
1a1f 1a1f u 02 01
1a1f 1a1f s 		BIT	4,A
1a21 1a21 d 2007
1a21 1a21 u 02 01
1a21 1a21 s 		JR  NZ,	IDRRC_2ROM
1a23 1a23 d 17
1a23 1a23 u 01 01
1a23 1a23 s 		RLA
1a24 1a24 d 1805
1a24 1a24 u 02 01
1a24 1a24 s 		JR	IDRRC_RET
1a26 1a26 s 
1a26 1a26 d 3e01
1a26 1a26 u 02 01
1a26 1a26 s IDRRC_ROM	LD	A,1		;Start at BANK 0 of RAM, bit0 set = RAM
1a28 1a28 d 1801
1a28 1a28 u 02 01
1a28 1a28 s 		JR	IDRRC_RET
1a2a 1a2a s 		
1a2a 1a2a d af
1a2a 1a2a u 01 01
1a2a 1a2a s IDRRC_2ROM	XOR	A		;Return to ROM after 15 Banks
1a2b 1a2b d 32dbff
1a2b 1a2b u 03 01
1a2b 1a2b s IDRRC_RET	LD	(READ_RAMROM),A
1a2e 1a2e d 18bc
1a2e 1a2e u 02 01
1a2e 1a2e s 		JR	IDDR_DISP
1a30 1a30 s 
1a30 1a30 s 
1a30 1a30 s 
1a30 1a30 s 
1a30 1a30 s ;============================================================================
1a30 1a30 s ;	Single Step
1a30 1a30 s ;============================================================================
1a30 1a30 d 3ab3ff
1a30 1a30 u 03 01
1a30 1a30 s ICMD7		LD	A,(ANBAR_DEF)	;Single step only allowed while in Monitor Mode
1a33 1a33 d e604
1a33 1a33 u 02 01
1a33 1a33 s 		AND	4
1a35 1a35 d cadf17
1a35 1a35 u 03 01
1a35 1a35 s 		JP  Z,	IKEY_DONE
1a38 1a38 s 		
1a38 1a38 s 		;DEBUG SINGLE STEP ONLY ALLOWED WITH FP BOARD
1a38 1a38 d 3a95ff
1a38 1a38 u 03 01
1a38 1a38 s 		LD	A,(HW_LIST)
1a3b 1a3b d e601
1a3b 1a3b u 02 01
1a3b 1a3b s 		AND	1
1a3d 1a3d d cadf17
1a3d 1a3d u 03 01
1a3d 1a3d s 		JP  Z,	IKEY_DONE
1a40 1a40 s 		
1a40 1a40 s 
1a40 1a40 d 3a95ff
1a40 1a40 u 03 01
1a40 1a40 s GO_SINGLE	LD	A,(HW_LIST)	;TEST HARDWARE LIST here for Return to Main Menu when
1a43 1a43 d e601
1a43 1a43 u 02 01
1a43 1a43 s 		AND	1		;Single Step was an RS232 input command
1a45 1a45 d 2027
1a45 1a45 u 02 01
1a45 1a45 s 		JR  NZ,	GS_OK
1a47 1a47 s 
1a47 1a47 d cdca0d
1a47 1a47 u 03 01
1a47 1a47 s 		CALL	PRINTI
1a4a 1a4a d 0d0a53696e676c6520537465702072657175697265732046726f6e742050616e656c00
1a4a 1a4a u 23 02
1a4a 1a4a s 		DB	CR,LF,"Single Step requires Front Panel",EOS		
1a6d 1a6d d c9
1a6d 1a6d u 01 01
1a6d 1a6d s 		RET	
1a6e 1a6e s 		
1a6e 1a6e d 21751a
1a6e 1a6e u 03 01
1a6e 1a6e s GS_OK		LD	HL,ISINGLE	;Redirect next Interrupt to Single Step
1a71 1a71 d 22ceff
1a71 1a71 u 03 01
1a71 1a71 s 		LD	(INT_VEC),HL
1a74 1a74 d 76
1a74 1a74 u 01 01
1a74 1a74 s 		HALT			;Halt for next interrupt (Aligns TC with INT)
1a75 1a75 s 
1a75 1a75 s 					;The following interrupt code happens		
1a75 1a75 s 		;RST	0x38		;13  (11 + 2 wait cycles)
1a75 1a75 s 		;EX	AF,AF'		;4
1a75 1a75 s 		;EXX			;4
1a75 1a75 s 		;LD	HL,(INT_VEC)	;16 Typical Calls are to ISR_DISPATCH
1a75 1a75 s 		;JP	(HL)		;4
1a75 1a75 s 					;st=41
1a75 1a75 s 					
1a75 1a75 s 					;On the next interrupt, handle it here
1a75 1a75 d 08
1a75 1a75 u 01 01
1a75 1a75 s ISINGLE		EX	AF,AF'		;4
1a76 1a76 d d9
1a76 1a76 u 01 01
1a76 1a76 s 		EXX			;4
1a77 1a77 d 3af5ff
1a77 1a77 u 03 01
1a77 1a77 s 		LD	A,(SCAN_LED)	;13 ZMC-Display Refresh / Reset Int
1a7a 1a7a d d340
1a7a 1a7a u 02 01
1a7a 1a7a s 		OUT	(Port40),A	;11 Output ASAP to satisfy Interrupt Flag
1a7c 1a7c s 
1a7c 1a7c d db40
1a7c 1a7c u 02 01
1a7c 1a7c s 		IN	A,(Port40)	;11 Resync the SCAN_PTR
1a7e 1a7e d 3c
1a7e 1a7e u 01 01
1a7e 1a7e s 		INC	A		;4  Advance to next column to match column after next OUT
1a7f 1a7f d e607
1a7f 1a7f u 02 01
1a7f 1a7f s 		AND	7		;7
1a81 1a81 d f6e0
1a81 1a81 u 02 01
1a81 1a81 s 		OR  LOW LED_DISPLAY	;7  LED_DISPLAY is at xxEO (it's ok to overlap in this order)
1a83 1a83 d 32d0ff
1a83 1a83 u 03 01
1a83 1a83 s 		LD	(SCAN_PTR),A	;13 Save Scan Ptr @ Next Scan Output
1a86 1a86 d 2ad0ff
1a86 1a86 u 03 01
1a86 1a86 s 		LD	HL,(SCAN_PTR)	;16 Fetch next byte to output
1a89 1a89 d 7e
1a89 1a89 u 01 01
1a89 1a89 s 		LD	A,(HL)		;7
1a8a 1a8a d 32f5ff
1a8a 1a8a u 03 01
1a8a 1a8a s 		LD	(SCAN_LED),A	;13 Save for next interrupt
1a8d 1a8d s 					;st=110
1a8d 1a8d s 
1a8d 1a8d d 219c1a
1a8d 1a8d u 03 01
1a8d 1a8d s 		LD	HL,ISINGLE_DONE	;10 Redirect next Interrupt to Single Step
1a90 1a90 d 22ceff
1a90 1a90 u 03 01
1a90 1a90 s 		LD	(INT_VEC),HL	;16
1a93 1a93 s 
1a93 1a93 d 3ed4
1a93 1a93 u 02 01
1a93 1a93 s 		LD	A,212		;7
1a95 1a95 s 					;st=33
1a95 1a95 s 					;-----
1a95 1a95 s 					;184 (+completion), There are 4096 cycles between interrupts.
1a95 1a95 s 					;	 4096 cycles to waste
1a95 1a95 s 					;	 -184 cycles to get here
1a95 1a95 s 					;	 -525 cycles to execute
1a95 1a95 s 					;	=3387 cycles more to waste
1a95 1a95 s 					;
1a95 1a95 s 					;	Waste Loop = 16 * 212 -5 = 3387
1a95 1a95 s 					;
1a95 1a95 d 3d
1a95 1a95 u 01 01
1a95 1a95 s ISINGLE_LP	DEC	A		;4  Count down the cycles to time the next ISR to occur
1a96 1a96 d 20fd
1a96 1a96 u 02 01
1a96 1a96 s 		JR NZ,	ISINGLE_LP	;12/7 cycle after execution commences
1a98 1a98 d 00
1a98 1a98 u 01 01
1a98 1a98 s 		NOP		
1a99 1a99 d c3710b
1a99 1a99 u 03 01
1a99 1a99 s 		JP	GO_EXEC		;10 Go Execute the single instruction!
1a9c 1a9c s 					;(515 T states until executing next instruction)
1a9c 1a9c s 
1a9c 1a9c d 08
1a9c 1a9c u 01 01
1a9c 1a9c s ISINGLE_DONE	EX	AF,AF'		;4
1a9d 1a9d d d9
1a9d 1a9d u 01 01
1a9d 1a9d s 		EXX			;4
1a9e 1a9e d ed7328fb
1a9e 1a9e u 04 01
1a9e 1a9e s 		LD	(SP_ISR_SAVE),SP
1aa2 1aa2 d e5
1aa2 1aa2 u 01 01
1aa2 1aa2 s 		PUSH	HL
1aa3 1aa3 d f5
1aa3 1aa3 u 01 01
1aa3 1aa3 s 		PUSH	AF
1aa4 1aa4 s 
1aa4 1aa4 d 3ed1
1aa4 1aa4 u 02 01
1aa4 1aa4 s 		LD	A,0xD1		;ISR being re-entered after the single step
1aa6 1aa6 d c30218
1aa6 1aa6 u 03 01
1aa6 1aa6 s 		JP 	ICMD_BREAK_RET	;
1aa9 1aa9 s 
1aa9 1aa9 s ;ICMD_BREAK_RET	....
1aa9 1aa9 s ;		DI
1aa9 1aa9 s ;		POP	AF
1aa9 1aa9 s ;		POP	HL
1aa9 1aa9 s ;		LD	SP,(SP_ISR_SAVE)
1aa9 1aa9 s ;		JP	0
1aa9 1aa9 s 		
1aa9 1aa9 s 
1aa9 1aa9 s 
1aa9 1aa9 s 
1aa9 1aa9 s 
1aa9 1aa9 s ;============================================================================
1aa9 1aa9 d 3abcff
1aa9 1aa9 u 03 01
1aa9 1aa9 s GET_DISPMODE	LD	A,(DISPMODE)
1aac 1aac d fe79
1aac 1aac u 02 01
1aac 1aac s 		CP  LOW IDISP_REG_DATA
1aae 1aae d c8
1aae 1aae u 01 01
1aae 1aae s 		RET Z				;Z=1 : DISPMODE = REGISTER
1aaf 1aaf d feb4
1aaf 1aaf u 02 01
1aaf 1aaf s 		CP  LOW IDISP_MEM_DATA
1ab1 1ab1 d 37
1ab1 1ab1 u 01 01
1ab1 1ab1 s 		SCF
1ab2 1ab2 d c0
1ab2 1ab2 u 01 01
1ab2 1ab2 s 		RET NZ				;Z=0, C=1 : DISPMODE = I/O
1ab3 1ab3 d b7
1ab3 1ab3 u 01 01
1ab3 1ab3 s 		OR	A			;WARNING, If LOW IDISP_MEM_DATA=0 Then ERROR
1ab4 1ab4 d c9
1ab4 1ab4 u 01 01
1ab4 1ab4 s 		RET				;Z=0, C=0 : DISPMODE = MEM
1ab5 1ab5 s 
1ab5 1ab5 s ;	if 0x00 = LOW IDISP_MEM_DATA
1ab5 1ab5 s ;	   error "Error, LOW IDISP_MEM_DATA must not be 0x00"
1ab5 1ab5 s ;	endif
1ab5 1ab5 s 
1ab5 1ab5 s ;============================================================================
1ab5 1ab5 s ;	Increment Display Element
1ab5 1ab5 s ;============================================================================
1ab5 1ab5 d cda91a
1ab5 1ab5 u 03 01
1ab5 1ab5 s ICMDA		CALL	GET_DISPMODE
1ab8 1ab8 d cac81a
1ab8 1ab8 u 03 01
1ab8 1ab8 s 		JP  Z,	ICMA_REG
1abb 1abb d dacf1a
1abb 1abb u 03 01
1abb 1abb s 		JP  C,	ICMA_IO
1abe 1abe s 
1abe 1abe d 2a88ff
1abe 1abe u 03 01
1abe 1abe s 		LD	HL,(ABUSS)
1ac1 1ac1 d 23
1ac1 1ac1 u 01 01
1ac1 1ac1 s 		INC     HL
1ac2 1ac2 d 2288ff
1ac2 1ac2 u 03 01
1ac2 1ac2 s 		LD	(ABUSS),HL
1ac5 1ac5 d c3d517
1ac5 1ac5 u 03 01
1ac5 1ac5 s 		JP	IKR_QREFRESH
1ac8 1ac8 s 
1ac8 1ac8 d 3a8aff
1ac8 1ac8 u 03 01
1ac8 1ac8 s ICMA_REG	LD      A,(RegPtr)
1acb 1acb d 3c
1acb 1acb u 01 01
1acb 1acb s 		INC	A
1acc 1acc d c3ef1a
1acc 1acc u 03 01
1acc 1acc s 		JP	ICMD_SET_REG
1acf 1acf s 
1acf 1acf d 218bff
1acf 1acf u 03 01
1acf 1acf s ICMA_IO		LD	HL,IoPtr
1ad2 1ad2 d 34
1ad2 1ad2 u 01 01
1ad2 1ad2 s 		INC	(HL)
1ad3 1ad3 d c3d517
1ad3 1ad3 u 03 01
1ad3 1ad3 s 		JP	IKR_QREFRESH
1ad6 1ad6 s 
1ad6 1ad6 s 
1ad6 1ad6 s ;============================================================================
1ad6 1ad6 s ;	Decrement Display Element (Reg, I/O, Mem)
1ad6 1ad6 s ;============================================================================
1ad6 1ad6 d cda91a
1ad6 1ad6 u 03 01
1ad6 1ad6 s ICMDB		CALL	GET_DISPMODE
1ad9 1ad9 d cae91a
1ad9 1ad9 u 03 01
1ad9 1ad9 s 		JP  Z,	ICMB_REG
1adc 1adc d dafa1a
1adc 1adc u 03 01
1adc 1adc s 		JP  C,	ICMB_IO
1adf 1adf s 
1adf 1adf d 2a88ff
1adf 1adf u 03 01
1adf 1adf s 		LD	HL,(ABUSS)
1ae2 1ae2 d 2b
1ae2 1ae2 u 01 01
1ae2 1ae2 s 		DEC     HL
1ae3 1ae3 d 2288ff
1ae3 1ae3 u 03 01
1ae3 1ae3 s 		LD	(ABUSS),HL
1ae6 1ae6 d c3d517
1ae6 1ae6 u 03 01
1ae6 1ae6 s 		JP	IKR_QREFRESH
1ae9 1ae9 s 
1ae9 1ae9 d 3a8aff
1ae9 1ae9 u 03 01
1ae9 1ae9 s ICMB_REG	LD      A,(RegPtr)
1aec 1aec d 3d
1aec 1aec u 01 01
1aec 1aec s ICMD0_R		DEC	A		;Adjust so Key 1 = 0 = SP
1aed 1aed d e60f
1aed 1aed u 02 01
1aed 1aed s 		AND	0xF
1aef 1aef d fe0d
1aef 1aef u 02 01
1aef 1aef s ICMD_SET_REG	CP	13
1af1 1af1 d 3801
1af1 1af1 u 02 01
1af1 1af1 s 		JR  C,	ICMD_SR_OK
1af3 1af3 d af
1af3 1af3 u 01 01
1af3 1af3 s 		XOR	A
1af4 1af4 d 328aff
1af4 1af4 u 03 01
1af4 1af4 s ICMD_SR_OK	LD	(RegPtr),A
1af7 1af7 d c3be17
1af7 1af7 u 03 01
1af7 1af7 s 		JP	IKC_RESET_CMD
1afa 1afa s 
1afa 1afa s 
1afa 1afa d 218bff
1afa 1afa u 03 01
1afa 1afa s ICMB_IO		LD	HL,IoPtr
1afd 1afd d 35
1afd 1afd u 01 01
1afd 1afd s 		DEC	(HL)
1afe 1afe d c3d517
1afe 1afe u 03 01
1afe 1afe s 		JP	IKR_QREFRESH
1b01 1b01 s 
1b01 1b01 s ;============================================================================
1b01 1b01 s ;	Alter Display Element (Reg, I/O, Mem)
1b01 1b01 s ;============================================================================
1b01 1b01 d cda91a
1b01 1b01 u 03 01
1b01 1b01 s ICMDD		CALL	GET_DISPMODE
1b04 1b04 d ca291b
1b04 1b04 u 03 01
1b04 1b04 s 		JP  Z,	ICMD_REG
1b07 1b07 d da451b
1b07 1b07 u 03 01
1b07 1b07 s 		JP  C,	ICMD_IO
1b0a 1b0a s 
1b0a 1b0a d cd1d0c
1b0a 1b0a u 03 01
1b0a 1b0a s ICMD_AMEM	CALL	WRITE_BLOCK
1b0d 1b0d d baff
1b0d 1b0d u 02 02
1b0d 1b0d s 		DW	LDISPMODE	;Where to write
1b0f 1b0f d 0e00
1b0f 1b0f u 02 02
1b0f 1b0f s 		DW	14		;Bytes to write
1b11 1b11 d 9c1b
1b11 1b11 u 02 02
1b11 1b11 s 		DW	IDISP_MEM	;(LDISPMODE)
1b13 1b13 d 9c1b
1b13 1b13 u 02 02
1b13 1b13 s 		DW	IDISP_MEM	;(DISPMODE)
1b15 1b15 d 3819
1b15 1b15 u 02 02
1b15 1b15 s 		DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
1b17 1b17 d 50
1b17 1b17 u 01 02
1b17 1b17 s 		DB	80		;(IK_TIMER)
1b18 1b18 d 8f
1b18 1b18 u 01 02
1b18 1b18 s 		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
1b19 1b19 d 01
1b19 1b19 u 01 02
1b19 1b19 s 		DB	1		;(DISPLABEL)
1b1a 1b1a d ff
1b1a 1b1a u 01 02
1b1a 1b1a s 		DB	-1		;(IK_HEXST)
1b1b 1b1b d e5ff
1b1b 1b1b u 02 02
1b1b 1b1b s 		DW	LED_DISPLAY+5	;(HEX_CURSOR) @d6
1b1d 1b1d d 8419
1b1d 1b1d u 02 02
1b1d 1b1d s 		DW	HEX2MEM		;(HEX_READY)
1b1f 1b1f s 
1b1f 1b1f d 21e7ff
1b1f 1b1f u 03 01
1b1f 1b1f s 		LD	HL,LED_ANBAR
1b22 1b22 d cbee
1b22 1b22 u 02 01
1b22 1b22 s 		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
1b24 1b24 d cbe6
1b24 1b24 u 02 01
1b24 1b24 s 		SET	4,(HL)		;ANBARLED 4 = Alter
1b26 1b26 d c3df17
1b26 1b26 u 03 01
1b26 1b26 s 		JP	IKEY_DONE
1b29 1b29 s 
1b29 1b29 s 
1b29 1b29 s 
1b29 1b29 d 21ca18
1b29 1b29 u 03 01
1b29 1b29 s ICMD_REG	LD	HL,ICMD_WORD	;Switch to WORD Input Mode
1b2c 1b2c d 22beff
1b2c 1b2c u 03 01
1b2c 1b2c s 		LD	(KEY_EVENT),HL
1b2f 1b2f d 212919
1b2f 1b2f u 03 01
1b2f 1b2f s 		LD	HL,HEX2REG
1b32 1b32 d 22c6ff
1b32 1b32 u 03 01
1b32 1b32 s 		LD	(HEX_READY),HL
1b35 1b35 d 21e3ff
1b35 1b35 u 03 01
1b35 1b35 s 		LD	HL,LED_DISPLAY+3 ;@d4
1b38 1b38 d 22c4ff
1b38 1b38 u 03 01
1b38 1b38 s 		LD	(HEX_CURSOR),HL
1b3b 1b3b s 		;LD	A,0x8F
1b3b 1b3b s 		;LD	(KEYBFMODE),A	;HEX Keyboard
1b3b 1b3b d 21e7ff
1b3b 1b3b u 03 01
1b3b 1b3b s 		LD	HL,LED_ANBAR
1b3e 1b3e d cbee
1b3e 1b3e u 02 01
1b3e 1b3e s 		SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
1b40 1b40 d cbe6
1b40 1b40 u 02 01
1b40 1b40 s 		SET	4,(HL)		;ANBARLED 4 = Alter
1b42 1b42 d c3df17
1b42 1b42 u 03 01
1b42 1b42 s 		JP	IKEY_DONE
1b45 1b45 s 
1b45 1b45 d fee7
1b45 1b45 u 02 01
1b45 1b45 s ICMD_IO		CP  LOW IDISP_IN_DATA
1b47 1b47 d ca9b19
1b47 1b47 u 03 01
1b47 1b47 s 		JP  Z,	ICMD5
1b4a 1b4a s 
1b4a 1b4a d cd1d0c
1b4a 1b4a u 03 01
1b4a 1b4a s ICMD_IO_OUT	CALL	WRITE_BLOCK
1b4d 1b4d d baff
1b4d 1b4d u 02 02
1b4d 1b4d s 		DW	LDISPMODE	;Where to write
1b4f 1b4f d 0e00
1b4f 1b4f u 02 02
1b4f 1b4f s 		DW	14		;Bytes to write
1b51 1b51 d 051c
1b51 1b51 u 02 02
1b51 1b51 s 		DW	IDISP_OUT	;(LDISPMODE)
1b53 1b53 d 051c
1b53 1b53 u 02 02
1b53 1b53 s 		DW	IDISP_OUT	;(DISPMODE)
1b55 1b55 d 3819
1b55 1b55 u 02 02
1b55 1b55 s 		DW	ICMD_BYTE	;(KEY_EVENT) Switch to HEX Input Mode
1b57 1b57 d 50
1b57 1b57 u 01 02
1b57 1b57 s 		DB	80		;(IK_TIMER)
1b58 1b58 d 8f
1b58 1b58 u 01 02
1b58 1b58 s 		DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
1b59 1b59 d 00
1b59 1b59 u 01 02
1b59 1b59 s 		DB	0		;(DISPLABEL)
1b5a 1b5a d ff
1b5a 1b5a u 01 02
1b5a 1b5a s 		DB	-1		;(IK_HEXST)
1b5b 1b5b d e5ff
1b5b 1b5b u 02 02
1b5b 1b5b s 		DW	LED_DISPLAY+5	;(HEX_CURSOR) @d6
1b5d 1b5d d 8f19
1b5d 1b5d u 02 02
1b5d 1b5d s 		DW	HEX2OUT_PORT	;(HEX_READY)
1b5f 1b5f d 21e7ff
1b5f 1b5f u 03 01
1b5f 1b5f s 		LD	HL,LED_ANBAR
1b62 1b62 d cbde
1b62 1b62 u 02 01
1b62 1b62 s 		SET	3,(HL)		;ANBARLED 3 = Send Data to Output Port
1b64 1b64 d c3df17
1b64 1b64 u 03 01
1b64 1b64 s 		JP	IKEY_DONE
1b67 1b67 s 
1b67 1b67 s 
1b67 1b67 s ;============================================================================
1b67 1b67 s ;	LED Display Register
1b67 1b67 s ;============================================================================
1b67 1b67 d cd7714
1b67 1b67 u 03 01
1b67 1b67 s IDISP_REG	CALL	LED_HOME
1b6a 1b6a d 3a8aff
1b6a 1b6a u 03 01
1b6a 1b6a s 		LD	A,(RegPtr)
1b6d 1b6d d cd2e0c
1b6d 1b6d u 03 01
1b6d 1b6d s 		CALL	GET_REGNAME
1b70 1b70 d cd781c
1b70 1b70 u 03 01
1b70 1b70 s 		CALL	LED_PRINT
1b73 1b73 d 21791b
1b73 1b73 u 03 01
1b73 1b73 s 		LD	HL,IDISP_REG_DATA
1b76 1b76 d 22bcff
1b76 1b76 u 03 01
1b76 1b76 s 		LD	(DISPMODE),HL
1b79 1b79 s 
1b79 1b79 d 3a8aff
1b79 1b79 u 03 01
1b79 1b79 s IDISP_REG_DATA	LD	A,(RegPtr)	;13 Then Display Data
1b7c 1b7c d cd6d0c
1b7c 1b7c u 03 01
1b7c 1b7c s 		CALL	GET_REGISTER	;17+169
1b7f 1b7f d 7d
1b7f 1b7f u 01 01
1b7f 1b7f s 		LD	A,L		;4
1b80 1b80 d f5
1b80 1b80 u 01 01
1b80 1b80 s 		PUSH	AF		;11
1b81 1b81 d 7c
1b81 1b81 u 01 01
1b81 1b81 s 		LD	A,H		;4
1b82 1b82 d 21e3ff
1b82 1b82 u 03 01
1b82 1b82 s 		LD	HL,LED_DISPLAY+3 ;10
1b85 1b85 d cd4a1c
1b85 1b85 u 03 01
1b85 1b85 s 		CALL	LED_PUT_BYTE_HL	;17+165
1b88 1b88 d f1
1b88 1b88 u 01 01
1b88 1b88 s 		POP	AF		;10
1b89 1b89 d cd4a1c
1b89 1b89 u 03 01
1b89 1b89 s 		CALL	LED_PUT_BYTE_HL	;17+165
1b8c 1b8c d 21c2ff
1b8c 1b8c u 03 01
1b8c 1b8c s 		LD	HL,DISPLABEL	;10
1b8f 1b8f d 35
1b8f 1b8f u 01 01
1b8f 1b8f s 		DEC	(HL)		;7
1b90 1b90 d c2e317
1b90 1b90 u 03 01
1b90 1b90 s 		JP NZ,	IDISP_RET	;10   sp=629
1b93 1b93 d 21671b
1b93 1b93 u 03 01
1b93 1b93 s 		LD	HL,IDISP_REG
1b96 1b96 d 22bcff
1b96 1b96 u 03 01
1b96 1b96 s 		LD	(DISPMODE),HL
1b99 1b99 d c3e317
1b99 1b99 u 03 01
1b99 1b99 s 		JP 	IDISP_RET
1b9c 1b9c s 
1b9c 1b9c s ;============================================================================
1b9c 1b9c s ;	LED Display Memory Location
1b9c 1b9c s ;============================================================================
1b9c 1b9c d 21e0ff
1b9c 1b9c u 03 01
1b9c 1b9c s IDISP_MEM	LD	HL,LED_DISPLAY	;First, Display location
1b9f 1b9f d 3a89ff
1b9f 1b9f u 03 01
1b9f 1b9f s 		LD	A,(ABUSS+1)
1ba2 1ba2 d cd4a1c
1ba2 1ba2 u 03 01
1ba2 1ba2 s 		CALL	LED_PUT_BYTE_HL
1ba5 1ba5 d 3a88ff
1ba5 1ba5 u 03 01
1ba5 1ba5 s 		LD	A,(ABUSS)
1ba8 1ba8 d cd4a1c
1ba8 1ba8 u 03 01
1ba8 1ba8 s 		CALL	LED_PUT_BYTE_HL
1bab 1bab d 3e80
1bab 1bab u 02 01
1bab 1bab s 		LD	A,0x80		;Blank next char
1bad 1bad d 77
1bad 1bad u 01 01
1bad 1bad s 		LD	(HL),A
1bae 1bae d 21b41b
1bae 1bae u 03 01
1bae 1bae s 		LD	HL,IDISP_MEM_DATA
1bb1 1bb1 d 22bcff
1bb1 1bb1 u 03 01
1bb1 1bb1 s 		LD	(DISPMODE),HL
1bb4 1bb4 s 					;Then Display DATA
1bb4 1bb4 d 2a88ff
1bb4 1bb4 u 03 01
1bb4 1bb4 s IDISP_MEM_DATA	LD	HL,(ABUSS)	;16
1bb7 1bb7 d cd45fb
1bb7 1bb7 u 03 01
1bb7 1bb7 s 		CALL	GET_MEM
1bba 1bba d 21e5ff
1bba 1bba u 03 01
1bba 1bba s 		LD	HL,LED_DISPLAY+5 ;10
1bbd 1bbd d cd4a1c
1bbd 1bbd u 03 01
1bbd 1bbd s 		CALL	LED_PUT_BYTE_HL	;17+165
1bc0 1bc0 d 21c2ff
1bc0 1bc0 u 03 01
1bc0 1bc0 s 		LD	HL,DISPLABEL	;10 Repeat Display of Data several times before redisplaying Location
1bc3 1bc3 d 35
1bc3 1bc3 u 01 01
1bc3 1bc3 s 		DEC	(HL)		;7
1bc4 1bc4 d c2e317
1bc4 1bc4 u 03 01
1bc4 1bc4 s 		JP NZ,	IDISP_RET	;10  st=242
1bc7 1bc7 d 219c1b
1bc7 1bc7 u 03 01
1bc7 1bc7 s 		LD	HL,IDISP_MEM
1bca 1bca d 22bcff
1bca 1bca u 03 01
1bca 1bca s 		LD	(DISPMODE),HL
1bcd 1bcd d c3e317
1bcd 1bcd u 03 01
1bcd 1bcd s 		JP 	IDISP_RET
1bd0 1bd0 s 
1bd0 1bd0 s 
1bd0 1bd0 s ;============================================================================
1bd0 1bd0 s ;	LED Display Input Port
1bd0 1bd0 s ;============================================================================
1bd0 1bd0 d cd8a1c
1bd0 1bd0 u 03 01
1bd0 1bd0 s IDISP_IN	CALL	LED_HOME_PRINTI
1bd3 1bd3 d 696e00
1bd3 1bd3 u 03 02
1bd3 1bd3 s 		DB	'in',EOS
1bd6 1bd6 d 3a8bff
1bd6 1bd6 u 03 01
1bd6 1bd6 s 		LD	A,(IoPtr)
1bd9 1bd9 d 21e2ff
1bd9 1bd9 u 03 01
1bd9 1bd9 s 		LD	HL,LED_DISPLAY+2
1bdc 1bdc d cd4a1c
1bdc 1bdc u 03 01
1bdc 1bdc s 		CALL	LED_PUT_BYTE_HL
1bdf 1bdf d 3680
1bdf 1bdf u 02 01
1bdf 1bdf s 		LD	(HL),0x80	;Blank d5
1be1 1be1 d 21e71b
1be1 1be1 u 03 01
1be1 1be1 s 		LD	HL,IDISP_IN_DATA
1be4 1be4 d 22bcff
1be4 1be4 u 03 01
1be4 1be4 s 		LD	(DISPMODE),HL
1be7 1be7 s 
1be7 1be7 d c5
1be7 1be7 u 01 01
1be7 1be7 s IDISP_IN_DATA	PUSH	BC
1be8 1be8 d 3a8bff
1be8 1be8 u 03 01
1be8 1be8 s 		LD	A,(IoPtr)
1beb 1beb d 4f
1beb 1beb u 01 01
1beb 1beb s 		LD	C,A
1bec 1bec d ed78
1bec 1bec u 02 01
1bec 1bec s 		IN	A,(C)
1bee 1bee d c1
1bee 1bee u 01 01
1bee 1bee s 		POP	BC
1bef 1bef d 21e5ff
1bef 1bef u 03 01
1bef 1bef s 		LD	HL,LED_DISPLAY+5
1bf2 1bf2 d cd4a1c
1bf2 1bf2 u 03 01
1bf2 1bf2 s 		CALL	LED_PUT_BYTE_HL
1bf5 1bf5 d 21c2ff
1bf5 1bf5 u 03 01
1bf5 1bf5 s 		LD	HL,DISPLABEL
1bf8 1bf8 d 35
1bf8 1bf8 u 01 01
1bf8 1bf8 s 		DEC	(HL)
1bf9 1bf9 d c2e317
1bf9 1bf9 u 03 01
1bf9 1bf9 s 		JP NZ,	IDISP_RET
1bfc 1bfc d 21d01b
1bfc 1bfc u 03 01
1bfc 1bfc s 		LD	HL,IDISP_IN
1bff 1bff d 22bcff
1bff 1bff u 03 01
1bff 1bff s 		LD	(DISPMODE),HL
1c02 1c02 d c3e317
1c02 1c02 u 03 01
1c02 1c02 s 		JP 	IDISP_RET
1c05 1c05 s 
1c05 1c05 s 
1c05 1c05 s ;============================================================================
1c05 1c05 s ;	LED Display Output Port		cmd 6
1c05 1c05 s ;============================================================================
1c05 1c05 d cd8a1c
1c05 1c05 u 03 01
1c05 1c05 s IDISP_OUT	CALL	LED_HOME_PRINTI
1c08 1c08 d 6f7500
1c08 1c08 u 03 02
1c08 1c08 s 		DB	'ou',EOS
1c0b 1c0b d 3a8bff
1c0b 1c0b u 03 01
1c0b 1c0b s 		LD	A,(IoPtr)
1c0e 1c0e d 21e2ff
1c0e 1c0e u 03 01
1c0e 1c0e s 		LD	HL,LED_DISPLAY+2
1c11 1c11 d cd4a1c
1c11 1c11 u 03 01
1c11 1c11 s 		CALL	LED_PUT_BYTE_HL
1c14 1c14 d 3680
1c14 1c14 u 02 01
1c14 1c14 s 		LD	(HL),0x80	;Blank d5
1c16 1c16 d 211c1c
1c16 1c16 u 03 01
1c16 1c16 s 		LD	HL,IDISP_OUT_DATA
1c19 1c19 d 22bcff
1c19 1c19 u 03 01
1c19 1c19 s 		LD	(DISPMODE),HL
1c1c 1c1c s 
1c1c 1c1c d 21c2ff
1c1c 1c1c u 03 01
1c1c 1c1c s IDISP_OUT_DATA	LD	HL,DISPLABEL
1c1f 1c1f d 35
1c1f 1c1f u 01 01
1c1f 1c1f s 		DEC	(HL)
1c20 1c20 d c2e317
1c20 1c20 u 03 01
1c20 1c20 s 		JP NZ,	IDISP_RET
1c23 1c23 d 21051c
1c23 1c23 u 03 01
1c23 1c23 s 		LD	HL,IDISP_OUT
1c26 1c26 d 22bcff
1c26 1c26 u 03 01
1c26 1c26 s 		LD	(DISPMODE),HL
1c29 1c29 d c3e317
1c29 1c29 u 03 01
1c29 1c29 s 		JP 	IDISP_RET
1c2c 1c2c s 
1c2c 1c2c s ;============================================================================
1c2c 1c2c s ;	LED Display OFF
1c2c 1c2c s ;============================================================================
1c2c 1c2c d 21e0ff
1c2c 1c2c u 03 01
1c2c 1c2c s IDISP_OFF	LD	HL,LED_DISPLAY
1c2f 1c2f d 3e80
1c2f 1c2f u 02 01
1c2f 1c2f s 		LD	A,0x80
1c31 1c31 d c5
1c31 1c31 u 01 01
1c31 1c31 s 		PUSH	BC
1c32 1c32 d 0608
1c32 1c32 u 02 01
1c32 1c32 s 		LD	B,8
1c34 1c34 d 77
1c34 1c34 u 01 01
1c34 1c34 s IDO_LP		LD	(HL),A
1c35 1c35 d 2c
1c35 1c35 u 01 01
1c35 1c35 s 		INC	L
1c36 1c36 d 10fc
1c36 1c36 u 02 01
1c36 1c36 s 		DJNZ	IDO_LP
1c38 1c38 d c1
1c38 1c38 u 01 01
1c38 1c38 s 		POP	BC
1c39 1c39 d 21e317
1c39 1c39 u 03 01
1c39 1c39 s 		LD	HL,IDISP_RET
1c3c 1c3c d 22bcff
1c3c 1c3c u 03 01
1c3c 1c3c s 		LD	(DISPMODE),HL
1c3f 1c3f d e9
1c3f 1c3f u 01 01
1c3f 1c3f s 		JP 	(HL)
1c40 1c40 s 
1c40 1c40 s ;============================================================================
1c40 1c40 s ;	LED Delay	- After a delay for spash screen, display Registers
1c40 1c40 s ;============================================================================
1c40 1c40 d 21c2ff
1c40 1c40 u 03 01
1c40 1c40 s IDISP_DELAY	LD	HL,DISPLABEL
1c43 1c43 d 35
1c43 1c43 u 01 01
1c43 1c43 s 		DEC	(HL)
1c44 1c44 d c2e317
1c44 1c44 u 03 01
1c44 1c44 s 		JP NZ,	IDISP_RET
1c47 1c47 d c3be17
1c47 1c47 u 03 01
1c47 1c47 s 		JP 	IKC_RESET_CMD
1c4a 1c4a s 
1c4a 1c4a s ;============================================================================
1c4a 1c4a s ;PUTS 2 HEX digits to LED Display
1c4a 1c4a s ;Input:	A=BYTE to display
1c4a 1c4a s ;	HL=Where to display
1c4a 1c4a s ;Output: HL=Next LED Display location
1c4a 1c4a d f5
1c4a 1c4a u 01 01
1c4a 1c4a s LED_PUT_BYTE_HL	PUSH	AF		;11 Save Byte to display (for 2nd HEX digit)
1c4b 1c4b d 0f
1c4b 1c4b u 01 01
1c4b 1c4b s 		RRCA			;4
1c4c 1c4c d 0f
1c4c 1c4c u 01 01
1c4c 1c4c s 		RRCA			;4
1c4d 1c4d d 0f
1c4d 1c4d u 01 01
1c4d 1c4d s 		RRCA			;4
1c4e 1c4e d 0f
1c4e 1c4e u 01 01
1c4e 1c4e s 		RRCA			;4
1c4f 1c4f d cd531c
1c4f 1c4f u 03 01
1c4f 1c4f s 		CALL	LED_PUT_HEX_HL
1c52 1c52 d f1
1c52 1c52 u 01 01
1c52 1c52 s 		POP	AF		;10
1c53 1c53 s 		;CALL	LED_PUT_HEX_HL
1c53 1c53 s 		;RET			;10  st=165
1c53 1c53 s 
1c53 1c53 d e5
1c53 1c53 u 01 01
1c53 1c53 s LED_PUT_HEX_HL	PUSH	HL
1c54 1c54 d e60f
1c54 1c54 u 02 01
1c54 1c54 s 		AND	0xF
1c56 1c56 d 2629
1c56 1c56 u 02 01
1c56 1c56 s 		LD	H,HIGH LED_HEX
1c58 1c58 d 6f
1c58 1c58 u 01 01
1c58 1c58 s 		LD	L,A
1c59 1c59 d 7e
1c59 1c59 u 01 01
1c59 1c59 s 		LD	A,(HL)		;Fetch LED Font for HEX digit
1c5a 1c5a d e1
1c5a 1c5a u 01 01
1c5a 1c5a s 		POP	HL
1c5b 1c5b d 77
1c5b 1c5b u 01 01
1c5b 1c5b s 		LD	(HL),A		;Display HEX digit
1c5c 1c5c d 2c
1c5c 1c5c u 01 01
1c5c 1c5c s 		INC	L
1c5d 1c5d d cb9d
1c5d 1c5d u 02 01
1c5d 1c5d s 		RES	3,L
1c5f 1c5f d c9
1c5f 1c5f u 01 01
1c5f 1c5f s 		RET
1c60 1c60 s 		
1c60 1c60 d e5
1c60 1c60 u 01 01
1c60 1c60 s LED_PUT_BYTE	PUSH	HL
1c61 1c61 d 2ac8ff
1c61 1c61 u 03 01
1c61 1c61 s 		LD	HL,(LED_CURSOR)
1c64 1c64 d cd4a1c
1c64 1c64 u 03 01
1c64 1c64 s 		CALL	LED_PUT_BYTE_HL
1c67 1c67 d 22c8ff
1c67 1c67 u 03 01
1c67 1c67 s 		LD	(LED_CURSOR),HL
1c6a 1c6a d e1
1c6a 1c6a u 01 01
1c6a 1c6a s 		POP	HL
1c6b 1c6b d c9
1c6b 1c6b u 01 01
1c6b 1c6b s 		RET
1c6c 1c6c s 		
1c6c 1c6c d e5
1c6c 1c6c u 01 01
1c6c 1c6c s LED_PUT_HEX	PUSH	HL
1c6d 1c6d d 2ac8ff
1c6d 1c6d u 03 01
1c6d 1c6d s 		LD	HL,(LED_CURSOR)
1c70 1c70 d cd531c
1c70 1c70 u 03 01
1c70 1c70 s 		CALL	LED_PUT_HEX_HL
1c73 1c73 d 22c8ff
1c73 1c73 u 03 01
1c73 1c73 s 		LD	(LED_CURSOR),HL
1c76 1c76 d e1
1c76 1c76 u 01 01
1c76 1c76 s 		POP	HL
1c77 1c77 d c9
1c77 1c77 u 01 01
1c77 1c77 s 		RET
1c78 1c78 s 		
1c78 1c78 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1c78 1c78 s ;LED_PRINT -- Print A null-terminated string @(HL)
1c78 1c78 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1c78 1c78 d f5
1c78 1c78 u 01 01
1c78 1c78 s LED_PRINT:	PUSH	AF
1c79 1c79 d c5
1c79 1c79 u 01 01
1c79 1c79 s 		PUSH	BC
1c7a 1c7a d 7e
1c7a 1c7a u 01 01
1c7a 1c7a s LED_PRINT_LP	LD	A, (HL)
1c7b 1c7b d 23
1c7b 1c7b u 01 01
1c7b 1c7b s 		INC	HL
1c7c 1c7c d b7
1c7c 1c7c u 01 01
1c7c 1c7c s 		OR	A
1c7d 1c7d d 2808
1c7d 1c7d u 02 01
1c7d 1c7d s 		JR Z,	LED_PRINT_RET
1c7f 1c7f d 4f
1c7f 1c7f u 01 01
1c7f 1c7f s 		LD	C,A
1c80 1c80 d e5
1c80 1c80 u 01 01
1c80 1c80 s 		PUSH	HL
1c81 1c81 d cd8a14
1c81 1c81 u 03 01
1c81 1c81 s 		CALL	PC_LED
1c84 1c84 d e1
1c84 1c84 u 01 01
1c84 1c84 s 		POP	HL
1c85 1c85 d 18f3
1c85 1c85 u 02 01
1c85 1c85 s 		JR	LED_PRINT_LP
1c87 1c87 d c1
1c87 1c87 u 01 01
1c87 1c87 s LED_PRINT_RET	POP	BC
1c88 1c88 d f1
1c88 1c88 u 01 01
1c88 1c88 s 		POP	AF
1c89 1c89 d c9
1c89 1c89 u 01 01
1c89 1c89 s 		RET
1c8a 1c8a s 
1c8a 1c8a s 
1c8a 1c8a s 
1c8a 1c8a d cd7714
1c8a 1c8a u 03 01
1c8a 1c8a s LED_HOME_PRINTI	CALL	LED_HOME
1c8d 1c8d s 		
1c8d 1c8d s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1c8d 1c8d s ;PRINT IMMEDIATE
1c8d 1c8d s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1c8d 1c8d d e3
1c8d 1c8d u 01 01
1c8d 1c8d s LED_PRINTI:	EX	(SP),HL	;HL = Top of Stack
1c8e 1c8e d cd781c
1c8e 1c8e u 03 01
1c8e 1c8e s 		CALL	LED_PRINT
1c91 1c91 d e3
1c91 1c91 u 01 01
1c91 1c91 s 		EX	(SP),HL	;Move updated return address back to stack
1c92 1c92 d c9
1c92 1c92 u 01 01
1c92 1c92 s 		RET
1c93 1c93 s 
1c93 1c93 s 
1c93 1c93 s 
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;
1c93 1c93 s ;	Chapter_12	S D - C A R D
1c93 1c93 s ;
1c93 1c93 s ;   *******   *******                *******      ***     ********   *******  
1c93 1c93 s ;  *********  ********              *********    *****    *********  ******** 
1c93 1c93 s ;  **         **    ***             **     **   *** ***   **     **  **    ***
1c93 1c93 s ;  **         **     **             **         ***   ***  **     **  **     **
1c93 1c93 s ;   ******    **     **   ******    **         *********  ********   **     **
1c93 1c93 s ;    ******   **     **   ******    **         *********  ********   **     **
1c93 1c93 s ;         **  **     **             **         **     **  **  **     **     **
1c93 1c93 s ;         **  **    ***             **     **  **     **  **   **    **    ***
1c93 1c93 s ;  *********  ********              *********  **     **  **    **   ******** 
1c93 1c93 s ;   *******   *******                *******   **     **  **     **  *******  
1c93 1c93 s ;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1c93 1c93 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1c93 1c93 s 
1c93 1c93 s ;String equates
1c93 1c93 s 
1c93 1c93 d f3
1c93 1c93 u 01 01
1c93 1c93 s GO_SD_CARD	DI			; Disable Interrupts
1c94 1c94 s 
1c94 1c94 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1c94 1c94 s ;Init all System RAM, enable interrupts
1c94 1c94 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1c94 1c94 d 213800
1c94 1c94 u 03 01
1c94 1c94 s GSC_INIT	LD	HL,0x0038
1c97 1c97 d 113800
1c97 1c97 u 03 01
1c97 1c97 s 		LD	DE,0x0038
1c9a 1c9a d 010600
1c9a 1c9a u 03 01
1c9a 1c9a s 		LD	BC,RST38_LEN
1c9d 1c9d d edb0
1c9d 1c9d u 02 01
1c9d 1c9d s 		LDIR
1c9f 1c9f s 
1c9f 1c9f d 2180fb
1c9f 1c9f u 03 01
1c9f 1c9f s 		LD	HL,SDISKA	;Initialize New Variables for SD-CARD operation & full 64K RAM
1ca2 1ca2 d 2208ff
1ca2 1ca2 u 03 01
1ca2 1ca2 s 		LD	(FCB_PTR),HL
1ca5 1ca5 d 21f916
1ca5 1ca5 u 03 01
1ca5 1ca5 s 		LD	HL,SKIP_HALT_TEST
1ca8 1ca8 d 22d2ff
1ca8 1ca8 u 03 01
1ca8 1ca8 s 		LD	(HALT_TEST),HL
1cab 1cab s 	
1cab 1cab d cd1d0c
1cab 1cab u 03 01
1cab 1cab s 		CALL	WRITE_BLOCK
1cae 1cae d b3ff
1cae 1cae u 02 02
1cae 1cae s 		DW	ANBAR_DEF	;Where to write
1cb0 1cb0 d 1000
1cb0 1cb0 u 02 02
1cb0 1cb0 s 		DW	16		;Bytes to write
1cb2 1cb2 d 82
1cb2 1cb2 u 01 02
1cb2 1cb2 s 		DB	0x82		;(ANBAR_DEF) = RUN MODE
1cb3 1cb3 d 7c0c
1cb3 1cb3 u 02 02
1cb3 1cb3 s 		DW	GET_REG_RUN	;(GET_REG)
1cb5 1cb5 d 910c
1cb5 1cb5 u 02 02
1cb5 1cb5 s 		DW	PUT_REG_RUN	;(PUT_REG)
1cb7 1cb7 d b217
1cb7 1cb7 u 02 02
1cb7 1cb7 s 		DW	CTRL_C_RET	;(CTRL_C_CHK)
1cb9 1cb9 d e317
1cb9 1cb9 u 02 02
1cb9 1cb9 s 		DW	IDISP_RET	;(LDISPMODE)
1cbb 1cbb d e317
1cbb 1cbb u 02 02
1cbb 1cbb s 		DW	IDISP_RET	;(DISPMODE)
1cbd 1cbd d 4218
1cbd 1cbd u 02 02
1cbd 1cbd s 		DW	IMON_CMD	;(KEY_EVENT) Initialize to Command Mode
1cbf 1cbf d 01
1cbf 1cbf u 01 02
1cbf 1cbf s 		DB	1		;(IK_TIMER)
1cc0 1cc0 d 90
1cc0 1cc0 u 01 02
1cc0 1cc0 s 		DB	0x90		;(KEYBFMODE) HEX Keyboard Mode (F on release)
1cc1 1cc1 d ff
1cc1 1cc1 u 01 02
1cc1 1cc1 s 		DB	0xFF		;(DISPLABEL)
1cc2 1cc2 s 
1cc2 1cc2 d fb
1cc2 1cc2 u 01 01
1cc2 1cc2 s 		EI			;************** Interrupts ON!!!!
1cc3 1cc3 s 
1cc3 1cc3 d cd8a1c
1cc3 1cc3 u 03 01
1cc3 1cc3 s 		CALL	LED_HOME_PRINTI
1cc6 1cc6 d 53642d4341524400
1cc6 1cc6 u 08 02
1cc6 1cc6 s 		DB	"Sd-CARD",EOS
1cce 1cce s 		
1cce 1cce d cddc22
1cce 1cce u 03 01
1cce 1cce s 		CALL	INIT_FAT
1cd1 1cd1 d c0
1cd1 1cd1 u 01 01
1cd1 1cd1 s 		RET	NZ		;RETURN IF FAILED
1cd2 1cd2 s 
1cd2 1cd2 d cd1f0e
1cd2 1cd2 u 03 01
1cd2 1cd2 s 		CALL	PUT_NEW_LINE
1cd5 1cd5 s 		
1cd5 1cd5 d 3ec0
1cd5 1cd5 u 02 01
1cd5 1cd5 s 		LD	A,0xC0
1cd7 1cd7 d 320cff
1cd7 1cd7 u 03 01
1cd7 1cd7 s 		LD	(VIEW_FLAGS),A	;View File open/not status & Size
1cda 1cda s 
1cda 1cda s 					;Filename will be preloaded on auto run
1cda 1cda d 3a43ff
1cda 1cda u 03 01
1cda 1cda s 		LD	A,(FILENAME)	;Check for any Auto Run
1cdd 1cdd d b7
1cdd 1cdd u 01 01
1cdd 1cdd s 		OR	A
1cde 1cde d 2808
1cde 1cde u 02 01
1cde 1cde s 		JR   Z,	SDC_MENU
1ce0 1ce0 s 		
1ce0 1ce0 d cda91d
1ce0 1ce0 u 03 01
1ce0 1ce0 s 		CALL	SD_OPEN_FILENAME
1ce3 1ce3 d 2803
1ce3 1ce3 u 02 01
1ce3 1ce3 s 		JR Z,	SDC_MENU	;Jump if file not found
1ce5 1ce5 d cdc31e
1ce5 1ce5 u 03 01
1ce5 1ce5 s 		CALL	READ_HEX_EXEC	;Read & Execute HEX file, Return if Error
1ce8 1ce8 s 
1ce8 1ce8 s ;----------------------------------------------------------------------------------------------------; SD MENU
1ce8 1ce8 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1ce8 1ce8 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1ce8 1ce8 s ;----------------------------------------------------------------------------------------------------; SD MENU
1ce8 1ce8 s 
1ce8 1ce8 d cdca0d
1ce8 1ce8 u 03 01
1ce8 1ce8 s SDC_MENU:	CALL	PRINTI		;Monitor Start, Display Welcome Message
1ceb 1ceb d 0d0a
1ceb 1ceb u 02 02
1ceb 1ceb s 		DB	CR,LF
1ced 1ced d 4c20202020202020202020202020204c4953542046494c45530d0a
1ced 1ced u 1b 02
1ced 1ced s 		DB	"L              LIST FILES",CR,LF
1d08 1d08 d 5720202020202020202020202020205749544e455353204c4f41440d0a
1d08 1d08 u 1d 02
1d08 1d08 s 		DB	"W              WITNESS LOAD",CR,LF
1d25 1d25 d 3f203e00
1d25 1d25 u 04 02
1d25 1d25 s 		DB	"? >",EOS
1d29 1d29 s 
1d29 1d29 d cde013
1d29 1d29 u 03 01
1d29 1d29 s 		CALL 	GET_CHAR	;get char
1d2c 1d2c d fe1b
1d2c 1d2c u 02 01
1d2c 1d2c s 		CP	27
1d2e 1d2e d c8
1d2e 1d2e u 01 01
1d2e 1d2e s 		RET	Z		;MAIN MENU
1d2f 1d2f d e65f
1d2f 1d2f u 02 01
1d2f 1d2f s 		AND 	0x5F		;to upper case
1d31 1d31 d fe4c
1d31 1d31 u 02 01
1d31 1d31 s 		CP	'L'
1d33 1d33 d 2815
1d33 1d33 u 02 01
1d33 1d33 s 		JR Z,	DO_DIR		; L = List Files
1d35 1d35 d fe57
1d35 1d35 u 02 01
1d35 1d35 s 		CP	'W'
1d37 1d37 d 2802
1d37 1d37 u 02 01
1d37 1d37 s 		JR Z,	BOOT_SDVIEW	; W = Witness Load
1d39 1d39 d 18ad
1d39 1d39 u 02 01
1d39 1d39 s 		JR	SDC_MENU	
1d3b 1d3b s 
1d3b 1d3b s ;=============================================================================
1d3b 1d3b d 210cff
1d3b 1d3b u 03 01
1d3b 1d3b s BOOT_SDVIEW	LD	HL,VIEW_FLAGS	;BIT .0=View HEX Load
1d3e 1d3e d cbc6
1d3e 1d3e u 02 01
1d3e 1d3e s 		SET	0,(HL)
1d40 1d40 d cdca0d
1d40 1d40 u 03 01
1d40 1d40 s 		CALL 	PRINTI
1d43 1d43 d 202d4f4e00
1d43 1d43 u 05 02
1d43 1d43 s 		DB	" -ON",EOS
1d48 1d48 d 189e
1d48 1d48 u 02 01
1d48 1d48 s 		JR	SDC_MENU	
1d4a 1d4a s 			
1d4a 1d4a s ;=============================================================================
1d4a 1d4a d cd5e1d
1d4a 1d4a u 03 01
1d4a 1d4a s DO_DIR		CALL	PRINT_DIR
1d4d 1d4d d cd2a21
1d4d 1d4d u 03 01
1d4d 1d4d s 		CALL	INPUT_FILENAME
1d50 1d50 d d8
1d50 1d50 u 01 01
1d50 1d50 s 		RET	C		;Return to Menu if <Esc>
1d51 1d51 d cd1f0e
1d51 1d51 u 03 01
1d51 1d51 s 		CALL	PUT_NEW_LINE
1d54 1d54 d cda91d
1d54 1d54 u 03 01
1d54 1d54 s 		CALL	SD_OPEN_FILENAME
1d57 1d57 d 28f1
1d57 1d57 u 02 01
1d57 1d57 s 		JR Z,	DO_DIR		;Jump if file not found
1d59 1d59 d cdc31e
1d59 1d59 u 03 01
1d59 1d59 s 		CALL	READ_HEX_EXEC	;Read & Execute HEX file, Return if Error
1d5c 1d5c d 18ec
1d5c 1d5c u 02 01
1d5c 1d5c s 		JR	DO_DIR
1d5e 1d5e s 
1d5e 1d5e s 
1d5e 1d5e s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1d5e 1d5e s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1d5e 1d5e s ;	Chapter_13	FILE operations
1d5e 1d5e s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1d5e 1d5e s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1d5e 1d5e s 
1d5e 1d5e s ;=============================================================================
1d5e 1d5e s ;		Destroys A,B,C,IX
1d5e 1d5e s ;-----------------------------------------------------------------------------
1d5e 1d5e d cdca0d
1d5e 1d5e u 03 01
1d5e 1d5e s PRINT_DIR	CALL	PRINTI
1d61 1d61 d 0d0a5c4449524543544f52593a0d0a00
1d61 1d61 u 10 02
1d61 1d61 s 		DB CR,LF,"\DIRECTORY:",CR,LF,EOS
1d71 1d71 d cdcb20
1d71 1d71 u 03 01
1d71 1d71 s 		CALL	SD_LDIR1
1d74 1d74 d c8
1d74 1d74 u 01 01
1d74 1d74 s SDLF_LP 	RET	Z			;End of list
1d75 1d75 d 7e
1d75 1d75 u 01 01
1d75 1d75 s 		LD	A,(HL)
1d76 1d76 d fe21
1d76 1d76 u 02 01
1d76 1d76 s 		CP	33
1d78 1d78 d faa41d
1d78 1d78 u 03 01
1d78 1d78 s 		JP M,	DD_NEXT
1d7b 1d7b d fe7f
1d7b 1d7b u 02 01
1d7b 1d7b s 		CP	127
1d7d 1d7d d f2a41d
1d7d 1d7d u 03 01
1d7d 1d7d s 		JP P,	DD_NEXT
1d80 1d80 d e5
1d80 1d80 u 01 01
1d80 1d80 s 		PUSH	HL			;Test if starting cluster is 0, skip file
1d81 1d81 d dde1
1d81 1d81 u 02 01
1d81 1d81 s 		POP	IX
1d83 1d83 d dd7e1a
1d83 1d83 u 03 01
1d83 1d83 s 		LD	A,(IX+1Ah)
1d86 1d86 d ddb61b
1d86 1d86 u 03 01
1d86 1d86 s 		OR	(IX+1Bh)
1d89 1d89 d caa41d
1d89 1d89 u 03 01
1d89 1d89 s 		JP Z,	DD_NEXT
1d8c 1d8c s 
1d8c 1d8c d cd0521
1d8c 1d8c u 03 01
1d8c 1d8c s 		CALL	PRINT_FILENAME
1d8f 1d8f s 		
1d8f 1d8f d cdcd13
1d8f 1d8f u 03 01
1d8f 1d8f s 		CALL	GET_POS		;Get output position (counted characters after CR)
1d92 1d92 d fe40
1d92 1d92 u 02 01
1d92 1d92 s 		CP	64
1d94 1d94 d f41f0e
1d94 1d94 u 03 01
1d94 1d94 s 		CALL P,	PUT_NEW_LINE
1d97 1d97 d cdcd13
1d97 1d97 u 03 01
1d97 1d97 s DD_TAB_LP	CALL	GET_POS		;TAB OUT 16 CHARS
1d9a 1d9a d e60f
1d9a 1d9a u 02 01
1d9a 1d9a s 		AND	0Fh
1d9c 1d9c d caa41d
1d9c 1d9c u 03 01
1d9c 1d9c s 		JP Z,	DD_NEXT
1d9f 1d9f d cd190e
1d9f 1d9f u 03 01
1d9f 1d9f s 		CALL	PUT_SPACE
1da2 1da2 d 18f3
1da2 1da2 u 02 01
1da2 1da2 s 		JR	DD_TAB_LP
1da4 1da4 s 
1da4 1da4 d cde020
1da4 1da4 u 03 01
1da4 1da4 s DD_NEXT		CALL	SD_LDIRN
1da7 1da7 d 18cb
1da7 1da7 u 02 01
1da7 1da7 s 		JR	SDLF_LP
1da9 1da9 s 
1da9 1da9 s 
1da9 1da9 s ;=============================================================================
1da9 1da9 s ;Open File	Enter with FILENAME set and FCB_PTR set to desired FCB
1da9 1da9 s ;		EXIT Z=1 If File Not Found
1da9 1da9 s ;-----------------------------------------------------------------------------
1da9 1da9 d 2a08ff
1da9 1da9 u 03 01
1da9 1da9 s SD_OPEN_FILENAME LD	HL,(FCB_PTR)
1dac 1dac d 23
1dac 1dac u 01 01
1dac 1dac s 		INC	HL		;+1 = FNAME
1dad 1dad d eb
1dad 1dad u 01 01
1dad 1dad s 		EX	DE,HL		
1dae 1dae d 2143ff
1dae 1dae u 03 01
1dae 1dae s 		LD	HL,FILENAME	;Write FILENAME to FCB
1db1 1db1 d 010b00
1db1 1db1 u 03 01
1db1 1db1 s 		LD	BC,11
1db4 1db4 d edb0
1db4 1db4 u 02 01
1db4 1db4 s 		LDIR
1db6 1db6 s 
1db6 1db6 s ;=============================================================================
1db6 1db6 s ;Open File	Enter with FCB_PTR set to desired FCB
1db6 1db6 s ;		EXIT Z=1 If File Not Found
1db6 1db6 s ;-----------------------------------------------------------------------------
1db6 1db6 d 2a08ff
1db6 1db6 u 03 01
1db6 1db6 s SD_OPEN		LD	HL,(FCB_PTR)
1db9 1db9 d 3600
1db9 1db9 u 02 01
1db9 1db9 s 		LD	(HL),0		;FSTAT=0, Clear Open Status
1dbb 1dbb d 23
1dbb 1dbb u 01 01
1dbb 1dbb s 		INC	HL		;+1 = FNAME
1dbc 1dbc d 1143ff
1dbc 1dbc u 03 01
1dbc 1dbc s 		LD	DE,FILENAME	;Write FCB Name to FILENAME
1dbf 1dbf d 010b00
1dbf 1dbf u 03 01
1dbf 1dbf s 		LD	BC,11
1dc2 1dc2 d edb0
1dc2 1dc2 u 02 01
1dc2 1dc2 s 		LDIR		
1dc4 1dc4 d cd8b20
1dc4 1dc4 u 03 01
1dc4 1dc4 s 		CALL	SDV_FIND_FILE	;HL = Directory Entry  ;PRINT FILE NAME, FOUND OR NOT
1dc7 1dc7 d c8
1dc7 1dc7 u 01 01
1dc7 1dc7 s 		RET	Z		;Exit if file not found
1dc8 1dc8 s 
1dc8 1dc8 s ;FAT-16 Directory Entry
1dc8 1dc8 s ; 46 44 49 53 4b 20 20 20 45 58 45 20 00 00 00 00  FDISK   .EXE
1dc8 1dc8 s ; 00 00 00 00 00 00 36 59 62 1b 02 00 17 73 00 00
1dc8 1dc8 s ;
1dc8 1dc8 s ;Bytes   Content
1dc8 1dc8 s ;0-10    File name (8 bytes) with extension (3 bytes)
1dc8 1dc8 s ;11      Attribute - a bitvector. Bit 0: read only. Bit 1: hidden.
1dc8 1dc8 s ;        Bit 2: system file. Bit 3: volume label. Bit 4: subdirectory.
1dc8 1dc8 s ;        Bit 5: archive. Bits 6-7: unused.
1dc8 1dc8 s ;12-21   Reserved (see below)
1dc8 1dc8 s ;22-23   Time (5/6/5 bits, for hour/minutes/doubleseconds)
1dc8 1dc8 s ;24-25   Date (7/4/5 bits, for year-since-1980/month/day)
1dc8 1dc8 s ;26-27   Starting cluster (0 for an empty file)
1dc8 1dc8 s ;28-31   Filesize in bytes
1dc8 1dc8 s ;
1dc8 1dc8 s ;Z80MC FCB
1dc8 1dc8 s ;
1dc8 1dc8 s ;SDFCB:
1dc8 1dc8 s ;FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
1dc8 1dc8 s ;FNAME		EQU	1	;DS 11	;+1  File name
1dc8 1dc8 s ;AFClus0	EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
1dc8 1dc8 s ;CRFClus (FFFF)	EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
1dc8 1dc8 s ;CAFClus (FFFF)	EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
1dc8 1dc8 s ;RFSec	 (FFFF)	EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
1dc8 1dc8 s ;SSOC	 (FF's)	EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
1dc8 1dc8 s ;ABS_SEC (FF's)	EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
1dc8 1dc8 s ;FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)
1dc8 1dc8 s 
1dc8 1dc8 s 
1dc8 1dc8 d e5
1dc8 1dc8 u 01 01
1dc8 1dc8 s SDO_DO		PUSH	HL		;HL Points to FAT Directory Entry
1dc9 1dc9 d 011c00
1dc9 1dc9 u 03 01
1dc9 1dc9 s 		LD	BC,1Ch		;File Size Offset (into Directory Entry)
1dcc 1dcc d 09
1dcc 1dcc u 01 01
1dcc 1dcc s 		ADD	HL,BC
1dcd 1dcd d eb
1dcd 1dcd u 01 01
1dcd 1dcd s 		EX	DE,HL
1dce 1dce d 2a08ff
1dce 1dce u 03 01
1dce 1dce s 		LD	HL,(FCB_PTR)	;HL=FCB
1dd1 1dd1 d 09
1dd1 1dd1 u 01 01
1dd1 1dd1 s 		ADD	HL,BC		;1C is also the offset for FSIZE
1dd2 1dd2 d e5
1dd2 1dd2 u 01 01
1dd2 1dd2 s 		PUSH	HL
1dd3 1dd3 d eb
1dd3 1dd3 u 01 01
1dd3 1dd3 s 		EX	DE,HL
1dd4 1dd4 d cd3e27
1dd4 1dd4 u 03 01
1dd4 1dd4 s 		CALL	MOV_32_HL	;Move (HL) to 32 bit register BCDE, Fetch File Size
1dd7 1dd7 d 214eff
1dd7 1dd7 u 03 01
1dd7 1dd7 s 		LD	HL,FILESIZE
1dda 1dda d cd4927
1dda 1dda u 03 01
1dda 1dda s 		CALL	MOV_HL_32	;Save 32 bits to RAM at HL (FILESIZE)
1ddd 1ddd d e1
1ddd 1ddd u 01 01
1ddd 1ddd s 		POP	HL		;HL = FCB.FSIZE
1dde 1dde d cd4927
1dde 1dde u 03 01
1dde 1dde s 		CALL	MOV_HL_32	;Save 32 bits to RAM at HL (FCB)
1de1 1de1 d e1
1de1 1de1 u 01 01
1de1 1de1 s 		POP	HL
1de2 1de2 s 
1de2 1de2 d 011a00
1de2 1de2 u 03 01
1de2 1de2 s 		LD	BC,1Ah		;H=(START CLUSTER)
1de5 1de5 d 09
1de5 1de5 u 01 01
1de5 1de5 s 		ADD	HL,BC
1de6 1de6 d cd4a0e
1de6 1de6 u 03 01
1de6 1de6 s 		CALL	LD_HL_HL	;Fetch Starting Custer
1de9 1de9 d eb
1de9 1de9 u 01 01
1de9 1de9 s 		EX	DE, HL		;DE=Starting Cluster
1dea 1dea d 2a08ff
1dea 1dea u 03 01
1dea 1dea s 		LD	HL,(FCB_PTR)	;HL=FCB
1ded 1ded d 3601
1ded 1ded u 02 01
1ded 1ded s 		LD	(HL),1		;FSTAT=1
1def 1def d 010c00
1def 1def u 03 01
1def 1def s 		LD	BC,AFClus0 	;offset to AFClus0
1df2 1df2 d 09
1df2 1df2 u 01 01
1df2 1df2 s 		ADD	HL,BC
1df3 1df3 d 73
1df3 1df3 u 01 01
1df3 1df3 s 		LD	(HL),E		;Save Starting Cluster
1df4 1df4 d 23
1df4 1df4 u 01 01
1df4 1df4 s 		INC	HL
1df5 1df5 d 72
1df5 1df5 u 01 01
1df5 1df5 s 		LD	(HL),D
1df6 1df6 d 23
1df6 1df6 u 01 01
1df6 1df6 s 		INC	HL
1df7 1df7 d 060e
1df7 1df7 u 02 01
1df7 1df7 s 		LD	B,14
1df9 1df9 d 3eff
1df9 1df9 u 02 01
1df9 1df9 s 		LD	A,0FFH
1dfb 1dfb d cd160c
1dfb 1dfb u 03 01
1dfb 1dfb s 		CALL	FILL_BLOCK	;Fill 14 bytes of FF (Nuke pointers to force new calculations)
1dfe 1dfe s 		
1dfe 1dfe d 3a0cff
1dfe 1dfe u 03 01
1dfe 1dfe s 		LD	A,(VIEW_FLAGS)	;BIT .0=View HEX Load, .6=FILE SIZE
1e01 1e01 d cb77
1e01 1e01 u 02 01
1e01 1e01 s 		BIT	6,A
1e03 1e03 d 281d
1e03 1e03 u 02 01
1e03 1e03 s 		JR  Z,	SDO_RET
1e05 1e05 s 		
1e05 1e05 d cdca0d
1e05 1e05 u 03 01
1e05 1e05 s 		CALL	PRINTI
1e08 1e08 d 2046494c452053495a453d307800
1e08 1e08 u 0e 02
1e08 1e08 s 		DB 	" FILE SIZE=0x",EOS
1e16 1e16 d 2a50ff
1e16 1e16 u 03 01
1e16 1e16 s 		LD	HL, (FILESIZE+2)
1e19 1e19 d cdea0d
1e19 1e19 u 03 01
1e19 1e19 s 		CALL	PUT_HL
1e1c 1e1c d 2a4eff
1e1c 1e1c u 03 01
1e1c 1e1c s 		LD	HL, (FILESIZE)
1e1f 1e1f d cdea0d
1e1f 1e1f u 03 01
1e1f 1e1f s 		CALL	PUT_HL
1e22 1e22 s 					
1e22 1e22 d 2a08ff
1e22 1e22 u 03 01
1e22 1e22 s SDO_RET		LD	HL,(FCB_PTR)	;HL=FCB
1e25 1e25 d f6ff
1e25 1e25 u 02 01
1e25 1e25 s 		OR	0FFh		;Clear Z
1e27 1e27 d c9
1e27 1e27 u 01 01
1e27 1e27 s 		RET
1e28 1e28 s 		
1e28 1e28 s 
1e28 1e28 s ;=============================================================================
1e28 1e28 s ;LINE INPUT	Enter with FCB_PTR set to desired FCB
1e28 1e28 s ;		(Recently opened so pointers will be initialized)
1e28 1e28 s ;		if Relative Cluster = 0xFFFF (new open), pointer will init to start of file.
1e28 1e28 s ;		Output Z=1 if EOF, HL=FCB_PTR
1e28 1e28 s ;		Z=0, HL=Pointer to Line Buffer
1e28 1e28 s ;		BC, DE nuked
1e28 1e28 s ;		LOGICAL_SEC is used/nuked
1e28 1e28 s ;-----------------------------------------------------------------------------
1e28 1e28 d 2a08ff
1e28 1e28 u 03 01
1e28 1e28 s LINE_INPUT	LD	HL,(FCB_PTR)	;Test FSTAT for EOF, marked in FCB Status
1e2b 1e2b d cb7e
1e2b 1e2b u 02 01
1e2b 1e2b s 		BIT	7,(HL)
1e2d 1e2d d c0
1e2d 1e2d u 01 01
1e2d 1e2d s 		RET	NZ		;Exit if EOF
1e2e 1e2e s 					;Test for newly opened file
1e2e 1e2e d 010e00
1e2e 1e2e u 03 01
1e2e 1e2e s 		LD	BC,14		; check Current Relative Cluster <> FFFF
1e31 1e31 d 09
1e31 1e31 u 01 01
1e31 1e31 s 		ADD	HL,BC
1e32 1e32 d 3eff
1e32 1e32 u 02 01
1e32 1e32 s 		LD	A,0xFF
1e34 1e34 d be
1e34 1e34 u 01 01
1e34 1e34 s 		CP	(HL)
1e35 1e35 d 201f
1e35 1e35 u 02 01
1e35 1e35 s 		JR NZ,	LI_TP		;Jump if file was read from
1e37 1e37 d 23
1e37 1e37 u 01 01
1e37 1e37 s 		INC	HL
1e38 1e38 d be
1e38 1e38 u 01 01
1e38 1e38 s 		CP	(HL)
1e39 1e39 d 201b
1e39 1e39 u 02 01
1e39 1e39 s 		JR NZ,	LI_TP		;Jump if file was read from
1e3b 1e3b s 					;File has not yet been read...
1e3b 1e3b d 010d00
1e3b 1e3b u 03 01
1e3b 1e3b s 		LD	BC, 28-15	;Advance to File Size
1e3e 1e3e d 09
1e3e 1e3e u 01 01
1e3e 1e3e s 		ADD	HL,BC
1e3f 1e3f d 1182fa
1e3f 1e3f u 03 01
1e3f 1e3f s 		LD	DE,LI_FILESIZE	;Init LI_FILESIZE with max count of bytes to read
1e42 1e42 d 010400
1e42 1e42 u 03 01
1e42 1e42 s 		LD	BC,4
1e45 1e45 d edb0
1e45 1e45 u 02 01
1e45 1e45 s 		LDIR			;Copy File Size to Byte counter
1e47 1e47 s 
1e47 1e47 d 210000
1e47 1e47 u 03 01
1e47 1e47 s 		LD	HL,0		;Start at first Logical Sector
1e4a 1e4a d 2288fa
1e4a 1e4a u 03 01
1e4a 1e4a s 		LD	(LI_SDLOG_SEC),HL
1e4d 1e4d d 220dff
1e4d 1e4d u 03 01
1e4d 1e4d s 		LD	(LOGICAL_SEC),HL
1e50 1e50 s 					;FCB_PTR = FILE TO READ
1e50 1e50 d cd8821
1e50 1e50 u 03 01
1e50 1e50 s 		CALL	DISK_READ	;HL=BUFF
1e53 1e53 d 2286fa
1e53 1e53 u 03 01
1e53 1e53 s 		LD	(LI_SDBUFF_PTR),HL	;Save Disk Buffer pointer
1e56 1e56 s 		
1e56 1e56 d cdba1e
1e56 1e56 u 03 01
1e56 1e56 s LI_TP		CALL	CLEAR_LINE_BUFF
1e59 1e59 s 
1e59 1e59 d ed4b82fa
1e59 1e59 u 04 01
1e59 1e59 s 		LD	BC,(LI_FILESIZE) ;Low 16bits of Filesize counter (32bit)
1e5d 1e5d d 1100fa
1e5d 1e5d u 03 01
1e5d 1e5d s 		LD	DE, LINE_BUFF	;Data desination @DE
1e60 1e60 d 2a86fa
1e60 1e60 u 03 01
1e60 1e60 s 		LD	HL,(LI_SDBUFF_PTR) ;Data source (SD BUFFER)
1e63 1e63 s 
1e63 1e63 d cda21e
1e63 1e63 u 03 01
1e63 1e63 s LI_LP		CALL	LI_GETDATA	;Fetch byte from SD_RAMBUFFER @HL
1e66 1e66 s 					;Advances to read next logical sector if HL>BUFF_SIZE
1e66 1e66 s 		
1e66 1e66 d eda0
1e66 1e66 u 02 01
1e66 1e66 s LI_1		LDI			;COPY A BYTE.  (DE)=(HL), INC HL, INC DE, DEC BC
1e68 1e68 d ea811e
1e68 1e68 u 03 01
1e68 1e68 s 		JP PE,	LI_2		;Jump if BC>0, Not at End of File possible
1e6b 1e6b s 		
1e6b 1e6b s 					;BC=0
1e6b 1e6b d e5
1e6b 1e6b u 01 01
1e6b 1e6b s 		PUSH	HL		
1e6c 1e6c d 2a84fa
1e6c 1e6c u 03 01
1e6c 1e6c s 		LD	HL,(LI_FILESIZE+2) ;Check upper 32 bits for 0 or decrement size.
1e6f 1e6f d 37
1e6f 1e6f u 01 01
1e6f 1e6f s 		SCF
1e70 1e70 d ed42
1e70 1e70 u 02 01
1e70 1e70 s 		SBC	HL,BC		;HL=HL-0000-1 (HL=HL-1 with *Borrow*)
1e72 1e72 d 3009
1e72 1e72 u 02 01
1e72 1e72 s 		JR NC,	LI_1B
1e74 1e74 d eb
1e74 1e74 u 01 01
1e74 1e74 s 		EX	DE,HL
1e75 1e75 d 2a08ff
1e75 1e75 u 03 01
1e75 1e75 s 		LD	HL,(FCB_PTR)
1e78 1e78 d cbfe
1e78 1e78 u 02 01
1e78 1e78 s 		SET	7,(HL)		;SET FSTAT EOF FLAG
1e7a 1e7a d e1
1e7a 1e7a u 01 01
1e7a 1e7a s 		POP	HL
1e7b 1e7b d 1819
1e7b 1e7b u 02 01
1e7b 1e7b s 		JR	LI_EOL
1e7d 1e7d s 		
1e7d 1e7d s 		
1e7d 1e7d d 2284fa
1e7d 1e7d u 03 01
1e7d 1e7d s LI_1B		LD	(LI_FILESIZE+2),HL
1e80 1e80 d e1
1e80 1e80 u 01 01
1e80 1e80 s 		POP	HL
1e81 1e81 s 	
1e81 1e81 d fe0d
1e81 1e81 u 02 01
1e81 1e81 s LI_2		CP	CR		;Test for CR
1e83 1e83 d 2008
1e83 1e83 u 02 01
1e83 1e83 s 		JR NZ,	LI_3
1e85 1e85 s 					;If CR, check if next char is LF
1e85 1e85 d cda21e
1e85 1e85 u 03 01
1e85 1e85 s 		CALL	LI_GETDATA	;Look ahead to next char
1e88 1e88 d fe0a
1e88 1e88 u 02 01
1e88 1e88 s 		CP	LF
1e8a 1e8a d 200a
1e8a 1e8a u 02 01
1e8a 1e8a s 		JR NZ,	LI_EOL		;NO LF? Consider the CR as EOL
1e8c 1e8c d 3c
1e8c 1e8c u 01 01
1e8c 1e8c s 		INC	A		;Nuke the LF
1e8d 1e8d s 			
1e8d 1e8d d fe0a
1e8d 1e8d u 02 01
1e8d 1e8d s LI_3		CP	LF		;Test if LF
1e8f 1e8f d 2805
1e8f 1e8f u 02 01
1e8f 1e8f s 		JR Z,	LI_EOL		;Jump if LF char copied
1e91 1e91 d 3e80
1e91 1e91 u 02 01
1e91 1e91 s LI_4		LD	A,LOW LINE_BUFFEND
1e93 1e93 d bb
1e93 1e93 u 01 01
1e93 1e93 s 		CP	E
1e94 1e94 d 20cd
1e94 1e94 u 02 01
1e94 1e94 s 		JR NZ,	LI_LP
1e96 1e96 s 
1e96 1e96 d 2286fa
1e96 1e96 u 03 01
1e96 1e96 s LI_EOL		LD	(LI_SDBUFF_PTR),HL	;Save SD_READ_BUFFER POINTER for next line
1e99 1e99 d ed4382fa
1e99 1e99 u 04 01
1e99 1e99 s 		LD	(LI_FILESIZE),BC ;Save count down for next line
1e9d 1e9d d 2100fa
1e9d 1e9d u 03 01
1e9d 1e9d s 		LD	HL, LINE_BUFF	;Return with HL=LINE_BUFF
1ea0 1ea0 d af
1ea0 1ea0 u 01 01
1ea0 1ea0 s 		XOR	A		;Z=1
1ea1 1ea1 d c9
1ea1 1ea1 u 01 01
1ea1 1ea1 s 		RET
1ea2 1ea2 s 
1ea2 1ea2 d 7c
1ea2 1ea2 u 01 01
1ea2 1ea2 s LI_GETDATA	LD	A,H		;Check for SD buffer over bounds
1ea3 1ea3 d fefe
1ea3 1ea3 u 02 01
1ea3 1ea3 s 		CP	HIGH (SD_RAM_BUFFER + 0x200)
1ea5 1ea5 d 7e
1ea5 1ea5 u 01 01
1ea5 1ea5 s 		LD	A,(HL)
1ea6 1ea6 d c0
1ea6 1ea6 u 01 01
1ea6 1ea6 s 		RET	NZ
1ea7 1ea7 d 2a88fa
1ea7 1ea7 u 03 01
1ea7 1ea7 s 		LD	HL,(LI_SDLOG_SEC) ;Read next 512 sector from file
1eaa 1eaa d 23
1eaa 1eaa u 01 01
1eaa 1eaa s 		INC	HL
1eab 1eab d 2288fa
1eab 1eab u 03 01
1eab 1eab s 		LD	(LI_SDLOG_SEC),HL
1eae 1eae d 220dff
1eae 1eae u 03 01
1eae 1eae s 		LD	(LOGICAL_SEC),HL
1eb1 1eb1 d c5
1eb1 1eb1 u 01 01
1eb1 1eb1 s 		PUSH	BC
1eb2 1eb2 d d5
1eb2 1eb2 u 01 01
1eb2 1eb2 s 		PUSH	DE
1eb3 1eb3 d cd8821
1eb3 1eb3 u 03 01
1eb3 1eb3 s 		CALL	DISK_READ	;HL=BUFF
1eb6 1eb6 d d1
1eb6 1eb6 u 01 01
1eb6 1eb6 s 		POP	DE
1eb7 1eb7 d c1
1eb7 1eb7 u 01 01
1eb7 1eb7 s 		POP	BC
1eb8 1eb8 d 7e
1eb8 1eb8 u 01 01
1eb8 1eb8 s 		LD	A,(HL)
1eb9 1eb9 d c9
1eb9 1eb9 u 01 01
1eb9 1eb9 s 		RET
1eba 1eba s 
1eba 1eba d 2100fa
1eba 1eba u 03 01
1eba 1eba s CLEAR_LINE_BUFF	LD	HL,LINE_BUFF	;Clear LINE_BUFF
1ebd 1ebd d 0682
1ebd 1ebd u 02 01
1ebd 1ebd s 		LD	B, LOW (LINE_BUFFEND - LINE_BUFF) +2
1ebf 1ebf d cd100c
1ebf 1ebf u 03 01
1ebf 1ebf s 		CALL	CLEAR_BLOCK	;LINE FULL OF EOS
1ec2 1ec2 d c9
1ec2 1ec2 u 01 01
1ec2 1ec2 s 		RET
1ec3 1ec3 s 
1ec3 1ec3 s ;=============================================================================
1ec3 1ec3 s ;	Read a HEX file and execute it
1ec3 1ec3 s ;-----------------------------------------------------------------------------
1ec3 1ec3 d 21281e
1ec3 1ec3 u 03 01
1ec3 1ec3 s READ_HEX_EXEC	LD	HL,LINE_INPUT
1ec6 1ec6 d 225bff
1ec6 1ec6 u 03 01
1ec6 1ec6 s 		LD	(HEX_SOURCE),HL
1ec9 1ec9 s 
1ec9 1ec9 d cdf41e
1ec9 1ec9 u 03 01
1ec9 1ec9 s 		CALL	READ_HEX_FILE
1ecc 1ecc d d8
1ecc 1ecc u 01 01
1ecc 1ecc s 		RET	C		;CY=1 ERROR encountered
1ecd 1ecd s 
1ecd 1ecd d 3a0cff
1ecd 1ecd u 03 01
1ecd 1ecd s 		LD	A, (VIEW_FLAGS)	;When veiwing load, prompt EXECUTE
1ed0 1ed0 d 0f
1ed0 1ed0 u 01 01
1ed0 1ed0 s 		RRCA
1ed1 1ed1 d d23220
1ed1 1ed1 u 03 01
1ed1 1ed1 s 		JP  NC,	GH_EXEC
1ed4 1ed4 s 
1ed4 1ed4 d cdca0d
1ed4 1ed4 u 03 01
1ed4 1ed4 s 		CALL	PRINTI		;End of File Reached
1ed7 1ed7 d 0d0a2d454f462d
1ed7 1ed7 u 07 02
1ed7 1ed7 s 		DB CR,LF,"-EOF-"
1ede 1ede d 0d0a457865637574653f00
1ede 1ede u 0b 02
1ede 1ede s 		DB CR,LF,"Execute?",EOS
1ee9 1ee9 s 		
1ee9 1ee9 d cde013
1ee9 1ee9 u 03 01
1ee9 1ee9 s 		CALL	GET_CHAR
1eec 1eec d e65f
1eec 1eec u 02 01
1eec 1eec s 		AND 	0x5F		;to upper case
1eee 1eee d fe59
1eee 1eee u 02 01
1eee 1eee s 		CP	'Y'
1ef0 1ef0 d ca3220
1ef0 1ef0 u 03 01
1ef0 1ef0 s 		JP Z,	GH_EXEC
1ef3 1ef3 d c9
1ef3 1ef3 u 01 01
1ef3 1ef3 s 		RET	
1ef4 1ef4 s 
1ef4 1ef4 s 
1ef4 1ef4 s 
1ef4 1ef4 s ;=============================================================================
1ef4 1ef4 s ;	Read a HEX file
1ef4 1ef4 s ;Input:	HEX_SOURCE must point to the routine that will fill LINE_BUFF with the next line
1ef4 1ef4 s ;Output	CY=1 ERROR encountered,  Z=0 Time Out
1ef4 1ef4 s ;-----------------------------------------------------------------------------
1ef4 1ef4 d cd8a1c
1ef4 1ef4 u 03 01
1ef4 1ef4 s READ_HEX_FILE	CALL	LED_HOME_PRINTI
1ef7 1ef7 d 464c2000
1ef7 1ef7 u 04 02
1ef7 1ef7 s 		DB	'FL ',EOS
1efb 1efb d 210000
1efb 1efb u 03 01
1efb 1efb s 		LD	HL, 0		;Zero Line Counter
1efe 1efe d 228afa
1efe 1efe u 03 01
1efe 1efe s 		LD	(RHF_LINES),HL
1f01 1f01 s 		
1f01 1f01 s 
1f01 1f01 d 2a5bff
1f01 1f01 u 03 01
1f01 1f01 s RHF_LOOP	LD	HL,(HEX_SOURCE)
1f04 1f04 d cda00c
1f04 1f04 u 03 01
1f04 1f04 s 		CALL	VCALL_HL	;JP	(HL)
1f07 1f07 d 37
1f07 1f07 u 01 01
1f07 1f07 s 		SCF
1f08 1f08 d 3f
1f08 1f08 u 01 01
1f08 1f08 s 		CCF			;CY=0
1f09 1f09 d c0
1f09 1f09 u 01 01
1f09 1f09 s 		RET	NZ		;Exit if Z=1 (End of File or Serial Time Out)
1f0a 1f0a s 				
1f0a 1f0a d 2a8afa
1f0a 1f0a u 03 01
1f0a 1f0a s 		LD	HL, (RHF_LINES)	;Increment Line Counter
1f0d 1f0d d 23
1f0d 1f0d u 01 01
1f0d 1f0d s 		INC	HL
1f0e 1f0e d 228afa
1f0e 1f0e u 03 01
1f0e 1f0e s 		LD	(RHF_LINES),HL
1f11 1f11 s 		
1f11 1f11 d 7c
1f11 1f11 u 01 01
1f11 1f11 s 		LD	A,H		;Display line on LED
1f12 1f12 d 45
1f12 1f12 u 01 01
1f12 1f12 s 		LD	B,L
1f13 1f13 d 21e3ff
1f13 1f13 u 03 01
1f13 1f13 s 		LD	HL,LED_DISPLAY+3
1f16 1f16 d cd4a1c
1f16 1f16 u 03 01
1f16 1f16 s 		CALL	LED_PUT_BYTE_HL
1f19 1f19 d 78
1f19 1f19 u 01 01
1f19 1f19 s 		LD	A,B
1f1a 1f1a d cd4a1c
1f1a 1f1a u 03 01
1f1a 1f1a s 		CALL	LED_PUT_BYTE_HL
1f1d 1f1d s 		
1f1d 1f1d d 3a0cff
1f1d 1f1d u 03 01
1f1d 1f1d s 		LD	A, (VIEW_FLAGS)	;BIT .0=View HEX Load, .6=FILE SIZE
1f20 1f20 d 0f
1f20 1f20 u 01 01
1f20 1f20 s 		RRCA
1f21 1f21 d 3006
1f21 1f21 u 02 01
1f21 1f21 s 		JR  NC,	RHF_DO
1f23 1f23 s 		
1f23 1f23 d 2100fa
1f23 1f23 u 03 01
1f23 1f23 s 		LD	HL, LINE_BUFF	;Reload HL
1f26 1f26 d cdbd0d
1f26 1f26 u 03 01
1f26 1f26 s 		CALL	PRINT		
1f29 1f29 s 				
1f29 1f29 d cd301f
1f29 1f29 u 03 01
1f29 1f29 s RHF_DO		CALL	RHF_LINE	;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
1f2c 1f2c d d8
1f2c 1f2c u 01 01
1f2c 1f2c s 		RET	C		;CY=1 ERROR encountered
1f2d 1f2d d 20d2
1f2d 1f2d u 02 01
1f2d 1f2d s 		JR  NZ,	RHF_LOOP	;Z=1 when End Of File record encountered
1f2f 1f2f d c9
1f2f 1f2f u 01 01
1f2f 1f2f s 		RET
1f30 1f30 s 		
1f30 1f30 s ;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
1f30 1f30 d 2100fa
1f30 1f30 u 03 01
1f30 1f30 s RHF_LINE	LD	HL, LINE_BUFF	;Reload HL
1f33 1f33 d 7e
1f33 1f33 u 01 01
1f33 1f33 s 		LD	A,(HL)
1f34 1f34 d fe3a
1f34 1f34 u 02 01
1f34 1f34 s 		CP	':'		;Step 0, look for colon
1f36 1f36 d 280f
1f36 1f36 u 02 01
1f36 1f36 s 		JR Z,	RHF_OK1
1f38 1f38 s 
1f38 1f38 d b7
1f38 1f38 u 01 01
1f38 1f38 s 		OR	A		;If LINE BLANK then EOF
1f39 1f39 d c8
1f39 1f39 u 01 01
1f39 1f39 s 		RET	Z		;Z=1,CY=0 EOF
1f3a 1f3a s 
1f3a 1f3a d cdca0d
1f3a 1f3a u 03 01
1f3a 1f3a s 		CALL	PRINTI
1f3d 1f3d d 0d0a434f4c4f4e00
1f3d 1f3d u 08 02
1f3d 1f3d s 		DB CR,LF,"COLON",EOS
1f45 1f45 d 1847
1f45 1f45 u 02 01
1f45 1f45 s 		JR	RHF_ERR_ON_LINE
1f47 1f47 s 
1f47 1f47 d e5
1f47 1f47 u 01 01
1f47 1f47 s RHF_OK1		PUSH	HL
1f48 1f48 d d1
1f48 1f48 u 01 01
1f48 1f48 s 		POP	DE		;DE=HL=LINE_BUFF
1f49 1f49 d 0e00
1f49 1f49 u 02 01
1f49 1f49 s 		LD	C,0		;Convert remaining HEX characters to Binary values
1f4b 1f4b d 0602
1f4b 1f4b u 02 01
1f4b 1f4b s RHF_BYTE_LP2	LD	B,2
1f4d 1f4d d 23
1f4d 1f4d u 01 01
1f4d 1f4d s RHF_BYTE_LP	INC	HL		;
1f4e 1f4e d 7e
1f4e 1f4e u 01 01
1f4e 1f4e s 		LD	A,(HL)
1f4f 1f4f d cd980d
1f4f 1f4f u 03 01
1f4f 1f4f s 		CALL	ASC2HEX		;Process LSD char
1f52 1f52 d 380c
1f52 1f52 u 02 01
1f52 1f52 s 		JR C,	RHF_NOT_HEX
1f54 1f54 d eb
1f54 1f54 u 01 01
1f54 1f54 s 		EX	DE,HL
1f55 1f55 d ed6f
1f55 1f55 u 02 01
1f55 1f55 s 		RLD			;Shift digit to LINE_BUFF @ DE
1f57 1f57 d eb
1f57 1f57 u 01 01
1f57 1f57 s 		EX	DE,HL
1f58 1f58 d 10f3
1f58 1f58 u 02 01
1f58 1f58 s 		DJNZ	RHF_BYTE_LP	;Repeat for 2 HEX digits
1f5a 1f5a d 1a
1f5a 1f5a u 01 01
1f5a 1f5a s 		LD	A,(DE)		;Update Checksum
1f5b 1f5b d 81
1f5b 1f5b u 01 01
1f5b 1f5b s 		ADD	A,C
1f5c 1f5c d 4f
1f5c 1f5c u 01 01
1f5c 1f5c s 		LD	C,A
1f5d 1f5d d 13
1f5d 1f5d u 01 01
1f5d 1f5d s 		INC	DE
1f5e 1f5e d 18eb
1f5e 1f5e u 02 01
1f5e 1f5e s 		JR	RHF_BYTE_LP2	;Repeat for all HEX pairs
1f60 1f60 s 		
1f60 1f60 d cd2c20
1f60 1f60 u 03 01
1f60 1f60 s RHF_NOT_HEX	CALL	IS_CRLF		;Test if final char is CR or LF
1f63 1f63 d 2814
1f63 1f63 u 02 01
1f63 1f63 s 		JR Z,	RHF_OK2
1f65 1f65 s 	
1f65 1f65 d cdca0d
1f65 1f65 u 03 01
1f65 1f65 s 		CALL	PRINTI
1f68 1f68 d 0d0a494e56414c4944204348415200
1f68 1f68 u 0f 02
1f68 1f68 s 		DB CR,LF,"INVALID CHAR",EOS
1f77 1f77 d 1815
1f77 1f77 u 02 01
1f77 1f77 s 		JR	RHF_ERR_ON_LINE
1f79 1f79 s 
1f79 1f79 d 05
1f79 1f79 u 01 01
1f79 1f79 s RHF_OK2		DEC	B
1f7a 1f7a d 05
1f7a 1f7a u 01 01
1f7a 1f7a s 		DEC	B
1f7b 1f7b d 282f
1f7b 1f7b u 02 01
1f7b 1f7b s 		JR Z,	RHF_OK3
1f7d 1f7d d cdca0d
1f7d 1f7d u 03 01
1f7d 1f7d s 		CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
1f80 1f80 d 0d0a4845582050414952494e4700
1f80 1f80 u 0e 02
1f80 1f80 s 		DB CR,LF,"HEX PAIRING",EOS
1f8e 1f8e s 		;JR	RHF_ERR_ON_LINE
1f8e 1f8e s 		
1f8e 1f8e d cdca0d
1f8e 1f8e u 03 01
1f8e 1f8e s RHF_ERR_ON_LINE	CALL	PRINTI
1f91 1f91 d 204552524f52204f4e204c494e452320307800
1f91 1f91 u 13 02
1f91 1f91 s 		DB " ERROR ON LINE# 0x",EOS
1fa4 1fa4 d 2a8afa
1fa4 1fa4 u 03 01
1fa4 1fa4 s 		LD	HL, (RHF_LINES)
1fa7 1fa7 d cdea0d
1fa7 1fa7 u 03 01
1fa7 1fa7 s 		CALL	PUT_HL
1faa 1faa d 37
1faa 1faa u 01 01
1faa 1faa s 		SCF			;Return with ERROR
1fab 1fab d c9
1fab 1fab u 01 01
1fab 1fab s 		RET			;Z=?,CY=1 ERROR
1fac 1fac s 
1fac 1fac s 
1fac 1fac d 3a00fa
1fac 1fac u 03 01
1fac 1fac s RHF_OK3		LD	A,(LINE_BUFF)	;Get Size of HEX line
1faf 1faf d 7b
1faf 1faf u 01 01
1faf 1faf s 		LD	A,E		;Get number of bytes processed from hex line
1fb0 1fb0 d d600
1fb0 1fb0 u 02 01
1fb0 1fb0 s 		SUB	LOW LINE_BUFF
1fb2 1fb2 d 2100fa
1fb2 1fb2 u 03 01
1fb2 1fb2 s 		LD	HL,LINE_BUFF
1fb5 1fb5 d 96
1fb5 1fb5 u 01 01
1fb5 1fb5 s 		SUB	(HL)		;Subtract the number of bytes indicated in the HEX Line
1fb6 1fb6 d fe05
1fb6 1fb6 u 02 01
1fb6 1fb6 s 		CP	5
1fb8 1fb8 d 280e
1fb8 1fb8 u 02 01
1fb8 1fb8 s 		JR Z,	RHF_OK4
1fba 1fba d cdca0d
1fba 1fba u 03 01
1fba 1fba s 		CALL	PRINTI		;
1fbd 1fbd d 0d0a4c454e47544800
1fbd 1fbd u 09 02
1fbd 1fbd s 		DB CR,LF,"LENGTH",EOS
1fc6 1fc6 d 18c6
1fc6 1fc6 u 02 01
1fc6 1fc6 s 		JR	RHF_ERR_ON_LINE
1fc8 1fc8 s 		
1fc8 1fc8 s ; LLAAAAFF000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1FXX
1fc8 1fc8 s ;:200000000000000000000000000000000000000000000000000000000000000000000000E0
1fc8 1fc8 s ;
1fc8 1fc8 s ;Length is 0x20 bytes, total line length is then 0x25 (len+add+field+data+chksum)  1+2+1+20+1
1fc8 1fc8 s 
1fc8 1fc8 d 79
1fc8 1fc8 u 01 01
1fc8 1fc8 s RHF_OK4		LD	A,C
1fc9 1fc9 d b7
1fc9 1fc9 u 01 01
1fc9 1fc9 s 		OR	A
1fca 1fca d 2810
1fca 1fca u 02 01
1fca 1fca s 		JR Z,	RHF_OK5
1fcc 1fcc d cdca0d
1fcc 1fcc u 03 01
1fcc 1fcc s 		CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
1fcf 1fcf d 0d0a434845434b53554d00
1fcf 1fcf u 0b 02
1fcf 1fcf s 		DB CR,LF,"CHECKSUM",EOS
1fda 1fda d 18b2
1fda 1fda u 02 01
1fda 1fda s 		JR	RHF_ERR_ON_LINE
1fdc 1fdc s 
1fdc 1fdc d 2103fa
1fdc 1fdc u 03 01
1fdc 1fdc s RHF_OK5		LD	HL,LINE_BUFF+3	;FIELD TYPE
1fdf 1fdf d 7e
1fdf 1fdf u 01 01
1fdf 1fdf s 		LD	A,(HL)
1fe0 1fe0 d b7
1fe0 1fe0 u 01 01
1fe0 1fe0 s 		OR	A
1fe1 1fe1 d 2829
1fe1 1fe1 u 02 01
1fe1 1fe1 s 		JR Z,	RHF_OK6
1fe3 1fe3 d 3d
1fe3 1fe3 u 01 01
1fe3 1fe3 s 		DEC	A
1fe4 1fe4 d c8
1fe4 1fe4 u 01 01
1fe4 1fe4 s 		RET	Z		;Z=1,CY=0 EOF
1fe5 1fe5 d cdca0d
1fe5 1fe5 u 03 01
1fe5 1fe5 s 		CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
1fe8 1fe8 d 0d0a554e4b4e4f574e205245434f524420545950452c2049474e4f52454400
1fe8 1fe8 u 1f 02
1fe8 1fe8 s 		DB CR,LF,"UNKNOWN RECORD TYPE, IGNORED",EOS
2007 2007 d cd8e1f
2007 2007 u 03 01
2007 2007 s 		CALL	RHF_ERR_ON_LINE
200a 200a d 181d
200a 200a u 02 01
200a 200a s 		JR	RHF_DO_NEXTL
200c 200c s 		
200c 200c d 2b
200c 200c u 01 01
200c 200c s RHF_OK6		DEC	HL		;ADDRESS (BIG ENDIAN)
200d 200d d 5e
200d 200d u 01 01
200d 200d s 		LD	E,(HL)
200e 200e d 2b
200e 200e u 01 01
200e 200e s 		DEC	HL
200f 200f d 56
200f 200f u 01 01
200f 200f s 		LD	D,(HL)
2010 2010 s 		
2010 2010 d 2b
2010 2010 u 01 01
2010 2010 s 		DEC	HL		;Length
2011 2011 d 7e
2011 2011 u 01 01
2011 2011 s 		LD	A,(HL)
2012 2012 d 4f
2012 2012 u 01 01
2012 2012 s 		LD	C,A
2013 2013 d 0600
2013 2013 u 02 01
2013 2013 s 		LD	B,0
2015 2015 s 
2015 2015 d 210cff
2015 2015 u 03 01
2015 2015 s 		LD	HL, VIEW_FLAGS
2018 2018 d cb4e
2018 2018 u 02 01
2018 2018 s 		BIT	1,(HL)
201a 201a d c22420
201a 201a u 03 01
201a 201a s 		JP  NZ,	RHF_OK7
201d 201d d cbce
201d 201d u 02 01
201d 201d s 		SET	1,(HL)
201f 201f d eb
201f 201f u 01 01
201f 201f s 		EX	DE,HL
2020 2020 d 220aff
2020 2020 u 03 01
2020 2020 s 		LD	(GH_START), HL
2023 2023 d eb
2023 2023 u 01 01
2023 2023 s 		EX	DE,HL
2024 2024 s 
2024 2024 d 2104fa
2024 2024 u 03 01
2024 2024 s RHF_OK7		LD	HL,LINE_BUFF+4	;DATA
2027 2027 d edb0
2027 2027 u 02 01
2027 2027 s 		LDIR
2029 2029 d af
2029 2029 u 01 01
2029 2029 s RHF_DO_NEXTL	XOR	A
202a 202a d 3d
202a 202a u 01 01
202a 202a s 		DEC	A
202b 202b d c9
202b 202b u 01 01
202b 202b s 		RET			;Z=0,CY=0 IGNORE
202c 202c s 
202c 202c s 
202c 202c d fe0d
202c 202c u 02 01
202c 202c s IS_CRLF		CP	CR
202e 202e d c8
202e 202e u 01 01
202e 202e s 		RET 	Z
202f 202f d fe0a
202f 202f u 02 01
202f 202f s 		CP	LF
2031 2031 d c9
2031 2031 u 01 01
2031 2031 s 		RET
2032 2032 s 
2032 2032 d 3a0cff
2032 2032 u 03 01
2032 2032 s GH_EXEC		LD	A, (VIEW_FLAGS)
2035 2035 d cb4f
2035 2035 u 02 01
2035 2035 s 		BIT	1,A
2037 2037 d 2020
2037 2037 u 02 01
2037 2037 s 		JR NZ,	GH_EXEC_GO
2039 2039 d cdca0d
2039 2039 u 03 01
2039 2039 s 		CALL	PRINTI
203c 203c d 0d0a2121212053544152542041444452455353204e4f542053455400
203c 203c u 1c 02
203c 203c s 		DB CR,LF,"!!! START ADDRESS NOT SET",EOS
2058 2058 d c9
2058 2058 u 01 01
2058 2058 s 		RET
2059 2059 s 
2059 2059 d 2a0aff
2059 2059 u 03 01
2059 2059 s GH_EXEC_GO	LD	HL, (GH_START)	;HL = JUMP ADDRESS
205c 205c d cdca0d
205c 205c u 03 01
205c 205c s GH_EXEC_GO2	CALL	PRINTI
205f 205f d 0d0a457865637574652061743a00
205f 205f u 0e 02
205f 205f s 		DB CR,LF,"Execute at:",EOS
206d 206d s 		
206d 206d d cdea0d
206d 206d u 03 01
206d 206d s 		CALL	PUT_HL
2070 2070 d cd1f0e
2070 2070 u 03 01
2070 2070 s 		CALL	PUT_NEW_LINE
2073 2073 s 
2073 2073 d e5
2073 2073 u 01 01
2073 2073 s 		PUSH	HL
2074 2074 d 218320
2074 2074 u 03 01
2074 2074 s 		LD	HL,HR_EXEC_GO_SUB	;Copy from
2077 2077 d 1153fb
2077 2077 u 03 01
2077 2077 s 		LD	DE,HR_EXE_GO		;Copy to
207a 207a d 010800
207a 207a u 03 01
207a 207a s 		LD	BC,HR_EXEC_GS_LEN	;Length=11 bytes
207d 207d d edb0
207d 207d u 02 01
207d 207d s 		LDIR
207f 207f d e1
207f 207f u 01 01
207f 207f s 		POP	HL
2080 2080 d c353fb
2080 2080 u 03 01
2080 2080 s 		JP	HR_EXE_GO
2083 2083 s 
2083 2083 d 3e01
2083 2083 u 02 01
2083 2083 s HR_EXEC_GO_SUB	LD	A,1
2085 2085 d 32d9ff
2085 2085 u 03 01
2085 2085 s 		LD	(RRSTATE),A
2088 2088 d d3c1
2088 2088 u 02 01
2088 2088 s 		OUT	(RAMROM),A
208a 208a d e9
208a 208a u 01 01
208a 208a s 		JP	(HL)	;Execute the Get HEX
208b 208b s 
208b 208b s HR_EXEC_GS_LEN	EQU	$-HR_EXEC_GO_SUB
208b 208b s 
208b 208b s 
208b 208b s 
208b 208b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
208b 208b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
208b 208b s ;	Chapter_14	FILE Support Routines
208b 208b s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
208b 208b s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
208b 208b s 
208b 208b s ;=============================================================================
208b 208b s 		;Find File w/ Verbose Output
208b 208b s 		;Call with File Name set in FILENAME.EXT
208b 208b s 		;Return Z=1 File Not Found
208b 208b s 		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
208b 208b s 		;Destroys A,B,C
208b 208b d 3a0cff
208b 208b u 03 01
208b 208b s SDV_FIND_FILE	LD	A,(VIEW_FLAGS)	;BIT .0=View HEX Load, .6=Display FILE SIZE, .7=Display File name & Found or Not
208e 208e d 07
208e 208e u 01 01
208e 208e s 		RLCA
208f 208f d 302c
208f 208f u 02 01
208f 208f s 		JR NC,	SD_FIND_FILE	;Call the Find File routine
2091 2091 d 2143ff
2091 2091 u 03 01
2091 2091 s 		LD	HL,FILENAME
2094 2094 d cd0521
2094 2094 u 03 01
2094 2094 s 		CALL	PRINT_FILENAME
2097 2097 d cdbd20
2097 2097 u 03 01
2097 2097 s 		CALL	SD_FIND_FILE	;Call the Find File routine
209a 209a d f5
209a 209a u 01 01
209a 209a s 		PUSH	AF
209b 209b d c2af20
209b 209b u 03 01
209b 209b s 		JP NZ,	SDV_FOUND	;Print Yah or Nah
209e 209e d cdca0d
209e 209e u 03 01
209e 209e s 		CALL 	PRINTI
20a1 20a1 d 202d4e4f5420464f554e4400
20a1 20a1 u 0c 02
20a1 20a1 s 		DB " -NOT FOUND",EOS
20ad 20ad d f1
20ad 20ad u 01 01
20ad 20ad s 		POP	AF
20ae 20ae d c9
20ae 20ae u 01 01
20ae 20ae s 		RET
20af 20af d cdca0d
20af 20af u 03 01
20af 20af s SDV_FOUND	CALL 	PRINTI
20b2 20b2 d 202d45584953545300
20b2 20b2 u 09 02
20b2 20b2 s 		DB " -EXISTS",EOS
20bb 20bb d f1
20bb 20bb u 01 01
20bb 20bb s 		POP	AF
20bc 20bc d c9
20bc 20bc u 01 01
20bc 20bc s 		RET
20bd 20bd s 
20bd 20bd s ;=============================================================================
20bd 20bd s 		;Find File
20bd 20bd s 		;Call with File Name set in RAM variable: FILENAME.EXT
20bd 20bd s 		;Return Z=1 File Not Found
20bd 20bd s 		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
20bd 20bd d cdcb20
20bd 20bd u 03 01
20bd 20bd s SD_FIND_FILE	CALL	SD_LDIR1
20c0 20c0 d c8
20c0 20c0 u 01 01
20c0 20c0 s SDFF_LP 	RET Z			;End of list
20c1 20c1 d cd6321
20c1 20c1 u 03 01
20c1 20c1 s 		CALL	CMP_FILENAME	;Compares file name at (HL) with FILENAME.EXT in RAM
20c4 20c4 d c0
20c4 20c4 u 01 01
20c4 20c4 s 		RET NZ			;FILE FOUND
20c5 20c5 d cde020
20c5 20c5 u 03 01
20c5 20c5 s 		CALL	SD_LDIRN
20c8 20c8 d c3c020
20c8 20c8 u 03 01
20c8 20c8 s 		JP	SDFF_LP
20cb 20cb s 
20cb 20cb s 
20cb 20cb s ;=============================================================================
20cb 20cb s ;Directory Routines.  1st Routine to start/init the search, 2nd routine to continue the search
20cb 20cb s ;-----------------------------------------------------------------------------
20cb 20cb s ;Call this routine to initialize and start the HL Pointer to the first Directory Entry
20cb 20cb d 2135ff
20cb 20cb u 03 01
20cb 20cb s SD_LDIR1	LD	HL,DIR_SECTOR	;SEC_PTR = DIR_SECTOR
20ce 20ce d cd3e27
20ce 20ce u 03 01
20ce 20ce s 		CALL	MOV_32_HL
20d1 20d1 d 2a25ff
20d1 20d1 u 03 01
20d1 20d1 s 		LD	HL, (ROOTDIR_SIZE)	;ENT_COUNT = ROOTDIR_SIZE (to count down directory entries searched)
20d4 20d4 d 2241ff
20d4 20d4 u 03 01
20d4 20d4 s 		LD	(ENT_COUNT), HL
20d7 20d7 s 		
20d7 20d7 s 
20d7 20d7 d cd9624
20d7 20d7 u 03 01
20d7 20d7 s SD_FETCH	CALL	SD_READ_SEC		;Fetch a ROOT DIRECTORY sector
20da 20da d 2100fc
20da 20da u 03 01
20da 20da s 		LD	HL,SD_RAM_BUFFER	;(Re)start H at start of Sector
20dd 20dd d af
20dd 20dd u 01 01
20dd 20dd s SD_TEST		XOR	A			;EXIT Z=0 if there is a File at this entry
20de 20de d be
20de 20de u 01 01
20de 20de s 		CP	(HL)
20df 20df d c9
20df 20df u 01 01
20df 20df s 		RET
20e0 20e0 s 
20e0 20e0 s ;=============================================================================
20e0 20e0 s ;Call this routine to advance to the next Directory Entry (loads next sector and restarts HL as needed)
20e0 20e0 s ;-----------------------------------------------------------------------------
20e0 20e0 d 012000
20e0 20e0 u 03 01
20e0 20e0 s SD_LDIRN	LD	BC,20h		;Advance to next file entry
20e3 20e3 d 09
20e3 20e3 u 01 01
20e3 20e3 s 		ADD	HL,BC
20e4 20e4 d 7c
20e4 20e4 u 01 01
20e4 20e4 s 		LD	A,H
20e5 20e5 d fefe
20e5 20e5 u 02 01
20e5 20e5 s 		CP	HIGH (SD_RAM_BUFFER+200h)
20e7 20e7 d c2dd20
20e7 20e7 u 03 01
20e7 20e7 s 		JP NZ,	SD_TEST		;Check if extended beyond this sector
20ea 20ea s 
20ea 20ea d af
20ea 20ea u 01 01
20ea 20ea s 		XOR	A		;Return Z=1 if no more files
20eb 20eb d 2a41ff
20eb 20eb u 03 01
20eb 20eb s 		LD	HL, (ENT_COUNT)
20ee 20ee d 01f0ff
20ee 20ee u 03 01
20ee 20ee s 		LD	BC,-16
20f1 20f1 d 09
20f1 20f1 u 01 01
20f1 20f1 s 		ADD	HL,BC
20f2 20f2 d 2241ff
20f2 20f2 u 03 01
20f2 20f2 s 		LD	(ENT_COUNT), HL
20f5 20f5 d d0
20f5 20f5 u 01 01
20f5 20f5 s 		RET NC			;Out of Directory entries
20f6 20f6 d 7c
20f6 20f6 u 01 01
20f6 20f6 s 		LD	A,H
20f7 20f7 d b5
20f7 20f7 u 01 01
20f7 20f7 s 		OR	L
20f8 20f8 d c8
20f8 20f8 u 01 01
20f8 20f8 s 		RET Z			;Out of Directory entries
20f9 20f9 s 
20f9 20f9 d 213dff
20f9 20f9 u 03 01
20f9 20f9 s 		LD	HL,SEC_PTR	;Advance to next SECTOR
20fc 20fc d cd3e27
20fc 20fc u 03 01
20fc 20fc s 		CALL	MOV_32_HL
20ff 20ff d cd6527
20ff 20ff u 03 01
20ff 20ff s 		CALL	INC_32
2102 2102 d c3d720
2102 2102 u 03 01
2102 2102 s 		JP	SD_FETCH
2105 2105 s 
2105 2105 s 
2105 2105 s ;=============================================================================
2105 2105 s ;	Prints Filename at HL (DESTROYS A)
2105 2105 s ;-----------------------------------------------------------------------------
2105 2105 d e5
2105 2105 u 01 01
2105 2105 s PRINT_FILENAME	PUSH	HL
2106 2106 d c5
2106 2106 u 01 01
2106 2106 s 		PUSH	BC
2107 2107 d 0608
2107 2107 u 02 01
2107 2107 s 		LD	B,8
2109 2109 d cd1d21
2109 2109 u 03 01
2109 2109 s 		CALL	PRINT_BS	;Print up to 8 characters or until an encouter with Space or NULL
210c 210c d 3e2e
210c 210c u 02 01
210c 210c s 		LD	A,'.'
210e 210e d cdec13
210e 210e u 03 01
210e 210e s 		CALL	PUT_CHAR
2111 2111 d 48
2111 2111 u 01 01
2111 2111 s 		LD	C,B		;Adjust HL to +8
2112 2112 d 0600
2112 2112 u 02 01
2112 2112 s 		LD	B,0	
2114 2114 d 09
2114 2114 u 01 01
2114 2114 s 		ADD	HL,BC
2115 2115 d 0603
2115 2115 u 02 01
2115 2115 s 		LD	B,3
2117 2117 d cd1d21
2117 2117 u 03 01
2117 2117 s 		CALL	PRINT_BS	;Print up to 3 characters or until an encouter with Space or NULL
211a 211a d c1
211a 211a u 01 01
211a 211a s 		POP	BC
211b 211b d e1
211b 211b u 01 01
211b 211b s 		POP	HL
211c 211c d c9
211c 211c u 01 01
211c 211c s 		RET
211d 211d s 
211d 211d d 7e
211d 211d u 01 01
211d 211d s PRINT_BS	LD	A,(HL)		;PRINT B CHARS OR UP TO EITHER A NULL OR SPACE.
211e 211e d b7
211e 211e u 01 01
211e 211e s 		OR	A
211f 211f d c8
211f 211f u 01 01
211f 211f s 		RET Z
2120 2120 d fe20
2120 2120 u 02 01
2120 2120 s 		CP	' '
2122 2122 d c8
2122 2122 u 01 01
2122 2122 s 		RET Z
2123 2123 d cdec13
2123 2123 u 03 01
2123 2123 s 		CALL	PUT_CHAR
2126 2126 d 23
2126 2126 u 01 01
2126 2126 s 		INC	HL
2127 2127 d 10f4
2127 2127 u 02 01
2127 2127 s 		DJNZ	PRINT_BS
2129 2129 d c9
2129 2129 u 01 01
2129 2129 s 		RET
212a 212a s 
212a 212a s 
212a 212a s ;=============================================================================
212a 212a s ;	OUTPUT: FILENAME ENTERED, C=0
212a 212a s ;		<ESC> PRESSED C=1
212a 212a d cdca0d
212a 212a u 03 01
212a 212a s INPUT_FILENAME	CALL 	PRINTI		;Display Menu Prompt
212d 212d d 0d0a454e54455220382e332046494c45204e414d453e2000
212d 212d u 18 02
212d 212d s 		DB CR,LF,"ENTER 8.3 FILE NAME> ",EOS
2145 2145 d 2143ff
2145 2145 u 03 01
2145 2145 s 		LD	HL,FILENAME
2148 2148 d 060b
2148 2148 u 02 01
2148 2148 s 		LD	B,11
214a 214a d 3e20
214a 214a u 02 01
214a 214a s 		LD	A,' '
214c 214c d cd160c
214c 214c u 03 01
214c 214c s 		CALL	FILL_BLOCK
214f 214f d 0e2e
214f 214f u 02 01
214f 214f s 		LD	C,'.'
2151 2151 d 0608
2151 2151 u 02 01
2151 2151 s 		LD	B,8
2153 2153 d cd9727
2153 2153 u 03 01
2153 2153 s 		CALL	GET_STRING
2156 2156 d d8
2156 2156 u 01 01
2156 2156 s 		RET C
2157 2157 d fe0d
2157 2157 u 02 01
2157 2157 s 		CP	13
2159 2159 d c8
2159 2159 u 01 01
2159 2159 s 		RET	Z
215a 215a d 214bff
215a 215a u 03 01
215a 215a s 		LD	HL,FILEEXT
215d 215d d 0603
215d 215d u 02 01
215d 215d s 		LD	B,3
215f 215f d cd9727
215f 215f u 03 01
215f 215f s 		CALL	GET_STRING
2162 2162 d c9
2162 2162 u 01 01
2162 2162 s 		RET
2163 2163 s 
2163 2163 s ;=============================================================================
2163 2163 d e5
2163 2163 u 01 01
2163 2163 s CMP_FILENAME	PUSH	HL		;Save H pointer into  Directory
2164 2164 d 010800
2164 2164 u 03 01
2164 2164 s 		LD	BC,8		;Compare 8 characters
2167 2167 d 1143ff
2167 2167 u 03 01
2167 2167 s 		LD	DE,FILENAME
216a 216a d cd8021
216a 216a u 03 01
216a 216a s 		CALL	CMP_STRING
216d 216d d 200e
216d 216d u 02 01
216d 216d s 		JR NZ,	CMPF_RETFAIL	;Exit if not equal
216f 216f s 		;ADD	HL,BC		;Adjust HL to +8, HL should be +8
216f 216f d 010300
216f 216f u 03 01
216f 216f s 		LD	BC,3
2172 2172 d 114bff
2172 2172 u 03 01
2172 2172 s 		LD	DE,FILEEXT
2175 2175 d cd8021
2175 2175 u 03 01
2175 2175 s 		CALL	CMP_STRING
2178 2178 d 2003
2178 2178 u 02 01
2178 2178 s 		JR NZ,	CMPF_RETFAIL	;Exit if not equal
217a 217a d 0c
217a 217a u 01 01
217a 217a s 		INC	C		;Z=0
217b 217b d e1
217b 217b u 01 01
217b 217b s 		POP	HL
217c 217c d c9
217c 217c u 01 01
217c 217c s 		RET
217d 217d s 		
217d 217d d af
217d 217d u 01 01
217d 217d s CMPF_RETFAIL	XOR	A		;Z=1
217e 217e d e1
217e 217e u 01 01
217e 217e s 		POP	HL
217f 217f d c9
217f 217f u 01 01
217f 217f s 		RET
2180 2180 s 
2180 2180 d 1a
2180 2180 u 01 01
2180 2180 s CMP_STRING	LD	A, (DE)
2181 2181 d eda1
2181 2181 u 02 01
2181 2181 s 		CPI			;CP (HL):INC HL:DEC BC
2183 2183 d c0
2183 2183 u 01 01
2183 2183 s 		RET NZ			;Exit if not equal
2184 2184 d e0
2184 2184 u 01 01
2184 2184 s 		RET PO			;Exit if end of string
2185 2185 d 13
2185 2185 u 01 01
2185 2185 s 		INC	DE
2186 2186 d 18f8
2186 2186 u 02 01
2186 2186 s 		JR	CMP_STRING
2188 2188 s 
2188 2188 s 
2188 2188 s ;=====================================================================================================
2188 2188 s ;Read of Logical Disk Sector.
2188 2188 s ;=====================================================================================================
2188 2188 s 	;Start-of-Directory = Size-of-Fat * Number-of-fats + 1 (boot sector)
2188 2188 s 	;Start-of-Data-Area = Start-of-Directory + #Entries/32/bytes_per_sector
2188 2188 s 
2188 2188 s 	;Input:	LOGICAL_SEC Disk Sector required (0 to 2001) based on 26 sectors per track by 77 tracks, counting from 0
2188 2188 s 	;Disk FCB in HL
2188 2188 s 
2188 2188 s 	;if AFClus0 = 0x0000 then attempt to open the file report Disk not loaded if fail
2188 2188 s 	;Relative file sector:
2188 2188 s 	;DISK_SEC is the input to this routine, it holds Virtual Disk Sector 0 to 2001
2188 2188 s 	;because every SD sector has 512 bytes, each SD sector holds 4 CP/M Virtual Disk sectors (that's 128 bytes)
2188 2188 s 	;RFSec is the Relative File Sector, it spans from 0 to 500 (this accomodates 501 SD Sectors or 256,512 bytes)
2188 2188 s 	;If RFSec = DISK_SEC / 4 Then...
2188 2188 s 	;If RFSec has not changed, then read that sector into RAM and be done.
2188 2188 s 	;That Relative File sector is located on the SD card at address set in the absolute sector (ABS_SEC)
2188 2188 s 	;
2188 2188 s 	;If RFSec has changed... then determine is the new RFSec is within the same cluster or not.
2188 2188 s 	;On a 1Gig SD card, the system uses 32 sectors per cluster.  This means, 32 sequential SD Memory Card sectors form 1 cluster.
2188 2188 s 	;If a sector within the same cluster is being accessed, then the cluster does not have to be found again.
2188 2188 s 	;If it's NOT in the same cluster, then find new cluster by looking through the FAT
2188 2188 s 	;If it is in the same cluster, then skip to the part were we can just offset the RFSec into the current cluster
2188 2188 s 	;
2188 2188 s 	;...else
2188 2188 s 	;RFSec = DISK_SEC / 4  'Set the new sector as the current one.
2188 2188 s 	;
2188 2188 s 	;Find the Relative File Cluster (RFClus).  This number will be from 0 to 15 on a 1Gig SD Card = 262,144 bytes (to hold a 256,256 file)
2188 2188 s 	;
2188 2188 s 	;Relative file cluster:
2188 2188 s 	;RFClus = RFSec / SEC_PER_CLUS
2188 2188 s 	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
2188 2188 s 	;  if RFClus < CRFClus then CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
2188 2188 s 	;  RFClus = RFClus - CRFClus
2188 2188 s 	;  do while RFClus>0
2188 2188 s 	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
2188 2188 s 	;      CAFClus = FAT(CAFClus)
2188 2188 s 	;      CRFClus = CRFClus + 1
2188 2188 s 	;      RFClus = RFClus - 1
2188 2188 s 	;  loop
2188 2188 s 	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
2188 2188 s 	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
2188 2188 s ;Destroys: A, BC, DE, HL, IX
2188 2188 s ;=====================================================================================================
2188 2188 s ;Read of Logical Disk Sector.
2188 2188 s ;Input:	LOGICAL_SEC = 0=First Sector
2188 2188 s DISK_READ	
2188 2188 s 		;CALL	PRINTI		;debug
2188 2188 s 		;DB  " R-",EOS		;debug
2188 2188 s 		;LD	HL,(LOGICAL_SEC);debug
2188 2188 s 		;CALL	PUT_HL		;debug
2188 2188 s 
2188 2188 d dd2a08ff
2188 2188 u 04 01
2188 2188 s 		LD	IX,(FCB_PTR)	;Get Current Disk FCB
218c 218c d dd7e00
218c 218c u 03 01
218c 218c s 		LD	A,(IX)		;Is file open?
218f 218f d b7
218f 218f u 01 01
218f 218f s 		OR	A		;Test FSTAT
2190 2190 d c2b321
2190 2190 u 03 01
2190 2190 s 		JP NZ,	DR_1		;Jump YES
2193 2193 s 		
2193 2193 s 		;PUSH	IX		;debug
2193 2193 s 		;POP	HL		;debug
2193 2193 s 		;CALL	PRINTI		;debug
2193 2193 s 		;DB  " HL:",EOS		;debug
2193 2193 s 		;CALL	PUT_HL		;debug
2193 2193 s 		
2193 2193 d cdb61d
2193 2193 u 03 01
2193 2193 s 		CALL	SD_OPEN		;ELSE, Attempt to open file
2196 2196 d dd7e00
2196 2196 u 03 01
2196 2196 s 		LD	A, (IX)		;Is file open?
2199 2199 d b7
2199 2199 u 01 01
2199 2199 s 		OR	A		;Test FSTAT
219a 219a d c2b321
219a 219a u 03 01
219a 219a s 		JP NZ,	DR_1		;Jump YES
219d 219d d cdca0d
219d 219d u 03 01
219d 219d s 		CALL	PRINTI
21a0 21a0 d 202d4469736b204e6f74204c6f6164656400
21a0 21a0 u 12 02
21a0 21a0 s 		DB " -Disk Not Loaded",EOS
21b2 21b2 d c9
21b2 21b2 u 01 01
21b2 21b2 s 		RET			;Exit if file could not open
21b3 21b3 s 
21b3 21b3 d dd6e12
21b3 21b3 u 03 01
21b3 21b3 s DR_1		LD	L,(IX+RFSec)	;If file open, Check if Read is from same Data Sector
21b6 21b6 d dd6613
21b6 21b6 u 03 01
21b6 21b6 s 		LD	H,(IX+RFSec+1)	;D=RFSec
21b9 21b9 s 
21b9 21b9 s 		;CALL	PRINTI		;debug
21b9 21b9 s 		;DB  " LS:",EOS		;debug
21b9 21b9 s 		;CALL	PUT_DE		;debug
21b9 21b9 s 
21b9 21b9 d ed5b0dff
21b9 21b9 u 04 01
21b9 21b9 s 		LD	DE, (LOGICAL_SEC) ;Fetch sector to be read
21bd 21bd d cd9127
21bd 21bd u 03 01
21bd 21bd s 		CALL	CMP_DE_HL
21c0 21c0 d c2d021
21c0 21c0 u 03 01
21c0 21c0 s 		JP NZ,	DR_NEW_SEC	;Jump if Read is from a different Data Sector
21c3 21c3 s 
21c3 21c3 s 					;LOGICAL SECTOR = LAST READ SECTOR, Fetch Absolute Sector and read it to RAM (if wasn't last read)
21c3 21c3 d 2a08ff
21c3 21c3 u 03 01
21c3 21c3 s 		LD	HL,(FCB_PTR)	;Get Current Disk FCB
21c6 21c6 d 3e18
21c6 21c6 u 02 01
21c6 21c6 s 		LD	A,ABS_SEC	;H=FCB(ABS_SEC)
21c8 21c8 d 85
21c8 21c8 u 01 01
21c8 21c8 s 		ADD	A,L
21c9 21c9 d 6f
21c9 21c9 u 01 01
21c9 21c9 s 		LD	L,A
21ca 21ca s 
21ca 21ca d cd3e27
21ca 21ca u 03 01
21ca 21ca s 		CALL	MOV_32_HL
21cd 21cd d c3d522
21cd 21cd u 03 01
21cd 21cd s 		JP	DR_READ_IT
21d0 21d0 s 
21d0 21d0 s 
21d0 21d0 s 	;RFClus = RFSec / SEC_PER_CLUS
21d0 21d0 s 	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
21d0 21d0 s 	;  if RFClus < CRFClus then
21d0 21d0 s 	;     CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
21d0 21d0 s 	;  eles
21d0 21d0 s 	;     RFClus = RFClus - CRFClus	   'else, continue FAT search from point of
21d0 21d0 s 	;  endif
21d0 21d0 s 	;  do while RFClus>0
21d0 21d0 s 	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
21d0 21d0 s 	;      CAFClus = FAT(CAFClus)
21d0 21d0 s 	;      CRFClus = CRFClus + 1
21d0 21d0 s 	;      RFClus = RFClus - 1
21d0 21d0 s 	;  loop
21d0 21d0 s 	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
21d0 21d0 s 	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
21d0 21d0 s 	
21d0 21d0 s DR_NEW_SEC				;We are to read a sector of the file that is different from the last READ.
21d0 21d0 s 					;This branch would also take place on the first time we read a file, since
21d0 21d0 s 					;the "Last Sector Read" was set to a dummy value of 0xFFFF
21d0 21d0 s 					;
21d0 21d0 s 					;Save the sector we are now reading as "Last Sector Read" = RFSec
21d0 21d0 s 
21d0 21d0 d dd7312
21d0 21d0 u 03 01
21d0 21d0 s 		LD	(IX+RFSec  ),E	;D=LOGICAL_SEC = Relative File Sector (Update FCB with this new Rel-File-Sec
21d3 21d3 d dd7213
21d3 21d3 u 03 01
21d3 21d3 s 		LD	(IX+RFSec+1),D	;
21d6 21d6 s 
21d6 21d6 s 					;Find in which relative or sequential Cluster this sector is in
21d6 21d6 s 					;by dividing by the "Sectors per Cluster"
21d6 21d6 s 					;eg. If there are 4 sectors per cluster, then Sectors 0 to 3 will be in Cluster 0
21d6 21d6 s 					;Cluster 0 is the first cluster of the file and the location of this cluster
21d6 21d6 s 					;(the Absolute Cluster) is given by the directory entry for this file.
21d6 21d6 s 
21d6 21d6 d 2a52ff
21d6 21d6 u 03 01
21d6 21d6 s 		LD	HL, (DIVIDE_FUNC)	;DE = DE / Sectors-Per-Cluster (Divide Func hard coded with Sec/Clus)
21d9 21d9 d cda00c
21d9 21d9 u 03 01
21d9 21d9 s 		CALL	VCALL_HL
21dc 21dc s 
21dc 21dc s 		;CALL	PRINTI		;debug
21dc 21dc s 		;DB  " RC:",EOS		;debug
21dc 21dc s 		;CALL	PUT_DE		;debug
21dc 21dc s 		
21dc 21dc d 2a08ff
21dc 21dc u 03 01
21dc 21dc s 		LD	HL,(FCB_PTR)
21df 21df d 3e0e
21df 21df u 02 01
21df 21df s 		LD	A,CRFClus	;H=FCB(CRFClus)
21e1 21e1 d 85
21e1 21e1 u 01 01
21e1 21e1 s 		ADD	A,L
21e2 21e2 d 6f
21e2 21e2 u 01 01
21e2 21e2 s 		LD	L,A
21e3 21e3 s 
21e3 21e3 d 4e
21e3 21e3 u 01 01
21e3 21e3 s 		LD	C,(HL)
21e4 21e4 d 23
21e4 21e4 u 01 01
21e4 21e4 s 		INC	HL
21e5 21e5 d 46
21e5 21e5 u 01 01
21e5 21e5 s 		LD	B,(HL)		;BC = CRFClus
21e6 21e6 d 2b
21e6 21e6 u 01 01
21e6 21e6 s 		DEC	HL
21e7 21e7 s 
21e7 21e7 s 		;CALL	PRINTI		;debug
21e7 21e7 s 		;DB  " LRC:", EOS	;debug
21e7 21e7 s 		;CALL	PUT_BC		;debug
21e7 21e7 s 
21e7 21e7 s 
21e7 21e7 s 					;H->FCB(CRFClus)
21e7 21e7 s 					;TEST DE - BC  aka NewRFClus vs FCB-RFClus
21e7 21e7 s 					;Speed Optimize the above code
21e7 21e7 d 7a
21e7 21e7 u 01 01
21e7 21e7 s 		LD	A,D
21e8 21e8 d b8
21e8 21e8 u 01 01
21e8 21e8 s 		CP	B
21e9 21e9 d 2005
21e9 21e9 u 02 01
21e9 21e9 s 		JR NZ,	DR_DIFF_CLUS
21eb 21eb d 7b
21eb 21eb u 01 01
21eb 21eb s 		LD	A,E
21ec 21ec d b9
21ec 21ec u 01 01
21ec 21ec s 		CP	C
21ed 21ed d cab222
21ed 21ed u 03 01
21ed 21ed s 		JP Z,	DR_SAME_CLUS	;IF they are the same, then the new sector is in the same cluster
21f0 21f0 d 3007
21f0 21f0 u 02 01
21f0 21f0 s DR_DIFF_CLUS	JR NC,	DR_BIGGER_CLUS
21f2 21f2 s 
21f2 21f2 s 					;If going to a smaller cluster, restart the FAT search from the begining
21f2 21f2 d 010000
21f2 21f2 u 03 01
21f2 21f2 s 		LD	BC,0		;CRFClus = 0
21f5 21f5 d 2b
21f5 21f5 u 01 01
21f5 21f5 s 		DEC	HL
21f6 21f6 d 2b
21f6 21f6 u 01 01
21f6 21f6 s 		DEC	HL
21f7 21f7 d 1808
21f7 21f7 u 02 01
21f7 21f7 s 		JR	DR_SEEK_FAT	;HL will load with AFClus0
21f9 21f9 s 
21f9 21f9 d 7b
21f9 21f9 u 01 01
21f9 21f9 s DR_BIGGER_CLUS	LD	A,E		;NewRFClus = NewRFClus - FCB-RFClus,  ie Set counter for number of new FAT hops.
21fa 21fa d 91
21fa 21fa u 01 01
21fa 21fa s 		SUB	C
21fb 21fb d 5f
21fb 21fb u 01 01
21fb 21fb s 		LD	E,A
21fc 21fc d 7a
21fc 21fc u 01 01
21fc 21fc s 		LD	A,D
21fd 21fd d 98
21fd 21fd u 01 01
21fd 21fd s 		SBC	A,B
21fe 21fe d 57
21fe 21fe u 01 01
21fe 21fe s 		LD	D,A
21ff 21ff s 
21ff 21ff d 23
21ff 21ff u 01 01
21ff 21ff s 		INC	HL
2200 2200 d 23
2200 2200 u 01 01
2200 2200 s 		INC	HL		;HL will load with CAFClus
2201 2201 s 
2201 2201 s 	;  do while RFClus>0
2201 2201 s 	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
2201 2201 s 	;      CAFClus = FAT(CAFClus)
2201 2201 s 	;      CRFClus = CRFClus + 1
2201 2201 s 	;      RFClus = RFClus - 1
2201 2201 s 	;  loop
2201 2201 s 
2201 2201 s DR_SEEK_FAT
2201 2201 d cd4a0e
2201 2201 u 03 01
2201 2201 s 		CALL	LD_HL_HL	;HL = CAFClus or AFClus0
2204 2204 s 
2204 2204 s ;		CALL	PRINTI		;debug
2204 2204 s ;		DB  CR,LF,"CAFClus=",EOS ;debug
2204 2204 s ;		CALL	PUT_HL		;debug
2204 2204 s ;		CALL	PRINTI		;debug
2204 2204 s ;		DB  CR,LF,"CRFClus=",EOS ;debug
2204 2204 s ;		CALL	PUT_BC		;debug
2204 2204 s ;		CALL	PRINTI		;debug
2204 2204 s ;		DB  CR,LF,"RFClus=",EOS	;debug
2204 2204 s ;		CALL	PUT_DE		;debug
2204 2204 s 
2204 2204 s 					;BC = CRFClus
2204 2204 d 7a
2204 2204 u 01 01
2204 2204 s DR_SEEK_LP	LD	A,D		;DE = RFClus
2205 2205 d b3
2205 2205 u 01 01
2205 2205 s 		OR	E
2206 2206 d 2861
2206 2206 u 02 01
2206 2206 s 		JR Z,	DR_SEEK_DONE
2208 2208 s 
2208 2208 s ;		CALL	PRINTI		;debug
2208 2208 s ;		DB  CR,LF,"seek=",EOS	;debug
2208 2208 s ;		CALL	PUT_HL		;debug
2208 2208 s 				
2208 2208 d 7c
2208 2208 u 01 01
2208 2208 s 		LD	A,H		;IF CAFClus = 0xFFFF... (No more clusters to fetch)
2209 2209 d a5
2209 2209 u 01 01
2209 2209 s 		AND	L
220a 220a d 2f
220a 220a u 01 01
220a 220a s 		CPL
220b 220b d b7
220b 220b u 01 01
220b 220b s 		OR	A		
220c 220c d c23b22
220c 220c u 03 01
220c 220c s 		JP NZ,	DR_SEEK_1
220f 220f s 					;Error, File too small
220f 220f d cdca0d
220f 220f u 03 01
220f 220f s 		CALL	PRINTI
2212 2212 d 202d4552524f522c204e4f204d4f524520414c4c4f434154454420434c5553544552532100
2212 2212 u 25 02
2212 2212 s 		DB " -ERROR, NO MORE ALLOCATED CLUSTERS!",EOS
2237 2237 d 76
2237 2237 u 01 01
2237 2237 s 		HALT
2238 2238 d c33722
2238 2238 u 03 01
2238 2238 s 		JP	$-1
223b 223b s 		
223b 223b s DR_SEEK_1	
223b 223b s 
223b 223b s 	;Here comes the FAT Hopping FUN...
223b 223b s 	;      CAFClus = FAT(CAFClus)
223b 223b s 	;it's convenient that 1 Sector is 512 bytes, that's 256 words = 256 FAT Entries, therefore...
223b 223b s 	;H = Sector of FAT
223b 223b s 	;L = Word within that Sector of FAT
223b 223b s 
223b 223b d c5
223b 223b u 01 01
223b 223b s 		PUSH	BC
223c 223c d d5
223c 223c u 01 01
223c 223c s 		PUSH	DE
223d 223d d e5
223d 223d u 01 01
223d 223d s 		PUSH	HL
223e 223e d 5c
223e 223e u 01 01
223e 223e s 		LD	E,H		;E=Sector of FAT
223f 223f d 2a31ff
223f 223f u 03 01
223f 223f s 		LD	HL, (FAT1START)	;DE = E + FAT1START
2242 2242 d 7d
2242 2242 u 01 01
2242 2242 s 		LD	A,L
2243 2243 d 83
2243 2243 u 01 01
2243 2243 s 		ADD	A,E
2244 2244 d 5f
2244 2244 u 01 01
2244 2244 s 		LD	E,A
2245 2245 d 7c
2245 2245 u 01 01
2245 2245 s 		LD	A,H
2246 2246 d ce00
2246 2246 u 02 01
2246 2246 s 		ADC	A,0		;Carry it forward
2248 2248 d 57
2248 2248 u 01 01
2248 2248 s 		LD	D,A
2249 2249 d 2a33ff
2249 2249 u 03 01
2249 2249 s 		LD	HL, (FAT1START+2)
224c 224c d 3001
224c 224c u 02 01
224c 224c s 		JR NC,	DRS_0		;Test for Carry
224e 224e d 23
224e 224e u 01 01
224e 224e s 		INC	HL		;Carry it forward
224f 224f d 44
224f 224f u 01 01
224f 224f s DRS_0		LD	B,H
2250 2250 d 4d
2250 2250 u 01 01
2250 2250 s 		LD	C,L		;BCDE now have Sector of FAT desired
2251 2251 d cd9624
2251 2251 u 03 01
2251 2251 s 		CALL	SD_READ_SEC
2254 2254 d d1
2254 2254 u 01 01
2254 2254 s 		POP	DE		;Fetch DE, E=Word within that FAT sector
2255 2255 d 2100fc
2255 2255 u 03 01
2255 2255 s 		LD	HL,SD_RAM_BUFFER
2258 2258 d b7
2258 2258 u 01 01
2258 2258 s 		OR	A		;Clear Carry
2259 2259 d 7b
2259 2259 u 01 01
2259 2259 s 		LD	A,E		;Fetch offset into FAT sector read
225a 225a d 17
225a 225a u 01 01
225a 225a s 		RLA
225b 225b d 6f
225b 225b u 01 01
225b 225b s 		LD	L,A		;
225c 225c d 7c
225c 225c u 01 01
225c 225c s 		LD	A,H
225d 225d d ce00
225d 225d u 02 01
225d 225d s 		ADC	A,0
225f 225f d 67
225f 225f u 01 01
225f 225f s 		LD	H,A		;HL -> FAT Entry
2260 2260 d cd4a0e
2260 2260 u 03 01
2260 2260 s 		CALL	LD_HL_HL	;HL = FAT Entry
2263 2263 d d1
2263 2263 u 01 01
2263 2263 s 		POP	DE
2264 2264 d c1
2264 2264 u 01 01
2264 2264 s 		POP	BC
2265 2265 s 
2265 2265 d 03
2265 2265 u 01 01
2265 2265 s 		INC	BC
2266 2266 d 1b
2266 2266 u 01 01
2266 2266 s 		DEC	DE
2267 2267 d 189b
2267 2267 u 02 01
2267 2267 s 		JR	DR_SEEK_LP
2269 2269 s 
2269 2269 s DR_SEEK_DONE	;Write Registers to FCB
2269 2269 s 		;BC = CRFClus  = The Relative Cluster (ie, the 5th cluster into the file)
2269 2269 s 		;DE = RFClus - Not required (it's a counter down to zero to find the correct cluster)
2269 2269 s 		;HL = CAFClus  = The Absolute or Actual Cluster (ie, Cluster 149 on the disk)
2269 2269 s 
2269 2269 d dd2a08ff
2269 2269 u 04 01
2269 2269 s 		LD	IX,(FCB_PTR)
226d 226d d dd710e
226d 226d u 03 01
226d 226d s 		LD	(IX+CRFClus  ),C	;Save CRFClust to FCB
2270 2270 d dd700f
2270 2270 u 03 01
2270 2270 s 		LD	(IX+CRFClus+1),B
2273 2273 d dd7510
2273 2273 u 03 01
2273 2273 s 		LD	(IX+CAFClus  ),L	;Save CAFClus to FCB
2276 2276 d dd7411
2276 2276 u 03 01
2276 2276 s 		LD	(IX+CAFClus+1),H
2279 2279 s 
2279 2279 s 	;Now, let's find the Data Sector to be loaded....
2279 2279 s 	;First, calculate the Starting Sector of Cluster (SSOC)
2279 2279 s 	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
2279 2279 s 
2279 2279 d 2b
2279 2279 u 01 01
2279 2279 s 		DEC	HL		;HL = CAFClus - 2
227a 227a d 2b
227a 227a u 01 01
227a 227a s 		DEC	HL
227b 227b s 		
227b 227b d eb
227b 227b u 01 01
227b 227b s 		EX	DE,HL
227c 227c s 
227c 227c s ;-------------------------------------	Multiply Routine.  16bit by 8 bit -> 24bit
227c 227c d 0e00
227c 227c u 02 01
227c 227c s 		LD	C,0		;CDE = 16bit input (need 24 bits to shift)
227e 227e d 0608
227e 227e u 02 01
227e 227e s 		LD	B,8		;Go through 8 bits
2280 2280 d dd2121ff
2280 2280 u 04 01
2280 2280 s 		LD	IX, SEC_PER_CLUS	;Fetch Multiplier
2284 2284 d af
2284 2284 u 01 01
2284 2284 s 		XOR	A
2285 2285 d 210000
2285 2285 u 03 01
2285 2285 s 		LD	HL,0		;AHL = 24bit output
2288 2288 s 		
2288 2288 d ddcb000e
2288 2288 u 04 01
2288 2288 s DRSS_LP		RRC	(IX)
228c 228c d 3002
228c 228c u 02 01
228c 228c s 		JR NC,	DRSS_SHIFT
228e 228e d 19
228e 228e u 01 01
228e 228e s 		ADD	HL,DE		;DE=DE+HL
228f 228f d 89
228f 228f u 01 01
228f 228f s 		ADC	A,C
2290 2290 s 
2290 2290 d cb23
2290 2290 u 02 01
2290 2290 s DRSS_SHIFT	SLA	E
2292 2292 d cb12
2292 2292 u 02 01
2292 2292 s 		RL	D
2294 2294 d cb11
2294 2294 u 02 01
2294 2294 s 		RL	C
2296 2296 d 10f0
2296 2296 u 02 01
2296 2296 s 		DJNZ	DRSS_LP
2298 2298 s 	
2298 2298 d 4f
2298 2298 u 01 01
2298 2298 s 		LD	C,A
2299 2299 d 0600
2299 2299 u 02 01
2299 2299 s 		LD	B,0		;BCHL = 32bit Absolute sector
229b 229b s 					;Add to BCHL, the DATASTART sector
229b 229b d ed5b39ff
229b 229b u 04 01
229b 229b s 		LD	DE, (DATASTART)	;32 Bit ADD DATASTART
229f 229f d 19
229f 229f u 01 01
229f 229f s 		ADD	HL, DE
22a0 22a0 d eb
22a0 22a0 u 01 01
22a0 22a0 s 		EX	DE, HL		;DE=DE+START (LSB)
22a1 22a1 d 2a3bff
22a1 22a1 u 03 01
22a1 22a1 s 		LD	HL, (DATASTART+2)
22a4 22a4 d ed4a
22a4 22a4 u 02 01
22a4 22a4 s 		ADC	HL,BC
22a6 22a6 d 4d
22a6 22a6 u 01 01
22a6 22a6 s 		LD	C,L
22a7 22a7 d 44
22a7 22a7 u 01 01
22a7 22a7 s 		LD	B,H		;BC=BC+START (MSB)
22a8 22a8 s ;-------
22a8 22a8 s 					;Save the result to RAM variable SSOC
22a8 22a8 d 2a08ff
22a8 22a8 u 03 01
22a8 22a8 s 		LD	HL,(FCB_PTR)
22ab 22ab d 3e14
22ab 22ab u 02 01
22ab 22ab s 		LD	A,SSOC		;Set FCB(SSOC)
22ad 22ad d 85
22ad 22ad u 01 01
22ad 22ad s 		ADD	A,L
22ae 22ae d 6f
22ae 22ae u 01 01
22ae 22ae s 		LD	L,A		
22af 22af d cd4927
22af 22af u 03 01
22af 22af s 		CALL	MOV_HL_32	;Save the 32 bit register BCDE to (HL)
22b2 22b2 s ;-------
22b2 22b2 s 
22b2 22b2 s 	;ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
22b2 22b2 s DR_SAME_CLUS				;Fetch the RFSec
22b2 22b2 d dd2a08ff
22b2 22b2 u 04 01
22b2 22b2 s 		LD	IX,(FCB_PTR)	;Set FCB(RFSec)
22b6 22b6 d dd5e12
22b6 22b6 u 03 01
22b6 22b6 s 		LD	E,(IX+RFSec)	;DE=RFSec
22b9 22b9 d dd5613
22b9 22b9 u 03 01
22b9 22b9 s 		LD	D,(IX+RFSec+1)
22bc 22bc s 
22bc 22bc d 2a56ff
22bc 22bc u 03 01
22bc 22bc s 		LD	HL,(MOD_FUNC)	;DE = DE % Sectors-Per-Cluster
22bf 22bf d cda00c
22bf 22bf u 03 01
22bf 22bf s 		CALL	VCALL_HL	;A = RFSec MOD SEC_PER_CLUS
22c2 22c2 s 
22c2 22c2 d 010000
22c2 22c2 u 03 01
22c2 22c2 s 		LD	BC,0		;BCDE = (RFSec MOD SEC_PER_CLUS)
22c5 22c5 d 1600
22c5 22c5 u 02 01
22c5 22c5 s 		LD	D,0
22c7 22c7 d 5f
22c7 22c7 u 01 01
22c7 22c7 s 		LD	E,A
22c8 22c8 s 
22c8 22c8 d 2a08ff
22c8 22c8 u 03 01
22c8 22c8 s 		LD	HL,(FCB_PTR)
22cb 22cb d 3e14
22cb 22cb u 02 01
22cb 22cb s 		LD	A,SSOC		;Set FCB(SSOC)
22cd 22cd d 85
22cd 22cd u 01 01
22cd 22cd s 		ADD	A,L
22ce 22ce d 6f
22ce 22ce u 01 01
22ce 22ce s 		LD	L,A		
22cf 22cf d cd5427
22cf 22cf u 03 01
22cf 22cf s 		CALL	ADD_32_HL	;BCDE = SSOC + (RFSec MOD SEC_PER_CLUS)
22d2 22d2 s 					;(HL returns +4) to ABS_SEC
22d2 22d2 s 
22d2 22d2 d cd4927
22d2 22d2 u 03 01
22d2 22d2 s 		CALL	MOV_HL_32	;Save the ABS_SEC
22d5 22d5 s 
22d5 22d5 d cd9624
22d5 22d5 u 03 01
22d5 22d5 s DR_READ_IT	CALL	SD_READ_SEC	;Fetch the Sector
22d8 22d8 s 
22d8 22d8 d 2100fc
22d8 22d8 u 03 01
22d8 22d8 s 		LD	HL,SD_RAM_BUFFER
22db 22db d c9
22db 22db u 01 01
22db 22db s 		RET
22dc 22dc s 
22dc 22dc s 
22dc 22dc s 
22dc 22dc s ;=====================================================================================================
22dc 22dc s ;=====================================================================================================
22dc 22dc s ;SD_CARD_TYPE	.BLOCK	1	;SD CARD TYPE
22dc 22dc s ;SDC_STATUS	.BLOCK	1	;SD Status Code returned
22dc 22dc s ;SD_PARAM	.BLOCK	4	;32 bit address parameter for SD Commands
22dc 22dc s ;SD_PART_TYPE	.BLOCK	1	;SD PARTITION TYPE
22dc 22dc s ;SD_PART_BASE	.BLOCK	4	;SD PARTITION STARTING RECORD
22dc 22dc s ;SD_PART_SIZE	.BLOCK	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
22dc 22dc s ;SEC_PER_CLUS	.BLOCK	1	;0x0D
22dc 22dc s ;RESERVED_SEC	.BLOCK	2	;0x0E - 0x0F
22dc 22dc s ;FAT_COPIES	.BLOCK	1	;0x10
22dc 22dc s ;RT_DIR_ENTRIES	.BLOCK	2	;0x11 - 0x12
22dc 22dc s ;TOT_FILESYS_SEC.BLOCK	4	;0x13 - 0x14 or 0x20 - 0x23
22dc 22dc s ;HIDDEN_SECTORS	.BLOCK	4	;0x1C - 0x1F
22dc 22dc s ;SEC_PER_FAT	.BLOCK	2	;0x16 - 0x17
22dc 22dc s ;FAT1START	.BLOCK	4	;Calculated
22dc 22dc s ;DIR_SECTOR	.BLOCK	4	;Calculated
22dc 22dc s ;DATASTART	.BLOCK	4	;Calculated
22dc 22dc s ;-----------------------------------------------------------------------------
22dc 22dc d 210aff
22dc 22dc u 03 01
22dc 22dc s INIT_FAT	LD	HL,FAT_CLEAR	;Clear RAM
22df 22df d 0639
22df 22df u 02 01
22df 22df s 		LD	B,FAT_CLR_LEN
22e1 22e1 d cd100c
22e1 22e1 u 03 01
22e1 22e1 s 		CALL	CLEAR_BLOCK
22e4 22e4 s 
22e4 22e4 d cd9b25
22e4 22e4 u 03 01
22e4 22e4 s 		CALL	INIT_SDCARD
22e7 22e7 d c0
22e7 22e7 u 01 01
22e7 22e7 s 		RET NZ			;RET NZ IF FAILED
22e8 22e8 s 
22e8 22e8 d cdca0d
22e8 22e8 u 03 01
22e8 22e8 s 		CALL 	PRINTI		;
22eb 22eb d 4d425200
22eb 22eb u 04 02
22eb 22eb s 		DB "MBR",EOS
22ef 22ef s 
22ef 22ef d 010000
22ef 22ef u 03 01
22ef 22ef s 		LD	BC,0		;BCDE = 0x00000000
22f2 22f2 d 110000
22f2 22f2 u 03 01
22f2 22f2 s 		LD	DE,0
22f5 22f5 d cdb424
22f5 22f5 u 03 01
22f5 22f5 s 		CALL	SD_RS_FORCED	;READ MBR (FORCED READ)
22f8 22f8 d cd8324
22f8 22f8 u 03 01
22f8 22f8 s 		CALL	TEST_SIGNATURE
22fb 22fb d c0
22fb 22fb u 01 01
22fb 22fb s 		RET NZ			;RET NZ IF FAILED
22fc 22fc s 
22fc 22fc d cdca0d
22fc 22fc u 03 01
22fc 22fc s 		CALL 	PRINTI		;
22ff 22ff d 205479706500
22ff 22ff u 06 02
22ff 22ff s 		DB " Type",EOS
2305 2305 d 3ac2fd
2305 2305 u 03 01
2305 2305 s 		LD	A, (SD_RAM_BUFFER+01C2h)
2308 2308 d cdf60d
2308 2308 u 03 01
2308 2308 s 		CALL	PUT_BYTE
230b 230b d 3216ff
230b 230b u 03 01
230b 230b s 		LD	(SD_PART_TYPE), A
230e 230e d fe04
230e 230e u 02 01
230e 230e s 		CP	4
2310 2310 d 2809
2310 2310 u 02 01
2310 2310 s 		JR   Z,	INITFAT_PGOOD
2312 2312 d fe06
2312 2312 u 02 01
2312 2312 s 		CP	6
2314 2314 d 2805
2314 2314 u 02 01
2314 2314 s 		JR   Z,	INITFAT_PGOOD
2316 2316 d fe86
2316 2316 u 02 01
2316 2316 s 		CP	86h
2318 2318 d c26b24
2318 2318 u 03 01
2318 2318 s 		JP  NZ,	INITFAT_FAIL
231b 231b s 
231b 231b d 21c6fd
231b 231b u 03 01
231b 231b s INITFAT_PGOOD	LD	HL,SD_RAM_BUFFER+1C6h
231e 231e d 1117ff
231e 231e u 03 01
231e 231e s 		LD	DE,SD_PART_BASE
2321 2321 d 010800
2321 2321 u 03 01
2321 2321 s 		LD	BC,8
2324 2324 d edb0
2324 2324 u 02 01
2324 2324 s 		LDIR		;Copy BASE & SIZE from BUFFER to RAM Variables
2326 2326 d cdca0d
2326 2326 u 03 01
2326 2326 s 		CALL 	PRINTI		;
2329 2329 d 2050425200
2329 2329 u 05 02
2329 2329 s 		DB " PBR",EOS
232e 232e s 
232e 232e d 2117ff
232e 232e u 03 01
232e 232e s 		LD	HL,SD_PART_BASE
2331 2331 d cd3e27
2331 2331 u 03 01
2331 2331 s 		CALL	MOV_32_HL	;Copy BASE to SEC_PTR
2334 2334 d cd9624
2334 2334 u 03 01
2334 2334 s 		CALL	SD_READ_SEC	;READ BOOT RECORD OF PARTITION
2337 2337 d cd8324
2337 2337 u 03 01
2337 2337 s 		CALL	TEST_SIGNATURE
233a 233a d c0
233a 233a u 01 01
233a 233a s 		RET NZ
233b 233b s 
233b 233b d 210bfc
233b 233b u 03 01
233b 233b s 		LD	HL,SD_RAM_BUFFER+0Bh
233e 233e d 111fff
233e 233e u 03 01
233e 233e s 		LD	DE,BYTE_P_SEC
2341 2341 d 010a00
2341 2341 u 03 01
2341 2341 s 		LD	BC,10
2344 2344 d edb0
2344 2344 u 02 01
2344 2344 s 		LDIR	;Copy Description Table to RAM Variables (Up to Total Filesys Sectors)
2346 2346 d eb
2346 2346 u 01 01
2346 2346 s 		EX	DE, HL	;Test TOTAL_FILESYS_SECTORS = 0
2347 2347 d 2b
2347 2347 u 01 01
2347 2347 s 		DEC	HL
2348 2348 d 2b
2348 2348 u 01 01
2348 2348 s 		DEC	HL
2349 2349 d 7e
2349 2349 u 01 01
2349 2349 s 		LD	A,(HL)
234a 234a d 23
234a 234a u 01 01
234a 234a s 		INC	HL
234b 234b d b6
234b 234b u 01 01
234b 234b s 		OR	(HL)
234c 234c d 200c
234c 234c u 02 01
234c 234c s 		JR  NZ,	INITFAT_TFS_OK
234e 234e d 2b
234e 234e u 01 01
234e 234e s 		DEC	HL
234f 234f d eb
234f 234f u 01 01
234f 234f s 		EX	DE, HL	
2350 2350 d 2120fc
2350 2350 u 03 01
2350 2350 s 		LD	HL,SD_RAM_BUFFER+020h
2353 2353 d 010400
2353 2353 u 03 01
2353 2353 s 		LD	BC,4
2356 2356 d edb0
2356 2356 u 02 01
2356 2356 s 		LDIR
2358 2358 d 1807
2358 2358 u 02 01
2358 2358 s 		JR	INITFAT_TFS_DONE
235a 235a s 
235a 235a d af
235a 235a u 01 01
235a 235a s INITFAT_TFS_OK	XOR	A
235b 235b d 23
235b 235b u 01 01
235b 235b s 		INC	HL
235c 235c d 77
235c 235c u 01 01
235c 235c s 		LD	(HL),A
235d 235d d 23
235d 235d u 01 01
235d 235d s 		INC	HL
235e 235e d 77
235e 235e u 01 01
235e 235e s 		LD	(HL),A
235f 235f d 23
235f 235f u 01 01
235f 235f s 		INC	HL
2360 2360 d eb
2360 2360 u 01 01
2360 2360 s 		EX	DE, HL	
2361 2361 s INITFAT_TFS_DONE
2361 2361 s 
2361 2361 d 211cfc
2361 2361 u 03 01
2361 2361 s 		LD	HL,SD_RAM_BUFFER+01Ch
2364 2364 d 010400
2364 2364 u 03 01
2364 2364 s 		LD	BC,4
2367 2367 d edb0
2367 2367 u 02 01
2367 2367 s 		LDIR			;Copy HIDDEN_SECTORS to RAM Variables
2369 2369 d 2116fc
2369 2369 u 03 01
2369 2369 s 		LD	HL,SD_RAM_BUFFER+016h
236c 236c d 010200
236c 236c u 03 01
236c 236c s 		LD	BC,2
236f 236f d edb0
236f 236f u 02 01
236f 236f s 		LDIR			;Copy SECTORS_PER_FAT to RAM Variables
2371 2371 s 
2371 2371 s ;BS.fat1Start = MBR.part1Start + BS.reservedSectors;
2371 2371 d 2a22ff
2371 2371 u 03 01
2371 2371 s 		LD	HL, (RESERVED_SEC)	;H=Reserved Sectors
2374 2374 d eb
2374 2374 u 01 01
2374 2374 s 		EX	DE, HL	
2375 2375 d 2a17ff
2375 2375 u 03 01
2375 2375 s 		LD	HL, (SD_PART_BASE)	;FAT1START = SD_PART_BASE + RESERVED_SEC
2378 2378 d 19
2378 2378 u 01 01
2378 2378 s 		ADD	HL,DE
2379 2379 d 2231ff
2379 2379 u 03 01
2379 2379 s 		LD	(FAT1START), HL
237c 237c d 2a19ff
237c 237c u 03 01
237c 237c s 		LD	HL, (SD_PART_BASE+2)
237f 237f d 3001
237f 237f u 02 01
237f 237f s 		JR  NC,	INITFAT_C1_DONE
2381 2381 d 23
2381 2381 u 01 01
2381 2381 s 		INC	HL
2382 2382 d 2233ff
2382 2382 u 03 01
2382 2382 s INITFAT_C1_DONE	LD	(FAT1START+2), HL
2385 2385 s 
2385 2385 s ;firstDirSector = BS.fat1Start + (BS.fatCopies * BS.sectorsPerFAT);
2385 2385 d 3a24ff
2385 2385 u 03 01
2385 2385 s 		LD	A, (FAT_COPIES)
2388 2388 d 47
2388 2388 u 01 01
2388 2388 s 		LD	B,A
2389 2389 d 2a2fff
2389 2389 u 03 01
2389 2389 s 		LD	HL, (SEC_PER_FAT)
238c 238c d eb
238c 238c u 01 01
238c 238c s 		EX	DE, HL	
238d 238d d 210000
238d 238d u 03 01
238d 238d s 		LD	HL,0
2390 2390 d 19
2390 2390 u 01 01
2390 2390 s INITFAT_C2_LP	ADD	HL,DE
2391 2391 d 10fd
2391 2391 u 02 01
2391 2391 s 		DJNZ	INITFAT_C2_LP	;H = FAT_COPIES * SEC_PER_FAT
2393 2393 d eb
2393 2393 u 01 01
2393 2393 s 		EX	DE, HL		;DE = FATS * SECperFAT
2394 2394 d 2a31ff
2394 2394 u 03 01
2394 2394 s 		LD	HL, (FAT1START)
2397 2397 d 19
2397 2397 u 01 01
2397 2397 s 		ADD	HL,DE		;DIR_SECTOR = FAT1START + FAT_COPIES * SEC_PER_FAT
2398 2398 d 2235ff
2398 2398 u 03 01
2398 2398 s 		LD	(DIR_SECTOR), HL
239b 239b d 2a33ff
239b 239b u 03 01
239b 239b s 		LD	HL, (FAT1START+2)
239e 239e d 3001
239e 239e u 02 01
239e 239e s 		JR  NC,	INITFAT_C2_DONE
23a0 23a0 d 23
23a0 23a0 u 01 01
23a0 23a0 s 		INC	HL
23a1 23a1 d 2237ff
23a1 23a1 u 03 01
23a1 23a1 s INITFAT_C2_DONE	LD	(DIR_SECTOR+2), HL
23a4 23a4 s 
23a4 23a4 s ;DATASTART = DIR_SECTOR + LEN(Directory)
23a4 23a4 s ;          = DIR_SECTOR + ROOTDIR_SIZE * 32 / BYTE_P_SEC
23a4 23a4 d 0610
23a4 23a4 u 02 01
23a4 23a4 s 		LD	B,16		;Maximum # of Reductions
23a6 23a6 d 2a1fff
23a6 23a6 u 03 01
23a6 23a6 s 		LD	HL, (BYTE_P_SEC)	;To fit math into 16 bits, let's reduce "ROOTDIR_SIZE / BYTE_P_SEC"
23a9 23a9 d eb
23a9 23a9 u 01 01
23a9 23a9 s 		EX	DE, HL	;Divide each by 2 while dividable
23aa 23aa d 2a25ff
23aa 23aa u 03 01
23aa 23aa s 		LD	HL, (ROOTDIR_SIZE)	;H=ROOTDIR_SIZE, D=BYTE_P_SEC
23ad 23ad d 7b
23ad 23ad u 01 01
23ad 23ad s INITFAT_C3_LP	LD	A,E
23ae 23ae d 1f
23ae 23ae u 01 01
23ae 23ae s 		RRA
23af 23af d 3829
23af 23af u 02 01
23af 23af s 		JR  C,	INITFAT_C3_0	;If lsb of D is 1, no more Reduction possible
23b1 23b1 d 7d
23b1 23b1 u 01 01
23b1 23b1 s 		LD	A,L
23b2 23b2 d 1f
23b2 23b2 u 01 01
23b2 23b2 s 		RRA
23b3 23b3 d 3825
23b3 23b3 u 02 01
23b3 23b3 s 		JR  C,	INITFAT_C3_0	;If lsb of H is 1, no more Reduction possible
23b5 23b5 d 7a
23b5 23b5 u 01 01
23b5 23b5 s 		LD	A,D
23b6 23b6 d 1f
23b6 23b6 u 01 01
23b6 23b6 s 		RRA
23b7 23b7 d 57
23b7 23b7 u 01 01
23b7 23b7 s 		LD	D,A
23b8 23b8 d 7b
23b8 23b8 u 01 01
23b8 23b8 s 		LD	A,E
23b9 23b9 d 1f
23b9 23b9 u 01 01
23b9 23b9 s 		RRA
23ba 23ba d 5f
23ba 23ba u 01 01
23ba 23ba s 		LD	E,A
23bb 23bb d 7c
23bb 23bb u 01 01
23bb 23bb s 		LD	A,H
23bc 23bc d 1f
23bc 23bc u 01 01
23bc 23bc s 		RRA
23bd 23bd d 67
23bd 23bd u 01 01
23bd 23bd s 		LD	H,A
23be 23be d 7d
23be 23be u 01 01
23be 23be s 		LD	A,L
23bf 23bf d 1f
23bf 23bf u 01 01
23bf 23bf s 		RRA
23c0 23c0 d 6f
23c0 23c0 u 01 01
23c0 23c0 s 		LD	L,A
23c1 23c1 d 10ea
23c1 23c1 u 02 01
23c1 23c1 s 		DJNZ	INITFAT_C3_LP
23c3 23c3 s 
23c3 23c3 d cdca0d
23c3 23c3 u 03 01
23c3 23c3 s INITFAT_C3_ERR	CALL 	PRINTI		;
23c6 23c6 d 204572726f722044415441535441525400
23c6 23c6 u 11 02
23c6 23c6 s 		DB " Error DATASTART",EOS
23d7 23d7 d af
23d7 23d7 u 01 01
23d7 23d7 s 		XOR	A
23d8 23d8 d 3d
23d8 23d8 u 01 01
23d8 23d8 s 		DEC	A
23d9 23d9 d c9
23d9 23d9 u 01 01
23d9 23d9 s 		RET
23da 23da s 		
23da 23da d 0605
23da 23da u 02 01
23da 23da s INITFAT_C3_0	LD	B,5		;5 shifts = Multiply 32
23dc 23dc d 29
23dc 23dc u 01 01
23dc 23dc s INITFAT_C3_LP2	ADD	HL,HL		;Double H
23dd 23dd d dac323
23dd 23dd u 03 01
23dd 23dd s 		JP C,	INITFAT_C3_ERR
23e0 23e0 d 10fa
23e0 23e0 u 02 01
23e0 23e0 s 		DJNZ	INITFAT_C3_LP2
23e2 23e2 s 
23e2 23e2 d 7b
23e2 23e2 u 01 01
23e2 23e2 s 		LD	A,E		;2'S Complement BYTE_P_SEC
23e3 23e3 d 2f
23e3 23e3 u 01 01
23e3 23e3 s 		CPL
23e4 23e4 d 4f
23e4 23e4 u 01 01
23e4 23e4 s 		LD	C,A
23e5 23e5 d 7a
23e5 23e5 u 01 01
23e5 23e5 s 		LD	A,D
23e6 23e6 d 2f
23e6 23e6 u 01 01
23e6 23e6 s 		CPL
23e7 23e7 d 47
23e7 23e7 u 01 01
23e7 23e7 s 		LD	B,A
23e8 23e8 d 03
23e8 23e8 u 01 01
23e8 23e8 s 		INC	BC
23e9 23e9 d 11ffff
23e9 23e9 u 03 01
23e9 23e9 s 		LD	DE,0FFFFh	;Start with -1
23ec 23ec d 09
23ec 23ec u 01 01
23ec 23ec s INITFAT_C3_LP3	ADD	HL,BC		;Divide by counting Subtractions
23ed 23ed d 13
23ed 23ed u 01 01
23ed 23ed s 		INC	DE
23ee 23ee d 38fc
23ee 23ee u 02 01
23ee 23ee s 		JR   C,	INITFAT_C3_LP3
23f0 23f0 d 2a35ff
23f0 23f0 u 03 01
23f0 23f0 s 		LD	HL, (DIR_SECTOR)	;Add the Dword at DIR_SECTOR
23f3 23f3 d 19
23f3 23f3 u 01 01
23f3 23f3 s 		ADD	HL,DE
23f4 23f4 d 2239ff
23f4 23f4 u 03 01
23f4 23f4 s 		LD	(DATASTART), HL
23f7 23f7 d 2a37ff
23f7 23f7 u 03 01
23f7 23f7 s 		LD	HL, (DIR_SECTOR+2)
23fa 23fa d 3001
23fa 23fa u 02 01
23fa 23fa s 		JR  NC,	INITFAT_C3_1
23fc 23fc d 23
23fc 23fc u 01 01
23fc 23fc s 		INC	HL
23fd 23fd d 223bff
23fd 23fd u 03 01
23fd 23fd s INITFAT_C3_1	LD	(DATASTART+2), HL
2400 2400 s 
2400 2400 d 3a21ff
2400 2400 u 03 01
2400 2400 s 		LD	A, (SEC_PER_CLUS)	;Determine the best way to divide Sectors into cluster#
2403 2403 d 3d
2403 2403 u 01 01
2403 2403 s 		DEC	A
2404 2404 d 3258ff
2404 2404 u 03 01
2404 2404 s 		LD	(MODMASK), A
2407 2407 d 3c
2407 2407 u 01 01
2407 2407 s 		INC	A
2408 2408 d 284b
2408 2408 u 02 01
2408 2408 s 		JR   Z,	INITFAT_FAIL1
240a 240a d 010008
240a 240a u 03 01
240a 240a s 		LD	BC,0800h
240d 240d d 1f
240d 240d u 01 01
240d 240d s INITFAT_C4_LP	RRA
240e 240e d 3002
240e 240e u 02 01
240e 240e s 		JR  NC,	INITFAT_C4_1
2410 2410 d 50
2410 2410 u 01 01
2410 2410 s 		LD	D,B		;Save location of "1" bit
2411 2411 d 0c
2411 2411 u 01 01
2411 2411 s 		INC	C		;Count of 1 bits.
2412 2412 d 10f9
2412 2412 u 02 01
2412 2412 s INITFAT_C4_1	DJNZ	INITFAT_C4_LP
2414 2414 d 3e01
2414 2414 u 02 01
2414 2414 s 		LD	A,1
2416 2416 d b9
2416 2416 u 01 01
2416 2416 s 		CP	C
2417 2417 d 200f
2417 2417 u 02 01
2417 2417 s 		JR  NZ,	INITFAT_C4_2	;More than 1 "1" bit, cannot do divide by simple shift.
2419 2419 d 7a
2419 2419 u 01 01
2419 2419 s 		LD	A,D		;Fetch position of the 1 bit.  8=lsb, 1=msb
241a 241a d 2f
241a 241a u 01 01
241a 241a s 		CPL
241b 241b d c60a
241b 241b u 02 01
241b 241b s 		ADD	A,10		;Re-adjust to make 1=lsb AND 8=msb  A=9-A
241d 241d d 3254ff
241d 241d u 03 01
241d 241d s 		LD	(DF_SHIFTCNT), A
2420 2420 d 212c27
2420 2420 u 03 01
2420 2420 s 		LD	HL,DIVBYSHIFT	;Use fast shift divider
2423 2423 d 113927
2423 2423 u 03 01
2423 2423 s 		LD	DE,MODBYMASK
2426 2426 d 1805
2426 2426 u 02 01
2426 2426 s 		JR	INITFAT_C4_3
2428 2428 s 
2428 2428 d 211427
2428 2428 u 03 01
2428 2428 s INITFAT_C4_2	LD	HL,DIV16BY8SPC	;Use Full Divide function for Sectors Per Cluster
242b 242b d e5
242b 242b u 01 01
242b 242b s 		PUSH	HL
242c 242c d d1
242c 242c u 01 01
242c 242c s 		POP	DE
242d 242d d 2252ff
242d 242d u 03 01
242d 242d s INITFAT_C4_3	LD	(DIVIDE_FUNC), HL
2430 2430 d eb
2430 2430 u 01 01
2430 2430 s 		EX	DE, HL	
2431 2431 d 2256ff
2431 2431 u 03 01
2431 2431 s 		LD	(MOD_FUNC), HL
2434 2434 s 
2434 2434 d cdca0d
2434 2434 u 03 01
2434 2434 s 		CALL 	PRINTI		;
2437 2437 d 20564f4c3d00
2437 2437 u 06 02
2437 2437 s 		DB " VOL=",EOS
243d 243d d 212bfc
243d 243d u 03 01
243d 243d s 		LD	HL,SD_RAM_BUFFER+002Bh
2440 2440 d 060b
2440 2440 u 02 01
2440 2440 s 		LD	B,11
2442 2442 d cdd00d
2442 2442 u 03 01
2442 2442 s 		CALL	PRINTB
2445 2445 d cdca0d
2445 2445 u 03 01
2445 2445 s 		CALL 	PRINTI		;
2448 2448 d 205359533d00
2448 2448 u 06 02
2448 2448 s 		DB " SYS=",EOS
244e 244e d 0608
244e 244e u 02 01
244e 244e s 		LD	B,8
2450 2450 d cdd00d
2450 2450 u 03 01
2450 2450 s 		CALL	PRINTB
2453 2453 d af
2453 2453 u 01 01
2453 2453 s 		XOR	A
2454 2454 d c9
2454 2454 u 01 01
2454 2454 s 		RET
2455 2455 s 
2455 2455 d cdca0d
2455 2455 u 03 01
2455 2455 s INITFAT_FAIL1	CALL 	PRINTI		;
2458 2458 d 0d0a4572726f723d30205365632f436c757300
2458 2458 u 13 02
2458 2458 s 		DB CR,LF,"Error=0 Sec/Clus",EOS
246b 246b d cdca0d
246b 246b u 03 01
246b 246b s INITFAT_FAIL	CALL 	PRINTI		;
246e 246e d 0d0a46415420496e6974204641494c454400
246e 246e u 12 02
246e 246e s 		DB CR,LF,"FAT Init FAILED",EOS
2480 2480 d af
2480 2480 u 01 01
2480 2480 s 		XOR	A
2481 2481 d 3d
2481 2481 u 01 01
2481 2481 s 		DEC	A
2482 2482 d c9
2482 2482 u 01 01
2482 2482 s 		RET
2483 2483 s 
2483 2483 s ;-------------------------------------------------
2483 2483 d cdca0d
2483 2483 u 03 01
2483 2483 s TEST_SIGNATURE	CALL 	PRINTI		;
2486 2486 d 205300
2486 2486 u 03 02
2486 2486 s 		DB " S",EOS
2489 2489 d 2b
2489 2489 u 01 01
2489 2489 s 		DEC	HL
248a 248a d 3eaa
248a 248a u 02 01
248a 248a s 		LD	A,0AAh
248c 248c d be
248c 248c u 01 01
248c 248c s 		CP	(HL)
248d 248d d 20dc
248d 248d u 02 01
248d 248d s 		JR  NZ,	INITFAT_FAIL
248f 248f d 2b
248f 248f u 01 01
248f 248f s 		DEC	HL
2490 2490 d 3e55
2490 2490 u 02 01
2490 2490 s 		LD	A,055h
2492 2492 d be
2492 2492 u 01 01
2492 2492 s 		CP	(HL)
2493 2493 d 20d6
2493 2493 u 02 01
2493 2493 s 		JR  NZ,	INITFAT_FAIL
2495 2495 d c9
2495 2495 u 01 01
2495 2495 s 		RET
2496 2496 s 
2496 2496 s 
2496 2496 s 
2496 2496 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2496 2496 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2496 2496 s ;	Chapter_15	SD Memory Card Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
2496 2496 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2496 2496 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2496 2496 s 
2496 2496 s ;-----------------------------------------------------------------------------------------------------
2496 2496 s ;Read the SD Card at Sector BCDE TO the SD_RAM_BUFFER
2496 2496 s ;-----------------------------------------------------------------------------------------------------
2496 2496 s 		;Sector in SEC_PTR
2496 2496 d 213dff
2496 2496 u 03 01
2496 2496 s SD_READ_SEC	LD	HL,SEC_PTR	;READ SECTOR
2499 2499 d cd7827
2499 2499 u 03 01
2499 2499 s 		CALL	CMP_HL_32
249c 249c d c8
249c 249c u 01 01
249c 249c s 		RET Z			;Return if no change to sector being read
249d 249d s 
249d 249d d 3a0fff
249d 249d u 03 01
249d 249d s 		LD	A, (DIRTY_DATA)	;Test if flush required
24a0 24a0 d b7
24a0 24a0 u 01 01
24a0 24a0 s 		OR	A
24a1 24a1 d cab424
24a1 24a1 u 03 01
24a1 24a1 s 		JP Z,	SD_RS_FORCED	;Jump if no change in SD RAM BUFFER
24a4 24a4 d af
24a4 24a4 u 01 01
24a4 24a4 s 		XOR	A
24a5 24a5 d 320fff
24a5 24a5 u 03 01
24a5 24a5 s 		LD	(DIRTY_DATA), A	;Clear Write Flag
24a8 24a8 s 
24a8 24a8 d c5
24a8 24a8 u 01 01
24a8 24a8 s 		PUSH	BC		;Save BCDE (Sector to Read)
24a9 24a9 d d5
24a9 24a9 u 01 01
24a9 24a9 s 		PUSH	DE
24aa 24aa d e5
24aa 24aa u 01 01
24aa 24aa s 		PUSH	HL
24ab 24ab d cd3e27
24ab 24ab u 03 01
24ab 24ab s 		CALL	MOV_32_HL	;Fetch the last SEC_PTR
24ae 24ae s 
24ae 24ae s ;		CALL	PRINTI		;debug
24ae 24ae s ;		DB  " Write:",EOS	;debug
24ae 24ae s ;		CALL	PUT_BC		;debug
24ae 24ae s ;		CALL	PUT_DE		;debug
24ae 24ae s 
24ae 24ae d cdf424
24ae 24ae u 03 01
24ae 24ae s 		CALL	SD_WRITE_SEC
24b1 24b1 d e1
24b1 24b1 u 01 01
24b1 24b1 s 		POP	HL
24b2 24b2 d d1
24b2 24b2 u 01 01
24b2 24b2 s 		POP	DE
24b3 24b3 d c1
24b3 24b3 u 01 01
24b3 24b3 s 		POP	BC
24b4 24b4 s 		
24b4 24b4 s SD_RS_FORCED
24b4 24b4 s 	;CALL	PRINTI		;debug
24b4 24b4 s 	;DB  " Read:",EOS	;debug
24b4 24b4 s 	;CALL	PUT_BC		;debug
24b4 24b4 s 	;CALL	PUT_DE		;debug
24b4 24b4 s 
24b4 24b4 d 213dff
24b4 24b4 u 03 01
24b4 24b4 s 		LD	HL,SEC_PTR
24b7 24b7 d cd4927
24b7 24b7 u 03 01
24b7 24b7 s 		CALL	MOV_HL_32	;Save Sector in SEC_PTR
24ba 24ba d cd7225
24ba 24ba u 03 01
24ba 24ba s 		CALL	SET_PARAM	;READ SECTOR, HL=SD_RAM_BUFFER
24bd 24bd d 0605
24bd 24bd u 02 01
24bd 24bd s 		LD	B,5		;5 Retries to read
24bf 24bf d 3e11
24bf 24bf u 02 01
24bf 24bf s SD_RS_LP0	LD	A,17 		;Read Sector Command
24c1 24c1 d cd9526
24c1 24c1 u 03 01
24c1 24c1 s 		CALL	SD_CMD
24c4 24c4 d 2807
24c4 24c4 u 02 01
24c4 24c4 s 		JR Z,	SD_RS_0
24c6 24c6 d 10f7
24c6 24c6 u 02 01
24c6 24c6 s 		DJNZ	SD_RS_LP0
24c8 24c8 s 					;Read failed
24c8 24c8 d 05
24c8 24c8 u 01 01
24c8 24c8 s 		DEC	B		;Clear Zero flag
24c9 24c9 d cd7d26
24c9 24c9 u 03 01
24c9 24c9 s 		CALL	SD_DESELECT	;Deselect card
24cc 24cc s 	;CALL	PRINTI	;debug
24cc 24cc s 	;DB  " #1",EOS	;debug
24cc 24cc d c9
24cc 24cc u 01 01
24cc 24cc s 		RET
24cd 24cd s 
24cd 24cd d 0600
24cd 24cd u 02 01
24cd 24cd s SD_RS_0		LD	B,0		;256 Attempts to recieve the DATASTART
24cf 24cf d cdde26
24cf 24cf u 03 01
24cf 24cf s SD_RS_LP1	CALL	SPI_RX
24d2 24d2 d fefe
24d2 24d2 u 02 01
24d2 24d2 s 		CP	0FEh		;IS DATASTART?
24d4 24d4 d 2806
24d4 24d4 u 02 01
24d4 24d4 s 		JR Z,	SD_RS_1
24d6 24d6 d 10f7
24d6 24d6 u 02 01
24d6 24d6 s 		DJNZ	SD_RS_LP1
24d8 24d8 d cd7d26
24d8 24d8 u 03 01
24d8 24d8 s 		CALL	SD_DESELECT	;Deselect card
24db 24db s 	;CALL	PRINTI	;debug
24db 24db s 	;DB  " #2",EOS	;debug
24db 24db d c9
24db 24db u 01 01
24db 24db s 		RET
24dc 24dc s 
24dc 24dc d 010002
24dc 24dc u 03 01
24dc 24dc s SD_RS_1		LD	BC,0200h
24df 24df d cdde26
24df 24df u 03 01
24df 24df s SD_RS_LP2	CALL	SPI_RX		;Fetch 512 Bytes to M(HL)
24e2 24e2 d 77
24e2 24e2 u 01 01
24e2 24e2 s 		LD	(HL),A
24e3 24e3 d 23
24e3 24e3 u 01 01
24e3 24e3 s 		INC	HL
24e4 24e4 d 0d
24e4 24e4 u 01 01
24e4 24e4 s 		DEC	C
24e5 24e5 d 20f8
24e5 24e5 u 02 01
24e5 24e5 s 		JR NZ,	SD_RS_LP2
24e7 24e7 d 10f6
24e7 24e7 u 02 01
24e7 24e7 s 		DJNZ	SD_RS_LP2
24e9 24e9 s 
24e9 24e9 d cdde26
24e9 24e9 u 03 01
24e9 24e9 s 		CALL	SPI_RX		;BURN 2 BYTES (CRC)
24ec 24ec d cdde26
24ec 24ec u 03 01
24ec 24ec s 		CALL	SPI_RX		;
24ef 24ef d cd7d26
24ef 24ef u 03 01
24ef 24ef s 		CALL	SD_DESELECT	;Deselect card
24f2 24f2 s 	;CALL	PRINTI	;debug
24f2 24f2 s 	;DB  " #3",EOS	;debug
24f2 24f2 d af
24f2 24f2 u 01 01
24f2 24f2 s 		XOR	A
24f3 24f3 d c9
24f3 24f3 u 01 01
24f3 24f3 s 		RET
24f4 24f4 s 
24f4 24f4 s 
24f4 24f4 s 
24f4 24f4 s ;-----------------------------------------------------------------------------------------------------
24f4 24f4 s ;Write the SD_RAM_BUFFER to the SD Card at Sector 'SEC_PTR'
24f4 24f4 s ;-----------------------------------------------------------------------------------------------------
24f4 24f4 s 		;Sector in SEC_PTR, H=SD_RAM_BUFFER
24f4 24f4 d af
24f4 24f4 u 01 01
24f4 24f4 s SD_WRITE_SEC	XOR	A
24f5 24f5 d d3c6
24f5 24f5 u 02 01
24f5 24f5 s 		OUT	(GREEN_LED),A
24f7 24f7 d cd7225
24f7 24f7 u 03 01
24f7 24f7 s 		CALL	SET_PARAM
24fa 24fa d 3e18
24fa 24fa u 02 01
24fa 24fa s 		LD	A,24 	;Write Sector Command
24fc 24fc d cd9526
24fc 24fc u 03 01
24fc 24fc s 		CALL	SD_CMD
24ff 24ff d 3e01
24ff 24ff u 02 01
24ff 24ff s 		LD	A,1 	;Error Code
2501 2501 d c25725
2501 2501 u 03 01
2501 2501 s 		JP NZ,	SD_WR_FAIL
2504 2504 s 
2504 2504 d 3efe
2504 2504 u 02 01
2504 2504 s 		LD	A,0FEh	;DATA START BLOCK
2506 2506 d cde026
2506 2506 u 03 01
2506 2506 s 		CALL	SPI_TX
2509 2509 d 010002
2509 2509 u 03 01
2509 2509 s 		LD	BC,0200h
250c 250c d 7e
250c 250c u 01 01
250c 250c s SD_WR_LP	LD	A,(HL)
250d 250d d 23
250d 250d u 01 01
250d 250d s 		INC	HL
250e 250e d cde026
250e 250e u 03 01
250e 250e s 		CALL	SPI_TX
2511 2511 d 0d
2511 2511 u 01 01
2511 2511 s 		DEC	C
2512 2512 d c20c25
2512 2512 u 03 01
2512 2512 s 		JP NZ,	SD_WR_LP
2515 2515 d 10f5
2515 2515 u 02 01
2515 2515 s 		DJNZ	SD_WR_LP
2517 2517 s 
2517 2517 d 3eff
2517 2517 u 02 01
2517 2517 s 		LD	A,0FFh
2519 2519 d cde026
2519 2519 u 03 01
2519 2519 s 		CALL	SPI_TX
251c 251c d 00
251c 251c u 01 01
251c 251c s 		NOP
251d 251d d 3eff
251d 251d u 02 01
251d 251d s 		LD	A,0FFh
251f 251f d cde026
251f 251f u 03 01
251f 251f s 		CALL	SPI_TX
2522 2522 s 
2522 2522 d cdde26
2522 2522 u 03 01
2522 2522 s 		CALL	SPI_RX
2525 2525 d e61f
2525 2525 u 02 01
2525 2525 s 		AND	1Fh
2527 2527 d fe05
2527 2527 u 02 01
2527 2527 s 		CP	5
2529 2529 d 3e02
2529 2529 u 02 01
2529 2529 s 		LD	A,2 	;Error Code
252b 252b d c25725
252b 252b u 03 01
252b 252b s 		JP NZ,	SD_WR_FAIL
252e 252e d cdf426
252e 252e u 03 01
252e 252e s 		CALL	WAIT_NOT_BUSY
2531 2531 d 3e03
2531 2531 u 02 01
2531 2531 s 		LD	A,3 	;Error Code
2533 2533 d da5725
2533 2533 u 03 01
2533 2533 s 		JP C,	SD_WR_FAIL
2536 2536 d cd8d25
2536 2536 u 03 01
2536 2536 s 		CALL	SD_CLEAR_ARG
2539 2539 d 3e0d
2539 2539 u 02 01
2539 2539 s 		LD	A,13		;SEND_STATUS
253b 253b d cd9526
253b 253b u 03 01
253b 253b s 		CALL	SD_CMD
253e 253e d 3e04
253e 253e u 02 01
253e 253e s 		LD	A,4 	;Error Code
2540 2540 d c25725
2540 2540 u 03 01
2540 2540 s 		JP NZ,	SD_WR_FAIL
2543 2543 d cdde26
2543 2543 u 03 01
2543 2543 s 		CALL	SPI_RX
2546 2546 d b7
2546 2546 u 01 01
2546 2546 s 		OR	A
2547 2547 d 3e05
2547 2547 u 02 01
2547 2547 s 		LD	A,5 	;Error Code
2549 2549 d c25725
2549 2549 u 03 01
2549 2549 s 		JP NZ,	SD_WR_FAIL
254c 254c s 
254c 254c d af
254c 254c u 01 01
254c 254c s 		XOR	A		;A should be zero
254d 254d d 320fff
254d 254d u 03 01
254d 254d s 		LD	(DIRTY_DATA), A
2550 2550 s 
2550 2550 d cd9026
2550 2550 u 03 01
2550 2550 s 		CALL	SD_DELAY
2553 2553 s 
2553 2553 d cd7d26
2553 2553 u 03 01
2553 2553 s 		CALL	SD_DESELECT	;Deselect card
2556 2556 d c9
2556 2556 u 01 01
2556 2556 s 		RET
2557 2557 s 
2557 2557 d cd7d26
2557 2557 u 03 01
2557 2557 s SD_WR_FAIL	CALL	SD_DESELECT	;Deselect card
255a 255a d cdca0d
255a 255a u 03 01
255a 255a s 		CALL	PRINTI
255d 255d d 0d0a2d5772697465204661696c65643a00
255d 255d u 11 02
255d 255d s 		DB CR,LF,"-Write Failed:",EOS
256e 256e d cdf60d
256e 256e u 03 01
256e 256e s 		CALL	PUT_BYTE
2571 2571 d c9
2571 2571 u 01 01
2571 2571 s 		RET
2572 2572 s 
2572 2572 s ;-----------------------------------------------------------------------------------------------------
2572 2572 s ;Input:	Sector in 32 bit register BCDE
2572 2572 d 3a10ff
2572 2572 u 03 01
2572 2572 s SET_PARAM	LD	A, (SD_CARD_TYPE)	;IF CARD_TYPE <> 3 THEN SHIFT SECTOR << 9 Bits
2575 2575 d fe03
2575 2575 u 02 01
2575 2575 s 		CP	3
2577 2577 d ca8325
2577 2577 u 03 01
2577 2577 s 		JP Z,	SP_RET
257a 257a s 
257a 257a d 79
257a 257a u 01 01
257a 257a s 		LD	A,C
257b 257b d eb
257b 257b u 01 01
257b 257b s 		EX	DE, HL	
257c 257c d 29
257c 257c u 01 01
257c 257c s 		ADD	HL,HL
257d 257d d 17
257d 257d u 01 01
257d 257d s 		RLA
257e 257e d 47
257e 257e u 01 01
257e 257e s 		LD	B,A
257f 257f d 4c
257f 257f u 01 01
257f 257f s 		LD	C,H
2580 2580 d 55
2580 2580 u 01 01
2580 2580 s 		LD	D,L
2581 2581 d 1e00
2581 2581 u 02 01
2581 2581 s 		LD	E,0
2583 2583 s 
2583 2583 d 2112ff
2583 2583 u 03 01
2583 2583 s SP_RET		LD	HL,SD_PARAM
2586 2586 d cd4927
2586 2586 u 03 01
2586 2586 s 		CALL	MOV_HL_32		;Save Parameter
2589 2589 d 2100fc
2589 2589 u 03 01
2589 2589 s 		LD	HL,SD_RAM_BUFFER	;Set buffer space
258c 258c d c9
258c 258c u 01 01
258c 258c s 		RET
258d 258d s 
258d 258d s ;-----------------------------------------------------------------------------------------------------
258d 258d d af
258d 258d u 01 01
258d 258d s SD_CLEAR_ARG	XOR	A
258e 258e d 3212ff
258e 258e u 03 01
258e 258e s 		LD	(SD_PARAM),A
2591 2591 d 3213ff
2591 2591 u 03 01
2591 2591 s 		LD	(SD_PARAM+1),A
2594 2594 d 3214ff
2594 2594 u 03 01
2594 2594 s 		LD	(SD_PARAM+2),A
2597 2597 d 3215ff
2597 2597 u 03 01
2597 2597 s 		LD	(SD_PARAM+3),A
259a 259a d c9
259a 259a u 01 01
259a 259a s 		RET
259b 259b s 
259b 259b s 
259b 259b s ;=====================================================================================================
259b 259b s ;SD Memory Car Routines, Low Level, INIT CARD, Send/Recieve Data, Send Commands
259b 259b s ;=====================================================================================================
259b 259b s ;-------------------------------- INIT SDCARD --------------------------------
259b 259b d cd7d26
259b 259b u 03 01
259b 259b s INIT_SDCARD	CALL	SD_DESELECT	;Deselect and clock the card many cycles
259e 259e d 0680
259e 259e u 02 01
259e 259e s 		LD	B,080H
25a0 25a0 d 3eff
25a0 25a0 u 02 01
25a0 25a0 s ISD_0		LD	A,0FFH
25a2 25a2 d 3210ff
25a2 25a2 u 03 01
25a2 25a2 s 		LD	(SD_CARD_TYPE),A
25a5 25a5 d cde026
25a5 25a5 u 03 01
25a5 25a5 s 		CALL	SPI_TX		;CLOCK many cycles
25a8 25a8 d 10f6
25a8 25a8 u 02 01
25a8 25a8 s 		DJNZ	ISD_0		;256 Clocks
25aa 25aa d cd8826
25aa 25aa u 03 01
25aa 25aa s 		CALL	SD_SELECT
25ad 25ad s 
25ad 25ad d cdca0d
25ad 25ad u 03 01
25ad 25ad s 		CALL 	PRINTI		;
25b0 25b0 d 0d0a496e697420534400
25b0 25b0 u 0a 02
25b0 25b0 s 		DB	CR,LF,"Init SD",EOS
25ba 25ba s 
25ba 25ba d cd8d25
25ba 25ba u 03 01
25ba 25ba s 		CALL	SD_CLEAR_ARG	;Fetch the 01 response
25bd 25bd d 0600
25bd 25bd u 02 01
25bd 25bd s 		LD	B,0		;256 retries
25bf 25bf d 3e00
25bf 25bf u 02 01
25bf 25bf s ISD_LP1		LD	A,0		;CMD 0
25c1 25c1 d cd9526
25c1 25c1 u 03 01
25c1 25c1 s 		CALL	SD_CMD
25c4 25c4 s 		;CALL	PUT_BYTE
25c4 25c4 d fe01
25c4 25c4 u 02 01
25c4 25c4 s 		CP	1		;Test 01 response
25c6 25c6 d 2813
25c6 25c6 u 02 01
25c6 25c6 s 		JR  Z,	ISD_1
25c8 25c8 d 10f5
25c8 25c8 u 02 01
25c8 25c8 s 		DJNZ	ISD_LP1
25ca 25ca s 		
25ca 25ca d cdca0d
25ca 25ca u 03 01
25ca 25ca s INIT_FAIL	CALL 	PRINTI		;
25cd 25cd d 2d4641494c454400
25cd 25cd u 08 02
25cd 25cd s 		DB	"-FAILED",EOS
25d5 25d5 d cd7d26
25d5 25d5 u 03 01
25d5 25d5 s 		CALL	SD_DESELECT
25d8 25d8 d af
25d8 25d8 u 01 01
25d8 25d8 s 		XOR	A		;Return Zero Flag cleared = Failure
25d9 25d9 d 3d
25d9 25d9 u 01 01
25d9 25d9 s 		DEC	A
25da 25da d c9
25da 25da u 01 01
25da 25da s 		RET
25db 25db s 
25db 25db d cdca0d
25db 25db u 03 01
25db 25db s ISD_1		CALL 	PRINTI		;
25de 25de d 20547970652300
25de 25de u 07 02
25de 25de s 		DB	" Type#",EOS
25e5 25e5 d 21aa01
25e5 25e5 u 03 01
25e5 25e5 s 		LD	HL,01AAh	;Deterimine Card Type
25e8 25e8 d 2212ff
25e8 25e8 u 03 01
25e8 25e8 s 		LD	(SD_PARAM),HL
25eb 25eb d 3e08
25eb 25eb u 02 01
25eb 25eb s 		LD	A,8		;CMD 8
25ed 25ed d cd9526
25ed 25ed u 03 01
25ed 25ed s 		CALL	SD_CMD
25f0 25f0 d e604
25f0 25f0 u 02 01
25f0 25f0 s 		AND	4
25f2 25f2 d 2808
25f2 25f2 u 02 01
25f2 25f2 s 		JR   Z,	ISD_2
25f4 25f4 d 3e01
25f4 25f4 u 02 01
25f4 25f4 s 		LD	A,1		;If CMD8 is Illegal Cmd, CARD_TYPE=1
25f6 25f6 d 3210ff
25f6 25f6 u 03 01
25f6 25f6 s 		LD	(SD_CARD_TYPE),A
25f9 25f9 d c31626
25f9 25f9 u 03 01
25f9 25f9 s 		JP	ISD_3
25fc 25fc s 
25fc 25fc d cdde26
25fc 25fc u 03 01
25fc 25fc s ISD_2		CALL	SPI_RX
25ff 25ff d cdde26
25ff 25ff u 03 01
25ff 25ff s 		CALL	SPI_RX
2602 2602 d cdde26
2602 2602 u 03 01
2602 2602 s 		CALL	SPI_RX
2605 2605 d cdde26
2605 2605 u 03 01
2605 2605 s 		CALL	SPI_RX
2608 2608 d 3211ff
2608 2608 u 03 01
2608 2608 s 		LD	(SDC_STATUS),A
260b 260b d feaa
260b 260b u 02 01
260b 260b s 		CP	0AAh
260d 260d d 3eaa
260d 260d u 02 01
260d 260d s 		LD	A,0AAh		;Error code
260f 260f d 20b9
260f 260f u 02 01
260f 260f s 		JR  NZ,	INIT_FAIL
2611 2611 d 3e02
2611 2611 u 02 01
2611 2611 s 		LD	A,2
2613 2613 d 3210ff
2613 2613 u 03 01
2613 2613 s 		LD	(SD_CARD_TYPE),A
2616 2616 s 
2616 2616 d cd090e
2616 2616 u 03 01
2616 2616 s ISD_3		CALL	PUT_HEX
2619 2619 d cdca0d
2619 2619 u 03 01
2619 2619 s 		CALL 	PRINTI		;
261c 261c d 2041434d44343100
261c 261c u 08 02
261c 261c s 		DB	" ACMD41",EOS
2624 2624 d cd8d25
2624 2624 u 03 01
2624 2624 s 		CALL	SD_CLEAR_ARG
2627 2627 s 
2627 2627 d 0600
2627 2627 u 02 01
2627 2627 s 		LD	B,0
2629 2629 d 3e37
2629 2629 u 02 01
2629 2629 s ISD_LP2		LD	A,55		;CMD 55 (ACMD)
262b 262b d cd9526
262b 262b u 03 01
262b 262b s 		CALL	SD_CMD
262e 262e d 3e29
262e 262e u 02 01
262e 262e s 		LD	A,41		;CMD 41
2630 2630 d cd9526
2630 2630 u 03 01
2630 2630 s 		CALL	SD_CMD
2633 2633 d fe00
2633 2633 u 02 01
2633 2633 s 		CP	0
2635 2635 d 2808
2635 2635 u 02 01
2635 2635 s 		JR Z,	ISD_4
2637 2637 d af
2637 2637 u 01 01
2637 2637 s 		XOR	A		;256 ~= 2mSec Delay
2638 2638 d cd9026
2638 2638 u 03 01
2638 2638 s 		CALL	SD_DELAY
263b 263b d 10ec
263b 263b u 02 01
263b 263b s 		DJNZ	ISD_LP2
263d 263d d 188b
263d 263d u 02 01
263d 263d s 		JR	INIT_FAIL
263f 263f s 
263f 263f d cdca0d
263f 263f u 03 01
263f 263f s ISD_4		CALL 	PRINTI		;
2642 2642 d 2b00
2642 2642 u 02 02
2642 2642 s 		DB	"+",EOS
2644 2644 d 3a10ff
2644 2644 u 03 01
2644 2644 s 		LD	A,(SD_CARD_TYPE)
2647 2647 d fe02
2647 2647 u 02 01
2647 2647 s 		CP	2
2649 2649 d 202d
2649 2649 u 02 01
2649 2649 s 		JR  NZ,	ISD_6
264b 264b d 3e3a
264b 264b u 02 01
264b 264b s 		LD	A,58		;CMD 58
264d 264d d cd9526
264d 264d u 03 01
264d 264d s 		CALL	SD_CMD
2650 2650 d fe00
2650 2650 u 02 01
2650 2650 s 		CP	0
2652 2652 d c2ca25
2652 2652 u 03 01
2652 2652 s 		JP  NZ,	INIT_FAIL
2655 2655 d cdde26
2655 2655 u 03 01
2655 2655 s 		CALL	SPI_RX
2658 2658 d e6c0
2658 2658 u 02 01
2658 2658 s 		AND	0C0h
265a 265a d fec0
265a 265a u 02 01
265a 265a s 		CP	0C0h
265c 265c d c26f26
265c 265c u 03 01
265c 265c s 		JP NZ,	ISD_5
265f 265f d 3e03
265f 265f u 02 01
265f 265f s 		LD	A,3
2661 2661 d 3210ff
2661 2661 u 03 01
2661 2661 s 		LD	(SD_CARD_TYPE),A
2664 2664 d cdca0d
2664 2664 u 03 01
2664 2664 s 		CALL 	PRINTI		;
2667 2667 d 2054797065233300
2667 2667 u 08 02
2667 2667 s 		DB	" Type#3",EOS
266f 266f d cdde26
266f 266f u 03 01
266f 266f s ISD_5		CALL	SPI_RX
2672 2672 d cdde26
2672 2672 u 03 01
2672 2672 s 		CALL	SPI_RX
2675 2675 d cdde26
2675 2675 u 03 01
2675 2675 s 		CALL	SPI_RX
2678 2678 s 
2678 2678 d cd7d26
2678 2678 u 03 01
2678 2678 s ISD_6		CALL	SD_DESELECT
267b 267b d af
267b 267b u 01 01
267b 267b s 		XOR	A		;Set Zero Flag = Success
267c 267c d c9
267c 267c u 01 01
267c 267c s 		RET
267d 267d s 
267d 267d s ;-----------------------------------------------------------------------------------------------------
267d 267d d f5
267d 267d u 01 01
267d 267d s SD_DESELECT	PUSH	AF
267e 267e d 3e01
267e 267e u 02 01
267e 267e s 		LD	A,1
2680 2680 d d3c4
2680 2680 u 02 01
2680 2680 s 		OUT	(SDCS),A
2682 2682 d d3c0
2682 2682 u 02 01
2682 2682 s 		OUT	(SDCLK),A
2684 2684 d d3c6
2684 2684 u 02 01
2684 2684 s 		OUT	(GREEN_LED),A
2686 2686 d f1
2686 2686 u 01 01
2686 2686 s 		POP	AF
2687 2687 d c9
2687 2687 u 01 01
2687 2687 s 		RET
2688 2688 s 		
2688 2688 s ;-----------------------------------------------------------------------------------------------------
2688 2688 d f5
2688 2688 u 01 01
2688 2688 s SD_SELECT	PUSH	AF
2689 2689 d af
2689 2689 u 01 01
2689 2689 s 		XOR	A
268a 268a d d3c4
268a 268a u 02 01
268a 268a s 		OUT	(SDCS),A
268c 268c d f1
268c 268c u 01 01
268c 268c s 		POP	AF
268d 268d d c9
268d 268d u 01 01
268d 268d s 		RET
268e 268e s 
268e 268e s ;-----------------------------------------------------------------------------------------------------
268e 268e d 3e0d
268e 268e u 02 01
268e 268e s SD_DELAY100	LD	A,13	 ;Small delay after selecting card
2690 2690 d 3d
2690 2690 u 01 01
2690 2690 s SD_DELAY	DEC	A	 ;5
2691 2691 d c29026
2691 2691 u 03 01
2691 2691 s 		JP NZ,	SD_DELAY ;10    15*13 ~= 200 ~= 100uSec
2694 2694 d c9
2694 2694 u 01 01
2694 2694 s 		RET
2695 2695 s 
2695 2695 s ;-----------------------------------------------------------------------------------------------------
2695 2695 s ;Send command to SD card
2695 2695 d c5
2695 2695 u 01 01
2695 2695 s SD_CMD		PUSH	BC
2696 2696 d cd8826
2696 2696 u 03 01
2696 2696 s 		CALL	SD_SELECT
2699 2699 d cdf426
2699 2699 u 03 01
2699 2699 s 		CALL	WAIT_NOT_BUSY
269c 269c s 
269c 269c d 06ff
269c 269c u 02 01
269c 269c s 		LD	B,0FFh	;Default CRC
269e 269e d fe00
269e 269e u 02 01
269e 269e s 		CP	0
26a0 26a0 d c2a526
26a0 26a0 u 03 01
26a0 26a0 s 		JP NZ,	SDC_1
26a3 26a3 d 0695
26a3 26a3 u 02 01
26a3 26a3 s 		LD	B,095h	;If CMD=0 THEN CRC=95
26a5 26a5 d fe08
26a5 26a5 u 02 01
26a5 26a5 s SDC_1		CP	8
26a7 26a7 d c2ac26
26a7 26a7 u 03 01
26a7 26a7 s 		JP NZ,	SDC_2
26aa 26aa d 0687
26aa 26aa u 02 01
26aa 26aa s 		LD	B,087h
26ac 26ac s SDC_2
26ac 26ac s 
26ac 26ac d f640
26ac 26ac u 02 01
26ac 26ac s 		OR	040H	;All Commands start with 40h
26ae 26ae d cde026
26ae 26ae u 03 01
26ae 26ae s 		CALL	SPI_TX
26b1 26b1 d 3a15ff
26b1 26b1 u 03 01
26b1 26b1 s 		LD	A,(SD_PARAM+3)
26b4 26b4 d cde026
26b4 26b4 u 03 01
26b4 26b4 s 		CALL	SPI_TX
26b7 26b7 d 3a14ff
26b7 26b7 u 03 01
26b7 26b7 s 		LD	A,(SD_PARAM+2)
26ba 26ba d cde026
26ba 26ba u 03 01
26ba 26ba s 		CALL	SPI_TX
26bd 26bd d 3a13ff
26bd 26bd u 03 01
26bd 26bd s 		LD	A,(SD_PARAM+1)
26c0 26c0 d cde026
26c0 26c0 u 03 01
26c0 26c0 s 		CALL	SPI_TX
26c3 26c3 d 3a12ff
26c3 26c3 u 03 01
26c3 26c3 s 		LD	A,(SD_PARAM)
26c6 26c6 d cde026
26c6 26c6 u 03 01
26c6 26c6 s 		CALL	SPI_TX
26c9 26c9 d 78
26c9 26c9 u 01 01
26c9 26c9 s 		LD	A,B
26ca 26ca d cde026
26ca 26ca u 03 01
26ca 26ca s 		CALL	SPI_TX
26cd 26cd s 
26cd 26cd d 0600
26cd 26cd u 02 01
26cd 26cd s 		LD	B,0
26cf 26cf d cdde26
26cf 26cf u 03 01
26cf 26cf s SDC_LP		CALL	SPI_RX	;Read Respsonse?
26d2 26d2 d 3211ff
26d2 26d2 u 03 01
26d2 26d2 s 		LD	(SDC_STATUS),A
26d5 26d5 d b7
26d5 26d5 u 01 01
26d5 26d5 s 		OR	A
26d6 26d6 d f2dc26
26d6 26d6 u 03 01
26d6 26d6 s 		JP P,	SDC_RET	;If Positive Response, EXIT
26d9 26d9 d 10f4
26d9 26d9 u 02 01
26d9 26d9 s 		DJNZ	SDC_LP	;Else Read next Response
26db 26db d b7
26db 26db u 01 01
26db 26db s 		OR	A
26dc 26dc d c1
26dc 26dc u 01 01
26dc 26dc s SDC_RET		POP	BC
26dd 26dd d c9
26dd 26dd u 01 01
26dd 26dd s 		RET
26de 26de s 
26de 26de s ;-----------------------------------------------------------------------------------------------------
26de 26de s ;------------------------------- Receive a byte from SPI
26de 26de d 3eff
26de 26de u 02 01
26de 26de s SPI_RX		LD	A,0FFH	;Read Respsonse, send a byte to get a byte...
26e0 26e0 s 
26e0 26e0 d c5
26e0 26e0 u 01 01
26e0 26e0 s SPI_TX		PUSH	BC
26e1 26e1 d 4f
26e1 26e1 u 01 01
26e1 26e1 s 		LD	C,A	;Save Byte to send in C
26e2 26e2 d 0608
26e2 26e2 u 02 01
26e2 26e2 s 		LD	B,8	;8 BITS
26e4 26e4 s 		
26e4 26e4 d dbce
26e4 26e4 u 02 01
26e4 26e4 s SPI_TX_LP	IN	A,(ACE_MSR)	;Fetch RX bit
26e6 26e6 d 17
26e6 26e6 u 01 01
26e6 26e6 s 		RLA			;Save bit in CY
26e7 26e7 d cb11
26e7 26e7 u 02 01
26e7 26e7 s 		RL	C		;Move bit into C (and bump next tx bit up)
26e9 26e9 d 17
26e9 26e9 u 01 01
26e9 26e9 s 		RLA			;Get bit to send in lsb
26ea 26ea d d3c5
26ea 26ea u 02 01
26ea 26ea s 		OUT	(SDTX),A	;Send bit
26ec 26ec d dbc0
26ec 26ec u 02 01
26ec 26ec s 		IN	A,(SDCLK)	;Clock the bit
26ee 26ee d 10f4
26ee 26ee u 02 01
26ee 26ee s 		DJNZ	SPI_TX_LP		
26f0 26f0 d 79
26f0 26f0 u 01 01
26f0 26f0 s 		LD	A,C
26f1 26f1 d 2f
26f1 26f1 u 01 01
26f1 26f1 s 		CPL			;Correct Inversion by ACE
26f2 26f2 d c1
26f2 26f2 u 01 01
26f2 26f2 s 		POP	BC
26f3 26f3 d c9
26f3 26f3 u 01 01
26f3 26f3 s 		RET
26f4 26f4 s 
26f4 26f4 s ;-----------------------------------------------------------------------------------------------------
26f4 26f4 s ;------------------------------- Wait until FF's come back from Card (ie NOT BUSY)
26f4 26f4 d f5
26f4 26f4 u 01 01
26f4 26f4 s WAIT_NOT_BUSY	PUSH	AF	;Do not destroy Acc
26f5 26f5 d c5
26f5 26f5 u 01 01
26f5 26f5 s 		PUSH	BC	;Fetch 1 consecutive FF's to be sure SD card NOT BUSY
26f6 26f6 d 0600
26f6 26f6 u 02 01
26f6 26f6 s 		LD	B,0
26f8 26f8 d 0e01
26f8 26f8 u 02 01
26f8 26f8 s WNB_LP		LD	C,1	;Set count for 1 trys
26fa 26fa d cdde26
26fa 26fa u 03 01
26fa 26fa s WNB_LP2		CALL	SPI_RX
26fd 26fd d 3c
26fd 26fd u 01 01
26fd 26fd s 		INC	A
26fe 26fe d c20a27
26fe 26fe u 03 01
26fe 26fe s 		JP NZ,	WNB_0	;NOT FF RETURNED, JUMP TO COUNT DOWN TRYS
2701 2701 d 0d
2701 2701 u 01 01
2701 2701 s 		DEC	C	;Count Down Consecutive FF's
2702 2702 d c2fa26
2702 2702 u 03 01
2702 2702 s 		JP NZ,	WNB_LP2
2705 2705 d c1
2705 2705 u 01 01
2705 2705 s 		POP	BC
2706 2706 d f1
2706 2706 u 01 01
2706 2706 s 		POP	AF
2707 2707 d 37
2707 2707 u 01 01
2707 2707 s 		SCF		;Return NOT BUSY (Clear Carry)
2708 2708 d 3f
2708 2708 u 01 01
2708 2708 s 		CCF
2709 2709 d c9
2709 2709 u 01 01
2709 2709 s 		RET
270a 270a s 
270a 270a d af
270a 270a u 01 01
270a 270a s WNB_0		XOR	A
270b 270b d cd9026
270b 270b u 03 01
270b 270b s 		CALL	SD_DELAY
270e 270e d 10e8
270e 270e u 02 01
270e 270e s 		DJNZ	WNB_LP	;Count Down Trys
2710 2710 d c1
2710 2710 u 01 01
2710 2710 s 		POP	BC
2711 2711 d f1
2711 2711 u 01 01
2711 2711 s 		POP	AF
2712 2712 d 37
2712 2712 u 01 01
2712 2712 s 		SCF		;Return STILL BUSY (Set Carry)
2713 2713 d c9
2713 2713 u 01 01
2713 2713 s 		RET
2714 2714 s 
2714 2714 s 
2714 2714 s 
2714 2714 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2714 2714 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2714 2714 s ;	Chapter_16	General Support Routines, 32 Bit stuff and other math
2714 2714 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2714 2714 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2714 2714 s 
2714 2714 s ;-----------------------------------------------------------------------------------------------------
2714 2714 s ;Maximum number to divide is Logical Sector 2001/4 = 500
2714 2714 s ;If dividing by powers of 2, then we can shift the number for fast divide
2714 2714 d 3a21ff
2714 2714 u 03 01
2714 2714 s DIV16BY8SPC	LD	A, (SEC_PER_CLUS)
2717 2717 s ;Input:	DE=Dividend, A=Divisor
2717 2717 s ;Out:	DE=Result, A=Remainder
2717 2717 d eb
2717 2717 u 01 01
2717 2717 s DIV16BY8	EX	DE, HL	; HL = Dividend
2718 2718 d 1e00
2718 2718 u 02 01
2718 2718 s 		LD	E,00	; Quotient = 0
271a 271a d 4f
271a 271a u 01 01
271a 271a s 		LD	C, A	; Store        Divisor
271b 271b d 0608
271b 271b u 02 01
271b 271b s 		LD	B, 08	; Count = 8
271d 271d d 29
271d 271d u 01 01
271d 271d s DIV16BY8_LP	ADD	HL,HL	; Dividend = Dividend x 2
271e 271e d cb03
271e 271e u 02 01
271e 271e s 		RLC	E	; Quotient = Quotient x 2
2720 2720 d 7c
2720 2720 u 01 01
2720 2720 s 		LD	A, H
2721 2721 d 91
2721 2721 u 01 01
2721 2721 s 		SUB	C	; Is most significant byte of Dividend > divisor
2722 2722 d 3802
2722 2722 u 02 01
2722 2722 s 		JR C,	DIV16BY8_SK	; No, go to Next step
2724 2724 d 67
2724 2724 u 01 01
2724 2724 s 		LD	H, A	; Yes, subtract divisor
2725 2725 d 1c
2725 2725 u 01 01
2725 2725 s 		INC	E	; and Quotient = Quotient + 1
2726 2726 d 10f5
2726 2726 u 02 01
2726 2726 s DIV16BY8_SK	DJNZ 	DIV16BY8_LP ; Count = Count - 1
2728 2728 d 7c
2728 2728 u 01 01
2728 2728 s 		LD	A, H
2729 2729 d 1600
2729 2729 u 02 01
2729 2729 s 		LD	D,0	; Quotient in DE
272b 272b d c9
272b 272b u 01 01
272b 272b s 		RET
272c 272c s 
272c 272c s ;-----------------------------------------------------------------------------------------------------
272c 272c d 3a54ff
272c 272c u 03 01
272c 272c s DIVBYSHIFT	LD	A, (DF_SHIFTCNT)	; DE = Dividend
272f 272f d 47
272f 272f u 01 01
272f 272f s 		LD	B,A
2730 2730 d 05
2730 2730 u 01 01
2730 2730 s DBS_LP		DEC	B
2731 2731 d c8
2731 2731 u 01 01
2731 2731 s 		RET Z
2732 2732 d cb3a
2732 2732 u 02 01
2732 2732 s 		SRL	D
2734 2734 d cb1b
2734 2734 u 02 01
2734 2734 s 		RR	E
2736 2736 d c33027
2736 2736 u 03 01
2736 2736 s 		JP	DBS_LP
2739 2739 s 
2739 2739 s ;-----------------------------------------------------------------------------------------------------
2739 2739 d 3a58ff
2739 2739 u 03 01
2739 2739 s MODBYMASK	LD	A, (MODMASK)
273c 273c d a3
273c 273c u 01 01
273c 273c s 		AND	E
273d 273d d c9
273d 273d u 01 01
273d 273d s 		RET
273e 273e s 
273e 273e s ;------------------------- Move (HL) to 32 bit register BCDE
273e 273e d 5e
273e 273e u 01 01
273e 273e s MOV_32_HL	LD	E,(HL)
273f 273f d 23
273f 273f u 01 01
273f 273f s 		INC	HL
2740 2740 d 56
2740 2740 u 01 01
2740 2740 s 		LD	D,(HL)
2741 2741 d 23
2741 2741 u 01 01
2741 2741 s 		INC	HL
2742 2742 d 4e
2742 2742 u 01 01
2742 2742 s 		LD	C,(HL)
2743 2743 d 23
2743 2743 u 01 01
2743 2743 s 		INC	HL
2744 2744 d 46
2744 2744 u 01 01
2744 2744 s 		LD	B,(HL)
2745 2745 d 2b
2745 2745 u 01 01
2745 2745 s 		DEC	HL
2746 2746 d 2b
2746 2746 u 01 01
2746 2746 s 		DEC	HL
2747 2747 d 2b
2747 2747 u 01 01
2747 2747 s 		DEC	HL
2748 2748 d c9
2748 2748 u 01 01
2748 2748 s 		RET
2749 2749 s 
2749 2749 s ;------------------------- Move 32 bit register BCDE to (HL)
2749 2749 d 73
2749 2749 u 01 01
2749 2749 s MOV_HL_32	LD	(HL),E
274a 274a d 23
274a 274a u 01 01
274a 274a s 		INC	HL
274b 274b d 72
274b 274b u 01 01
274b 274b s 		LD	(HL),D
274c 274c d 23
274c 274c u 01 01
274c 274c s 		INC	HL
274d 274d d 71
274d 274d u 01 01
274d 274d s 		LD	(HL),C
274e 274e d 23
274e 274e u 01 01
274e 274e s 		INC	HL
274f 274f d 70
274f 274f u 01 01
274f 274f s 		LD	(HL),B
2750 2750 d 2b
2750 2750 u 01 01
2750 2750 s 		DEC	HL
2751 2751 d 2b
2751 2751 u 01 01
2751 2751 s 		DEC	HL
2752 2752 d 2b
2752 2752 u 01 01
2752 2752 s 		DEC	HL
2753 2753 d c9
2753 2753 u 01 01
2753 2753 s 		RET
2754 2754 s 
2754 2754 s ;------------------------- ADD (HL) to 32 bit register BCDE - (Must return with HL changed to last byte)
2754 2754 d 7b
2754 2754 u 01 01
2754 2754 s ADD_32_HL	LD	A,E
2755 2755 d 86
2755 2755 u 01 01
2755 2755 s 		ADD	A,(HL)
2756 2756 d 5f
2756 2756 u 01 01
2756 2756 s 		LD	E,A
2757 2757 d 23
2757 2757 u 01 01
2757 2757 s 		INC	HL
2758 2758 d 7a
2758 2758 u 01 01
2758 2758 s 		LD	A,D
2759 2759 d 8e
2759 2759 u 01 01
2759 2759 s 		ADC	A,(HL)
275a 275a d 57
275a 275a u 01 01
275a 275a s 		LD	D,A
275b 275b d 23
275b 275b u 01 01
275b 275b s 		INC	HL
275c 275c d 79
275c 275c u 01 01
275c 275c s 		LD	A,C
275d 275d d 8e
275d 275d u 01 01
275d 275d s 		ADC	A,(HL)
275e 275e d 4f
275e 275e u 01 01
275e 275e s 		LD	C,A
275f 275f d 23
275f 275f u 01 01
275f 275f s 		INC	HL		
2760 2760 d 78
2760 2760 u 01 01
2760 2760 s 		LD	A,B
2761 2761 d 8e
2761 2761 u 01 01
2761 2761 s 		ADC	A,(HL)
2762 2762 d 47
2762 2762 u 01 01
2762 2762 s 		LD	B,A
2763 2763 d 23
2763 2763 u 01 01
2763 2763 s 		INC	HL		;(Must return with HL advanced past 32 bits)
2764 2764 d c9
2764 2764 u 01 01
2764 2764 s 		RET
2765 2765 s 
2765 2765 s ;-----------------------------------------------------------------------------------------------------
2765 2765 d 13
2765 2765 u 01 01
2765 2765 s INC_32		INC	DE
2766 2766 d 7a
2766 2766 u 01 01
2766 2766 s 		LD	A,D
2767 2767 d b3
2767 2767 u 01 01
2767 2767 s 		OR	E
2768 2768 d c0
2768 2768 u 01 01
2768 2768 s 		RET NZ
2769 2769 d 03
2769 2769 u 01 01
2769 2769 s 		INC	BC
276a 276a d c9
276a 276a u 01 01
276a 276a s 		RET
276b 276b s 
276b 276b s ;-----------------------------------------------------------------------------------------------------
276b 276b d 7a
276b 276b u 01 01
276b 276b s DEC_32		LD	A,D
276c 276c d b3
276c 276c u 01 01
276c 276c s 		OR	E
276d 276d d c27127
276d 276d u 03 01
276d 276d s 		JP NZ,	DEC_32NB
2770 2770 d 0b
2770 2770 u 01 01
2770 2770 s 		DEC	BC
2771 2771 d 1b
2771 2771 u 01 01
2771 2771 s DEC_32NB	DEC	DE
2772 2772 d c9
2772 2772 u 01 01
2772 2772 s 		RET
2773 2773 s 
2773 2773 s ;-----------------------------------------------------------------------------------------------------
2773 2773 d 7a
2773 2773 u 01 01
2773 2773 s TSTZ_32		LD	A,D
2774 2774 d b3
2774 2774 u 01 01
2774 2774 s 		OR	E
2775 2775 d b1
2775 2775 u 01 01
2775 2775 s 		OR	C
2776 2776 d b0
2776 2776 u 01 01
2776 2776 s 		OR	B
2777 2777 d c9
2777 2777 u 01 01
2777 2777 s 		RET
2778 2778 s 
2778 2778 s ;-----------------------------------------------------------------------------------------------------
2778 2778 s ;Compare BCDE with 32bit word at HL
2778 2778 d 23
2778 2778 u 01 01
2778 2778 s CMP_HL_32	INC	HL		;Point to MSB
2779 2779 d 23
2779 2779 u 01 01
2779 2779 s 		INC	HL
277a 277a d 23
277a 277a u 01 01
277a 277a s 		INC	HL
277b 277b d 78
277b 277b u 01 01
277b 277b s 		LD	A,B		;Compare with B
277c 277c d be
277c 277c u 01 01
277c 277c s 		CP	(HL)
277d 277d d 200e
277d 277d u 02 01
277d 277d s 		JR NZ,	CH3_R1
277f 277f d 2b
277f 277f u 01 01
277f 277f s 		DEC	HL
2780 2780 d 79
2780 2780 u 01 01
2780 2780 s 		LD	A,C
2781 2781 d be
2781 2781 u 01 01
2781 2781 s 		CP	(HL)
2782 2782 d 200a
2782 2782 u 02 01
2782 2782 s 		JR NZ,	CH3_R2
2784 2784 d 2b
2784 2784 u 01 01
2784 2784 s 		DEC	HL
2785 2785 d 7a
2785 2785 u 01 01
2785 2785 s 		LD	A,D
2786 2786 d be
2786 2786 u 01 01
2786 2786 s 		CP	(HL)
2787 2787 d 2006
2787 2787 u 02 01
2787 2787 s 		JR NZ,	CH3_R3
2789 2789 d 2b
2789 2789 u 01 01
2789 2789 s 		DEC	HL
278a 278a d 7b
278a 278a u 01 01
278a 278a s 		LD	A,E
278b 278b d be
278b 278b u 01 01
278b 278b s 		CP	(HL)
278c 278c d c9
278c 278c u 01 01
278c 278c s 		RET
278d 278d d 2b
278d 278d u 01 01
278d 278d s CH3_R1		DEC	HL
278e 278e d 2b
278e 278e u 01 01
278e 278e s CH3_R2		DEC	HL
278f 278f d 2b
278f 278f u 01 01
278f 278f s CH3_R3		DEC	HL
2790 2790 d c9
2790 2790 u 01 01
2790 2790 s 		RET
2791 2791 s 
2791 2791 s ;------------------------- COMPARE DE WITH HL
2791 2791 d 7a
2791 2791 u 01 01
2791 2791 s CMP_DE_HL	LD	A,D		;Compare the MSB first
2792 2792 d bc
2792 2792 u 01 01
2792 2792 s 		CP	H
2793 2793 d c0
2793 2793 u 01 01
2793 2793 s 		RET NZ
2794 2794 d 7b
2794 2794 u 01 01
2794 2794 s 		LD	A,E
2795 2795 d bd
2795 2795 u 01 01
2795 2795 s 		CP	L
2796 2796 d c9
2796 2796 u 01 01
2796 2796 s 		RET
2797 2797 s 
2797 2797 s 
2797 2797 s 
2797 2797 s ;=====================================================================================================
2797 2797 s ;General Support Routines, Strings
2797 2797 s ;=====================================================================================================
2797 2797 s ;	OUTPUT: STRING ENTERED @M(HL), C=0
2797 2797 s ;		<ESC> PRESSED C=1
2797 2797 s ;-----------------------------------------------------------------------------------------------------
2797 2797 d cde013
2797 2797 u 03 01
2797 2797 s GET_STRING:	CALL	GET_CHAR
279a 279a d fe1b
279a 279a u 02 01
279a 279a s 		CP	27
279c 279c d 37
279c 279c u 01 01
279c 279c s 		SCF			;Set Carry to indicate Abort
279d 279d d c8
279d 279d u 01 01
279d 279d s 		RET Z
279e 279e d fe0d
279e 279e u 02 01
279e 279e s 		CP	13		;Exit on <CR>
27a0 27a0 d c8
27a0 27a0 u 01 01
27a0 27a0 s 		RET Z
27a1 27a1 d b9
27a1 27a1 u 01 01
27a1 27a1 s 		CP	C		;Exit on Selectable Char (dot for file input)
27a2 27a2 d c8
27a2 27a2 u 01 01
27a2 27a2 s 		RET Z
27a3 27a3 d cdb227
27a3 27a3 u 03 01
27a3 27a3 s 		CALL	TO_UPPER
27a6 27a6 d fe21
27a6 27a6 u 02 01
27a6 27a6 s 		CP	' '+1		;Test if ACC is Control or Space
27a8 27a8 d 38ed
27a8 27a8 u 02 01
27a8 27a8 s 		JR C,	GET_STRING	;Skip such characters
27aa 27aa d 05
27aa 27aa u 01 01
27aa 27aa s 		DEC	B
27ab 27ab d 04
27ab 27ab u 01 01
27ab 27ab s 		INC	B		;Exit if B characters are already inputed
27ac 27ac d c8
27ac 27ac u 01 01
27ac 27ac s 		RET Z			;Exit if no more characters allowed
27ad 27ad d 77
27ad 27ad u 01 01
27ad 27ad s 		LD	(HL),A
27ae 27ae d 23
27ae 27ae u 01 01
27ae 27ae s 		INC	HL
27af 27af d 05
27af 27af u 01 01
27af 27af s 		DEC	B
27b0 27b0 d 18e5
27b0 27b0 u 02 01
27b0 27b0 s 		JR	GET_STRING
27b2 27b2 s 
27b2 27b2 s ;-----------------------------------------------------------------------------------------------------
27b2 27b2 d fe61
27b2 27b2 u 02 01
27b2 27b2 s TO_UPPER	CP	'a'
27b4 27b4 d d8
27b4 27b4 u 01 01
27b4 27b4 s 		RET C		;Return if ACC < 'a'
27b5 27b5 d fe7b
27b5 27b5 u 02 01
27b5 27b5 s 		CP	'z'+1
27b7 27b7 d d0
27b7 27b7 u 01 01
27b7 27b7 s 		RET NC		;Return if ACC > 'z'
27b8 27b8 d e65f
27b8 27b8 u 02 01
27b8 27b8 s 		AND	5Fh	;Convert to upper case
27ba 27ba d c9
27ba 27ba u 01 01
27ba 27ba s 		RET
27bb 27bb s 
27bb 27bb s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
27bb 27bb d fe41
27bb 27bb u 02 01
27bb 27bb s IS_LETTER	CP	'A'
27bd 27bd d d8
27bd 27bd u 01 01
27bd 27bd s 		RET C
27be 27be d fe5b
27be 27be u 02 01
27be 27be s 		CP	'Z'+1
27c0 27c0 d 3f
27c0 27c0 u 01 01
27c0 27c0 s 		CCF
27c1 27c1 d c9
27c1 27c1 u 01 01
27c1 27c1 s 		RET
27c2 27c2 s 
27c2 27c2 s ;-----------------------------------------------------------------------------------------------------
27c2 27c2 s ;ASCII TO BINARY
27c2 27c2 s ;INPUT:	HL Points to a 2 character String of ASCII
27c2 27c2 s ;	DE Points to a memory location to receive the Binary value
27c2 27c2 s ;OUTPUT: CY=0 if successful (both ASCII characters were a valid HEX digit (0-9,A-F,a-f)
27c2 27c2 s ;	 (DE) = Binary value of (HL) and (HL+1)
27c2 27c2 s ;	eg:
27c2 27c2 s ;	Before Call: HL=1000, DE=2000, M(1000)='A', M(1001)='B', M(2000)=xx, CY=?
27c2 27c2 s ;	After  Call: HL=1002, DE=2000, M(1000)='A', M(1001)='B', M(2000)=AB, CY=0
27c2 27c2 s ;	
27c2 27c2 s ;	CY=1 if invalid hex char encountered, a partial output may appear at (DE)
27c2 27c2 s ;	eg:
27c2 27c2 s ;	Before Call: HL=1000, DE=2000, M(1000)='J', M(1001)='B', M(2000)=12, CY=?
27c2 27c2 s ;	After  Call: HL=1000, DE=2000, M(1000)='J', M(1001)='B', M(2000)=12, CY=1
27c2 27c2 s ;	eg:
27c2 27c2 s ;	Before Call: HL=1000, DE=2000, M(1000)='A', M(1001)='J', M(2000)=12, CY=?
27c2 27c2 s ;	After  Call: HL=1001, DE=2000, M(1000)='A', M(1001)='J', M(2000)=2A, CY=1
27c2 27c2 s ;
27c2 27c2 s ;DESTROYS: AF
27c2 27c2 s ;
27c2 27c2 d cdc627
27c2 27c2 u 03 01
27c2 27c2 s ASC2BIN		CALL	ABF1		;Convert 2 chars to HEX @(DE)
27c5 27c5 d d8
27c5 27c5 u 01 01
27c5 27c5 s 		RET	C		;Exit on error CY=1
27c6 27c6 d 7e
27c6 27c6 u 01 01
27c6 27c6 s ABF1		LD	A,(HL)
27c7 27c7 d cd980d
27c7 27c7 u 03 01
27c7 27c7 s 		CALL	ASC2HEX	;(non-hex) char when CY=1
27ca 27ca d d8
27ca 27ca u 01 01
27ca 27ca s 		RET	C
27cb 27cb d eb
27cb 27cb u 01 01
27cb 27cb s ABF_GOODHEX	EX	DE,HL
27cc 27cc d ed6f
27cc 27cc u 02 01
27cc 27cc s 		RLD
27ce 27ce d eb
27ce 27ce u 01 01
27ce 27ce s 		EX	DE,HL
27cf 27cf d 23
27cf 27cf u 01 01
27cf 27cf s 		INC	HL
27d0 27d0 d c9
27d0 27d0 u 01 01
27d0 27d0 s 		RET		
27d1 27d1 s 
27d1 27d1 d 32b2ff
27d1 27d1 u 03 01
27d1 27d1 s BEEP		LD	(BEEP_TO),A
27d4 27d4 d c9
27d4 27d4 u 01 01
27d4 27d4 s 		RET
27d5 27d5 s 
27d5 27d5 d 32f2ff
27d5 27d5 u 03 01
27d5 27d5 s SET_ECHO	LD	(ECHO_STATE),A	;TURN ON/OFF ECHO
27d8 27d8 d c9
27d8 27d8 u 01 01
27d8 27d8 s 		RET
27d9 27d9 s 
27d9 27d9 d 32c0ff
27d9 27d9 u 03 01
27d9 27d9 s LED_UPDATE	LD	(IK_TIMER),A	;0 = Cancel any monitor time outs
27dc 27dc d 213c18
27dc 27dc u 03 01
27dc 27dc s 		LD	HL,ISET_PRESSED
27df 27df d 22beff
27df 27df u 03 01
27df 27df s 		LD	(KEY_EVENT),HL
27e2 27e2 d 21e317
27e2 27e2 u 03 01
27e2 27e2 s 		LD	HL,IDISP_RET
27e5 27e5 d 22bcff
27e5 27e5 u 03 01
27e5 27e5 s 		LD	(DISPMODE),HL
27e8 27e8 d c9
27e8 27e8 u 01 01
27e8 27e8 s 		RET
27e9 27e9 s 
27e9 27e9 d 3ac8ff
27e9 27e9 u 03 01
27e9 27e9 s LED_GET_POS	LD	A,(LED_CURSOR)
27ec 27ec d e607
27ec 27ec u 02 01
27ec 27ec s 		AND	7
27ee 27ee d c9
27ee 27ee u 01 01
27ee 27ee s 		RET
27ef 27ef s 		
27ef 27ef d e607
27ef 27ef u 02 01
27ef 27ef s LED_SET_POS	AND	7
27f1 27f1 d f6e0
27f1 27f1 u 02 01
27f1 27f1 s 		OR	LOW LED_DISPLAY
27f3 27f3 d 32c8ff
27f3 27f3 u 03 01
27f3 27f3 s 		LD	(LED_CURSOR),A
27f6 27f6 d c9
27f6 27f6 u 01 01
27f6 27f6 s 		RET
27f7 27f7 s 		
27f7 27f7 d e5
27f7 27f7 u 01 01
27f7 27f7 s LED_RIGHT	PUSH	HL
27f8 27f8 d c5
27f8 27f8 u 01 01
27f8 27f8 s 		PUSH	BC
27f9 27f9 d 21e0ff
27f9 27f9 u 03 01
27f9 27f9 s 		LD	HL,LED_DISPLAY
27fc 27fc d 22c8ff
27fc 27fc u 03 01
27fc 27fc s 		LD	(LED_CURSOR),HL
27ff 27ff d 0607
27ff 27ff u 02 01
27ff 27ff s 		LD	B,7
2801 2801 d 3e80
2801 2801 u 02 01
2801 2801 s 		LD	A,0x80				
2803 2803 d 4e
2803 2803 u 01 01
2803 2803 s LEDR_LP		LD	C,(HL)
2804 2804 d 77
2804 2804 u 01 01
2804 2804 s 		LD	(HL),A
2805 2805 d 79
2805 2805 u 01 01
2805 2805 s 		LD	A,C
2806 2806 d 23
2806 2806 u 01 01
2806 2806 s 		INC	HL
2807 2807 d 10fa
2807 2807 u 02 01
2807 2807 s 		DJNZ	LEDR_LP
2809 2809 d c1
2809 2809 u 01 01
2809 2809 s 		POP	BC
280a 280a d e1
280a 280a u 01 01
280a 280a s 		POP	HL				
280b 280b d c9
280b 280b u 01 01
280b 280b s 		RET
280c 280c s 
280c 280c d e5
280c 280c u 01 01
280c 280c s LED_LEFT	PUSH	HL
280d 280d d c5
280d 280d u 01 01
280d 280d s 		PUSH	BC
280e 280e d 21e6ff
280e 280e u 03 01
280e 280e s 		LD	HL,LED_DISPLAY+6
2811 2811 d 22c8ff
2811 2811 u 03 01
2811 2811 s 		LD	(LED_CURSOR),HL
2814 2814 d 0607
2814 2814 u 02 01
2814 2814 s 		LD	B,7
2816 2816 d 3e80
2816 2816 u 02 01
2816 2816 s 		LD	A,0x80				
2818 2818 d 4e
2818 2818 u 01 01
2818 2818 s LEDL_LP		LD	C,(HL)
2819 2819 d 77
2819 2819 u 01 01
2819 2819 s 		LD	(HL),A
281a 281a d 79
281a 281a u 01 01
281a 281a s 		LD	A,C
281b 281b d 2b
281b 281b u 01 01
281b 281b s 		DEC	HL
281c 281c d 10e5
281c 281c u 02 01
281c 281c s 		DJNZ	LEDR_LP
281e 281e d c1
281e 281e u 01 01
281e 281e s 		POP	BC
281f 281f d e1
281f 281f u 01 01
281f 281f s 		POP	HL
2820 2820 d c9
2820 2820 u 01 01
2820 2820 s 		RET
2821 2821 s 
2821 2821 s 
2821 2821 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2821 2821 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2821 2821 s ;	Chapter_17	High RAM routines
2821 2821 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2821 2821 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2821 2821 s ;These routines cause bank memory switches between RAM/ROM and must be in HIGH RAM to execute.
2821 2821 s ;They will be loaded into HIGH RAM
2821 2821 s 
2821 2821 d 212d28
2821 2821 u 03 01
2821 2821 s LOAD_HIGH_RAM	LD	HL,ROM_CODE	;Copy ISR Dispatch & Return to Upper RAM
2824 2824 d 112afb
2824 2824 u 03 01
2824 2824 s 		LD	DE,HRAM_CODE
2827 2827 d 012900
2827 2827 u 03 01
2827 2827 s 		LD	BC,ROM_CODE_LEN
282a 282a d edb0
282a 282a u 02 01
282a 282a s 		LDIR
282c 282c d c9
282c 282c u 01 01
282c 282c s 		RET
282d 282d s 
282d 282d s ;FOLLOWING IS THE ISR DISPATCH ROUTINE  ISR_DISPATCH (IN HIGH RAM)
282d 282d s ;
282d 282d s ;ISR_DISPATCH:
282d 282d d af
282d 282d u 01 01
282d 282d s ROM_CODE	XOR	A		;4  
282e 282e d d3c1
282e 282e u 02 01
282e 282e s 		OUT	(RAMROM),A	;11 SELECT ROM
2830 2830 d db40
2830 2830 u 02 01
2830 2830 s 		IN	A,(Port40)	;11	
2832 2832 d 07
2832 2832 u 01 01
2832 2832 s 		RLCA			;4
2833 2833 d d23b16
2833 2833 u 03 01
2833 2833 s 		JP NC,	ISR_RXD		;10	Jump ASAP if RS-232 start bit coming in (2 Stack Words)
2836 2836 d 07
2836 2836 u 01 01
2836 2836 s 		RLCA			;4
2837 2837 d daac16
2837 2837 u 03 01
2837 2837 s 		JP C,	ISR_TIMER	;10 (st=50) Jump if Timer interrupt   		(7 Stack Words)
283a 283a d 3e80
283a 283a u 02 01
283a 283a s 		LD	A,0x80		;	Otherwise, unknown interrupt (RS-232 noise?)
283c 283c d d340
283c 283c u 02 01
283c 283c s 		OUT	(Port40),A	;11	Just reset Timer interrupt, just incase?
283e 283e s 		;JP	ISR_RET
283e 283e s 
283e 283e s ISR_RET_OFF	EQU	$-ROM_CODE
283e 283e d 3ad9ff
283e 283e u 03 01
283e 283e s 		LD	A,(RRSTATE)	;Restore RAM/ROM selection
2841 2841 d d3c1
2841 2841 u 02 01
2841 2841 s 		OUT	(RAMROM),A
2843 2843 d 08
2843 2843 u 01 01
2843 2843 s 		EX	AF,AF'		;Restore swapped Registers
2844 2844 d d9
2844 2844 u 01 01
2844 2844 s 		EXX
2845 2845 d fb
2845 2845 u 01 01
2845 2845 s 		EI
2846 2846 d ed4d
2846 2846 u 02 01
2846 2846 s 		RETI			;Return to Mainline code
2848 2848 s 		
2848 2848 s GET_MEM_OFF	EQU	$-ROM_CODE
2848 2848 d 3adbff
2848 2848 u 03 01
2848 2848 s 		LD	A,(READ_RAMROM)	;Bit 0 is RAM/ROM
284b 284b d f3
284b 284b u 01 01
284b 284b s 		DI
284c 284c d d3c1
284c 284c u 02 01
284c 284c s 		OUT	(RAMROM),A	;Select RAM/ROM
284e 284e d 7e
284e 284e u 01 01
284e 284e s 		LD	A,(HL)		;Fetch from RAM/ROM
284f 284f d 08
284f 284f u 01 01
284f 284f s 		EX	AF,AF'
2850 2850 d af
2850 2850 u 01 01
2850 2850 s 		XOR	A		;Return to ROM
2851 2851 d d3c1
2851 2851 u 02 01
2851 2851 s 		OUT	(RAMROM),A
2853 2853 d 08
2853 2853 u 01 01
2853 2853 s 		EX	AF,AF'
2854 2854 d fb
2854 2854 u 01 01
2854 2854 s 		EI		
2855 2855 d c9
2855 2855 u 01 01
2855 2855 s 		RET
2856 2856 s 		
2856 2856 s ;Alternative way to Get Mem and minimize the Interrupt mask black out
2856 2856 s ;HR_GET_MEM	PUSH	BC
2856 2856 s ;		LD	B,0
2856 2856 s ;		LD	C,RAMROM
2856 2856 s ;		LD	A,(READ_RAMROM)
2856 2856 s ;		DI
2856 2856 s ;		OUT	(C),A
2856 2856 s ;		LD	A,(HL)		;Fetch from RAM/ROM
2856 2856 s ;		OUT	(C),B
2856 2856 s ;		EI
2856 2856 s ;		POP	BC
2856 2856 s ;		RET
2856 2856 s 		
2856 2856 s 		
2856 2856 s ROM_CODE_LEN	equ	$-ROM_CODE
2856 2856 s 
2856 2856 s 
2856 2856 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2856 2856 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2856 2856 s ;	Appendix_A	LED FONT
2856 2856 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2856 2856 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2856 2856 s 
2856 2856 s 
2856 2856 s ; **         *********  *******        *********    *****    **     **  *********
2856 2856 s ; **         *********  ********       *********   *******   ***    **  *********
2856 2856 s ; **         **         **    ***      **         ***   ***  ****   **     ***
2856 2856 s ; **         **         **     **      **         **     **  *****  **     ***
2856 2856 s ; **         *********  **     **      *********  **     **  ** *** **     ***
2856 2856 s ; **         *********  **     **      *********  **     **  **  *****     ***
2856 2856 s ; **         **         **     **      **         **     **  **   ****     ***
2856 2856 s ; **         **         **    ***      **         ***   ***  **    ***     ***
2856 2856 s ; *********  *********  ********       **          *******   **     **     ***
2856 2856 s ; *********  *********  *******        **           *****    **     **     ***
2856 2856 s 
2856 2856 s ;	0 = Segment D OR LED7       --4--
2856 2856 s ;	1 = Segment E OR LED6      2|   |3
2856 2856 s ;	2 = Segment F OR LED5       |   |
2856 2856 s ;	3 = Segment B OR LED4       --5--
2856 2856 s ;	4 = Segment A OR LED3      1|   |6
2856 2856 s ;	5 = Segment G OR LED2       |   |
2856 2856 s ;	6 = Segment C OR LED1       --0--
2856 2856 s 
2856 2856 s 
2900 2900 s 		ORG  ($ & 0xFF00) + 0x100
2900 2900 d dfc8bbf9ecf5f7d8
2900 2900 u 08 02
2900 2900 s LED_HEX	DB	11011111b, 11001000b, 10111011b, 11111001b, 11101100b, 11110101b, 11110111b, 11011000b	;00-07 01234567
2908 2908 d fffcfee797ebb7b6
2908 2908 u 08 02
2908 2908 s 	DB	11111111b, 11111100b, 11111110b, 11100111b, 10010111b, 11101011b, 10110111b, 10110110b	;08-0F 89ABCDEF
2910 2910 s 
2910 2910 s 
2920 2920 s 		ORG  ($ & 0xFF00) + 0x20
2920 2920 s ;	**** 	; CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED	;HEX	Character
2920 2920 d 80868cbcd5a8a984
2920 2920 u 08 02
2920 2920 s LED_FONT DB	10000000b, 10000110b, 10001100b, 10111100b, 11010101b, 10101000b, 10101001b, 10000100b 	;20-27  !"#$%&'
2928 2928 d 97d994a6c1a081aa
2928 2928 u 08 02
2928 2928 s 	DB	10010111b, 11011001b, 10010100b, 10100110b, 11000001b, 10100000b, 10000001b, 10101010b	;28-2F ()*+,-./
2930 2930 d dfc8bbf9ecf5f7d8
2930 2930 u 08 02
2930 2930 s 	DB	11011111b, 11001000b, 10111011b, 11111001b, 11101100b, 11110101b, 11110111b, 11011000b	;30-37 01234567
2938 2938 d fffc91d183a1c1ba
2938 2938 u 08 02
2938 2938 s 	DB	11111111b, 11111100b, 10010001b, 11010001b, 10000011b, 10100001b, 11000001b, 10111010b	;38-3F 89:;<=>?
2940 2940 d fbfee797ebb7b6d7
2940 2940 u 08 02
2940 2940 s 	DB	11111011b, 11111110b, 11100111b, 10010111b, 11101011b, 10110111b, 10110110b, 11010111b	;40-47 @ABCDEFG
2948 2948 d eec8cbae87eadedf
2948 2948 u 08 02
2948 2948 s 	DB	11101110b, 11001000b, 11001011b, 10101110b, 10000111b, 11101010b, 11011110b, 11011111b	;48-4F HIJKLMNO
2950 2950 d befca2f596cfcfcf
2950 2950 u 08 02
2950 2950 s 	DB	10111110b, 11111100b, 10100010b, 11110101b, 10010110b, 11001111b, 11001111b, 11001111b	;50-57 PQRSTUVW
2958 2958 d e0ed9b97e4d99c81
2958 2958 u 08 02
2958 2958 s 	DB	11100000b, 11101101b, 10011011b, 10010111b, 11100100b, 11011001b, 10011100b, 10000001b	;58-5F XYZ[\]^_
2960 2960 d 88fbe7a3ebbfb6fd
2960 2960 u 08 02
2960 2960 s 	DB	10001000b, 11111011b, 11100111b, 10100011b, 11101011b, 10111111b, 10110110b, 11111101b	;60-67 `abcdefg
2968 2968 d e6c0cbae86eae2e3
2968 2968 u 08 02
2968 2968 s 	DB	11100110b, 11000000b, 11001011b, 10101110b, 10000110b, 11101010b, 11100010b, 11100011b	;68-6F hijklmno
2970 2970 d befca2f5a7c3c3c3
2970 2970 u 08 02
2970 2970 s 	DB	10111110b, 11111100b, 10100010b, 11110101b, 10100111b, 11000011b, 11000011b, 11000011b	;70-77 pqrstuvw
2978 2978 d e0ed9b9786d990eb
2978 2978 u 08 02
2978 2978 s 	DB	11100000b, 11101101b, 10011011b, 10010111b, 10000110b, 11011001b, 10010000b, 11101011b	;78-7F xyz{|}~
2980 2980 s 
2a00 2a00 s 		ORG  ($ & 0xFF00) + 0x100
2a00 2a00 s GO_BASIC
2a00 2a00 s 	INCLUDE	BASICZ80.ASM
2a00 2a00 f BASICZ80.ASM
2a00 2a00 s 		;*************************************************************
2a00 2a00 s 		;                       MICRO-BASIC                          *
2a00 2a00 s 		;------------------------------------------------------------*
2a00 2a00 s 		;   A SMALL INTEGER BASIC INTERPRETER FOR THE 8080/8085/Z80  *
2a00 2a00 s 		;                                D.F. DUNFIELD  JAN 25/1983  *
2a00 2a00 s 		;------------------------------------------------------------*
2a00 2a00 s 		;Translated to Z80 code for use with Lee Hart's Z80
2a00 2a00 s 		;Membership Card.  April 1, 2017 by Josh Bensadon.
2a00 2a00 s 		;
2a00 2a00 s 		;------------------------------------------------------------*
2a00 2a00 s 		;                      BASIC COMMANDS                        *
2a00 2a00 s 		;                                                            *
2a00 2a00 s 		;  CLEAR,    DATA,     DIM,      END,      BEXIT,     FOR,    *
2a00 2a00 s 		;  GOSUB,    GOSUB(N), GOTO,     GOTO(N),  IF/THEN,  INPUT,  *
2a00 2a00 s 		;  LET,      LIF/THEN, LIST,     LOAD,     NEW,      NEXT,   *
2a00 2a00 s 		;  ORDER,    PLOT,     PRINT,    READ,     REM,      RETURN, *
2a00 2a00 s 		;  RUN,      SAVE,     SIZE,     STOP,     USR,      <EDIT>  *
2a00 2a00 s 		;------------------------------------------------------------*
2a00 2a00 s 		;                     BASIC OPERATORS                        *
2a00 2a00 s 		;                                                            *
2a00 2a00 s 		; NUMERIC:     + - * % / \ & | ; ( ) < = > == -= <= >=       *
2a00 2a00 s 		; CHARACTER:   + = == -=                                     *
2a00 2a00 s 		; OTHER:       : # $ @ ? [ ] ( )                             *
2a00 2a00 s 		;------------------------------------------------------------*
2a00 2a00 s 		;                      BASIC VARIABLES                       *
2a00 2a00 s 		;                                                            *
2a00 2a00 s 		;     A - Z ......... 16 BIT SIMPLE INTEGER VARIABLES.       *
2a00 2a00 s 		;     A$ - Z$ ....... SIMPLE CHARACTER VARIABLES. < 36 CHARS *
2a00 2a00 s 		;     A[N] - Z[N] ... 16 BIT INTEGER ARRAYS.                 *
2a00 2a00 s 		;     @[N] .......... PSEUDO MEMORY REFERENCE ARRAY.         *
2a00 2a00 s 		;     @[N]$ ......... NUMERIC TO CHARACTER CONVERSION.(CHR$) *
2a00 2a00 s 		;     ? ............. PSEUDO RANDOM NUMBER GENERATOR.        *
2a00 2a00 s 		;------------------------------------------------------------*
2a00 2a00 s 		;                        MEMORY MAP                          *
2a00 2a00 s 		;                                                            *
2a00 2a00 s 		;    0000-03FF     1K SYSTEM MONITOR (IN ROM).               *
2a00 2a00 s 		;    0400-0FFF     3K BASIC INTERPRETER (IN ROM).            *
2a00 2a00 s 		;    1000-13FF     1K MEMORY MAPPED 64*16 VIDEO DISPLAY      *
2a00 2a00 s 		;    1400-15FF     0.5K POINTERS, STACKS, BUFFERS.           *
2a00 2a00 s 		;    1600-19FF     1K VARIABLES AND POINTERS.                *
2a00 2a00 s 		;    1A00-FFFF     PROGRAM AND ARRAY STORAGE.                *
2a00 2a00 s 		;*************************************************************
2a00 2a00 s 		;	PAGE
2a00 2a00 s 		;
2a00 2a00 s 		;*************************************************************
2a00 2a00 s 		;                   CONSTANTS AND EQUATES
2a00 2a00 s 		;*************************************************************
2a00 2a00 s 		;
2a00 2a00 s 		; MONITOR ROUTINES
2a00 2a00 s 		;
2a00 2a00 s 		BINCHR	EQU	0x51		;INPUT ROUTINE ADDRESS
2a00 2a00 s 		BPUTCHR EQU	0x45		;OUTPUT ROUTINE ADDRESS
2a00 2a00 s 		;CTRLC	EQU	0x27E		;CONTROL-C TEST ROUTINE ADDRESS
2a00 2a00 s 		BEXIT	EQU	0x42		;TERMINATION RETURN ADDRESS
2a00 2a00 s 		;GETR	EQU	0x2EB		;ROUTINE TO LOAD INTEL HEX FORMAT
2a00 2a00 s 		;TDUMP	EQU	0xD6		;ROUTINE TO DUMP IN INTEL HEX FORMAT
2a00 2a00 s 		;TON	EQU	0x396		;ROUTINE TO START TAPE
2a00 2a00 s 		;TOFF	EQU	0x3A6		;ROUTINE TO STOP TAPE
2a00 2a00 s 		;CURPOS	EQU	0x37E		;ROUTINE TO POSITION CURSOR
2a00 2a00 s 		BPUTSP	EQU	0x7D		;DISPLAY SPACE ON CONSOLE
2a00 2a00 s 		BPUTNL	EQU	0x80		;ROUTINE TO PRINT A <LF>, <CR> ON TERMINAL
2a00 2a00 s 		PRINTM	EQU	0x57		;DISPLAY'S MSGM UP TO ZERO OR <CR>
2a00 2a00 s 		;CR	EQU	0x0D
2a00 2a00 s 		;LF	EQU	0x0A
2a00 2a00 s 		; MEMORY ALLOCATION
2a00 2a00 s 		BUFF	EQU	0x8000		;START OF RAM, INPUT BUFFER
2a00 2a00 s 		IOCON	EQU	BUFF+0xFF	;INPUT/OUTPUT CONFIGURATION
2a00 2a00 s 		USROUT	EQU	IOCON-2		;USER SUPPLIED OUTPUT DEVICE VECTOR
2a00 2a00 s 		CURSOR	EQU	USROUT-2	;CURSOR POSITION
2a00 2a00 s 		LSTCHR	EQU	CURSOR-2	;CHARACTER UNDER CURSOR
2a00 2a00 s 		STACK	EQU	LSTCHR-2	;MACHINE STACK
2a00 2a00 s 		TB	EQU	BUFF+50		;TEMPORARY TEXT BUFFER
2a00 2a00 s 		XBF	EQU	TB+50		;EXTRA TEXT BUFFER
2a00 2a00 s 		EDBUF	EQU	BUFF+256	;EDIT BUFFER
2a00 2a00 s 		CS	EQU	EDBUF+0xFA	;CONTROL STACK SPACE
2a00 2a00 s 		CSP	EQU	CS+1		;CONTROL STACK POINTER
2a00 2a00 s 		ARYLOC	EQU	CSP+2		;LOCATION OF ARRAYS
2a00 2a00 s 		SEED	EQU	ARYLOC+1	;RANDOM NUMBER SEED
2a00 2a00 s 		VARS	EQU	SEED+2		;VARIABLE SPACE
2a00 2a00 s 		RFLAG	EQU	VARS+52		;PROGRAM RUNNING FLAG
2a00 2a00 s 		IFLAG	EQU	RFLAG+1		;INPUTTING FLAG
2a00 2a00 s 		PP	EQU	IFLAG+1		;POINTER TO END OF EXPRESSION
2a00 2a00 s 		EFLAG	EQU	PP+1		;ASSIGNMENT FLAG
2a00 2a00 s 		DATA	EQU	EFLAG+1		;READ/DATA POINTER
2a00 2a00 s 		LAST	EQU	DATA+2		;LAST FREE ARRAY SPACE
2a00 2a00 s 		SIGT	EQU	LAST+2		;SIGNATURE TO PREVENT CLEARING OF PROGRAM
2a00 2a00 s 		TEMP	EQU	SIGT+2		;TEMPORARY STORAGE
2a00 2a00 s 		TEXT	EQU	VARS+1024	;PROGRAM AND ARRAY STORAGE
2a00 2a00 s 		NEGTEXT EQU     0x007a
2a00 2a00 s 		DELETE	EQU	0x7F		;DELETE CHARACTER
2a00 2a00 s 		;	PAGE
2a00 2a00 s 		;
2a00 2a00 s 		;*******************************************************************
2a00 2a00 s 		; START OF MAIN PROGRAM, FIRST INITIALIZE, INSURING WE DON'T THINK *
2a00 2a00 s 		; WE HAVE A VALID PROGRAM, ALSO CLEAR OUT HIS VARIABLES AND ARRAYS *
2a00 2a00 s 		;*******************************************************************
2a00 2a00 s 		;
2a00 2a00 s 		;	ORG	0x8000		;FOLLOW MONITOR
2a00 2a00 d 210036
2a00 2a00 u 03 01
2a00 2a00 s 		BASIC	LD	HL,INTRO	;ADDRESS OF 'INTRO' MESSAGE
2a03 2a03 d cd5700
2a03 2a03 u 03 01
2a03 2a03 s 			CALL	PRINTM		;TELL HIM WHO WROTE THIS!
2a06 2a06 d 2a3c82
2a06 2a06 u 03 01
2a06 2a06 s 			LD	HL,(SIGT)	;CHECK IF RAM IS SIGNED
2a09 2a09 d 116913
2a09 2a09 u 03 01
2a09 2a09 s 			LD	DE,0x1369
2a0c 2a0c d af
2a0c 2a0c u 01 01
2a0c 2a0c s 			XOR	A
2a0d 2a0d d ed52
2a0d 2a0d u 02 01
2a0d 2a0d s 			SBC	HL,DE
2a0f 2a0f d 280c
2a0f 2a0f u 02 01
2a0f 2a0f s 			JR Z,	INIT		;JUMP IF SIGNATURE, IE DON'T INIT TEXT SPACE
2a11 2a11 s 			
2a11 2a11 d ed533c82
2a11 2a11 u 04 01
2a11 2a11 s 			LD	(SIGT),DE	;SIGN RAM FOR NEXT TIME
2a15 2a15 d 3eff
2a15 2a15 u 02 01
2a15 2a15 s 		NEW	LD	A,0xFF		;INDICATES END OF PROGRAM
2a17 2a17 d 320086
2a17 2a17 u 03 01
2a17 2a17 s 			LD	(TEXT), A	;INITIALIZE TO NO PROGRAM
2a1a 2a1a d cdaf2c
2a1a 2a1a u 03 01
2a1a 2a1a s 		RESV	CALL	CLEAR		;CLEAR OUT HIS VARIABLES
2a1d 2a1d s 		; RESET FLAGS, AND PROMPT WITH 'READY', SO HE WILL KNOW WE ARE LISTENING
2a1d 2a1d d 210000
2a1d 2a1d u 03 01
2a1d 2a1d s 		INIT	LD	HL,0		;GET DOUBLE BYTE ZERO
2a20 2a20 d 223482
2a20 2a20 u 03 01
2a20 2a20 s 			LD	(RFLAG), HL	;INDICATE NOT RUNNING, AND NOT INPUT
2a23 2a23 d 223682
2a23 2a23 u 03 01
2a23 2a23 s 			LD	(PP), HL		;INDICATE NO ASSIGNMENT DONE
2a26 2a26 d 213036
2a26 2a26 u 03 01
2a26 2a26 s 			LD	HL,RDY		;ADDRESS OF 'READY' MESSAGE
2a29 2a29 d cd5700
2a29 2a29 u 03 01
2a29 2a29 s 			CALL	PRINTM		;TELL HIM WE ARE READY
2a2c 2a2c s 		; GET A LINE FROM CONSOLE, AND SEE WHAT HE WANTS
2a2c 2a2c d 31f780
2a2c 2a2c u 03 01
2a2c 2a2c s 		TOP	LD	SP,STACK	;FIX UP STACK IN CASE WE ABORTED SOMETHING
2a2f 2a2f s 			
2a2f 2a2f d 2180ff
2a2f 2a2f u 03 01
2a2f 2a2f s 			LD	HL,RC_TYPE	;Check Auto Boot
2a32 2a32 d cb7e
2a32 2a32 u 02 01
2a32 2a32 s 			BIT	7,(HL)
2a34 2a34 d cbbe
2a34 2a34 u 02 01
2a34 2a34 s 			RES	7,(HL)
2a36 2a36 d c2ec2c
2a36 2a36 u 03 01
2a36 2a36 s 			JP  NZ,	RUN
2a39 2a39 s 			
2a39 2a39 d cdd02a
2a39 2a39 u 03 01
2a39 2a39 s 			CALL	GLINE		;LET HIM GIVE US A LINE
2a3c 2a3c d fe0d
2a3c 2a3c u 02 01
2a3c 2a3c s 			CP	CR		;DID HE ONLY PRESS RETURN
2a3e 2a3e d ca2c2a
2a3e 2a3e u 03 01
2a3e 2a3e s 			JP Z,	TOP		;NOT GOOD ENOUGH, MAKE HIM TRY AGAIN
2a41 2a41 d cdc62a
2a41 2a41 u 03 01
2a41 2a41 s 			CALL	NUM		;DID HIS LINE START WITH A NUMBER
2a44 2a44 d d2af2b
2a44 2a44 u 03 01
2a44 2a44 s 			JP NC,	EDIT		;IF SO, HE IS WRITING A PROGRAM!!!
2a47 2a47 s 		; LOOK UP COMMAND AND EXECUTE
2a47 2a47 d 011d2a
2a47 2a47 u 03 01
2a47 2a47 s 			LD	BC,INIT		;ADDRESS TO RETURN TO
2a4a 2a4a d c5
2a4a 2a4a u 01 01
2a4a 2a4a s 			PUSH	BC		;SAVE SO WE CAN RETURN
2a4b 2a4b d 212135
2a4b 2a4b u 03 01
2a4b 2a4b s 			LD	HL,KTAB-1	;POINT TO COMMAND TABLE
2a4e 2a4e s 		;
2a4e 2a4e s 		; LOCATES COMMAND POINTED TO BY D-E IN THE COMMAND TABLE POINTED TO BY H-L
2a4e 2a4e s 		; AND CHAINS TO THE COMMAND PROCESSING CODE FOR THAT COMMAND
2a4e 2a4e s 		;
2a4e 2a4e d cd0431
2a4e 2a4e u 03 01
2a4e 2a4e s 		CMD	CALL	PARSE1		;ADVANCE TO NEXT CHARACTER
2a51 2a51 d d5
2a51 2a51 u 01 01
2a51 2a51 s 		TLP0	PUSH	DE		;SAVE POINTER TO START OF COMMAND
2a52 2a52 d 23
2a52 2a52 u 01 01
2a52 2a52 s 		CMDL	INC	HL		;ADVANCE IN TABLE
2a53 2a53 d 1a
2a53 2a53 u 01 01
2a53 2a53 s 			LD	A, (DE)		;GET DATA FROM COMMAND
2a54 2a54 d be
2a54 2a54 u 01 01
2a54 2a54 s 			CP	(HL)		;COMPARE WITH TABLE CONTENTS
2a55 2a55 d 13
2a55 2a55 u 01 01
2a55 2a55 s 			INC	DE		;ADVANCE IN COMMAND
2a56 2a56 d ca522a
2a56 2a56 u 03 01
2a56 2a56 s 			JP Z,	CMDL		;IF SAME, KEEP TESTING
2a59 2a59 s 		; DIDN'T MATCH, SEE IF IT'S END OF WORD (HIGH BIT SET)
2a59 2a59 d f680
2a59 2a59 u 02 01
2a59 2a59 s 			OR	0x80		;ARE WE AT END?
2a5b 2a5b d be
2a5b 2a5b u 01 01
2a5b 2a5b s 			CP	(HL)		;AND IS IT THIS ONE?
2a5c 2a5c d ca6f2a
2a5c 2a5c u 03 01
2a5c 2a5c s 			JP Z,	GOTCMD		;IF SO, WE HAVE IT
2a5f 2a5f s 		; WASN'T THAT ENTRY, KEEP LOOKING
2a5f 2a5f d 97
2a5f 2a5f u 01 01
2a5f 2a5f s 			SUB	A		;SEE IT THIS IS END OF TABLE
2a60 2a60 d be
2a60 2a60 u 01 01
2a60 2a60 s 			CP	(HL)		;ARE WE AT END?
2a61 2a61 d ca6e2a
2a61 2a61 u 03 01
2a61 2a61 s 			JP Z,	GOTDEF		;IF SO, WE WILL SAY WE FOUND
2a64 2a64 d d1
2a64 2a64 u 01 01
2a64 2a64 s 			POP	DE		;RESTORE POINTER TO COMMAND
2a65 2a65 d b6
2a65 2a65 u 01 01
2a65 2a65 s 		CMD1	OR	(HL)		;TEST FOR AT END OF TABLE ENTRY
2a66 2a66 d 23
2a66 2a66 u 01 01
2a66 2a66 s 			INC	HL		;POINT TO NEXT
2a67 2a67 d f2652a
2a67 2a67 u 03 01
2a67 2a67 s 			JP P,	CMD1		;IF NO, KEEP LOOKING
2a6a 2a6a d 23
2a6a 2a6a u 01 01
2a6a 2a6a s 			INC	HL		;SKIP FIRST ADDRESS BYTE
2a6b 2a6b d c3512a
2a6b 2a6b u 03 01
2a6b 2a6b s 			JP	TLP0		;TEST THIS ENTRY
2a6e 2a6e s 		; WE HIT THE END OF THE TABLE, ASSUME THE DEFAULT ADDRESS (LET)
2a6e 2a6e d 1b
2a6e 2a6e u 01 01
2a6e 2a6e s 		GOTDEF	DEC	DE		;BACKUP TO START OF WORD
2a6f 2a6f s 		; WE MATCHED ALL THE WAY TO THE END OF A COMMAND WORD, GET IT'S ADDRESS
2a6f 2a6f d 23
2a6f 2a6f u 01 01
2a6f 2a6f s 		GOTCMD	INC	HL		;POINT TO ADDRESS BYTE
2a70 2a70 d 4e
2a70 2a70 u 01 01
2a70 2a70 s 			LD	C,(HL)		;SAVE TEMPORARY
2a71 2a71 d 23
2a71 2a71 u 01 01
2a71 2a71 s 			INC	HL		;POINT TO NEXT ADDRESS BYTE
2a72 2a72 d 66
2a72 2a72 u 01 01
2a72 2a72 s 			LD	H,(HL)		;GET LOW ADDRESS
2a73 2a73 d 69
2a73 2a73 u 01 01
2a73 2a73 s 			LD	L,C		;GET HIGH ADDRESS
2a74 2a74 d e3
2a74 2a74 u 01 01
2a74 2a74 s 			EX	(SP), HL	
2a75 2a75 d c30431
2a75 2a75 u 03 01
2a75 2a75 s 			JP	PARSE1		;SKIP TO NEXT NON-BLANK, AND CHAIN TO CODE
2a78 2a78 s 		;
2a78 2a78 s 		;***************************************************************
2a78 2a78 s 		;              ERROR CHECKING AND HANDLING CODE
2a78 2a78 s 		;***************************************************************
2a78 2a78 s 		;
2a78 2a78 s 		; VCHAR... TESTS FOR A VALID VARIABLE, SYNTAX ERROR IF NOT
2a78 2a78 s 		;
2a78 2a78 d cdfc30
2a78 2a78 u 03 01
2a78 2a78 s 		VCHAR	CALL	CHAR		;TEST VARIABLE
2a7b 2a7b d d0
2a7b 2a7b u 01 01
2a7b 2a7b s 			RET NC			;IF OK, GO BACK
2a7c 2a7c s 		;
2a7c 2a7c s 		; SYNTAX ERROR... HE'S NOT MAKEING ANY SENSE AT ALL
2a7c 2a7c s 		; ISSUE NASTY MESSAGE TO STRAIGHTEN HIM OUT
2a7c 2a7c s 		;
2a7c 2a7c d 21ea35
2a7c 2a7c u 03 01
2a7c 2a7c s 		SYNT	LD	HL,SYN		;GET NASTY 'SYNTAX' MESSAGE
2a7f 2a7f d 1b
2a7f 2a7f u 01 01
2a7f 2a7f s 			DEC	DE		;BACK UP IN SOURCE SO WE DONT SAY WRONG LINE
2a80 2a80 s 		;
2a80 2a80 s 		; ERROR STUFF... SOMETHING HAS GONE WRONG... TELL HIM THE BAD NEWS AND
2a80 2a80 s 		; QUIT ANYTHING THAT WE MAY HAVE STARTED, SO THAT THINGS CAN'T GET WORSE
2a80 2a80 s 		; ALSO, IF WE WERE RUNNING, GIVE HIM THE LINE NUMBER AS A CLUE
2a80 2a80 s 		;
2a80 2a80 d 3e3f
2a80 2a80 u 02 01
2a80 2a80 s 		ERR	LD	A,'?'		;PRECEDE ERROR MESSAGE BY '?'
2a82 2a82 d cd4500
2a82 2a82 u 03 01
2a82 2a82 s 			CALL	BPUTCHR	;DISPLAY ON TERMINAL
2a85 2a85 d 3a3582
2a85 2a85 u 03 01
2a85 2a85 s 			LD	A, (IFLAG)	;WERE WE TRYING TO 'INPUT' SOMETHING)
2a88 2a88 d a7
2a88 2a88 u 01 01
2a88 2a88 s 			AND	A		;IF WE WERE, THEN ..
2a89 2a89 d c2312f
2a89 2a89 u 03 01
2a89 2a89 s 			JP NZ,	INERR		;SPECIAL MESSAGE + HANDLEING
2a8c 2a8c s 		; NOW THAT WE HAVE FIGURED OUT WHAT'S GOING ON, LET HIM IN ON IT
2a8c 2a8c d cd5700
2a8c 2a8c u 03 01
2a8c 2a8c s 			CALL	PRINTM		;PRINT ERROR MESSAGE
2a8f 2a8f d 213d36
2a8f 2a8f u 03 01
2a8f 2a8f s 			LD	HL,EM		;FOLLOWED BY..
2a92 2a92 s 		; PRINT MESSAGE FOLLOWED BY LINE NUMBER (ALSO USED BY 'STOP IN LINE XXXX')
2a92 2a92 d cd5700
2a92 2a92 u 03 01
2a92 2a92 s 		PERR	CALL	PRINTM		;THE ' ERROR ' PART
2a95 2a95 d 3a3482
2a95 2a95 u 03 01
2a95 2a95 s 			LD	A, (RFLAG)	;WERE WE RUNNING..
2a98 2a98 d a7
2a98 2a98 u 01 01
2a98 2a98 s 			AND	A		;IF NOT,
2a99 2a99 d cabd2a
2a99 2a99 u 03 01
2a99 2a99 s 			JP Z,	INLF		;THEN THATS ALL WE HAVE TO DO
2a9c 2a9c s 		; DISPLAY LINE NUMBER OF RUNNING PROGRAM
2a9c 2a9c d 21e035
2a9c 2a9c u 03 01
2a9c 2a9c s 			LD	HL,INL		;ADDRESS OF 'IN LINE ' MESSAGE
2a9f 2a9f d cd5700
2a9f 2a9f u 03 01
2a9f 2a9f s 			CALL	PRINTM		;DISPLAY FOR HIM
2aa2 2aa2 s 		; FIND START OF OUR LINE, AND DISPLAY LINE NUMBER
2aa2 2aa2 d 1b
2aa2 2aa2 u 01 01
2aa2 2aa2 s 		FSOL	DEC	DE		;BACK UP IN SOURCE
2aa3 2aa3 d 7a
2aa3 2aa3 u 01 01
2aa3 2aa3 s 			LD	A,D		;GET HIGH BYTE OF ADDRESS
2aa4 2aa4 d fe86
2aa4 2aa4 u 02 01
2aa4 2aa4 s 			CP	HIGH TEXT	;TEST FOR BEYOND BEGINNING
2aa6 2aa6 d daaf2a
2aa6 2aa6 u 03 01
2aa6 2aa6 s 			JP C,	STLIN		;AT START OF LINE
2aa9 2aa9 d 1a
2aa9 2aa9 u 01 01
2aa9 2aa9 s 			LD	A, (DE)		;GET CHARACTER FROM BUFER
2aaa 2aaa d fe0d
2aaa 2aaa u 02 01
2aaa 2aaa s 			CP	CR		;TEST FOR CARRIAGE RETURN
2aac 2aac d c2a22a
2aac 2aac u 03 01
2aac 2aac s 			JP NZ,	FSOL		;IF NOT, KEEP LOOKING
2aaf 2aaf d 13
2aaf 2aaf u 01 01
2aaf 2aaf s 		STLIN	INC	DE		;ADVANCE IN SOURCE
2ab0 2ab0 d eb
2ab0 2ab0 u 01 01
2ab0 2ab0 s 			EX	DE, HL	
2ab1 2ab1 d cd512c
2ab1 2ab1 u 03 01
2ab1 2ab1 s 			CALL	PNUM		;PRINT AND BUFFER LINE NUMBER
2ab4 2ab4 s 		; COPY LINE WITH ERROR INTO OLD LINE EDIT BUFFER, INCASE HE WANTS TO FIX IT
2ab4 2ab4 d 23
2ab4 2ab4 u 01 01
2ab4 2ab4 s 		FIXIT	INC	HL		;SKIP LENGTH BYTE, ADVANCE TO NEXT IN SOURCE
2ab5 2ab5 d 7e
2ab5 2ab5 u 01 01
2ab5 2ab5 s 			LD	A,(HL)		;GET CHARACTER FROM LINE
2ab6 2ab6 d 12
2ab6 2ab6 u 01 01
2ab6 2ab6 s 			LD	(DE), A		;SAVE IN BUFFER
2ab7 2ab7 d 13
2ab7 2ab7 u 01 01
2ab7 2ab7 s 			INC	DE		;ADVANCE TO NEXT IN BUFFER
2ab8 2ab8 d fe0d
2ab8 2ab8 u 02 01
2ab8 2ab8 s 			CP	CR		;TEST FOR END-OF-LINE
2aba 2aba d c2b42a
2aba 2aba u 03 01
2aba 2aba s 			JP NZ,	FIXIT		;IF NOT, KEEP COPYING
2abd 2abd s 		; WAIT FOR CONSOLE INPUT, ON A NEW LINE
2abd 2abd d cd8000
2abd 2abd u 03 01
2abd 2abd s 		INLF	CALL	BPUTNL		;ADVANCE A LINE ON HIS TERMINAL
2ac0 2ac0 d cddf2c
2ac0 2ac0 u 03 01
2ac0 2ac0 s 			CALL	RESET		;RESET DATA POINTER AND CONTROL-STACK
2ac3 2ac3 d c31d2a
2ac3 2ac3 u 03 01
2ac3 2ac3 s 			JP	INIT		;GET NEXT COMMAND
2ac6 2ac6 s 		;
2ac6 2ac6 s 		; SUBROUTINE TEST FOR VALID ASCII DIGIT (0-9), RETURNS WITH C=1 IF NOT
2ac6 2ac6 s 		;
2ac6 2ac6 d fe30
2ac6 2ac6 u 02 01
2ac6 2ac6 s 		NUM	CP	'0'		;TEST FOR < '0'
2ac8 2ac8 d d8
2ac8 2ac8 u 01 01
2ac8 2ac8 s 			RET C			;IF SO, BAD DIGIT
2ac9 2ac9 d fe3a
2ac9 2ac9 u 02 01
2ac9 2ac9 s 			CP	'9'+1		;TEST FOR >'9'
2acb 2acb d 3f
2acb 2acb u 01 01
2acb 2acb s 			CCF			;INVERT LOGIC, C=1 IF BAD
2acc 2acc d c9
2acc 2acc u 01 01
2acc 2acc s 			RET
2acd 2acd s 		;
2acd 2acd s 		;***************************************************************
2acd 2acd s 		;                    TEXT EDITING ROUTINES
2acd 2acd s 		;***************************************************************
2acd 2acd s 		;
2acd 2acd s 		; SUBROUTINE TO GET AND EDIT COMMAND LINE FROM TERMINAL
2acd 2acd s 		;
2acd 2acd d cd8000
2acd 2acd u 03 01
2acd 2acd s 		BADLN	CALL	BPUTNL		;ADVANCE TO NEW LINE
2ad0 2ad0 d 110080
2ad0 2ad0 u 03 01
2ad0 2ad0 s 		GLINE	LD	DE,BUFF		;POINT TO INPUT BUFFER
2ad3 2ad3 d 210081
2ad3 2ad3 u 03 01
2ad3 2ad3 s 			LD	HL,EDBUF	;POINT TO EDIT BUFFER
2ad6 2ad6 d 43
2ad6 2ad6 u 01 01
2ad6 2ad6 s 			LD	B,E		;CLEAR INSERT FLAG (LOW ADR OF BUFFER IS ZERO)
2ad7 2ad7 d 7b
2ad7 2ad7 u 01 01
2ad7 2ad7 s 		LOOP1	LD	A,E		;GET LOW ADDRESS OF OUR POSITION
2ad8 2ad8 d a7
2ad8 2ad8 u 01 01
2ad8 2ad8 s 			AND	A		;TEST FOR NEGATIVE
2ad9 2ad9 d facd2a
2ad9 2ad9 u 03 01
2ad9 2ad9 s 			JP M,	BADLN		;IF SO, HE'S DELETED BEYOND START OF BUFFER
2adc 2adc d cded34
2adc 2adc u 03 01
2adc 2adc s 			CALL	BGETCHR		;GET A CHARACTER
2adf 2adf d fe03
2adf 2adf u 02 01
2adf 2adf s 			CP	3		;TEST FOR CONTROL-C (CANCEL)
2ae1 2ae1 d cabd2a
2ae1 2ae1 u 03 01
2ae1 2ae1 s 			JP Z,	INLF		;IF SO, ABORT BACK TO COMMAND HANDLER
2ae4 2ae4 d fe06
2ae4 2ae4 u 02 01
2ae4 2ae4 s 			CP	6		;TEST FOR CONTROL-F (FIND COMMAND)
2ae6 2ae6 d ca672b
2ae6 2ae6 u 03 01
2ae6 2ae6 s 			JP Z,	GFIND		;EXECUTE FIND
2ae9 2ae9 d fe01
2ae9 2ae9 u 02 01
2ae9 2ae9 s 			CP	1		;TEST FOR CONTROL-A (ADVANCE COMMAND)
2aeb 2aeb d ca492b
2aeb 2aeb u 03 01
2aeb 2aeb s 			JP Z,	GADV		;EXECUTE ADVANCE
2aee 2aee d fe09
2aee 2aee u 02 01
2aee 2aee s 			CP	9		;TEST FOR CONTROL-I (TOGGLE INSERT MODE)
2af0 2af0 d ca8a2b
2af0 2af0 u 03 01
2af0 2af0 s 			JP Z,	GINST		;TOGGLE INSERT MODE
2af3 2af3 d fe04
2af3 2af3 u 02 01
2af3 2af3 s 			CP	4		;TEST FOR CONTROL-D (DELETE CHARACTER.)
2af5 2af5 d ca582b
2af5 2af5 u 03 01
2af5 2af5 s 			JP Z,	GRUB		;ERASE CHARACTER
2af8 2af8 d fe20
2af8 2af8 u 02 01
2af8 2af8 s 			CP	' '		;TEST FOR CONTROL-CHARACTER
2afa 2afa d d2072b
2afa 2afa u 03 01
2afa 2afa s 			JP NC,	OKPRT		;IF NOT, OK TO PROCESS
2afd 2afd d fe0d
2afd 2afd u 02 01
2afd 2afd s 			CP	CR		;CARRIAGE RETURN IS OK,
2aff 2aff d ca072b
2aff 2aff u 03 01
2aff 2aff s 			JP Z,	OKPRT		;SO PROCESS IT
2b02 2b02 d fe08
2b02 2b02 u 02 01
2b02 2b02 s 			CP	8		;SO IS A BACKSPACE
2b04 2b04 d c2d72a
2b04 2b04 u 03 01
2b04 2b04 s 			JP NZ,	LOOP1		;ANYTHING ELSE SHOULD BE IGNORED
2b07 2b07 s 		; WE HAVE GOTTEN A VALID CHARACTER
2b07 2b07 d fe7f
2b07 2b07 u 02 01
2b07 2b07 s 		OKPRT	CP	DELETE		;TEST FOR DELETE CHARACTER
2b09 2b09 d c20e2b
2b09 2b09 u 03 01
2b09 2b09 s 			JP NZ,	RECT		;IF IT IS A DELETE,
2b0c 2b0c d 3e08
2b0c 2b0c u 02 01
2b0c 2b0c s 			LD	A,8		;MAKE IT INTO A BACKSPACE
2b0e 2b0e d 4f
2b0e 2b0e u 01 01
2b0e 2b0e s 		RECT	LD	C,A		;COPY INTO C
2b0f 2b0f d cd4500
2b0f 2b0f u 03 01
2b0f 2b0f s 			CALL	BPUTCHR		;DISPLAY ON TERMINAL
2b12 2b12 d 1b
2b12 2b12 u 01 01
2b12 2b12 s 			DEC	DE		;ASSUME DELETE (BACKSPACE)
2b13 2b13 s 		; DON'T DELETE CHARS FROM OLD LINE BUFFER IF WE ARE INSERTING
2b13 2b13 d b0
2b13 2b13 u 01 01
2b13 2b13 s 			OR	B		;TEST INSERT FLAG
2b14 2b14 d fa182b
2b14 2b14 u 03 01
2b14 2b14 s 			JP M,	IND		;IF NOT, WE ARE INSERTING
2b17 2b17 d 2b
2b17 2b17 u 01 01
2b17 2b17 s 			DEC	HL		;REDUCE OLD BUFFER POSITION
2b18 2b18 d 79
2b18 2b18 u 01 01
2b18 2b18 s 		IND	LD	A,C		;GET CHARACTER BACK
2b19 2b19 d fe08
2b19 2b19 u 02 01
2b19 2b19 s 			CP	8		;TEST FOR DELETE (BACKSPACE)
2b1b 2b1b d cad72a
2b1b 2b1b u 03 01
2b1b 2b1b s 			JP Z,	LOOP1		;IF SO, WE WERE RIGHT, GET NEXT CHARACTER
2b1e 2b1e d 13
2b1e 2b1e u 01 01
2b1e 2b1e s 			INC	DE		;FIX OUR MISTAKE (NOT DELETE)
2b1f 2b1f d 12
2b1f 2b1f u 01 01
2b1f 2b1f s 			LD	(DE), A		;SAVE CHARACTER IN BUFFER)
2b20 2b20 s 		; DON'T MOVE OLD LINE POINTER IF WE ARE INSERTING
2b20 2b20 d b0
2b20 2b20 u 01 01
2b20 2b20 s 			OR	B		;TEST INSERT FLAG
2b21 2b21 d fa2c2b
2b21 2b21 u 03 01
2b21 2b21 s 			JP M,	INOK		;IF SO, DON'T INCREMENT
2b24 2b24 d 23
2b24 2b24 u 01 01
2b24 2b24 s 			INC	HL		;ADVANCE IN OLD LINE BUFFER
2b25 2b25 d 7e
2b25 2b25 u 01 01
2b25 2b25 s 			LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2b26 2b26 d fe0d
2b26 2b26 u 02 01
2b26 2b26 s 			CP	CR		;TEST FOR END OF OLD LINE
2b28 2b28 d ca2c2b
2b28 2b28 u 03 01
2b28 2b28 s 			JP Z,	INOK		;IF SO, DON'T GO PAST IT
2b2b 2b2b d 23
2b2b 2b2b u 01 01
2b2b 2b2b s 			INC	HL		;ADVANCE TO NEXT CHARACTER OF OLD LINE
2b2c 2b2c d 79
2b2c 2b2c u 01 01
2b2c 2b2c s 		INOK	LD	A,C		;GET CHARACTER BACK
2b2d 2b2d d 13
2b2d 2b2d u 01 01
2b2d 2b2d s 			INC	DE		;ADVANCE POINTER IN NEW LINE
2b2e 2b2e d fe0d
2b2e 2b2e u 02 01
2b2e 2b2e s 			CP	CR		;TEST FOR CARRAIGE RETURN (END OF LINE)
2b30 2b30 d c2d72a
2b30 2b30 u 03 01
2b30 2b30 s 			JP NZ,	LOOP1		;IF NOT, KEEP GETTING CHARACTERS
2b33 2b33 d cd8000
2b33 2b33 u 03 01
2b33 2b33 s 			CALL	BPUTNL		;PRINT LINE-FEED CARRIAGE RETURN
2b36 2b36 s 		; COPY NEW LINE INTO OLD LINE BUFFER (MAKEING IT THE 'NEW' OLD LINE)
2b36 2b36 d 110080
2b36 2b36 u 03 01
2b36 2b36 s 			LD	DE,BUFF		;POINT BACK TO NEW LINE BUFFER
2b39 2b39 d d5
2b39 2b39 u 01 01
2b39 2b39 s 			PUSH	DE		;SAVE BUFFER ADDRESS
2b3a 2b3a d 210081
2b3a 2b3a u 03 01
2b3a 2b3a s 			LD	HL,EDBUF	;POINT TO OLD LINE BUFFER
2b3d 2b3d d 1a
2b3d 2b3d u 01 01
2b3d 2b3d s 		MOVL	LD	A, (DE)		;GET CHARACTER FROM NEW LINE
2b3e 2b3e d 77
2b3e 2b3e u 01 01
2b3e 2b3e s 			LD	(HL),A		;SAVE IN OLD LINE BUFFER
2b3f 2b3f d 23
2b3f 2b3f u 01 01
2b3f 2b3f s 			INC	HL		;POINT TO NEXT
2b40 2b40 d 13
2b40 2b40 u 01 01
2b40 2b40 s 			INC	DE		;POINT TO NEXT
2b41 2b41 d fe0d
2b41 2b41 u 02 01
2b41 2b41 s 			CP	CR		;TEST FOR END OF LINE
2b43 2b43 d c23d2b
2b43 2b43 u 03 01
2b43 2b43 s 			JP NZ,	MOVL		;IF NOT, KEEP MOVEING
2b46 2b46 d d1
2b46 2b46 u 01 01
2b46 2b46 s 			POP	DE		;RESTORE BUFFER ADDRESS
2b47 2b47 d 1a
2b47 2b47 u 01 01
2b47 2b47 s 			LD	A, (DE)		;AND FIRST CHARACTER FROM IT
2b48 2b48 d c9
2b48 2b48 u 01 01
2b48 2b48 s 			RET
2b49 2b49 s 		; COPY ONE CHARACTER FROM OLD LINE TO NEW LINE
2b49 2b49 d 7e
2b49 2b49 u 01 01
2b49 2b49 s 		GADV	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2b4a 2b4a d fe0d
2b4a 2b4a u 02 01
2b4a 2b4a s 			CP	CR		;INSURE ITS NOT THE END
2b4c 2b4c d cad72a
2b4c 2b4c u 03 01
2b4c 2b4c s 			JP Z,	LOOP1		;IF SO, IGNORE COMMAND
2b4f 2b4f d b0
2b4f 2b4f u 01 01
2b4f 2b4f s 			OR	B		;TEST INSERT FLAG
2b50 2b50 d 7e
2b50 2b50 u 01 01
2b50 2b50 s 			LD	A,(HL)		;GET CHARACTER BACK
2b51 2b51 d f20e2b
2b51 2b51 u 03 01
2b51 2b51 s 			JP P,	RECT		;IF NO INSERT, OK
2b54 2b54 d 23
2b54 2b54 u 01 01
2b54 2b54 s 			INC	HL		;ADVANCE TO NEXT
2b55 2b55 d c30e2b
2b55 2b55 u 03 01
2b55 2b55 s 			JP	RECT		;PASS CHARACTER TO INPUT ROUTINE
2b58 2b58 s 		; RUB OUT ONE CHARACTER FROM THE OLD LINE
2b58 2b58 d 7e
2b58 2b58 u 01 01
2b58 2b58 s 		GRUB	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2b59 2b59 d fe0d
2b59 2b59 u 02 01
2b59 2b59 s 			CP	CR		;TEST FOR END OF LINE
2b5b 2b5b d cad72a
2b5b 2b5b u 03 01
2b5b 2b5b s 			JP Z,	LOOP1		;IF SO, IGNORE COMMAND
2b5e 2b5e d 3e2a
2b5e 2b5e u 02 01
2b5e 2b5e s 			LD	A,'*'		;INDICATE RUBBED OUT CHARACTER WITH '*'
2b60 2b60 d cd4500
2b60 2b60 u 03 01
2b60 2b60 s 			CALL	BPUTCHR	;PRINT  IT TO SHOW WHAT WE ARE DOING
2b63 2b63 d 23
2b63 2b63 u 01 01
2b63 2b63 s 			INC	HL		;ADVANCE PASSED CHARACTER (RUBBING IT OUT)
2b64 2b64 d c3d72a
2b64 2b64 u 03 01
2b64 2b64 s 			JP	LOOP1		;RETURN FOR NEXT CHARACTER
2b67 2b67 s 		; FIND NEXT CHARACTER IN NEW LINE
2b67 2b67 d cded34
2b67 2b67 u 03 01
2b67 2b67 s 		GFIND	CALL	BGETCHR		;GET A CHARACTER
2b6a 2b6a d 4f
2b6a 2b6a u 01 01
2b6a 2b6a s 			LD	C,A		;SAVE IN C (TO COMPARE AGAINST.)
2b6b 2b6b d e5
2b6b 2b6b u 01 01
2b6b 2b6b s 			PUSH	HL		;SAVE POSITION IN OLD LINE
2b6c 2b6c s 		; FIND OUT IF IT IS THERE..
2b6c 2b6c d 7e
2b6c 2b6c u 01 01
2b6c 2b6c s 		GF1	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2b6d 2b6d d fe0d
2b6d 2b6d u 02 01
2b6d 2b6d s 		GF0	CP	CR		;TEST FOR END OF LINE
2b6f 2b6f d ca862b
2b6f 2b6f u 03 01
2b6f 2b6f s 			JP Z,	ABFND		;IF SO, WE DIDN'T FIND IT
2b72 2b72 d 23
2b72 2b72 u 01 01
2b72 2b72 s 			INC	HL		;ADVANCE TO NEXT CHARACTER
2b73 2b73 d 7e
2b73 2b73 u 01 01
2b73 2b73 s 			LD	A,(HL)		;GET CHARACTER
2b74 2b74 d b9
2b74 2b74 u 01 01
2b74 2b74 s 			CP	C		;TEST FOR CHARACTER WE DESIRE
2b75 2b75 d c26d2b
2b75 2b75 u 03 01
2b75 2b75 s 			JP NZ,	GF0		;IF NOT, KEEP LOOKING
2b78 2b78 d e1
2b78 2b78 u 01 01
2b78 2b78 s 			POP	HL		;RESTORE POSITION ON OLD LINE
2b79 2b79 s 		; NOW COPY OLD LINE OVER..
2b79 2b79 d 7e
2b79 2b79 u 01 01
2b79 2b79 s 		GF2	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
2b7a 2b7a d 12
2b7a 2b7a u 01 01
2b7a 2b7a s 		GF3	LD	(DE), A		;SAVE IN NEW LINE
2b7b 2b7b d cd4500
2b7b 2b7b u 03 01
2b7b 2b7b s 			CALL	BPUTCHR	;DISPLAY ON TERMINAL
2b7e 2b7e d 23
2b7e 2b7e u 01 01
2b7e 2b7e s 			INC	HL		;POINT TO NEXT CHAR. IN OLD LINE
2b7f 2b7f d 13
2b7f 2b7f u 01 01
2b7f 2b7f s 			INC	DE		;POINT TO NEXT CHAR IN NEW LINE
2b80 2b80 d 7e
2b80 2b80 u 01 01
2b80 2b80 s 			LD	A,(HL)		;GET NEXT CHAR FROM NEW LINE
2b81 2b81 d b9
2b81 2b81 u 01 01
2b81 2b81 s 			CP	C		;TEST FOR CHARACTER WE WANT
2b82 2b82 d c27a2b
2b82 2b82 u 03 01
2b82 2b82 s 			JP NZ,	GF3		;IF NOT, KEEP COPYING
2b85 2b85 d e5
2b85 2b85 u 01 01
2b85 2b85 s 			PUSH	HL		;FIX UP STACK
2b86 2b86 d e1
2b86 2b86 u 01 01
2b86 2b86 s 		ABFND	POP	HL		;RESTORE POSITION IN OLD LINE
2b87 2b87 d c3d72a
2b87 2b87 u 03 01
2b87 2b87 s 			JP	LOOP1		;GET NEXT CHARACTER
2b8a 2b8a s 		; TOGGLE INSERT MODE
2b8a 2b8a d 78
2b8a 2b8a u 01 01
2b8a 2b8a s 		GINST	LD	A,B		;GET INSERT MODE FLAG
2b8b 2b8b d eeff
2b8b 2b8b u 02 01
2b8b 2b8b s 			XOR	0xFF		;COMPLEMENT, SETTING FLAGS
2b8d 2b8d d 47
2b8d 2b8d u 01 01
2b8d 2b8d s 			LD	B,A		;REAVE IN FLAG REGISTER
2b8e 2b8e d 3e3c
2b8e 2b8e u 02 01
2b8e 2b8e s 			LD	A,'<'		;INDICATE ENTERING INSERT MODE
2b90 2b90 d fa952b
2b90 2b90 u 03 01
2b90 2b90 s 			JP M,	GIN1		;IF SO, INDICATE SO
2b93 2b93 d 3e3e
2b93 2b93 u 02 01
2b93 2b93 s 			LD	A,'>'		;INDICATE LEAVING INSERT
2b95 2b95 d cd4500
2b95 2b95 u 03 01
2b95 2b95 s 		GIN1	CALL	BPUTCHR	;DISPLAY INDICATOR ON TERMINAL
2b98 2b98 d c3d72a
2b98 2b98 u 03 01
2b98 2b98 s 			JP	LOOP1		;GET NEXT CHARACTER FROM TERMINAL
2b9b 2b9b s 		;
2b9b 2b9b s 		; GET A PACKED-DECIMAL LINE NUMBER FROM THE COMMAND BUFFER
2b9b 2b9b s 		;
2b9b 2b9b d 210000
2b9b 2b9b u 03 01
2b9b 2b9b s 		GETLN	LD	HL,0		;START WITH ZERO
2b9e 2b9e d 1a
2b9e 2b9e u 01 01
2b9e 2b9e s 		ELOOP	LD	A, (DE)		;GET DIGIT FROM COMMAND BUFFER
2b9f 2b9f d cdc62a
2b9f 2b9f u 03 01
2b9f 2b9f s 			CALL	NUM		;TEST FOR ASCII DIGIT
2ba2 2ba2 d d8
2ba2 2ba2 u 01 01
2ba2 2ba2 s 			RET C			;IF NOT, STOP (WE HAVE IT)
2ba3 2ba3 d 13
2ba3 2ba3 u 01 01
2ba3 2ba3 s 			INC	DE		;ADVANCE TO NEXT BUFFER POSITION
2ba4 2ba4 d 29
2ba4 2ba4 u 01 01
2ba4 2ba4 s 			ADD	HL,HL		;MAKE ROOM FOR DIGIT IN BOTTOM..
2ba5 2ba5 d 29
2ba5 2ba5 u 01 01
2ba5 2ba5 s 			ADD	HL,HL		;OF THE RESULT, BY ..
2ba6 2ba6 d 29
2ba6 2ba6 u 01 01
2ba6 2ba6 s 			ADD	HL,HL		;ROTATING IT..
2ba7 2ba7 d 29
2ba7 2ba7 u 01 01
2ba7 2ba7 s 			ADD	HL,HL		;LEFT BY FOUR BITS
2ba8 2ba8 d e60f
2ba8 2ba8 u 02 01
2ba8 2ba8 s 			AND	0x0F		;CONVERT DIGIT TO BINARY
2baa 2baa d b5
2baa 2baa u 01 01
2baa 2baa s 			OR	L		;INSERT INTO LOWER DIGITS OF RESULT
2bab 2bab d 6f
2bab 2bab u 01 01
2bab 2bab s 			LD	L,A		;AND REPLACE BYTE IN RESULT WITH NEW VALUE
2bac 2bac d c39e2b
2bac 2bac u 03 01
2bac 2bac s 			JP	ELOOP		;GET NEXT DIGIT
2baf 2baf s 		;
2baf 2baf s 		; LINE EDITOR, EDITS PROGRAM SOURCE BY LINE NUMBER IN COMMAND BUFFER
2baf 2baf s 		;
2baf 2baf d cd1f2c
2baf 2baf u 03 01
2baf 2baf s 		EDIT	CALL	LINEF		;LOCATE LINE NUMBER IN SOURCE
2bb2 2bb2 d e5
2bb2 2bb2 u 01 01
2bb2 2bb2 s 			PUSH	HL		;SAVE POINTER INTO TEXT
2bb3 2bb3 d c2c72b
2bb3 2bb3 u 03 01
2bb3 2bb3 s 			JP NZ,	INS		;IF NEW LINE, DON'T TRY TO DELETE
2bb6 2bb6 s 		; DELETE LINE POINTED TO BY H-L
2bb6 2bb6 d 54
2bb6 2bb6 u 01 01
2bb6 2bb6 s 		DEL	LD	D,H		;COPY POINTER INTO
2bb7 2bb7 d 5d
2bb7 2bb7 u 01 01
2bb7 2bb7 s 			LD	E,L		;THE D-E PAIR FOR BACKWARDS COPY
2bb8 2bb8 d 3e0d
2bb8 2bb8 u 02 01
2bb8 2bb8 s 			LD	A,CR		;WE ARE LOOKING FOR A CARRIAGE RETURN
2bba 2bba s 		; FIND START OF NEXT LINE
2bba 2bba d be
2bba 2bba u 01 01
2bba 2bba s 		DELNX	CP	(HL)		;TEST FOR END OF LINE TO DELETE
2bbb 2bbb d 23
2bbb 2bbb u 01 01
2bbb 2bbb s 			INC	HL		;POINT TO NEXT CHARACTER IN SOURCE
2bbc 2bbc d c2ba2b
2bbc 2bbc u 03 01
2bbc 2bbc s 			JP NZ,	DELNX		;IF NOT END OF LINE, KEEP LOOKING
2bbf 2bbf s 		; COPY REST OF PROGRAM BACK OVER DELETED LINE
2bbf 2bbf d 7e
2bbf 2bbf u 01 01
2bbf 2bbf s 		DELLP	LD	A,(HL)		;GET CHARACTER FROM NEXT LINE
2bc0 2bc0 d 12
2bc0 2bc0 u 01 01
2bc0 2bc0 s 			LD	(DE), A		;SAVE OVER DELETED LINE
2bc1 2bc1 d 13
2bc1 2bc1 u 01 01
2bc1 2bc1 s 			INC	DE		;POINT TO NEXT IN NEW LINE
2bc2 2bc2 d 23
2bc2 2bc2 u 01 01
2bc2 2bc2 s 			INC	HL		;POINT TO NEXT IN OLD LINE
2bc3 2bc3 d 3c
2bc3 2bc3 u 01 01
2bc3 2bc3 s 			INC	A		;TEST FOR END OF FILE
2bc4 2bc4 d c2bf2b
2bc4 2bc4 u 03 01
2bc4 2bc4 s 			JP NZ,	DELLP		;IF NOT, KEEP DELETEING
2bc7 2bc7 s 		; INSERT LINE INTO TEXT
2bc7 2bc7 d 010200
2bc7 2bc7 u 03 01
2bc7 2bc7 s 		INS	LD	BC,2		;SET LENGTH TO 2 (PACKED DECIMAL NUMBERS ARE 2)
2bca 2bca d 110080
2bca 2bca u 03 01
2bca 2bca s 			LD	DE,BUFF		;POINT TO BUFFER (CONTAINING NEW LINE)
2bcd 2bcd s 		; CALCULATE LENGTH OF LINE
2bcd 2bcd d cd9b2b
2bcd 2bcd u 03 01
2bcd 2bcd s 			CALL	GETLN		;REMOVE NUMBERS AS THEY ARE NOT STORED AS TEXT
2bd0 2bd0 d 0c
2bd0 2bd0 u 01 01
2bd0 2bd0 s 		ILP	INC	C		;INCREMENT LENGTH
2bd1 2bd1 d 1a
2bd1 2bd1 u 01 01
2bd1 2bd1 s 			LD	A, (DE)		;GET CHARACTER FROM NEW LINE (IN BUFFER)
2bd2 2bd2 d 13
2bd2 2bd2 u 01 01
2bd2 2bd2 s 			INC	DE		;POINT TO NEXT CHARACTER FROM NEW LINE
2bd3 2bd3 d fe0d
2bd3 2bd3 u 02 01
2bd3 2bd3 s 			CP	CR		;TEST FOR END OF LINE
2bd5 2bd5 d c2d02b
2bd5 2bd5 u 03 01
2bd5 2bd5 s 			JP NZ,	ILP		;IF NOT, KEEP COUNTING
2bd8 2bd8 d 79
2bd8 2bd8 u 01 01
2bd8 2bd8 s 			LD	A,C		;GET LENGTH
2bd9 2bd9 d e1
2bd9 2bd9 u 01 01
2bd9 2bd9 s 			POP	HL		;RESTORE POSITION IN TEXT
2bda 2bda d fe03
2bda 2bda u 02 01
2bda 2bda s 			CP	3		;TEST FOR NULL LINE
2bdc 2bdc d ca2c2a
2bdc 2bdc u 03 01
2bdc 2bdc s 			JP Z,	TOP		;IS SO, DON'T INSERT
2bdf 2bdf s 		; INSERT NEW LINE INTO TEXT
2bdf 2bdf d 54
2bdf 2bdf u 01 01
2bdf 2bdf s 		INLN	LD	D,H		;SET D-E TO POINT TO
2be0 2be0 d 5d
2be0 2be0 u 01 01
2be0 2be0 s 			LD	E,L		;THE LINE POSITION
2be1 2be1 d cdbb30
2be1 2be1 u 03 01
2be1 2be1 s 			CALL	GETEOF		;GET END OF FILE ADDRESS
2be4 2be4 d 23
2be4 2be4 u 01 01
2be4 2be4 s 			INC	HL		;ADVANCE TO FREE BYTE
2be5 2be5 d c5
2be5 2be5 u 01 01
2be5 2be5 s 			PUSH	BC		;SAVE LENGTH
2be6 2be6 d e5
2be6 2be6 u 01 01
2be6 2be6 s 			PUSH	HL		;STACK END OF FILE ADDRESS
2be7 2be7 d 09
2be7 2be7 u 01 01
2be7 2be7 s 			ADD	HL,BC		;ADD LENGTH
2be8 2be8 d c1
2be8 2be8 u 01 01
2be8 2be8 s 			POP	BC		;GET END OF FILE ADDRESS
2be9 2be9 d 23
2be9 2be9 u 01 01
2be9 2be9 s 			INC	HL		;ADVANCE BECAUSE WE DECREMENT
2bea 2bea d 2b
2bea 2bea u 01 01
2bea 2bea s 		IL01	DEC	HL		;REDUCE POINTER INTO NEW POSITION
2beb 2beb d 0b
2beb 2beb u 01 01
2beb 2beb s 			DEC	BC		;REDUCE POINTER TO OLD POSITION
2bec 2bec d 0a
2bec 2bec u 01 01
2bec 2bec s 			LD	A, (BC)		;GET BYTE OF OLD DATA
2bed 2bed d 77
2bed 2bed u 01 01
2bed 2bed s 			LD	(HL),A		;SAVE IN NEW POSITION
2bee 2bee d 79
2bee 2bee u 01 01
2bee 2bee s 			LD	A,C		;GET LOW ADDRESS
2bef 2bef d bb
2bef 2bef u 01 01
2bef 2bef s 			CP	E		;TEST AGAINST WHERE WE ARE GOING
2bf0 2bf0 d c2ea2b
2bf0 2bf0 u 03 01
2bf0 2bf0 s 			JP NZ,	IL01		;IF NOT, KEEP COPYING
2bf3 2bf3 d 78
2bf3 2bf3 u 01 01
2bf3 2bf3 s 			LD	A,B		;GET HIGH ADDRESS
2bf4 2bf4 d ba
2bf4 2bf4 u 01 01
2bf4 2bf4 s 			CP	D		;TEST AGAINST DESTINATION
2bf5 2bf5 d c2ea2b
2bf5 2bf5 u 03 01
2bf5 2bf5 s 			JP NZ,	IL01		;IF NOT SAME, KEEP COPYING
2bf8 2bf8 d 110080
2bf8 2bf8 u 03 01
2bf8 2bf8 s 			LD	DE,BUFF		;GET ADDRESS OF NEW LINE
2bfb 2bfb d cd9b2b
2bfb 2bfb u 03 01
2bfb 2bfb s 			CALL	GETLN		;OBTAIN NUMBERS
2bfe 2bfe d 7c
2bfe 2bfe u 01 01
2bfe 2bfe s 			LD	A,H		;GET HIGH 2 DIGITS
2bff 2bff d 02
2bff 2bff u 01 01
2bff 2bff s 			LD	(BC), A		;SAVE IN NEW LINE
2c00 2c00 d 03
2c00 2c00 u 01 01
2c00 2c00 s 			INC	BC		;POINT TO NEXT CHARACTER OF NEW LINE
2c01 2c01 d 7d
2c01 2c01 u 01 01
2c01 2c01 s 			LD	A,L		;GET LOW DIGITS
2c02 2c02 d 02
2c02 2c02 u 01 01
2c02 2c02 s 			LD	(BC), A		;SAVE IN NEW LINE
2c03 2c03 d 03
2c03 2c03 u 01 01
2c03 2c03 s 			INC	BC		;ADVANCE TO NEXT CHARACTER IN NEW LINE
2c04 2c04 d e1
2c04 2c04 u 01 01
2c04 2c04 s 			POP	HL		;RESTORE LENGTH
2c05 2c05 d 7d
2c05 2c05 u 01 01
2c05 2c05 s 			LD	A,L		;GET LENGTH
2c06 2c06 d c610
2c06 2c06 u 02 01
2c06 2c06 s 			ADD	A,0x10		;ADD OFFSET TO MAKE UNIQUE
2c08 2c08 d 02
2c08 2c08 u 01 01
2c08 2c08 s 			LD	(BC), A		;SAVE IN NEW LINE
2c09 2c09 d 03
2c09 2c09 u 01 01
2c09 2c09 s 			INC	BC		;POINT TO NEXT CHARACTER
2c0a 2c0a d 1a
2c0a 2c0a u 01 01
2c0a 2c0a s 		IL02	LD	A, (DE)		;GET CHARACTER FROM NEW LINE IN BUFFER
2c0b 2c0b d 02
2c0b 2c0b u 01 01
2c0b 2c0b s 			LD	(BC), A		;SAVE IN TEXT
2c0c 2c0c d 03
2c0c 2c0c u 01 01
2c0c 2c0c s 			INC	BC		;POINT TO NEXT POSITION IN TEXT
2c0d 2c0d d 13
2c0d 2c0d u 01 01
2c0d 2c0d s 			INC	DE		;ADVANCE IN BUFFER
2c0e 2c0e d fe0d
2c0e 2c0e u 02 01
2c0e 2c0e s 			CP	CR		;TEST FOR END OF LINE
2c10 2c10 d c20a2c
2c10 2c10 u 03 01
2c10 2c10 s 			JP NZ,	IL02		;IF NOT, KEEP LOOKING
2c13 2c13 s 		; WE ARE INSERTING OR REPLACEING A LINE, SINCE WE DON'T KNOW HOW MUCH
2c13 2c13 s 		; MEMORY IT WILL REQUIRE, WE MUST CLEAR THE ARRAYS, AS THEY FOLLOW THE
2c13 2c13 s 		; PROGRAM. WE DO NOT HAVE TO DO THIS WHEN DELETING LINES
2c13 2c13 d cdcd2c
2c13 2c13 u 03 01
2c13 2c13 s 			CALL	CLRARY		;CLEAR ARRAYS AND RETURN
2c16 2c16 d c32c2a
2c16 2c16 u 03 01
2c16 2c16 s 			JP	TOP		;GO BACK FOR NEXT COMMAND
2c19 2c19 s 		;
2c19 2c19 s 		; LOCATE LINE IN TEXT, SYNTAX ERROR IF NOT LINE NUMBER
2c19 2c19 s 		;
2c19 2c19 d cdc62a
2c19 2c19 u 03 01
2c19 2c19 s 		FNDLIN	CALL	NUM		;IS IT A VALID NUMBER
2c1c 2c1c d da7c2a
2c1c 2c1c u 03 01
2c1c 2c1c s 			JP C,	SYNT		;IF NOT, IT'S A INVALID
2c1f 2c1f s 		;
2c1f 2c1f s 		; FINDS LINE IN PROGRAM TEXT. RETURNS WITH Z FLAG SET IF LINE EXISTS
2c1f 2c1f s 		; H-L POINTS TO START OF LINE. B-C CONTAINS LINE NUMBER OF ACTUAL
2c1f 2c1f s 		; LINE FOUND. (IF LINE NOT FOUND, POINTS TO FIRST GREATER LINE NUMBER)
2c1f 2c1f s 		;
2c1f 2c1f d cd9b2b
2c1f 2c1f u 03 01
2c1f 2c1f s 		LINEF	CALL	GETLN		;GET LINE NUMBER FROM COMMAND BUFFER
2c22 2c22 d eb
2c22 2c22 u 01 01
2c22 2c22 s 			EX	DE, HL	
2c23 2c23 d 210086
2c23 2c23 u 03 01
2c23 2c23 s 			LD	HL,TEXT		;START AT TOP OF PROGRAM
2c26 2c26 d 7e
2c26 2c26 u 01 01
2c26 2c26 s 		TRY	LD	A,(HL)		;GET FIRST CHARACTER FROM PROGRAM LINE
2c27 2c27 d feff
2c27 2c27 u 02 01
2c27 2c27 s 			CP	0xFF		;TEST FOR END OF FILE
2c29 2c29 d ca4e2c
2c29 2c29 u 03 01
2c29 2c29 s 			JP Z,	EOF		;IF SO, WE DIDN'T FIND
2c2c 2c2c d 23
2c2c 2c2c u 01 01
2c2c 2c2c s 			INC	HL		;ADVANCE POINTER TO LOW DIGITS
2c2d 2c2d d ba
2c2d 2c2d u 01 01
2c2d 2c2d s 			CP	D		;TEST FOR HIGH DIGITS CORRECT
2c2e 2c2e d da392c
2c2e 2c2e u 03 01
2c2e 2c2e s 			JP C,	NEXTL		;IF LESS, FIND NEXT LINE
2c31 2c31 d c2462c
2c31 2c31 u 03 01
2c31 2c31 s 			JP NZ,	NOTFND		;IF GREATER, LINE WASN'T FOUND
2c34 2c34 d 7e
2c34 2c34 u 01 01
2c34 2c34 s 			LD	A,(HL)		;GET LOW DIGITS
2c35 2c35 d bb
2c35 2c35 u 01 01
2c35 2c35 s 			CP	E		;TEST LOW DIGITS
2c36 2c36 d d2462c
2c36 2c36 u 03 01
2c36 2c36 s 			JP NC,	NOTFND		;IF LESS, LINE IS HERE OR DOSN'T EXIST
2c39 2c39 s 		; ADVANCE TO NEXT LINE IN SOURCE
2c39 2c39 d 23
2c39 2c39 u 01 01
2c39 2c39 s 		NEXTL	INC	HL		;POINT TO LINE LENGTH
2c3a 2c3a d 7e
2c3a 2c3a u 01 01
2c3a 2c3a s 			LD	A,(HL)		;GET LENGTH
2c3b 2c3b d d611
2c3b 2c3b u 02 01
2c3b 2c3b s 			SUB	0x11		;SUBTRACT OFFSET USED TO MAKE IT UNIQUE
2c3d 2c3d d 85
2c3d 2c3d u 01 01
2c3d 2c3d s 			ADD	A,L		;ADD TO POINTER
2c3e 2c3e d 6f
2c3e 2c3e u 01 01
2c3e 2c3e s 			LD	L,A		;AND REPLACE IN POINTER
2c3f 2c3f d d2262c
2c3f 2c3f u 03 01
2c3f 2c3f s 			JP NC,	TRY		;IF NO CARRY, THATS IT
2c42 2c42 d 23
2c42 2c42 u 01 01
2c42 2c42 s 			INC	HL		;BUMP HIGH ADDRESS
2c43 2c43 d c3262c
2c43 2c43 u 03 01
2c43 2c43 s 			JP	TRY		;AND TEST THIS LINE
2c46 2c46 s 		; LINE IS HERE OR BEFORE
2c46 2c46 d 2b
2c46 2c46 u 01 01
2c46 2c46 s 		NOTFND	DEC	HL		;BACK UP TO DIGIT
2c47 2c47 d 4f
2c47 2c47 u 01 01
2c47 2c47 s 			LD	C,A		;PLACE LOW ORDER DIGIT IN C
2c48 2c48 d 46
2c48 2c48 u 01 01
2c48 2c48 s 			LD	B,(HL)		;PLACE HIGH ORDER DIGIT IN B
2c49 2c49 d bb
2c49 2c49 u 01 01
2c49 2c49 s 			CP	E		;TEST FOR LINE FOUND
2c4a 2c4a d c0
2c4a 2c4a u 01 01
2c4a 2c4a s 			RET NZ			;IF NOT SAME, RETURN INDICATING SO
2c4b 2c4b d 78
2c4b 2c4b u 01 01
2c4b 2c4b s 			LD	A,B		;GET HIGH DIGIT
2c4c 2c4c d ba
2c4c 2c4c u 01 01
2c4c 2c4c s 			CP	D		;INDICATE IF NUMBERS SAME
2c4d 2c4d d c9
2c4d 2c4d u 01 01
2c4d 2c4d s 			RET
2c4e 2c4e s 		; LINE WAS GREATER THAN ALL LINES IN PROGRAM, INDICATE EOF REACHED
2c4e 2c4e d 47
2c4e 2c4e u 01 01
2c4e 2c4e s 		EOF	LD	B,A		;RETURN HIGH LINE NUMBER
2c4f 2c4f d a7
2c4f 2c4f u 01 01
2c4f 2c4f s 			AND	A		;INDICATE LINE DOSN'T EXIST
2c50 2c50 d c9
2c50 2c50 u 01 01
2c50 2c50 s 			RET
2c51 2c51 s 		;
2c51 2c51 s 		; PRINTS PACKED-DECIMAL LINE NUMBER ON TERMINAL, AS WELL AS PLACEING
2c51 2c51 s 		; IT AT THE START OF THE EDIT BUFFER
2c51 2c51 s 		;
2c51 2c51 d 110081
2c51 2c51 u 03 01
2c51 2c51 s 		PNUM	LD	DE,EDBUF	;SET UP POINTER TO EDIT BUFFER
2c54 2c54 d cd572c
2c54 2c54 u 03 01
2c54 2c54 s 			CALL	HPOUT		;PRINT FIRST TWO DIGITS
2c57 2c57 d 7e
2c57 2c57 u 01 01
2c57 2c57 s 		HPOUT	LD	A,(HL)		;GET CONTENTS OF MEMORY
2c58 2c58 d 23
2c58 2c58 u 01 01
2c58 2c58 s 			INC	HL		;AND POINT TO NEXT
2c59 2c59 d f5
2c59 2c59 u 01 01
2c59 2c59 s 			PUSH	AF
2c5a 2c5a d 0f
2c5a 2c5a u 01 01
2c5a 2c5a s 			RRCA			;ROTATE
2c5b 2c5b d 0f
2c5b 2c5b u 01 01
2c5b 2c5b s 			RRCA			;UPPER DIGIT
2c5c 2c5c d 0f
2c5c 2c5c u 01 01
2c5c 2c5c s 			RRCA			;INTO
2c5d 2c5d d 0f
2c5d 2c5d u 01 01
2c5d 2c5d s 			RRCA			;LOWER DIGIT
2c5e 2c5e d cd622c
2c5e 2c5e u 03 01
2c5e 2c5e s 			CALL	POUT		;DISPLAY UPPER DIGIT
2c61 2c61 d f1
2c61 2c61 u 01 01
2c61 2c61 s 			POP	AF
2c62 2c62 s 		; DISPLAYS ONE DIGIT
2c62 2c62 d e60f
2c62 2c62 u 02 01
2c62 2c62 s 		POUT	AND	0x0F		;REMOVE UPPER GARBAGE
2c64 2c64 d f630
2c64 2c64 u 02 01
2c64 2c64 s 			OR	0x30		;CONVERT TO ASCII DIGIT
2c66 2c66 d 12
2c66 2c66 u 01 01
2c66 2c66 s 			LD	(DE), A		;SAVE IN EDIT BUFFER
2c67 2c67 d 13
2c67 2c67 u 01 01
2c67 2c67 s 			INC	DE		;ADVANCE POINTER IN EDIT BUFFER
2c68 2c68 d c34500
2c68 2c68 u 03 01
2c68 2c68 s 			JP	BPUTCHR	;DISPLAY DIGIT ON TERMINAL AND RETURN
2c6b 2c6b s 		;
2c6b 2c6b s 		;*****************************************************************
2c6b 2c6b s 		;                   BASIC COMMAND HANDLERS
2c6b 2c6b s 		;*****************************************************************
2c6b 2c6b s 		;
2c6b 2c6b s 		; IT'S A 'LIST' COMMAND, LETS GIVE HIM A PEEK AT THE SOURCE
2c6b 2c6b s 		; ALSO PLACE LAST LINE LISTED IN BUFFER, INCASE HE WANTS TO EDIT IT
2c6b 2c6b s 		;
2c6b 2c6b d d5
2c6b 2c6b u 01 01
2c6b 2c6b s 		LIST:	PUSH	DE		;SAVE PROGRAM POINTER
2c6c 2c6c d 210086
2c6c 2c6c u 03 01
2c6c 2c6c s 			LD	HL,TEXT		;START AT THE BEGINNING OF THE PROGRAM
2c6f 2c6f d 06ff
2c6f 2c6f u 02 01
2c6f 2c6f s 			LD	B,255		;SET ENDING LINE BEYOND END OF TEXT
2c71 2c71 d 1a
2c71 2c71 u 01 01
2c71 2c71 s 			LD	A, (DE)		;GET CHARACTER OF OPERAND
2c72 2c72 d cdc62a
2c72 2c72 u 03 01
2c72 2c72 s 			CALL	NUM		;TEST FOR A NUMBER
2c75 2c75 d da892c
2c75 2c75 u 03 01
2c75 2c75 s 			JP C,	GO		;IF NOT, LIST WHOLE THING
2c78 2c78 d cd9b2b
2c78 2c78 u 03 01
2c78 2c78 s 			CALL	GETLN		;GET LINE NUMBER
2c7b 2c7b d e5
2c7b 2c7b u 01 01
2c7b 2c7b s 			PUSH	HL		;SAVE ON STACK
2c7c 2c7c d 13
2c7c 2c7c u 01 01
2c7c 2c7c s 			INC	DE		;POINT TO NEXT CHARACTER
2c7d 2c7d d fe2c
2c7d 2c7d u 02 01
2c7d 2c7d s 			CP	','		;TEST FOR ENDING NUMBER
2c7f 2c7f d cc1f2c
2c7f 2c7f u 03 01
2c7f 2c7f s 			CALL Z,	LINEF		;IF SO, GET ENDING NUMBER
2c82 2c82 d 23
2c82 2c82 u 01 01
2c82 2c82 s 			INC	HL		;ADVANCE PAST BEGINNING OF LINE
2c83 2c83 d d1
2c83 2c83 u 01 01
2c83 2c83 s 			POP	DE		;GET STARTING LINE NUMBER BACK
2c84 2c84 d e5
2c84 2c84 u 01 01
2c84 2c84 s 			PUSH	HL		;SAVE ENDING LINE
2c85 2c85 d cd232c
2c85 2c85 u 03 01
2c85 2c85 s 			CALL	LINEF+4		;FIND STARTING LINE ADDRESS
2c88 2c88 d c1
2c88 2c88 u 01 01
2c88 2c88 s 			POP	BC		;GET ENDING ADDRESS BACK
2c89 2c89 s 		; LIST TEXT FROM STARTING LINE IN H-L TO ENDING LINE IN B-C
2c89 2c89 d 7e
2c89 2c89 u 01 01
2c89 2c89 s 		GO	LD	A,(HL)		;GET CHARACTER FROM START OF LINE
2c8a 2c8a d 3c
2c8a 2c8a u 01 01
2c8a 2c8a s 			INC	A		;TEST FOR END OF FILE
2c8b 2c8b d caad2c
2c8b 2c8b u 03 01
2c8b 2c8b s 			JP Z,	LIRET		;IF SO, STOP LISTING
2c8e 2c8e d cd512c
2c8e 2c8e u 03 01
2c8e 2c8e s 			CALL	PNUM		;DISPLAY LINE NUMBER AND BUFFER IT
2c91 2c91 d 23
2c91 2c91 u 01 01
2c91 2c91 s 			INC	HL		;SKIP LENGTH BYTE, AS IT DOSN'T LOOK PRETTY
2c92 2c92 d 7e
2c92 2c92 u 01 01
2c92 2c92 s 		PRINS	LD	A,(HL)		;GET CHARACTER FROM LINE
2c93 2c93 d 12
2c93 2c93 u 01 01
2c93 2c93 s 			LD	(DE), A		;PLACE INTO BUFFER
2c94 2c94 d 13
2c94 2c94 u 01 01
2c94 2c94 s 			INC	DE		;ADVANCE IN BUFFER
2c95 2c95 d cd4500
2c95 2c95 u 03 01
2c95 2c95 s 			CALL	BPUTCHR	;DISPLAY ON TERMINAL
2c98 2c98 d 23
2c98 2c98 u 01 01
2c98 2c98 s 			INC	HL		;ADVANCE POINTER IN PROGRAM
2c99 2c99 d fe0d
2c99 2c99 u 02 01
2c99 2c99 s 			CP	CR		;TEST FOR END OF LINE
2c9b 2c9b d c2922c
2c9b 2c9b u 03 01
2c9b 2c9b s 			JP NZ,	PRINS		;IF NOT, KEEP PRINTING
2c9e 2c9e d cd8000
2c9e 2c9e u 03 01
2c9e 2c9e s 			CALL	BPUTNL		;NEW LINE ON TERMINAL
2ca1 2ca1 d cd6532
2ca1 2ca1 u 03 01
2ca1 2ca1 s 			CALL	COMP		;TEST FOR LAST LINE LISTED
2ca4 2ca4 d d2ad2c
2ca4 2ca4 u 03 01
2ca4 2ca4 s 			JP NC,	LIRET		;IF SO, STOP LISTING
2ca7 2ca7 d cde734
2ca7 2ca7 u 03 01
2ca7 2ca7 s 			CALL	CTRLC		;TEST FOR ABORT FROM TERMINAL
2caa 2caa d c2892c
2caa 2caa u 03 01
2caa 2caa s 			JP NZ,	GO		;KEEP LISTING IF NOT
2cad 2cad d d1
2cad 2cad u 01 01
2cad 2cad s 		LIRET	POP	DE		;RESTORE PROGRAM POINTER
2cae 2cae d c9
2cae 2cae u 01 01
2cae 2cae s 			RET
2caf 2caf s 		;
2caf 2caf s 		; CLEARS VARIABLES AND ARRAYS. (INITIALIZES THEM) AND INITIALIZES EDIT BUFFER
2caf 2caf s 		;
2caf 2caf d 210082
2caf 2caf u 03 01
2caf 2caf s 		CLEAR	LD	HL,VARS		;POINT TO VARIABLE SPACE
2cb2 2cb2 d 3e0d
2cb2 2cb2 u 02 01
2cb2 2cb2 s 			LD	A,CR		;GET A CARRIAGE RETURN (END OF LINE CHARACTER)
2cb4 2cb4 d 320081
2cb4 2cb4 u 03 01
2cb4 2cb4 s 			LD	(EDBUF), A	;INITIALIZE EDIT BUFFER TO A NULL LINE
2cb7 2cb7 d 0e34
2cb7 2cb7 u 02 01
2cb7 2cb7 s 			LD	C,52		;26 VARIABLE TIMES 2 BYTES/VARIABLE
2cb9 2cb9 d 3600
2cb9 2cb9 u 02 01
2cb9 2cb9 s 		CVLP	LD	(HL),0		;CLEAR INTEGER VARAIBLES TO ZERO
2cbb 2cbb d 23
2cbb 2cbb u 01 01
2cbb 2cbb s 			INC	HL		;ADVANCE TO NEXT BYTE OF VARIABLE SPACE
2cbc 2cbc d 0d
2cbc 2cbc u 01 01
2cbc 2cbc s 			DEC	C		;REDUCE COUNT OF VARAIABLES LEFT
2cbd 2cbd d c2b92c
2cbd 2cbd u 03 01
2cbd 2cbd s 			JP NZ,	CVLP		;KEEP GOING TILL ALL INTEGERS ARE ZERO'ED
2cc0 2cc0 d 3e86
2cc0 2cc0 u 02 01
2cc0 2cc0 s 			LD	A,HIGH (VARS + 0x400) ;ADDRESS OF END OF VARIABLE TABLE
2cc2 2cc2 d 010a00
2cc2 2cc2 u 03 01
2cc2 2cc2 s 			LD	BC,10		;SKIP AHEAD 10 BYTES
2cc5 2cc5 d 09
2cc5 2cc5 u 01 01
2cc5 2cc5 s 			ADD	HL,BC		;SO THAT WE DON'T CLOBBER OUR FLAGS
2cc6 2cc6 d 36ff
2cc6 2cc6 u 02 01
2cc6 2cc6 s 		CVL1	LD	(HL),255	;0xFF IS NULL CHARACTER FOR CHAR. VARS
2cc8 2cc8 d 23
2cc8 2cc8 u 01 01
2cc8 2cc8 s 			INC	HL		;POINT TO NEXT BYTE IN CHAR. VAR. SPACE
2cc9 2cc9 d bc
2cc9 2cc9 u 01 01
2cc9 2cc9 s 			CP	H		;TEST FOR COMPLETE (ALL SET TO NULL STRINGS)
2cca 2cca d c2c62c
2cca 2cca u 03 01
2cca 2cca s 			JP NZ,	CVL1		;KEEP GOING TILL WE DO THEM ALL
2ccd 2ccd s 		; INITIALIZE ARRAYS, RESET ARRAY SPACE TO FIRST PAGE FOLLOWING PROGRAM
2ccd 2ccd d cdbb30
2ccd 2ccd u 03 01
2ccd 2ccd s 		CLRARY	CALL	GETEOF		;GET ADDRESS OF FIRST FREE PAGE+SET POINTER
2cd0 2cd0 d 32fd81
2cd0 2cd0 u 03 01
2cd0 2cd0 s 			LD	(ARYLOC), A	;STASH IN ARRAY TABLE POINTER
2cd3 2cd3 d 67
2cd3 2cd3 u 01 01
2cd3 2cd3 s 			LD	H,A		;PLACE IN H, SO WE CAN REFERENCE INDERECT
2cd4 2cd4 d 2e34
2cd4 2cd4 u 02 01
2cd4 2cd4 s 			LD	L,52		;START AT END OF TABLE
2cd6 2cd6 d 223a82
2cd6 2cd6 u 03 01
2cd6 2cd6 s 			LD	(LAST), HL	;INDICATE FREE SPACE FOR NEXT ARRAY
2cd9 2cd9 d 97
2cd9 2cd9 u 01 01
2cd9 2cd9 s 			SUB	A		;GET A ZERO
2cda 2cda d 2d
2cda 2cda u 01 01
2cda 2cda s 		CALS	DEC	L		;BACK UP IN TABLE
2cdb 2cdb d 77
2cdb 2cdb u 01 01
2cdb 2cdb s 			LD	(HL),A		;INITIALIZE TO INDICATE NO ARRAY
2cdc 2cdc d c2da2c
2cdc 2cdc u 03 01
2cdc 2cdc s 			JP NZ,	CALS		;KEEP GOING TILL TABLE IS CLEARED
2cdf 2cdf s 		; RESET CONTROL STACK AND DATA POINTER
2cdf 2cdf d 21fa81
2cdf 2cdf u 03 01
2cdf 2cdf s 		RESET	LD	HL,CS		;GET USER STACK POINTER
2ce2 2ce2 d 22fb81
2ce2 2ce2 u 03 01
2ce2 2ce2 s 			LD	(CSP), HL	;INITIALZE USER STACK POINTER
2ce5 2ce5 d 210000
2ce5 2ce5 u 03 01
2ce5 2ce5 s 			LD	HL,0		;GET A ZERO (NO DATA POINTER)
2ce8 2ce8 d 223882
2ce8 2ce8 u 03 01
2ce8 2ce8 s 			LD	(DATA), HL	;INSURE NO DATA PRESENT
2ceb 2ceb d c9
2ceb 2ceb u 01 01
2ceb 2ceb s 			RET
2cec 2cec s 		;
2cec 2cec s 		; ** WE'VE GOTTEN A 'RUN' COMMAND, LETS START THE PROGRAM ROLLING **
2cec 2cec s 		;
2cec 2cec d 3a0086
2cec 2cec u 03 01
2cec 2cec s 		RUN	LD	A, (TEXT)	;GET FIRST CHARACTER OF PROGRAM
2cef 2cef d 21d535
2cef 2cef u 03 01
2cef 2cef s 			LD	HL,NP		;AND ADDRESS OF 'NO PROGRAM' MESSAGE
2cf2 2cf2 d 3c
2cf2 2cf2 u 01 01
2cf2 2cf2 s 			INC	A		;TEST FOR EXISTANCE OF PROGRAM
2cf3 2cf3 d ca802a
2cf3 2cf3 u 03 01
2cf3 2cf3 s 			JP Z,	ERR		;IF NOT, POINT OUT HIS MISTAKE
2cf6 2cf6 d cdaf2c
2cf6 2cf6 u 03 01
2cf6 2cf6 s 			CALL	CLEAR		;CLEAR VARIABLES AND ARRAYS
2cf9 2cf9 d 110086
2cf9 2cf9 u 03 01
2cf9 2cf9 s 			LD	DE,TEXT		;START INTERPRETING AT THE BEGINNING
2cfc 2cfc d 3eff
2cfc 2cfc u 02 01
2cfc 2cfc s 		RGON	LD	A,255		;INDICATE THAT WE ARE RUNNING
2cfe 2cfe d 323482
2cfe 2cfe u 03 01
2cfe 2cfe s 			LD	(RFLAG), A	;BY SETTING THIS FLAG
2d01 2d01 d 13
2d01 2d01 u 01 01
2d01 2d01 s 		RNEWL	INC	DE		;SKIP PACKED DECIMAL LINE
2d02 2d02 d 13
2d02 2d02 u 01 01
2d02 2d02 s 			INC	DE		;NUMBERS, AND THE LENGTH BYTE,
2d03 2d03 d 13
2d03 2d03 u 01 01
2d03 2d03 s 			INC	DE		;AS THE COMMAND FINDER WON'T LIKE IT
2d04 2d04 s 		; MAIN 'RUN' INTERPRETING LOOP
2d04 2d04 d 31f780
2d04 2d04 u 03 01
2d04 2d04 s 		RLOOP	LD	SP,STACK	;REPAIR ANY DAMAGE
2d07 2d07 d cde734
2d07 2d07 u 03 01
2d07 2d07 s 			CALL	CTRLC		;TEST FOR 'MAGIC' CONTROL-C CHARACTER
2d0a 2d0a d ca2c2d
2d0a 2d0a u 03 01
2d0a 2d0a s 			JP Z,	STOP		;IF SO, FAKE A 'STOP' COMMAND
2d0d 2d0d d 21f234
2d0d 2d0d u 03 01
2d0d 2d0d s 			LD	HL,PTAB-1	;POINT TO PROGRAM COMMAND TABLE
2d10 2d10 d cd4e2a
2d10 2d10 u 03 01
2d10 2d10 s 			CALL	CMD		;RUN PROGRAM CODE
2d13 2d13 s 		; ADVANCE TO NEXT STATEMENT
2d13 2d13 d 1a
2d13 2d13 u 01 01
2d13 2d13 s 		RNEXT	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2d14 2d14 d fe22
2d14 2d14 u 02 01
2d14 2d14 s 			CP	'"'		;TEST FOR A QUOTE
2d16 2d16 d cc2931
2d16 2d16 u 03 01
2d16 2d16 s 			CALL Z,	SKPQUO		;IF SO, SEARCH FOR NEXT ONE
2d19 2d19 d 13
2d19 2d19 u 01 01
2d19 2d19 s 			INC	DE		;ADVANCE TO NEXT CHARACTER
2d1a 2d1a d fe3a
2d1a 2d1a u 02 01
2d1a 2d1a s 			CP	':'		;TEST FOR COLON (NEW STATEMENT)
2d1c 2d1c d ca042d
2d1c 2d1c u 03 01
2d1c 2d1c s 			JP Z,	RLOOP		;IF SO, EXECUTE NEXT COMMAND
2d1f 2d1f d fe0d
2d1f 2d1f u 02 01
2d1f 2d1f s 			CP	CR		;TEST FOR CARRIAGE RETURN
2d21 2d21 d c2132d
2d21 2d21 u 03 01
2d21 2d21 s 			JP NZ,	RNEXT		;IF NOT, KEEP LOOKING
2d24 2d24 d 1a
2d24 2d24 u 01 01
2d24 2d24 s 			LD	A, (DE)		;GET FIRST CHAR OF NEW LINE
2d25 2d25 d 3c
2d25 2d25 u 01 01
2d25 2d25 s 			INC	A		;TEST FOR 0xFF (END OF FILE)
2d26 2d26 d ca1d2a
2d26 2d26 u 03 01
2d26 2d26 s 			JP Z,	INIT		;IF SO, GO BACK TO COMMAND MODE
2d29 2d29 d c3012d
2d29 2d29 u 03 01
2d29 2d29 s 			JP	RNEWL		;EXECUTE THIS LINE
2d2c 2d2c s 			
2d2c 2d2c s 		;
2d2c 2d2c s 		; EITHER WE HAVE GOTTEN A 'STOP' COMMAND, OR THE OPERATOR PRESSED
2d2c 2d2c s 		; CONTROL-C, EITHER WAY, PRINT THE MESSAGE AND BEXIT
2d2c 2d2c s 		;
2d2c 2d2c d 213836
2d2c 2d2c u 03 01
2d2c 2d2c s 		STOP	LD	HL,STMSG	;ADDRESS OF 'STOP' MESSAGE
2d2f 2d2f d c3922a
2d2f 2d2f u 03 01
2d2f 2d2f s 			JP	PERR		;TREAT IT LIKE AN ERROR
2d32 2d32 s 		; IT'S A 'THEN', FOLLOWING AN 'IF', LOOK FOR LINE NUMBER OR A STATEMENT
2d32 2d32 d cdc62a
2d32 2d32 u 03 01
2d32 2d32 s 		THEN	CALL	NUM		;IS IT A NUMBER?
2d35 2d35 d d2432d
2d35 2d35 u 03 01
2d35 2d35 s 			JP NC,	GOTO		;IF SO, ITS A NUMBER TO 'GOTO'
2d38 2d38 d c3042d
2d38 2d38 u 03 01
2d38 2d38 s 			JP	RLOOP		;IF NOT, ITS A STATEMENT TO EXECUTE
2d3b 2d3b s 		;
2d3b 2d3b s 		; IT'S A 'GOSUB' SAVE RETURN ADDRESS, AND PRETEND IT'S 'GOTO'
2d3b 2d3b s 		;
2d3b 2d3b d cdbd2d
2d3b 2d3b u 03 01
2d3b 2d3b s 		GOSUB	CALL	PUSHD		;SAVE SOURCE POSITION
2d3e 2d3e d 97
2d3e 2d3e u 01 01
2d3e 2d3e s 			SUB	A		;INDICATE GOSUB ENTRY
2d3f 2d3f d cda92d
2d3f 2d3f u 03 01
2d3f 2d3f s 			CALL	PUSHS		;SAVE ON USER STACK
2d42 2d42 d 1a
2d42 2d42 u 01 01
2d42 2d42 s 			LD	A, (DE)		;RESTORE OPERAND CHARACTER
2d43 2d43 s 		;
2d43 2d43 s 		; IT'S A 'GOTO' MAKE THE BIG JUMP
2d43 2d43 s 		;
2d43 2d43 d fe28
2d43 2d43 u 02 01
2d43 2d43 s 		GOTO	CP	'('		;TEST FOR COMPUTED GOTO
2d45 2d45 d c25e2d
2d45 2d45 u 03 01
2d45 2d45 s 			JP NZ,	NOON		;IF NO, NOT AN 'ON' STATEMENT
2d48 2d48 d cd3531
2d48 2d48 u 03 01
2d48 2d48 s 			CALL	EXPR		;GET VALUE OF INTERNAL EXPRESSION
2d4b 2d4b d cd0f31
2d4b 2d4b u 03 01
2d4b 2d4b s 		GLPO	CALL	SKIP		;SKIP TO NEXT EXPRESSION
2d4e 2d4e d fe2c
2d4e 2d4e u 02 01
2d4e 2d4e s 			CP	','		;IF THERE IS NO MORE COMMA'S
2d50 2d50 d c27c2a
2d50 2d50 u 03 01
2d50 2d50 s 			JP NZ,	SYNT		;THEN WE RAN OUT OF OPERANDS
2d53 2d53 d 13
2d53 2d53 u 01 01
2d53 2d53 s 		GLPD	INC	DE		;SKIP THE COMMA
2d54 2d54 d 2d
2d54 2d54 u 01 01
2d54 2d54 s 			DEC	L		;REDUCE OUR COUNT
2d55 2d55 d f24b2d
2d55 2d55 u 03 01
2d55 2d55 s 			JP P,	GLPO		;IF IT'S STILL POSITIVE, KEEP SKIPPING
2d58 2d58 d 1a
2d58 2d58 u 01 01
2d58 2d58 s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
2d59 2d59 d fe20
2d59 2d59 u 02 01
2d59 2d59 s 			CP	' '		;TEST FOR BLANKS
2d5b 2d5b d ca532d
2d5b 2d5b u 03 01
2d5b 2d5b s 			JP Z,	GLPD		;AND KEEP GOING TILL WE SKIP THEM
2d5e 2d5e d d5
2d5e 2d5e u 01 01
2d5e 2d5e s 		NOON	PUSH	DE		;SAVE POSITION (IN CASE WE FAIL)
2d5f 2d5f d cd192c
2d5f 2d5f u 03 01
2d5f 2d5f s 			CALL	FNDLIN		;FIND THE LINE HE WANTS
2d62 2d62 d d1
2d62 2d62 u 01 01
2d62 2d62 s 			POP	DE		;RESTORE OUR POSITION
2d63 2d63 d eb
2d63 2d63 u 01 01
2d63 2d63 s 			EX	DE, HL	
2d64 2d64 d cafc2c
2d64 2d64 u 03 01
2d64 2d64 s 			JP Z,	RGON		;IF SUCESS, GOTO NEW LINE
2d67 2d67 d eb
2d67 2d67 u 01 01
2d67 2d67 s 			EX	DE, HL	
2d68 2d68 s 		;
2d68 2d68 s 		; OH OH, LOOKS LIKE HE'S TRIED TO GOTO, GOSUB OR ORDER TO A LINE HE FORGOT
2d68 2d68 s 		; TO TYPE IN, TELL HIM ABOUT IT AND LET HIM TRY TO FIGURE IT OUT
2d68 2d68 s 		;
2d68 2d68 d 21c935
2d68 2d68 u 03 01
2d68 2d68 s 		BADLIN	LD	HL,LIN		;ADDRESS OF 'LINE NUMBER' MESSAGE
2d6b 2d6b d c3802a
2d6b 2d6b u 03 01
2d6b 2d6b s 			JP	ERR		;HANDLE LIKE ANY ERROR
2d6e 2d6e s 		;
2d6e 2d6e s 		; IT'S A 'RETURN', HOPE SOMEBODY DID A 'GOSUB' SOMEWHERE
2d6e 2d6e s 		;
2d6e 2d6e d cdb42d
2d6e 2d6e u 03 01
2d6e 2d6e s 		RETURN	CALL	POPS		;GET TYPE OF STACK ENTRY
2d71 2d71 d a7
2d71 2d71 u 01 01
2d71 2d71 s 			AND	A		;TEST FOR 'GOSUB' ENTRY
2d72 2d72 d cac72d
2d72 2d72 u 03 01
2d72 2d72 s 			JP Z,	POPD		;IF SO, GET ADDRESS BACK AND RETURN
2d75 2d75 s 		;
2d75 2d75 s 		; HE SCREWED UP THE FOR/NEXT, GOSUB/RETURN NESTING
2d75 2d75 s 		; LET HIM IN ON IT AND DIE WHILE WE CAN
2d75 2d75 s 		;
2d75 2d75 d 21c135
2d75 2d75 u 03 01
2d75 2d75 s 		NSTERR	LD	HL,CSTK		;ADDRESS OF 'NESTING' MESSAGE
2d78 2d78 d c3802a
2d78 2d78 u 03 01
2d78 2d78 s 			JP	ERR		;HANDLE LIKE ANY ERROR
2d7b 2d7b s 		;
2d7b 2d7b s 		; IT'S A 'FOR' COMMAND, LETS THROW THIS THING FOR A LOOP
2d7b 2d7b s 		;
2d7b 2d7b d cd782a
2d7b 2d7b u 03 01
2d7b 2d7b s 		FOR	CALL	VCHAR		;INSURE IT'S A VARIABLE
2d7e 2d7e d f5
2d7e 2d7e u 01 01
2d7e 2d7e s 			PUSH	AF
2d7f 2d7f d 1b
2d7f 2d7f u 01 01
2d7f 2d7f s 			DEC	DE		;BACK UP POINT JUST BEFORE EXPRESSION
2d80 2d80 d 7b
2d80 2d80 u 01 01
2d80 2d80 s 			LD	A,E		;GET LOW ADDRESS
2d81 2d81 d 323682
2d81 2d81 u 03 01
2d81 2d81 s 			LD	(PP), A		;AND PLACE IN POSITION FLAG
2d84 2d84 d 1a
2d84 2d84 u 01 01
2d84 2d84 s 		FINTO	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2d85 2d85 d fe0d
2d85 2d85 u 02 01
2d85 2d85 s 			CP	CR		;TEST FOR END OF LINE
2d87 2d87 d ca7c2a
2d87 2d87 u 03 01
2d87 2d87 s 			JP Z,	SYNT		;IF SO, HE'S GOOFED
2d8a 2d8a d 13
2d8a 2d8a u 01 01
2d8a 2d8a s 			INC	DE		;SKIP TO NEXT
2d8b 2d8b d fe54
2d8b 2d8b u 02 01
2d8b 2d8b s 			CP	'T'		;TEST FOR A 'T'
2d8d 2d8d d c2842d
2d8d 2d8d u 03 01
2d8d 2d8d s 			JP NZ,	FINTO		;IF NOT, WE ARN'T THERE YET
2d90 2d90 d 1a
2d90 2d90 u 01 01
2d90 2d90 s 			LD	A, (DE)		;GET NEXT CHARACTER
2d91 2d91 d fe4f
2d91 2d91 u 02 01
2d91 2d91 s 			CP	'O'		;IS IT 'TO'
2d93 2d93 d c2842d
2d93 2d93 u 03 01
2d93 2d93 s 			JP NZ,	FINTO		;NO, MUST BE VARIABLE 'T'
2d96 2d96 d d5
2d96 2d96 u 01 01
2d96 2d96 s 			PUSH	DE		;SAVE OUR POSITION
2d97 2d97 d 1b
2d97 2d97 u 01 01
2d97 2d97 s 			DEC	DE		;BACKUP TO THE 'T'
2d98 2d98 d cd3e31
2d98 2d98 u 03 01
2d98 2d98 s 			CALL	DOEXP		;EVALUATE EXPRESSION
2d9b 2d9b d d1
2d9b 2d9b u 01 01
2d9b 2d9b s 			POP	DE		;RESTORE OUT POSITION
2d9c 2d9c d 13
2d9c 2d9c u 01 01
2d9c 2d9c s 			INC	DE		;SKIP 'O'
2d9d 2d9d d cd3531
2d9d 2d9d u 03 01
2d9d 2d9d s 			CALL	EXPR		;GET LIMIT EXPRESSION
2da0 2da0 d cdbd2d
2da0 2da0 u 03 01
2da0 2da0 s 			CALL	PUSHD		;SAVE OUR POSITION ON STACK
2da3 2da3 d eb
2da3 2da3 u 01 01
2da3 2da3 s 			EX	DE, HL	
2da4 2da4 d cdbd2d
2da4 2da4 u 03 01
2da4 2da4 s 			CALL	PUSHD		;SAVE ON STACK
2da7 2da7 d eb
2da7 2da7 u 01 01
2da7 2da7 s 			EX	DE, HL	
2da8 2da8 d f1
2da8 2da8 u 01 01
2da8 2da8 s 			POP	AF
2da9 2da9 s 		;
2da9 2da9 s 		; SAVES A SINGLE BYTE ENTRY ON THE USER (CONTROL) STACK
2da9 2da9 s 		;
2da9 2da9 d e5
2da9 2da9 u 01 01
2da9 2da9 s 		PUSHS	PUSH	HL		;SAVE H-L
2daa 2daa d 2afb81
2daa 2daa u 03 01
2daa 2daa s 			LD	HL, (CSP)	;GET STACK POINTER
2dad 2dad d 77
2dad 2dad u 01 01
2dad 2dad s 			LD	(HL),A		;SAVE BYTE ON STACK
2dae 2dae d 2b
2dae 2dae u 01 01
2dae 2dae s 		PSH1	DEC	HL		;REDUCE POINTER
2daf 2daf d 22fb81
2daf 2daf u 03 01
2daf 2daf s 		PSH2	LD	(CSP), HL	;RESAVE STACK POINTER
2db2 2db2 d e1
2db2 2db2 u 01 01
2db2 2db2 s 			POP	HL		;RESTORE H-L
2db3 2db3 d c9
2db3 2db3 u 01 01
2db3 2db3 s 			RET
2db4 2db4 s 		;
2db4 2db4 s 		; POP A SINGLE BYTE ENTRY FROM THE USER (CONTROL) STACK
2db4 2db4 s 		;
2db4 2db4 d e5
2db4 2db4 u 01 01
2db4 2db4 s 		POPS	PUSH	HL		;SAVE H-L
2db5 2db5 d 2afb81
2db5 2db5 u 03 01
2db5 2db5 s 			LD	HL, (CSP)	;GET STACK POINTER
2db8 2db8 d 23
2db8 2db8 u 01 01
2db8 2db8 s 			INC	HL		;ADVANCE TO NEXT ENTRY
2db9 2db9 d 7e
2db9 2db9 u 01 01
2db9 2db9 s 			LD	A,(HL)		;GET BYTE BACK
2dba 2dba d c3af2d
2dba 2dba u 03 01
2dba 2dba s 			JP	PSH2		;SAVE POINTER AND CONTINUE
2dbd 2dbd s 		;
2dbd 2dbd s 		; PUSHES A DOUBLE BYTE ENTRY ON THE USER (CONTROL) STACK
2dbd 2dbd s 		;
2dbd 2dbd d e5
2dbd 2dbd u 01 01
2dbd 2dbd s 		PUSHD	PUSH	HL		;SAVE H-L
2dbe 2dbe d 2afb81
2dbe 2dbe u 03 01
2dbe 2dbe s 			LD	HL, (CSP)	;GET STACK POINTER
2dc1 2dc1 d 72
2dc1 2dc1 u 01 01
2dc1 2dc1 s 			LD	(HL),D		;SAVE HIGH BYTE
2dc2 2dc2 d 2b
2dc2 2dc2 u 01 01
2dc2 2dc2 s 			DEC	HL		;BACK UP
2dc3 2dc3 d 73
2dc3 2dc3 u 01 01
2dc3 2dc3 s 			LD	(HL),E		;SAVE LOW BYTE
2dc4 2dc4 d c3ae2d
2dc4 2dc4 u 03 01
2dc4 2dc4 s 			JP	PSH1		;SAVE POINTER AND CONTINUE
2dc7 2dc7 s 		;
2dc7 2dc7 s 		; POPS A DOUBLE BYTE ENTRY FROM THE USER STACK
2dc7 2dc7 s 		;
2dc7 2dc7 d e5
2dc7 2dc7 u 01 01
2dc7 2dc7 s 		POPD	PUSH	HL		;SAVE H-L
2dc8 2dc8 d 2afb81
2dc8 2dc8 u 03 01
2dc8 2dc8 s 			LD	HL, (CSP)	;GET STACK POINTER
2dcb 2dcb d 23
2dcb 2dcb u 01 01
2dcb 2dcb s 			INC	HL		;ADVANCE TO LAST ENTRY
2dcc 2dcc d 5e
2dcc 2dcc u 01 01
2dcc 2dcc s 			LD	E,(HL)		;GET LOW BYTE
2dcd 2dcd d 23
2dcd 2dcd u 01 01
2dcd 2dcd s 			INC	HL		;ADVANCE TO HIGH BYTE
2dce 2dce d 56
2dce 2dce u 01 01
2dce 2dce s 			LD	D,(HL)		;GET HIGH BYTE
2dcf 2dcf d c3af2d
2dcf 2dcf u 03 01
2dcf 2dcf s 			JP	PSH2		;SAVE AND CONTINUE
2dd2 2dd2 s 		;
2dd2 2dd2 s 		; LET COMMAND, EVALUATE EXPRESSION
2dd2 2dd2 s 		;
2dd2 2dd2 d cd3531
2dd2 2dd2 u 03 01
2dd2 2dd2 s 		LET	CALL	EXPR		;EVALUATE EXPRESSION
2dd5 2dd5 d 3a3782
2dd5 2dd5 u 03 01
2dd5 2dd5 s 			LD	A, (EFLAG)	;DID HE MAKE AN ASSIGNMENT?
2dd8 2dd8 d a7
2dd8 2dd8 u 01 01
2dd8 2dd8 s 			AND	A		;IF NOT..
2dd9 2dd9 d ca7c2a
2dd9 2dd9 u 03 01
2dd9 2dd9 s 			JP Z,	SYNT		;HE'S MADE ANOTHER MISTAKE
2ddc 2ddc d 97
2ddc 2ddc u 01 01
2ddc 2ddc s 			SUB	A		;RESET THE FLAG
2ddd 2ddd d 323782
2ddd 2ddd u 03 01
2ddd 2ddd s 			LD	(EFLAG), A	;SO WE KNOW WHEN HE SCREW'S UP AGAIN
2de0 2de0 d c9
2de0 2de0 u 01 01
2de0 2de0 s 			RET
2de1 2de1 s 		;
2de1 2de1 s 		; IT'S A NEXT COMMAND, TEST INDEX AGAINST LIMIT, AND LOOP IF NEEDED
2de1 2de1 s 		;
2de1 2de1 d cd782a
2de1 2de1 u 03 01
2de1 2de1 s 		NEXT	CALL	VCHAR		;TEST FOR VALID VARIABLE
2de4 2de4 d 47
2de4 2de4 u 01 01
2de4 2de4 s 			LD	B,A		;STASH IN B FOR SAFEKEEPING
2de5 2de5 d 2afb81
2de5 2de5 u 03 01
2de5 2de5 s 			LD	HL, (CSP)	;SAVE CONTROL STACK POINTER..
2de8 2de8 d 223e82
2de8 2de8 u 03 01
2de8 2de8 s 			LD	(TEMP), HL	;IN CASE WE NEED TO LOOP AGAIN
2deb 2deb d cdb42d
2deb 2deb u 03 01
2deb 2deb s 			CALL	POPS		;GET VARIABLE NAME FROM STACK
2dee 2dee d b8
2dee 2dee u 01 01
2dee 2dee s 			CP	B		;TEST FOR WHAT HE GAVE US
2def 2def d c2752d
2def 2def u 03 01
2def 2def s 			JP NZ,	NSTERR		;IF NOT, HE'S SCREWED UP THE NESTING
2df2 2df2 d cdf82f
2df2 2df2 u 03 01
2df2 2df2 s 			CALL	LOOK		;GET VARIABLE VALUE
2df5 2df5 d d5
2df5 2df5 u 01 01
2df5 2df5 s 			PUSH	DE		;SAVE POSITION
2df6 2df6 d cdc72d
2df6 2df6 u 03 01
2df6 2df6 s 			CALL	POPD		;GET LIMIT FROM STACK
2df9 2df9 d 42
2df9 2df9 u 01 01
2df9 2df9 s 			LD	B,D		;GET LIMIT
2dfa 2dfa d 4b
2dfa 2dfa u 01 01
2dfa 2dfa s 			LD	C,E		;INTO B-C SO WE CAN 'COMP'
2dfb 2dfb d cd6532
2dfb 2dfb u 03 01
2dfb 2dfb s 			CALL	COMP		;TEST IF INDEX >= LIMIT
2dfe 2dfe d d2112e
2dfe 2dfe u 03 01
2dfe 2dfe s 			JP NC,	NOMORE		;IF SO, DON'T LOOP ANYMORE
2e01 2e01 d d1
2e01 2e01 u 01 01
2e01 2e01 s 			POP	DE		;GET POSITION BACK
2e02 2e02 d 23
2e02 2e02 u 01 01
2e02 2e02 s 			INC	HL		;INCREMENT LOOP INDEX
2e03 2e03 d 1a
2e03 2e03 u 01 01
2e03 2e03 s 			LD	A, (DE)		;GET VARIABLE NAME BACK
2e04 2e04 d cde72f
2e04 2e04 u 03 01
2e04 2e04 s 			CALL	STOR		;SAVE IT AWAY
2e07 2e07 d cdc72d
2e07 2e07 u 03 01
2e07 2e07 s 			CALL	POPD		;GET NEW POSITION
2e0a 2e0a d 2a3e82
2e0a 2e0a u 03 01
2e0a 2e0a s 			LD	HL, (TEMP)	;GET CONTROL-STACK POINTER
2e0d 2e0d d 22fb81
2e0d 2e0d u 03 01
2e0d 2e0d s 			LD	(CSP), HL	;AND REPLACE IT (LEAVING STACK UNCHANGED)
2e10 2e10 d c9
2e10 2e10 u 01 01
2e10 2e10 s 			RET
2e11 2e11 s 		; WE HAVE HIT THE END OF A FOR NEXT LOOP
2e11 2e11 d cdc72d
2e11 2e11 u 03 01
2e11 2e11 s 		NOMORE	CALL	POPD		;CLEAN UP CONTROL STACK
2e14 2e14 d d1
2e14 2e14 u 01 01
2e14 2e14 s 			POP	DE		;GET PROGRAM COUNTER BACK
2e15 2e15 s 		;
2e15 2e15 s 		; REMARK, DO NOTHING, BUT RETURN, ALLOWING 'RNEXT' TO SKIP THE COMMAND
2e15 2e15 s 		;
2e15 2e15 d c9
2e15 2e15 u 01 01
2e15 2e15 s 		REM:	RET
2e16 2e16 s 		;
2e16 2e16 s 		; IT'S AN 'IF' STATEMENT. FIND OUT 'IF' WE DO IT OR NOT
2e16 2e16 s 		;
2e16 2e16 d 1b
2e16 2e16 u 01 01
2e16 2e16 s 		IF:	DEC	DE		;BACK UP IN SOURCE
2e17 2e17 d 7b
2e17 2e17 u 01 01
2e17 2e17 s 			LD	A,E		;GET LOW ADDRESS
2e18 2e18 d 323682
2e18 2e18 u 03 01
2e18 2e18 s 			LD	(PP), A		;SAVE IN POSITION POINTER
2e1b 2e1b d 1a
2e1b 2e1b u 01 01
2e1b 2e1b s 		FTHEN	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2e1c 2e1c d fe0d
2e1c 2e1c u 02 01
2e1c 2e1c s 			CP	CR		;IF IT'S A CARRIAGE RETURN..
2e1e 2e1e d ca7c2a
2e1e 2e1e u 03 01
2e1e 2e1e s 			JP Z,	SYNT		;THEN HE DIDN'T TYPE IN A 'THEN'
2e21 2e21 d 13
2e21 2e21 u 01 01
2e21 2e21 s 			INC	DE		;ADVANCE TO NEXT CHARACTER
2e22 2e22 d fe54
2e22 2e22 u 02 01
2e22 2e22 s 			CP	'T'		;IS IT A 'T'?
2e24 2e24 d c21b2e
2e24 2e24 u 03 01
2e24 2e24 s 			JP NZ,	FTHEN		;IF NOT, IT AINT THE START OF 'THEN'
2e27 2e27 d 1a
2e27 2e27 u 01 01
2e27 2e27 s 			LD	A, (DE)		;GET NEXT CHARACTER
2e28 2e28 d fe48
2e28 2e28 u 02 01
2e28 2e28 s 			CP	'H'		;TEST FOR NEXT CHARACTER OF 'THEN'
2e2a 2e2a d c21b2e
2e2a 2e2a u 03 01
2e2a 2e2a s 			JP NZ,	FTHEN		;NO, MUST BE VARIABLE 'T' (OR HE CAN'T SPELL)
2e2d 2e2d d 1b
2e2d 2e2d u 01 01
2e2d 2e2d s 			DEC	DE		;BACK UP TO 'T'
2e2e 2e2e d d5
2e2e 2e2e u 01 01
2e2e 2e2e s 			PUSH	DE		;SAVE POSITION IN SOURCE
2e2f 2e2f d cd3e31
2e2f 2e2f u 03 01
2e2f 2e2f s 			CALL	DOEXP		;EVALUATE CONDITION EXPRESSION
2e32 2e32 d d1
2e32 2e32 u 01 01
2e32 2e32 s 			POP	DE		;GET POSITION BACK
2e33 2e33 d 7c
2e33 2e33 u 01 01
2e33 2e33 s 			LD	A,H		;GET RESULT AND TEST.
2e34 2e34 d b5
2e34 2e34 u 01 01
2e34 2e34 s 			OR	L		;IT FOR ZERO (FALSE)
2e35 2e35 d c8
2e35 2e35 u 01 01
2e35 2e35 s 			RET Z			;IF SO, SKIP THIS STATEMENT
2e36 2e36 d c3042d
2e36 2e36 u 03 01
2e36 2e36 s 			JP	RLOOP		;EXECUTE THE 'THEN'
2e39 2e39 s 		;
2e39 2e39 s 		; LONG IF, CONTROLS REMAINDER OF ENTIRE LINE
2e39 2e39 s 		;
2e39 2e39 d cd162e
2e39 2e39 u 03 01
2e39 2e39 s 		LIF	CALL	IF		;CALCULATE AND PROCESS IF TRUE
2e3c 2e3c d 13
2e3c 2e3c u 01 01
2e3c 2e3c s 		LNXT	INC	DE		;ADVANCE IN SOURCE
2e3d 2e3d d 1a
2e3d 2e3d u 01 01
2e3d 2e3d s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
2e3e 2e3e d fe0d
2e3e 2e3e u 02 01
2e3e 2e3e s 			CP	CR		;TEST FOR END OF LINE
2e40 2e40 d c23c2e
2e40 2e40 u 03 01
2e40 2e40 s 			JP NZ,	LNXT		;KEEP LOOKING
2e43 2e43 d c9
2e43 2e43 u 01 01
2e43 2e43 s 			RET
2e44 2e44 s 		;
2e44 2e44 s 		; IT A 'PLOT' COMMAND, (HE'S PLOTTING AGAINST US)
2e44 2e44 s 		;
2e44 2e44 d cd3531
2e44 2e44 u 03 01
2e44 2e44 s 		PLOT	CALL	EXPR		;GET X COORDINATE
2e47 2e47 d da7c2a
2e47 2e47 u 03 01
2e47 2e47 s 			JP C,	SYNT		;IF CHARACTER, IT'S NO GOOD
2e4a 2e4a d e5
2e4a 2e4a u 01 01
2e4a 2e4a s 			PUSH	HL		;SAVE X COORDINATE
2e4b 2e4b d 13
2e4b 2e4b u 01 01
2e4b 2e4b s 			INC	DE		;ADVANCE PAST ','
2e4c 2e4c d cd3531
2e4c 2e4c u 03 01
2e4c 2e4c s 			CALL	EXPR		;GET Y COORDINATE
2e4f 2e4f d c1
2e4f 2e4f u 01 01
2e4f 2e4f s 			POP	BC		;GET X POSITION IN B-C
2e50 2e50 d 29
2e50 2e50 u 01 01
2e50 2e50 s 			ADD	HL,HL		;MULTIPLY.
2e51 2e51 d 29
2e51 2e51 u 01 01
2e51 2e51 s 			ADD	HL,HL		;Y POSITION.
2e52 2e52 d 29
2e52 2e52 u 01 01
2e52 2e52 s 			ADD	HL,HL		;BY 64.
2e53 2e53 d 29
2e53 2e53 u 01 01
2e53 2e53 s 			ADD	HL,HL		;TO PLACE ADDRESS.
2e54 2e54 d 29
2e54 2e54 u 01 01
2e54 2e54 s 			ADD	HL,HL		;ON PROPER LINE.
2e55 2e55 d 29
2e55 2e55 u 01 01
2e55 2e55 s 			ADD	HL,HL		;OF THE DISPLAY
2e56 2e56 d 09
2e56 2e56 u 01 01
2e56 2e56 s 			ADD	HL,BC		;ADD IN X POSITION
2e57 2e57 d 010004
2e57 2e57 u 03 01
2e57 2e57 s 			LD	BC,1024		;TEST AGAINST END OF SCREEN
2e5a 2e5a d cd6532
2e5a 2e5a u 03 01
2e5a 2e5a s 			CALL	COMP		;TO SEE IF WE ARE OVER
2e5d 2e5d d d2af2f
2e5d 2e5d u 03 01
2e5d 2e5d s 			JP NC,	DIMERR		;IF SO, 'DIMENSION ERROR'
2e60 2e60 s 			;CALL	CURPOS		;POSITION THE CURSOR
2e60 2e60 s 		; LOOK FOR END OF LINE, OR OTHER OPERANDS
2e60 2e60 d cd0f31
2e60 2e60 u 03 01
2e60 2e60 s 			CALL	SKIP		;GET NEXT SEPERATOR
2e63 2e63 d fe2c
2e63 2e63 u 02 01
2e63 2e63 s 			CP	','		;TEST FOR COMMA
2e65 2e65 d c0
2e65 2e65 u 01 01
2e65 2e65 s 			RET NZ			;IF NOT, WE ARE DONE
2e66 2e66 d 13
2e66 2e66 u 01 01
2e66 2e66 s 			INC	DE		;SKIP ','
2e67 2e67 s 		; OUT STATEMENT, LET'S OUTPUT SOMETHING TO A PORT
2e67 2e67 d cd3531
2e67 2e67 u 03 01
2e67 2e67 s 		OUTP	CALL	EXPR		;GET EXPRESSION FOR PORT#
2e6a 2e6a d da7c2a
2e6a 2e6a u 03 01
2e6a 2e6a s 			JP  C,	SYNT
2e6d 2e6d d c5
2e6d 2e6d u 01 01
2e6d 2e6d s 			PUSH	BC
2e6e 2e6e d 4d
2e6e 2e6e u 01 01
2e6e 2e6e s 			LD	C,L		;SET PORT
2e6f 2e6f d 1a
2e6f 2e6f u 01 01
2e6f 2e6f s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
2e70 2e70 d fe2c
2e70 2e70 u 02 01
2e70 2e70 s 			CP	','		;TEST FOR COMMA
2e72 2e72 d c27c2a
2e72 2e72 u 03 01
2e72 2e72 s 			JP NZ,	SYNT
2e75 2e75 d cd0331
2e75 2e75 u 03 01
2e75 2e75 s 			CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
2e78 2e78 d cd3531
2e78 2e78 u 03 01
2e78 2e78 s 			CALL	EXPR		;GET EXPRESSION FOR PORT#
2e7b 2e7b d da7c2a
2e7b 2e7b u 03 01
2e7b 2e7b s 			JP  C,	SYNT
2e7e 2e7e d ed69
2e7e 2e7e u 02 01
2e7e 2e7e s 			OUT	(C),L
2e80 2e80 d 79
2e80 2e80 u 01 01
2e80 2e80 s 			LD	A,C		;IF OUTPUT TO 0x40, THEN WRITE TO SCAN LED
2e81 2e81 d e6e0
2e81 2e81 u 02 01
2e81 2e81 s 			AND	0xE0
2e83 2e83 d fe40
2e83 2e83 u 02 01
2e83 2e83 s 			CP	0x40
2e85 2e85 d 2004
2e85 2e85 u 02 01
2e85 2e85 s 			JR  NZ,	OUTPR
2e87 2e87 d 7d
2e87 2e87 u 01 01
2e87 2e87 s 			LD	A,L
2e88 2e88 d 32f5ff
2e88 2e88 u 03 01
2e88 2e88 s 			LD	(0xFFF5),A	;SCAN_LED ON Z80MC
2e8b 2e8b d c1
2e8b 2e8b u 01 01
2e8b 2e8b s 		OUTPR	POP	BC
2e8c 2e8c d c9
2e8c 2e8c u 01 01
2e8c 2e8c s 			RET
2e8d 2e8d s 		;
2e8d 2e8d s 		; PRINT STATEMENT, LET'S OUTPUT SOMETHING SO HE WON'T GET UPSET
2e8d 2e8d s 		; WHILE STARING AT THE TUBE WONDERING IF WE DIED
2e8d 2e8d s 		;
2e8d 2e8d d cd3531
2e8d 2e8d u 03 01
2e8d 2e8d s 		BPRINT	CALL	EXPR		;GET EXPRESSION TO PRINT
2e90 2e90 d d5
2e90 2e90 u 01 01
2e90 2e90 s 			PUSH	DE		;SAVE BASIC'S PROGRAM COUNTER
2e91 2e91 d d4b22e
2e91 2e91 u 03 01
2e91 2e91 s 			CALL NC, DECPRT		;IF NUMERIC, OUTPUT DECIMAL NUMBER
2e94 2e94 d d1
2e94 2e94 u 01 01
2e94 2e94 s 			POP	DE		;RESTORE BASIC'S PROGRAM COUNTER
2e95 2e95 d dca52e
2e95 2e95 u 03 01
2e95 2e95 s 			CALL C,	PV1		;IF CHARACTER, DISPLAY CHARACTER VALUE
2e98 2e98 d 1a
2e98 2e98 u 01 01
2e98 2e98 s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
2e99 2e99 d fe2c
2e99 2e99 u 02 01
2e99 2e99 s 			CP	','		;TEST FOR COMMA
2e9b 2e9b d c28000
2e9b 2e9b u 03 01
2e9b 2e9b s 			JP NZ,	BPUTNL		;IF NOT, IT'S THE END
2e9e 2e9e d cd0331
2e9e 2e9e u 03 01
2e9e 2e9e s 			CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
2ea1 2ea1 d c28d2e
2ea1 2ea1 u 03 01
2ea1 2ea1 s 			JP NZ,	BPRINT		;PRINT NEXT EXPRESSION
2ea4 2ea4 d c9
2ea4 2ea4 u 01 01
2ea4 2ea4 s 			RET
2ea5 2ea5 s 		; PRINT CHARACTER EXPRESSIONS
2ea5 2ea5 d 216480
2ea5 2ea5 u 03 01
2ea5 2ea5 s 		PV1	LD	HL,XBF		;EXPRESSION IS IN EXTRA BUFFER
2ea8 2ea8 d 7e
2ea8 2ea8 u 01 01
2ea8 2ea8 s 		PZ	LD	A,(HL)		;GET CHARACTER FROM EXPRESSION
2ea9 2ea9 d 23
2ea9 2ea9 u 01 01
2ea9 2ea9 s 			INC	HL		;POINT TO NEXT
2eaa 2eaa d a7
2eaa 2eaa u 01 01
2eaa 2eaa s 			AND	A		;TEST FOR END OF EXPRESSION
2eab 2eab d f8
2eab 2eab u 01 01
2eab 2eab s 			RET M			;IF SO, END IT NOW
2eac 2eac d cd4500
2eac 2eac u 03 01
2eac 2eac s 			CALL	BPUTCHR	;PRINT CHARACTER
2eaf 2eaf d c3a82e
2eaf 2eaf u 03 01
2eaf 2eaf s 			JP	PZ		;KEEP GOING TILL END
2eb2 2eb2 s 			
2eb2 2eb2 s 		; RECURSIVE ROUTINE OUTPUTS NUMBER IN DECIMAL
2eb2 2eb2 d fe28
2eb2 2eb2 u 02 01
2eb2 2eb2 s 		DECPRT	CP	'('		;TEST FOR SPECIAL CASE
2eb4 2eb4 d c47d00
2eb4 2eb4 u 03 01
2eb4 2eb4 s 			CALL NZ, BPUTSP	;IF NOT, PRECEDE WITH SPACE
2eb7 2eb7 d 010a00
2eb7 2eb7 u 03 01
2eb7 2eb7 s 		DECP1	LD	BC,10		;DIVIDE BY 10
2eba 2eba d cd2932
2eba 2eba u 03 01
2eba 2eba s 			CALL	DODIV		;PERFORM DIVISION
2ebd 2ebd d 3e30
2ebd 2ebd u 02 01
2ebd 2ebd s 			LD	A,0x30		;TO CONVERT TO ASCII
2ebf 2ebf d 85
2ebf 2ebf u 01 01
2ebf 2ebf s 			ADD	A,L		;GET DIGIT
2ec0 2ec0 d f5
2ec0 2ec0 u 01 01
2ec0 2ec0 s 			PUSH	AF
2ec1 2ec1 d eb
2ec1 2ec1 u 01 01
2ec1 2ec1 s 			EX	DE, HL	
2ec2 2ec2 d 7c
2ec2 2ec2 u 01 01
2ec2 2ec2 s 			LD	A,H		;GET HIGH BYTE
2ec3 2ec3 d b5
2ec3 2ec3 u 01 01
2ec3 2ec3 s 			OR	L		;TEST FOR ZERO, (FINISHED)
2ec4 2ec4 d c4b72e
2ec4 2ec4 u 03 01
2ec4 2ec4 s 			CALL NZ, DECP1		;IF NOT, GET NEXT VALUE
2ec7 2ec7 d f1
2ec7 2ec7 u 01 01
2ec7 2ec7 s 			POP	AF
2ec8 2ec8 d c34500
2ec8 2ec8 u 03 01
2ec8 2ec8 s 			JP	BPUTCHR	;DISPLAY AND RETURN
2ecb 2ecb s 		;
2ecb 2ecb s 		; IT'S AN 'INPUT', LETS GIVE HIM A CHANCE TO DO SOME TYPING.. BUT
2ecb 2ecb s 		; KEEP AN EYE ON HIM, IN CASE HE TRY'S TO PUT SOMETHING OVER ON US
2ecb 2ecb s 		;
2ecb 2ecb d cda334
2ecb 2ecb u 03 01
2ecb 2ecb s 		INPUT	CALL	CLBF		;CLEAR EXTRA TEXT BUFFER
2ece 2ece d 3e3f
2ece 2ece u 02 01
2ece 2ece s 			LD	A,'?'		;GET A QUESTION MARK.
2ed0 2ed0 d 326480
2ed0 2ed0 u 03 01
2ed0 2ed0 s 			LD	(XBF), A	;TO USE AS THE DEFAULT PROMPT
2ed3 2ed3 d 1a
2ed3 2ed3 u 01 01
2ed3 2ed3 s 			LD	A, (DE)		;GET FIRST CHAR OF OPERAND
2ed4 2ed4 d fe22
2ed4 2ed4 u 02 01
2ed4 2ed4 s 			CP	'"'		;TEST FOR USER SUPPLIED PROMPT
2ed6 2ed6 d c2df2e
2ed6 2ed6 u 03 01
2ed6 2ed6 s 			JP NZ,	INP1		;IF NOT, DON'T CHANGE EXISTING ONE
2ed9 2ed9 d cd3531
2ed9 2ed9 u 03 01
2ed9 2ed9 s 			CALL	EXPR		;EVALUATE USER SUPPLIED PROMPT
2edc 2edc d cd0331
2edc 2edc u 03 01
2edc 2edc s 			CALL	PARSE		;SKIP TO NEXT NON-BLANK
2edf 2edf d cd782a
2edf 2edf u 03 01
2edf 2edf s 		INP1	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
2ee2 2ee2 d d5
2ee2 2ee2 u 01 01
2ee2 2ee2 s 			PUSH	DE		;SAVE SOURCE POSITION
2ee3 2ee3 d 13
2ee3 2ee3 u 01 01
2ee3 2ee3 s 			INC	DE		;ADVANCE TO NEXT CHARACTER
2ee4 2ee4 d f5
2ee4 2ee4 u 01 01
2ee4 2ee4 s 			PUSH	AF
2ee5 2ee5 d 1a
2ee5 2ee5 u 01 01
2ee5 2ee5 s 			LD	A, (DE)		;GET NEXT CHARACTER
2ee6 2ee6 d fe24
2ee6 2ee6 u 02 01
2ee6 2ee6 s 			CP	'$'		;TEST FOR CHARACTER INPUT
2ee8 2ee8 d ca0c2f
2ee8 2ee8 u 03 01
2ee8 2ee8 s 			JP Z,	GCHR		;IF SO, GET CHARACTER DATA
2eeb 2eeb d 210000
2eeb 2eeb u 03 01
2eeb 2eeb s 			LD	HL,0		;START WITH A ZERO
2eee 2eee d 39
2eee 2eee u 01 01
2eee 2eee s 			ADD	HL,SP		;AND GET STACK POINTER. IN CASE WE BLOW UP
2eef 2eef d 223e82
2eef 2eef u 03 01
2eef 2eef s 			LD	(TEMP), HL	;SAVE SO WE CAN GET IT BACK LATER
2ef2 2ef2 d cda52e
2ef2 2ef2 u 03 01
2ef2 2ef2 s 		RETRY	CALL	PV1		;DISPLAY USER PROMPT
2ef5 2ef5 d 97
2ef5 2ef5 u 01 01
2ef5 2ef5 s 			SUB	A		;GET A ZERO
2ef6 2ef6 d 323582
2ef6 2ef6 u 03 01
2ef6 2ef6 s 			LD	(IFLAG), A	;AND CLEAR THE INPUT FLAG (IN CASE HE CTRL-C'S)
2ef9 2ef9 d cdd02a
2ef9 2ef9 u 03 01
2ef9 2ef9 s 			CALL	GLINE		;GET A LINE FROM THE TERMINAL
2efc 2efc d 323582
2efc 2efc u 03 01
2efc 2efc s 			LD	(IFLAG), A	;SET IFLAG. (SO GET ERROR, WE CAN COME BACK)
2eff 2eff d cd3531
2eff 2eff u 03 01
2eff 2eff s 			CALL	EXPR		;EVALUATE EXPRESSION
2f02 2f02 d f1
2f02 2f02 u 01 01
2f02 2f02 s 			POP	AF
2f03 2f03 d cde72f
2f03 2f03 u 03 01
2f03 2f03 s 			CALL	STOR		;STASH VALUE IN VARIABLE
2f06 2f06 d d1
2f06 2f06 u 01 01
2f06 2f06 s 			POP	DE		;RESTORE SOURCE POSITION
2f07 2f07 d 97
2f07 2f07 u 01 01
2f07 2f07 s 			SUB	A		;GET A ZERO
2f08 2f08 d 323582
2f08 2f08 u 03 01
2f08 2f08 s 			LD	(IFLAG), A	;AND CLEAR IFLAG
2f0b 2f0b d c9
2f0b 2f0b u 01 01
2f0b 2f0b s 			RET
2f0c 2f0c s 		; CHARACTER INPUT
2f0c 2f0c d cda52e
2f0c 2f0c u 03 01
2f0c 2f0c s 		GCHR	CALL	PV1		;DISPLAY USER PROMPT
2f0f 2f0f d cdd02a
2f0f 2f0f u 03 01
2f0f 2f0f s 			CALL	GLINE		;GET A LINE OF INPUT
2f12 2f12 d f1
2f12 2f12 u 01 01
2f12 2f12 s 			POP	AF
2f13 2f13 d cdb52f
2f13 2f13 u 03 01
2f13 2f13 s 			CALL	LTA		;GET THE TEXT VARIABLE'S ADDRESS
2f16 2f16 d 0623
2f16 2f16 u 02 01
2f16 2f16 s 			LD	B,35		;LENGTH IS 35
2f18 2f18 d 1a
2f18 2f18 u 01 01
2f18 2f18 s 		Z1	LD	A, (DE)		;GET CHARACTER FROM INPUT BUFFER
2f19 2f19 d fe0d
2f19 2f19 u 02 01
2f19 2f19 s 			CP	CR		;TEST FOR END OF BUFFER
2f1b 2f1b d ca282f
2f1b 2f1b u 03 01
2f1b 2f1b s 			JP Z,	Z2		;IF SO, END THE LINE
2f1e 2f1e d 0b
2f1e 2f1e u 01 01
2f1e 2f1e s 			DEC	BC		;TEST FOR END OF VARIABLE SPACE
2f1f 2f1f d ca282f
2f1f 2f1f u 03 01
2f1f 2f1f s 			JP Z,	Z2		;IF SO, END THE LINE
2f22 2f22 d 77
2f22 2f22 u 01 01
2f22 2f22 s 			LD	(HL),A		;SAVE IN VARIABLE SPACE
2f23 2f23 d 23
2f23 2f23 u 01 01
2f23 2f23 s 			INC	HL		;NEXT CHARACTER IN VARIABLE
2f24 2f24 d 13
2f24 2f24 u 01 01
2f24 2f24 s 			INC	DE		;NEXT CHARACTER IN INPUT BUFFER
2f25 2f25 d c3182f
2f25 2f25 u 03 01
2f25 2f25 s 			JP	Z1		;COPY NEXT CHARACTER
2f28 2f28 d d1
2f28 2f28 u 01 01
2f28 2f28 s 		Z2	POP	DE		;RESTORE SOURCE POSITION
2f29 2f29 d 36ff
2f29 2f29 u 02 01
2f29 2f29 s 		Z3	LD	(HL),0xFF	;PAD BUFFER WITH NULL CHARACTERS
2f2b 2f2b d 23
2f2b 2f2b u 01 01
2f2b 2f2b s 			INC	HL		;NEXT POSITION IN VARIABLE
2f2c 2f2c d 0b
2f2c 2f2c u 01 01
2f2c 2f2c s 			DEC	BC		;REDUCE COUNT TILL END
2f2d 2f2d d f2292f
2f2d 2f2d u 03 01
2f2d 2f2d s 			JP P,	Z3		;KEEP GOING TILL VARIABLE IS FILLED
2f30 2f30 d c9
2f30 2f30 u 01 01
2f30 2f30 s 			RET
2f31 2f31 s 		;
2f31 2f31 s 		; LOOK'S LIKE HE CAN'T EVEN ENTER A SIMPLE NUMBER, CLEAN UP ANY STACK
2f31 2f31 s 		; HE MAY HAVE USED, AND LET HIM TAKE ANOTHER BLIND STAB AT THE KEYBOARD
2f31 2f31 s 		;
2f31 2f31 d 21ae35
2f31 2f31 u 03 01
2f31 2f31 s 		INERR	LD	HL,IERMS	;GET NASTY MESSAGE
2f34 2f34 d cd5700
2f34 2f34 u 03 01
2f34 2f34 s 			CALL	PRINTM		;GIVE HIM THE BAD NEWS
2f37 2f37 d 2a3e82
2f37 2f37 u 03 01
2f37 2f37 s 			LD	HL, (TEMP)	;GET HIS OLD STACK BACK
2f3a 2f3a d f9
2f3a 2f3a u 01 01
2f3a 2f3a s 			LD	SP, HL	
2f3b 2f3b d c3f22e
2f3b 2f3b u 03 01
2f3b 2f3b s 			JP	RETRY		;LET HIM TRY AGAIN
2f3e 2f3e s 		;
2f3e 2f3e s 		; DIMENSION, HE WANTS SOME ARRAY SPACE.. I SUPPOSE WE SHOULD GIVE IT TO HIM
2f3e 2f3e s 		;
2f3e 2f3e d 7b
2f3e 2f3e u 01 01
2f3e 2f3e s 		DIM	LD	A,E		;GET ADDRESS OF OUR POSITION
2f3f 2f3f d 323682
2f3f 2f3f u 03 01
2f3f 2f3f s 			LD	(PP), A		;SAVE IN POSITION POINTER
2f42 2f42 d 1a
2f42 2f42 u 01 01
2f42 2f42 s 		DIM0	LD	A, (DE)		;GET CHARACTER FROM SOURCE
2f43 2f43 d 13
2f43 2f43 u 01 01
2f43 2f43 s 			INC	DE		;ADVANCE TO NEXT
2f44 2f44 d fe0d
2f44 2f44 u 02 01
2f44 2f44 s 			CP	CR		;TEST FOR END OF LINE
2f46 2f46 d ca7c2a
2f46 2f46 u 03 01
2f46 2f46 s 			JP Z,	SYNT		;IF SO, TELL HIM TO STRAIGHTEN UP
2f49 2f49 d fe29
2f49 2f49 u 02 01
2f49 2f49 s 			CP	')'		;TEST FOR START OF ARRAY DIMENSION
2f4b 2f4b d c2422f
2f4b 2f4b u 03 01
2f4b 2f4b s 			JP NZ,	DIM0		;IF NOT, KEEP LOOKING
2f4e 2f4e d 1b
2f4e 2f4e u 01 01
2f4e 2f4e s 			DEC	DE		;BACK UP FOR EXPRESSION
2f4f 2f4f d d5
2f4f 2f4f u 01 01
2f4f 2f4f s 			PUSH	DE		;SAVE BASIC PROGRAM COUNTER
2f50 2f50 d cd3e31
2f50 2f50 u 03 01
2f50 2f50 s 			CALL	DOEXP		;EVALUATE ARRAY SIZE
2f53 2f53 d 23
2f53 2f53 u 01 01
2f53 2f53 s 			INC	HL		;ADD ONE ENTRY (ZERO ENTRY DOES EXIST)
2f54 2f54 d 29
2f54 2f54 u 01 01
2f54 2f54 s 			ADD	HL,HL		;DOUBLE BECAUSE THEY ARE 16 BIT'S
2f55 2f55 d 1b
2f55 2f55 u 01 01
2f55 2f55 s 			DEC	DE		;BACK UP TO NAME
2f56 2f56 d 44
2f56 2f56 u 01 01
2f56 2f56 s 			LD	B,H		;COPY SIZE NEEDED
2f57 2f57 d 4d
2f57 2f57 u 01 01
2f57 2f57 s 			LD	C,L		;INTO B AND C
2f58 2f58 d 2a3a82
2f58 2f58 u 03 01
2f58 2f58 s 			LD	HL, (LAST)	;GET FREE ADDRESS
2f5b 2f5b d e5
2f5b 2f5b u 01 01
2f5b 2f5b s 			PUSH	HL		;SAVE FOR TABLE
2f5c 2f5c d 3600
2f5c 2f5c u 02 01
2f5c 2f5c s 		DLOOP	LD	(HL),0		;ZERO ARRAY BYTE
2f5e 2f5e d 23
2f5e 2f5e u 01 01
2f5e 2f5e s 			INC	HL		;ADVANCE TO NEXT
2f5f 2f5f d 0b
2f5f 2f5f u 01 01
2f5f 2f5f s 			DEC	BC		;REDUCE COUNT
2f60 2f60 d 78
2f60 2f60 u 01 01
2f60 2f60 s 			LD	A,B		;GET HIGH BYTE OF REMAINING TO DO
2f61 2f61 d b1
2f61 2f61 u 01 01
2f61 2f61 s 			OR	C		;TEST FOR NONE LEFT
2f62 2f62 d c25c2f
2f62 2f62 u 03 01
2f62 2f62 s 			JP NZ,	DLOOP		;IF NOT, KEEP ZEROING
2f65 2f65 d 223a82
2f65 2f65 u 03 01
2f65 2f65 s 			LD	(LAST), HL	;SAVE NEXT FREE SPACE INDICATOR
2f68 2f68 d e1
2f68 2f68 u 01 01
2f68 2f68 s 			POP	HL		;GET ADDRESS OF ARRAY BACK
2f69 2f69 d 1a
2f69 2f69 u 01 01
2f69 2f69 s 			LD	A, (DE)		;GET ARRAY NAME
2f6a 2f6a d cd7d2f
2f6a 2f6a u 03 01
2f6a 2f6a s 			CALL	TABENT		;GET TABLE ENTRY
2f6d 2f6d d 7c
2f6d 2f6d u 01 01
2f6d 2f6d s 			LD	A,H		;GET HIGH ADDRESS
2f6e 2f6e d 02
2f6e 2f6e u 01 01
2f6e 2f6e s 			LD	(BC), A		;PLACE IN TABLE
2f6f 2f6f d 03
2f6f 2f6f u 01 01
2f6f 2f6f s 			INC	BC		;ADVANCE IN TABLE
2f70 2f70 d 7d
2f70 2f70 u 01 01
2f70 2f70 s 			LD	A,L		;GET LOW ADDRESS
2f71 2f71 d 02
2f71 2f71 u 01 01
2f71 2f71 s 			LD	(BC), A		;PLACE IN TABLE
2f72 2f72 d d1
2f72 2f72 u 01 01
2f72 2f72 s 			POP	DE		;GET SOURCE POSITION BACK
2f73 2f73 d cd0331
2f73 2f73 u 03 01
2f73 2f73 s 			CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
2f76 2f76 d c8
2f76 2f76 u 01 01
2f76 2f76 s 			RET Z
2f77 2f77 d fe2c
2f77 2f77 u 02 01
2f77 2f77 s 			CP	','		;TEST FOR ANOTHER OPERAND
2f79 2f79 d ca3e2f
2f79 2f79 u 03 01
2f79 2f79 s 			JP Z,	DIM		;IF SO, KEEP GOING
2f7c 2f7c d 97
2f7c 2f7c u 01 01
2f7c 2f7c s 			SUB	A		;CAUSE A SYNTAX ERROR BECAUSE WE ARE BAD
2f7d 2f7d s 		;
2f7d 2f7d s 		; LOCATES TABLE POSITION OF AN ARRAY
2f7d 2f7d s 		;
2f7d 2f7d d cd782a
2f7d 2f7d u 03 01
2f7d 2f7d s 		TABENT	CALL	VCHAR		;INSURE IT'S OK
2f80 2f80 d d641
2f80 2f80 u 02 01
2f80 2f80 s 			SUB	'A'		;CONVERT TO BINARY
2f82 2f82 d 87
2f82 2f82 u 01 01
2f82 2f82 s 			ADD	A,A		;X 2 FOR TWO BYTE ENTRIES
2f83 2f83 d 4f
2f83 2f83 u 01 01
2f83 2f83 s 			LD	C,A		;SAVE IN C
2f84 2f84 d 3afd81
2f84 2f84 u 03 01
2f84 2f84 s 			LD	A, (ARYLOC)	;GET ARRAY PAGE
2f87 2f87 d 47
2f87 2f87 u 01 01
2f87 2f87 s 			LD	B,A		;SAVE IN HIGH ZBYTE
2f88 2f88 d c9
2f88 2f88 u 01 01
2f88 2f88 s 			RET
2f89 2f89 s 		; LOOKS UP AN ARRAY VALUE
2f89 2f89 d cd3e31
2f89 2f89 u 03 01
2f89 2f89 s 		ALOOK	CALL	DOEXP		;CALCULATE INDEX VALUE
2f8c 2f8c d 1b
2f8c 2f8c u 01 01
2f8c 2f8c s 			DEC	DE		;BACK UP PAST '['
2f8d 2f8d d 1a
2f8d 2f8d u 01 01
2f8d 2f8d s 			LD	A, (DE)		;GET VARIABLE NAME
2f8e 2f8e d cd9e2f
2f8e 2f8e u 03 01
2f8e 2f8e s 			CALL	LOOKT		;FIND ADDRESS OF ENTRY
2f91 2f91 d 46
2f91 2f91 u 01 01
2f91 2f91 s 			LD	B,(HL)		;GET HIGH BYTE OF ENTRY
2f92 2f92 d 23
2f92 2f92 u 01 01
2f92 2f92 s 			INC	HL		;ADVANCE TO LOW BYTE
2f93 2f93 d 4e
2f93 2f93 u 01 01
2f93 2f93 s 			LD	C,(HL)		;GET LOW BYTE OF ARRAY ENTRY
2f94 2f94 d 60
2f94 2f94 u 01 01
2f94 2f94 s 			LD	H,B		;TRANSFER RESULT TO .
2f95 2f95 d 69
2f95 2f95 u 01 01
2f95 2f95 s 			LD	L,C		;H AND L WHERE THEY ARE EXPECTED
2f96 2f96 d 1a
2f96 2f96 u 01 01
2f96 2f96 s 			LD	A, (DE)		;GET VARIABLE NAME BACK
2f97 2f97 d fe40
2f97 2f97 u 02 01
2f97 2f97 s 			CP	'@'		;TEST FOR MAGIC 'PEEK' ARRAY
2f99 2f99 d c0
2f99 2f99 u 01 01
2f99 2f99 s 			RET NZ			;IF NOT, WE ARE OK
2f9a 2f9a d 6c
2f9a 2f9a u 01 01
2f9a 2f9a s 			LD	L,H		;SET VALUE TO THAT OF FIRST BYTE
2f9b 2f9b d 2600
2f9b 2f9b u 02 01
2f9b 2f9b s 			LD	H,0		;AND ELIMINATE HIGH BYTE
2f9d 2f9d d c9
2f9d 2f9d u 01 01
2f9d 2f9d s 			RET
2f9e 2f9e s 		;
2f9e 2f9e s 		; LOCATES ADDRESS OF AN ARRAY ENTRY IN THE ARRAY TABLE. INDEX IN HL
2f9e 2f9e s 		;
2f9e 2f9e d fe40
2f9e 2f9e u 02 01
2f9e 2f9e s 		LOOKT	CP	'@'		;TEST FOR SPECIAL CASE
2fa0 2fa0 d c8
2fa0 2fa0 u 01 01
2fa0 2fa0 s 			RET Z			;IF SO, PEEK AT ADDRESS
2fa1 2fa1 d cd7d2f
2fa1 2fa1 u 03 01
2fa1 2fa1 s 			CALL	TABENT		;LOCATE TABLE ENTRY
2fa4 2fa4 d d5
2fa4 2fa4 u 01 01
2fa4 2fa4 s 			PUSH	DE		;SAVE BASIC PROGRAM COUNTER
2fa5 2fa5 d 0a
2fa5 2fa5 u 01 01
2fa5 2fa5 s 			LD	A, (BC)		;GET FIRST BYTE
2fa6 2fa6 d 57
2fa6 2fa6 u 01 01
2fa6 2fa6 s 			LD	D,A		;COPY TO HIGH BYTE
2fa7 2fa7 d 03
2fa7 2fa7 u 01 01
2fa7 2fa7 s 			INC	BC		;ADVANCE TO NEXT
2fa8 2fa8 d 0a
2fa8 2fa8 u 01 01
2fa8 2fa8 s 			LD	A, (BC)		;GET LOW BYTE
2fa9 2fa9 d 5f
2fa9 2fa9 u 01 01
2fa9 2fa9 s 			LD	E,A		;COPY TO D
2faa 2faa d 29
2faa 2faa u 01 01
2faa 2faa s 			ADD	HL,HL		;X TWO FOR TWO BYTE ENTRIES
2fab 2fab d 19
2fab 2fab u 01 01
2fab 2fab s 			ADD	HL,DE		;ADD IN OFFSET FOR START OF ARRAY
2fac 2fac d b2
2fac 2fac u 01 01
2fac 2fac s 			OR	D		;TEST FOR ADDRESS OF ZERO, = NOT DIMENSIONED
2fad 2fad d d1
2fad 2fad u 01 01
2fad 2fad s 			POP	DE		;RESTORE PROGRAM COUNTER
2fae 2fae d c0
2fae 2fae u 01 01
2fae 2fae s 			RET NZ			;NOT A DIMENSION ERROR, GO BACK
2faf 2faf s 		;
2faf 2faf s 		; EITHER HE'S TRIED TO INDEX A NON-ARRAY VARIABLE, TRIED TO INDEX A CHARACTER
2faf 2faf s 		; VARIABLE WITH A VALUE GREATER THEN 34, OR HE'S PLOTTED OUTSIDE OF THE SCREEN
2faf 2faf s 		; NO MATTER WHAT HE'S DONE, GIVE HIM A NASTY MESSAGE SO HE WON'T DO IT AGAIN
2faf 2faf s 		;
2faf 2faf d 21f635
2faf 2faf u 03 01
2faf 2faf s 		DIMERR	LD	HL,OVM		;ADDRESS OF NASTY MESSAGE
2fb2 2fb2 d c3802a
2fb2 2fb2 u 03 01
2fb2 2fb2 s 			JP	ERR		;GIVE IT TO HIM
2fb5 2fb5 s 		; LOCATES THE ADDRESS OF A CHARACTER (TEXT) VARIABLE
2fb5 2fb5 d d641
2fb5 2fb5 u 02 01
2fb5 2fb5 s 		LTA	SUB	0x41		;REDUCE TO SIMPLE BINARY
2fb7 2fb7 d fe1a
2fb7 2fb7 u 02 01
2fb7 2fb7 s 			CP	26		;TEST FOR VALID VARIABLE
2fb9 2fb9 d d27c2a
2fb9 2fb9 u 03 01
2fb9 2fb9 s 			JP NC,	SYNT		;IF NOT, GET MAD
2fbc 2fbc d 211982
2fbc 2fbc u 03 01
2fbc 2fbc s 			LD	HL,VARS+25	;START OF CHARACTER VARIABLES (-37)
2fbf 2fbf d 012500
2fbf 2fbf u 03 01
2fbf 2fbf s 			LD	BC,37		;LENGTH OF CHARACTER VARIABLES
2fc2 2fc2 d 09
2fc2 2fc2 u 01 01
2fc2 2fc2 s 		V1	ADD	HL,BC		;OFFSET INTO TABLE
2fc3 2fc3 d 3d
2fc3 2fc3 u 01 01
2fc3 2fc3 s 			DEC	A		;REDUCE VARIABLES WE HAVE TO GO
2fc4 2fc4 d f2c22f
2fc4 2fc4 u 03 01
2fc4 2fc4 s 			JP P,	V1		;IF NOT FINISHED, KEEP OFFSETING
2fc7 2fc7 d c9
2fc7 2fc7 u 01 01
2fc7 2fc7 s 			RET
2fc8 2fc8 s 		;
2fc8 2fc8 s 		; IT'S A 'USR' COMMAND, FIND OUT WHAT HE WANT'S, PASS CONTROL  TO
2fc8 2fc8 s 		; HIS MACHINE LANGUAGE ROUTINE, AND GOD HELP HIM IF HE SCREW'S UP
2fc8 2fc8 s 		; BECAUSE WE CAN'T DO ANYTHING FOR HIM UNTIL HE RETURNS
2fc8 2fc8 s 		;
2fc8 2fc8 d 21dd2f
2fc8 2fc8 u 03 01
2fc8 2fc8 s 		USR	LD	HL,URET		;GET ON STACK (SO HE CAN 'RET' TO IT)
2fcb 2fcb d e5
2fcb 2fcb u 01 01
2fcb 2fcb s 			PUSH	HL		;SAVE IN MACHINE STACK
2fcc 2fcc d cd3531
2fcc 2fcc u 03 01
2fcc 2fcc s 			CALL	EXPR		;EVALUATE ADDRESS
2fcf 2fcf d e5
2fcf 2fcf u 01 01
2fcf 2fcf s 			PUSH	HL		;SAVE ON STACK (SO WE CAN 'RET' TO IT)
2fd0 2fd0 d 1a
2fd0 2fd0 u 01 01
2fd0 2fd0 s 			LD	A, (DE)		;GET NEXT CHARACTER
2fd1 2fd1 d fe2c
2fd1 2fd1 u 02 01
2fd1 2fd1 s 			CP	','		;TEST FOR MORE PARAMETERS
2fd3 2fd3 d c2da2f
2fd3 2fd3 u 03 01
2fd3 2fd3 s 			JP NZ,	CSAV		;IF NOT, DONT EVALUATE
2fd6 2fd6 d 13
2fd6 2fd6 u 01 01
2fd6 2fd6 s 			INC	DE		;SKIP THE ','
2fd7 2fd7 d cd3531
2fd7 2fd7 u 03 01
2fd7 2fd7 s 			CALL	EXPR		;EVALUATE PARAMETER TO PASS
2fda 2fda s 		; WHEN 'PUSHD' RETURNS, IT WILL EFFECT A JUMP TO HIS CODE
2fda 2fda d c3bd2d
2fda 2fda u 03 01
2fda 2fda s 		CSAV	JP	PUSHD		;SAVE PROGRAM POSITION
2fdd 2fdd s 		; IF WE GET HERE, HE MADE IT BACK IN ONE PIECE
2fdd 2fdd d cdc72d
2fdd 2fdd u 03 01
2fdd 2fdd s 		URET	CALL	POPD		;GET PROGRAM COUNTER BACK
2fe0 2fe0 d 1a
2fe0 2fe0 u 01 01
2fe0 2fe0 s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
2fe1 2fe1 d fe2c
2fe1 2fe1 u 02 01
2fe1 2fe1 s 			CP	','		;TEST FOR VARIABLE TO RECEIVE H-L
2fe3 2fe3 d c0
2fe3 2fe3 u 01 01
2fe3 2fe3 s 			RET NZ			;IF NOT, WE ARE DONE
2fe4 2fe4 d cd0331
2fe4 2fe4 u 03 01
2fe4 2fe4 s 			CALL	PARSE		;KEEP LOOKING
2fe7 2fe7 s 		;
2fe7 2fe7 s 		; STORES H-L INTO A INTEGER VARIABLE PASSED IN A
2fe7 2fe7 s 		;
2fe7 2fe7 d 0682
2fe7 2fe7 u 02 01
2fe7 2fe7 s 		STOR	LD	B,HIGH VARS	;GET ADDRESS OF VARIABLE TABLE
2fe9 2fe9 d d641
2fe9 2fe9 u 02 01
2fe9 2fe9 s 			SUB	0x41		;CONVERT TO BINARY
2feb 2feb d fe1a
2feb 2feb u 02 01
2feb 2feb s 			CP	26		;TEST FOR VALID VARIABLE NAME
2fed 2fed d d27c2a
2fed 2fed u 03 01
2fed 2fed s 			JP NC,	SYNT		;IF NOT, IT'S INVALID
2ff0 2ff0 d 87
2ff0 2ff0 u 01 01
2ff0 2ff0 s 			ADD	A,A		;DOUBLE BECAUSE THEY ARE 16 BIT ENTRIES
2ff1 2ff1 d 4f
2ff1 2ff1 u 01 01
2ff1 2ff1 s 			LD	C,A		;PLACE IN C, MAKING COMPLETE ADDRESS
2ff2 2ff2 d 7d
2ff2 2ff2 u 01 01
2ff2 2ff2 s 			LD	A,L		;GET LOW VALUE TO SAVE
2ff3 2ff3 d 02
2ff3 2ff3 u 01 01
2ff3 2ff3 s 			LD	(BC), A		;SAVE IN VARIABLE
2ff4 2ff4 d 03
2ff4 2ff4 u 01 01
2ff4 2ff4 s 			INC	BC		;NEXT BYTE OF VARIABLE
2ff5 2ff5 d 7c
2ff5 2ff5 u 01 01
2ff5 2ff5 s 			LD	A,H		;GET HIGH BYTE
2ff6 2ff6 d 02
2ff6 2ff6 u 01 01
2ff6 2ff6 s 			LD	(BC), A		;SAVE IN VARIABLE
2ff7 2ff7 d c9
2ff7 2ff7 u 01 01
2ff7 2ff7 s 			RET
2ff8 2ff8 s 		;
2ff8 2ff8 s 		; RETERIVES CONTENTS OF A VARIABLE
2ff8 2ff8 s 		;
2ff8 2ff8 d 0682
2ff8 2ff8 u 02 01
2ff8 2ff8 s 		LOOK	LD	B,HIGH VARS	;ADDRESS OF VARIABLES
2ffa 2ffa d d641
2ffa 2ffa u 02 01
2ffa 2ffa s 			SUB	'A'		;CONVERT NAME TO BINARY
2ffc 2ffc d 87
2ffc 2ffc u 01 01
2ffc 2ffc s 			ADD	A,A		;DOUBLE FOR 16 BIT ENTRIES
2ffd 2ffd d 4f
2ffd 2ffd u 01 01
2ffd 2ffd s 			LD	C,A		;MAKE COMPLETE ADDRESS
2ffe 2ffe d 0a
2ffe 2ffe u 01 01
2ffe 2ffe s 			LD	A, (BC)		;GET LOW BYTE
2fff 2fff d 6f
2fff 2fff u 01 01
2fff 2fff s 			LD	L,A		;PLACE IN L
3000 3000 d 03
3000 3000 u 01 01
3000 3000 s 			INC	BC		;NEXT BYTE OF VARIABLE
3001 3001 d 0a
3001 3001 u 01 01
3001 3001 s 			LD	A, (BC)		;GET HIGH BYTE
3002 3002 d 67
3002 3002 u 01 01
3002 3002 s 			LD	H,A		;PLACE IN H
3003 3003 d c9
3003 3003 u 01 01
3003 3003 s 			RET
3004 3004 s 		;
3004 3004 s 		; IT'S AN 'ORDER', (HE THINKS HE KNOWS WHERE THERE IS SOME DATA)
3004 3004 s 		;
3004 3004 d d5
3004 3004 u 01 01
3004 3004 s 		ORDER	PUSH	DE		;SAVE OUR SOURCE POSITION
3005 3005 d cd192c
3005 3005 u 03 01
3005 3005 s 			CALL	FNDLIN		;GET ADDRESS OF THE LINE HE WANTS
3008 3008 d d1
3008 3008 u 01 01
3008 3008 s 			POP	DE		;RESTORE OUR POSITION
3009 3009 d d5
3009 3009 u 01 01
3009 3009 s 			PUSH	DE		;AND RESAVE OUR POSITION
300a 300a d c2682d
300a 300a u 03 01
300a 300a s 			JP NZ,	BADLIN		;IF IT DOSN'T EXIST, THEN FORGET IT
300d 300d d 23
300d 300d u 01 01
300d 300d s 			INC	HL		;SKIP FIRST TWO DIGITS OF LINE NUMBER
300e 300e d 23
300e 300e u 01 01
300e 300e s 			INC	HL		;SKIP LAST TWO DIGITS OF LINE NUMBER
300f 300f d 23
300f 300f u 01 01
300f 300f s 			INC	HL		;SKIP LENGTH BYTE
3010 3010 d eb
3010 3010 u 01 01
3010 3010 s 			EX	DE, HL	
3011 3011 d cd9430
3011 3011 u 03 01
3011 3011 s 			CALL	VERDAT		;GET STATEMENT FROM LINE
3014 3014 d 223882
3014 3014 u 03 01
3014 3014 s 			LD	(DATA), HL	;SAVE DATA POINTER
3017 3017 d d1
3017 3017 u 01 01
3017 3017 s 			POP	DE		;RESTORE OUR LINE, (SO WE CAN TELL HIM)
3018 3018 d c8
3018 3018 u 01 01
3018 3018 s 			RET Z
3019 3019 s 		;
3019 3019 s 		; DATA ERROR... ATTEMPT TO READ FROM A LINE WITHOUT 'DATA' OR
3019 3019 s 		; ATTEMPT TO READ THE WRONG DATA TYPE. LET HIM IN ON IT
3019 3019 s 		;
3019 3019 d 21f135
3019 3019 u 03 01
3019 3019 s 		DERR	LD	HL,DTXT		;ADDRESS OF 'DATA' MESSAGE
301c 301c d c37f2a
301c 301c u 03 01
301c 301c s 			JP	SYNT+3		;DISPLAY IT
301f 301f s 		;
301f 301f s 		; IT'S A READ. (HE WANTS TO KNOW WHATS IN THAT DATA WE FOUND)
301f 301f s 		;
301f 301f d cd782a
301f 301f u 03 01
301f 301f s 		READ	CALL	VCHAR		;IS IT A VALID VARIABLE
3022 3022 d f5
3022 3022 u 01 01
3022 3022 s 			PUSH	AF
3023 3023 d 13
3023 3023 u 01 01
3023 3023 s 			INC	DE		;ADVANCE TO NEXT CHARACTER
3024 3024 d 1a
3024 3024 u 01 01
3024 3024 s 			LD	A, (DE)		;GET NEXT CHARACTER
3025 3025 d fe24
3025 3025 u 02 01
3025 3025 s 			CP	'$'		;IS IT A CHARACTER VARIABLE?
3027 3027 d ca3730
3027 3027 u 03 01
3027 3027 s 			JP Z,	CDAT		;IF SO, LOOK FOR CHARACTER DATA
302a 302a s 		; NUMERIC DATA, FOR NUMERIC VARIABLE
302a 302a d cd5d30
302a 302a u 03 01
302a 302a s 			CALL	GETDAT		;GET NUMERIC DATA
302d 302d d da1930
302d 302d u 03 01
302d 302d s 			JP C,	DERR		;IF CHARACTER, IT A DATA TYPE ERROR
3030 3030 d f1
3030 3030 u 01 01
3030 3030 s 			POP	AF
3031 3031 d cde72f
3031 3031 u 03 01
3031 3031 s 			CALL	STOR		;STASH VALUE IN IT
3034 3034 d c35130
3034 3034 u 03 01
3034 3034 s 			JP	MORDAT		;SEE IF HE WANT'S MORE DATA
3037 3037 s 		; CHARACTER DATA, FOR CHARACTER VARIABLE
3037 3037 d 13
3037 3037 u 01 01
3037 3037 s 		CDAT	INC	DE		;SKIP DOLLAR SIGN
3038 3038 d cd5d30
3038 3038 u 03 01
3038 3038 s 			CALL	GETDAT		;GET DATA
303b 303b d d21930
303b 303b u 03 01
303b 303b s 			JP NC,	DERR		;IF NUMERIC, IT'S BAD
303e 303e d f1
303e 303e u 01 01
303e 303e s 			POP	AF
303f 303f d cdb52f
303f 303f u 03 01
303f 303f s 			CALL	LTA		;FIND IT'S ADDRESS
3042 3042 d 016480
3042 3042 u 03 01
3042 3042 s 			LD	BC,XBF		;DATA IS IN EXTRA BUFFER
3045 3045 d d5
3045 3045 u 01 01
3045 3045 s 			PUSH	DE		;SAVE SOURCE POSITION
3046 3046 d 1e23
3046 3046 u 02 01
3046 3046 s 			LD	E,35		;MOVE 35 CHARACTERS
3048 3048 d 0a
3048 3048 u 01 01
3048 3048 s 		SL1	LD	A, (BC)		;GET CHARACTER FROM BUFFER. (DATA)
3049 3049 d 77
3049 3049 u 01 01
3049 3049 s 			LD	(HL),A		;STASH IT IN THE VARIABLE
304a 304a d 03
304a 304a u 01 01
304a 304a s 			INC	BC		;SKIP TO THE NEXT CHARACTER IN THE BUFFER
304b 304b d 23
304b 304b u 01 01
304b 304b s 			INC	HL		;SKIP TO THE NEXT POSITION IN VARIABLE
304c 304c d 1d
304c 304c u 01 01
304c 304c s 			DEC	E		;REDUCE COUNT OF HOW MANY TO MOVE
304d 304d d c24830
304d 304d u 03 01
304d 304d s 			JP NZ,	SL1		;IF NOT FINISHED, KEEP COPYING
3050 3050 d d1
3050 3050 u 01 01
3050 3050 s 			POP	DE		;RESTORE SOURCE POSITION
3051 3051 s 		; LOOK FOR MORE VARIABLES (OPERANDS) IN THE 'READ' STATEMENT
3051 3051 d cd0431
3051 3051 u 03 01
3051 3051 s 		MORDAT	CALL	PARSE1		;FIND NEXT NON-BLANK
3054 3054 d fe2c
3054 3054 u 02 01
3054 3054 s 			CP	','		;IF COMMA..
3056 3056 d c0
3056 3056 u 01 01
3056 3056 s 			RET NZ			;IF NOT, WE HAVE ALL THERE IS
3057 3057 d cd0331
3057 3057 u 03 01
3057 3057 s 			CALL	PARSE		;SKIP COMMA AND FIND VARIABLE NAME
305a 305a d c31f30
305a 305a u 03 01
305a 305a s 			JP	READ		;GET MORE DATA FOR FOLLOWING VARIABLE
305d 305d s 		; GETS DATA FROM THE DATA STATEMENTS, POINTED TO BY THE CURRENT READ POINTER
305d 305d d 2a3882
305d 305d u 03 01
305d 305d s 		GETDAT	LD	HL, (DATA)	;GET DATA POINTER
3060 3060 d 7c
3060 3060 u 01 01
3060 3060 s 			LD	A,H		;SEE IF IT IS ZERO.
3061 3061 d b5
3061 3061 u 01 01
3061 3061 s 			OR	L		;WHICH INDICATES THAT IT WASN'T INITIALIZED
3062 3062 d ca1930
3062 3062 u 03 01
3062 3062 s 			JP Z,	DERR		;IF SO, IT'S A DATA ERROR
3065 3065 d d5
3065 3065 u 01 01
3065 3065 s 			PUSH	DE		;SAVE SOURCE POSIITION
3066 3066 d eb
3066 3066 u 01 01
3066 3066 s 			EX	DE, HL	
3067 3067 d cd3531
3067 3067 u 03 01
3067 3067 s 			CALL	EXPR		;EVALUATE THE DATA EXPRESSION
306a 306a d f5
306a 306a u 01 01
306a 306a s 			PUSH	AF
306b 306b d 1a
306b 306b u 01 01
306b 306b s 		ENDAT	LD	A, (DE)		;GET NEXT CHARACTER FROM THE SOURCE
306c 306c d fe2c
306c 306c u 02 01
306c 306c s 			CP	','		;TEST FOR MORE DATA
306e 306e d ca8b30
306e 306e u 03 01
306e 306e s 			JP Z,	COMA		;IF SO, WE ARE OK
3071 3071 d fe3a
3071 3071 u 02 01
3071 3071 s 			CP	':'		;TEST FOR END OF STATEMENT
3073 3073 d ca7e30
3073 3073 u 03 01
3073 3073 s 			JP Z,	DAT1		;GO TO NEXT DATA STATEMENT
3076 3076 d 13
3076 3076 u 01 01
3076 3076 s 			INC	DE		;ADVANCE ONE CHARACTER
3077 3077 d fe0d
3077 3077 u 02 01
3077 3077 s 			CP	CR		;CARRIAGE RETURN?
3079 3079 d c26b30
3079 3079 u 03 01
3079 3079 s 			JP NZ,	ENDAT		;KEEP LOOKING IF NOT
307c 307c s 		; HIT THE END OF A LINE, SKIP TO NEXT DATA STATEMENT
307c 307c d 13
307c 307c u 01 01
307c 307c s 			INC	DE		;SKIP FIRST TWO DIGITS
307d 307d d 13
307d 307d u 01 01
307d 307d s 			INC	DE		;SKIP SECOND TWO DIGITS
307e 307e d 13
307e 307e u 01 01
307e 307e s 		DAT1	INC	DE		;SKIP LENGTH (OR ':' IF STMT)
307f 307f d e5
307f 307f u 01 01
307f 307f s 			PUSH	HL		;SAVE H-L REG
3080 3080 d cd9430
3080 3080 u 03 01
3080 3080 s 			CALL	VERDAT		;CHECK FOR DATA STATEMENT
3083 3083 d eb
3083 3083 u 01 01
3083 3083 s 			EX	DE, HL	
3084 3084 d e1
3084 3084 u 01 01
3084 3084 s 			POP	HL		;RESTORE REGISTERS
3085 3085 d ca8c30
3085 3085 u 03 01
3085 3085 s 			JP Z,	GDEND		;RETURN, WITH NEW DATA POINTER
3088 3088 d 11ffff
3088 3088 u 03 01
3088 3088 s 			LD	DE,0xFFFF	;INDICATE NO MORE DATA STATEMENTS
308b 308b d 13
308b 308b u 01 01
308b 308b s 		COMA	INC	DE		;SKIP THE COMMA
308c 308c d eb
308c 308c u 01 01
308c 308c s 		GDEND	EX	DE, HL	
308d 308d d 223882
308d 308d u 03 01
308d 308d s 			LD	(DATA), HL	;SAVE IN POINTER
3090 3090 d eb
3090 3090 u 01 01
3090 3090 s 			EX	DE, HL	
3091 3091 d f1
3091 3091 u 01 01
3091 3091 s 			POP	AF
3092 3092 d d1
3092 3092 u 01 01
3092 3092 s 			POP	DE		;GET SOURCE POSITION BACK
3093 3093 d c9
3093 3093 u 01 01
3093 3093 s 			RET
3094 3094 s 		;
3094 3094 s 		; VERIFY THAT COMMAND WAS 'DATA'
3094 3094 s 		;
3094 3094 d cd0431
3094 3094 u 03 01
3094 3094 s 		VERDAT	CALL	PARSE1		;SKIP TO COMMAND
3097 3097 d eb
3097 3097 u 01 01
3097 3097 s 			EX	DE, HL	
3098 3098 d 111735
3098 3098 u 03 01
3098 3098 s 			LD	DE,DATCMD	;POINT TO DATA COMMAND
309b 309b d 7b
309b 309b u 01 01
309b 309b s 		VER1	LD	A,E		;GET LOW ADDRESS
309c 309c d fe1b
309c 309c u 02 01
309c 309c s 			CP	LOW (DATCMD+4)	;ARE WE AT END
309e 309e d c8
309e 309e u 01 01
309e 309e s 			RET Z
309f 309f d 1a
309f 309f u 01 01
309f 309f s 			LD	A, (DE)		;GET CHR FROM TABLE
30a0 30a0 d 13
30a0 30a0 u 01 01
30a0 30a0 s 			INC	DE		;ADVANCE TO NEXT
30a1 30a1 d e67f
30a1 30a1 u 02 01
30a1 30a1 s 			AND	0x7F		;INSURE IT'S CORRECT
30a3 30a3 d be
30a3 30a3 u 01 01
30a3 30a3 s 			CP	(HL)		;DUZ IT MATCH?
30a4 30a4 d 23
30a4 30a4 u 01 01
30a4 30a4 s 			INC	HL		;NEXT IN DATA COMMAND
30a5 30a5 d ca9b30
30a5 30a5 u 03 01
30a5 30a5 s 			JP Z,	VER1		;OK, TEST NEXT
30a8 30a8 d c9
30a8 30a8 u 01 01
30a8 30a8 s 			RET
30a9 30a9 s 		;
30a9 30a9 s 		; HE WANT'S TO KNOW HOW BIG IT IS... LETS FIGURE IT OUT AND LET HIM IN ON IT
30a9 30a9 s 		;
30a9 30a9 d d5
30a9 30a9 u 01 01
30a9 30a9 s 		SIZE	PUSH	DE		;SAVE PROGRAM POINTER
30aa 30aa d cdbb30
30aa 30aa u 03 01
30aa 30aa s 			CALL	GETEOF		;FIND THE END OF THE FILE
30ad 30ad d 017a00
30ad 30ad u 03 01
30ad 30ad s 			LD	BC,NEGTEXT	;GET THE (NEGATIVE) FILE START ADDRESS
30b0 30b0 d 09
30b0 30b0 u 01 01
30b0 30b0 s 			ADD	HL,BC		;SUBTRACT FILE START FROM FILE END
30b1 30b1 d cdb22e
30b1 30b1 u 03 01
30b1 30b1 s 			CALL	DECPRT		;DISPLAY VALUE IN DECIMAL
30b4 30b4 d 214436
30b4 30b4 u 03 01
30b4 30b4 s 			LD	HL,SIMSG	;GET ' BYTES' MESSAGE
30b7 30b7 d d1
30b7 30b7 u 01 01
30b7 30b7 s 			POP	DE		;RESTORE PROGRAM POINTER
30b8 30b8 d c35700
30b8 30b8 u 03 01
30b8 30b8 s 			JP	PRINTM		;TELL HIM WHAT IT IS
30bb 30bb s 		; FINDS THE END OF THE FILE, HL=LAST BYTE OF PGM., A=FIRST FREE PAGE
30bb 30bb d 210086
30bb 30bb u 03 01
30bb 30bb s 		GETEOF	LD	HL,TEXT		;START AT THE BEGINING
30be 30be d 3eff
30be 30be u 02 01
30be 30be s 			LD	A,255		;LOOKING FOR AN FF
30c0 30c0 d be
30c0 30c0 u 01 01
30c0 30c0 s 		GLPX	CP	(HL)		;IS THIS IT?
30c1 30c1 d 23
30c1 30c1 u 01 01
30c1 30c1 s 			INC	HL		;ADVANCE TO NEXT
30c2 30c2 d c2c030
30c2 30c2 u 03 01
30c2 30c2 s 			JP NZ,	GLPX		;IF NOT IT, KEEP LOOKING
30c5 30c5 d 2b
30c5 30c5 u 01 01
30c5 30c5 s 			DEC	HL		;POINT BACK TO 0xFF
30c6 30c6 d 7c
30c6 30c6 u 01 01
30c6 30c6 s 			LD	A,H		;GET HIGH VALUE
30c7 30c7 d 3c
30c7 30c7 u 01 01
30c7 30c7 s 			INC	A		;ADVANCE TO NEXT PAGE
30c8 30c8 d c9
30c8 30c8 u 01 01
30c8 30c8 s 			RET
30c9 30c9 s 		;
30c9 30c9 s 		; HE'S TRYING TO 'LOAD' SOMETHING, I WONDER IF HE HAS SOMETHING SAVED..
30c9 30c9 s 		;
30c9 30c9 s 		LOAD:	;CALL	TON		;TURN ON TAPE AND WAIT
30c9 30c9 s 		LOD1:	;CALL	GETR		;GET A RECORD
30c9 30c9 s 			;JP C,	LOD1		;KEEP GOING TILL WE HAVE IT ALL
30c9 30c9 s 			;CALL	TOFF		;SHUT TAPE OFF
30c9 30c9 d c31a2a
30c9 30c9 u 03 01
30c9 30c9 s 			JP	RESV		;CLEAR VARIABLES AND GET A NEW COMMAND
30cc 30cc s 		;
30cc 30cc s 		; HE'S TRYING TO 'SAVE' SOMETHING..
30cc 30cc s 		;
30cc 30cc d d5
30cc 30cc u 01 01
30cc 30cc s 		SAVE	PUSH	DE		;SAVE PROGRAM POINTER
30cd 30cd d 110086
30cd 30cd u 03 01
30cd 30cd s 			LD	DE,TEXT		;GET ADDRESS OF TEXT
30d0 30d0 d 1a
30d0 30d0 u 01 01
30d0 30d0 s 			LD	A, (DE)		;GET FIRST BYTE
30d1 30d1 d 3c
30d1 30d1 u 01 01
30d1 30d1 s 			INC	A		;TEST FOR NO PROGRAM
30d2 30d2 d caec2c
30d2 30d2 u 03 01
30d2 30d2 s 			JP Z,	RUN		;IF SO, RUN WILL ABORT WITH ERROR
30d5 30d5 d cdbb30
30d5 30d5 u 03 01
30d5 30d5 s 			CALL	GETEOF		;GET ENDING ADDRESS
30d8 30d8 s 			;CALL	TDUMP		;DUMP PROGRAM AND RETURN
30d8 30d8 d d1
30d8 30d8 u 01 01
30d8 30d8 s 			POP	DE		;RESTORE PROGRAM POINTER
30d9 30d9 d c9
30d9 30d9 u 01 01
30d9 30d9 s 			RET
30da 30da s 		;
30da 30da s 		;****************************************************************
30da 30da s 		;                 EXPRESSION EVALUATION CODE
30da 30da s 		;****************************************************************
30da 30da s 		;
30da 30da s 		; EVALUATES 16 BIT DECIMAL NUMBERS
30da 30da s 		;
30da 30da d 010100
30da 30da u 03 01
30da 30da s 		EVAL	LD	BC,1		;MULTIPLIER IS ONE
30dd 30dd d 60
30dd 30dd u 01 01
30dd 30dd s 			LD	H,B		;INITIALIZE
30de 30de d 68
30de 30de u 01 01
30de 30de s 			LD	L,B		;STARTING RESULT TO ZERO
30df 30df d 1a
30df 30df u 01 01
30df 30df s 		ETOP	LD	A, (DE)		;GET DIGIT FROM SOURCE
30e0 30e0 d cdc62a
30e0 30e0 u 03 01
30e0 30e0 s 			CALL	NUM		;TEST FOR INVALID DIGIT
30e3 30e3 d d8
30e3 30e3 u 01 01
30e3 30e3 s 			RET C			;IF SO, WE ARE FINISHED
30e4 30e4 d e60f
30e4 30e4 u 02 01
30e4 30e4 s 			AND	0x0F		;CONVERT TO BINARY
30e6 30e6 s 		; ADD DIGIT TIMES MULTIPLIER IN B-C TO H-L
30e6 30e6 d 3d
30e6 30e6 u 01 01
30e6 30e6 s 		ZLOOP	DEC	A		;REDUCE BY ONE
30e7 30e7 d faee30
30e7 30e7 u 03 01
30e7 30e7 s 			JP M,	ESP1		;BEXIT WHEN EXAUSTED
30ea 30ea d 09
30ea 30ea u 01 01
30ea 30ea s 			ADD	HL,BC		;ADD MULTIPLIER
30eb 30eb d c3e630
30eb 30eb u 03 01
30eb 30eb s 			JP	ZLOOP		;CONTINUE TILL DONE
30ee 30ee s 		; MULTIPLY MULTIPLIER (BC) BY 10
30ee 30ee d e5
30ee 30ee u 01 01
30ee 30ee s 		ESP1	PUSH	HL		;SAVE H-L
30ef 30ef d 60
30ef 30ef u 01 01
30ef 30ef s 			LD	H,B		;GET B-C INTO
30f0 30f0 d 69
30f0 30f0 u 01 01
30f0 30f0 s 			LD	L,C		;H-L SO WE CAN USE 'DAD'
30f1 30f1 d 09
30f1 30f1 u 01 01
30f1 30f1 s 			ADD	HL,BC		;BC=BC*2
30f2 30f2 d 29
30f2 30f2 u 01 01
30f2 30f2 s 			ADD	HL,HL		;BC=BC*4
30f3 30f3 d 09
30f3 30f3 u 01 01
30f3 30f3 s 			ADD	HL,BC		;BC=BC*5
30f4 30f4 d 29
30f4 30f4 u 01 01
30f4 30f4 s 			ADD	HL,HL		;BC=BC*10
30f5 30f5 d 44
30f5 30f5 u 01 01
30f5 30f5 s 			LD	B,H		;SAVE BACK INTO
30f6 30f6 d 4d
30f6 30f6 u 01 01
30f6 30f6 s 			LD	C,L		;B-C REGISTER PAIR
30f7 30f7 d e1
30f7 30f7 u 01 01
30f7 30f7 s 			POP	HL		;RESTORE H-L
30f8 30f8 d 1b
30f8 30f8 u 01 01
30f8 30f8 s 			DEC	DE		;REDUCE POINTER IN SOURCE
30f9 30f9 d c3df30
30f9 30f9 u 03 01
30f9 30f9 s 			JP	ETOP		;EVALUATE NEXT CHARACTER
30fc 30fc s 		;
30fc 30fc s 		; SUBROUTINE TESTS FOR VALID ASCII CHARACTERS
30fc 30fc s 		;
30fc 30fc d fe41
30fc 30fc u 02 01
30fc 30fc s 		CHAR	CP	'A'		;TEST FOR < 'A'
30fe 30fe d d8
30fe 30fe u 01 01
30fe 30fe s 			RET C			;RETURN SAYING IT'S BAD
30ff 30ff d fe5b
30ff 30ff u 02 01
30ff 30ff s 			CP	'Z'+1		;TEST FOR >'Z'
3101 3101 d 3f
3101 3101 u 01 01
3101 3101 s 			CCF			;INVERT LOGIC
3102 3102 d c9
3102 3102 u 01 01
3102 3102 s 			RET
3103 3103 s 		;
3103 3103 s 		; PARSES FORWARD, SEARCHING FOR FIRST NON-BLANK CHARACTER
3103 3103 s 		;
3103 3103 d 13
3103 3103 u 01 01
3103 3103 s 		PARSE	INC	DE		;ADVANCE IN SOURCE
3104 3104 d 1a
3104 3104 u 01 01
3104 3104 s 		PARSE1	LD	A, (DE)		;GET CHARACTER FROM SOURCE
3105 3105 d fe20
3105 3105 u 02 01
3105 3105 s 			CP	' '		;TEST FOR SPACE
3107 3107 d 28fa
3107 3107 u 02 01
3107 3107 s 			JR Z,	PARSE		;KEEP LOOKING
3109 3109 d fe3a
3109 3109 u 02 01
3109 3109 s 			CP	':'		;TEST FOR END OF STATEMENT
310b 310b d c8
310b 310b u 01 01
310b 310b s 			RET Z			;IF SO, RETURN WITH Z SET
310c 310c d fe0d
310c 310c u 02 01
310c 310c s 			CP	CR		;TEST FOR END OF LINE
310e 310e d c9
310e 310e u 01 01
310e 310e s 			RET
310f 310f s 		;
310f 310f s 		; SKIPS TO NEXT EXPRESSION OR COMMAND
310f 310f s 		;
310f 310f d cd0431
310f 310f u 03 01
310f 310f s 		SKIP	CALL	PARSE1		;ADVANCE TO NEXT NON-BLANK
3112 3112 d 1b
3112 3112 u 01 01
3112 3112 s 			DEC	DE		;BACK UP TO POSITION
3113 3113 d 7b
3113 3113 u 01 01
3113 3113 s 			LD	A,E		;GET LOW ORDER ADDRESS
3114 3114 d 323682
3114 3114 u 03 01
3114 3114 s 			LD	(PP), A		;SAVE IN POSITION BYTE
3117 3117 s 		; LOOK FOR DELIMITER
3117 3117 d 13
3117 3117 u 01 01
3117 3117 s 		SKIP1	INC	DE		;ADVANCE TO NEXT
3118 3118 d 1a
3118 3118 u 01 01
3118 3118 s 			LD	A, (DE)		;GET CHARACTER
3119 3119 d fe3a
3119 3119 u 02 01
3119 3119 s 			CP	':'		;TEST FOR DELIMITER
311b 311b d c8
311b 311b u 01 01
311b 311b s 			RET Z			;IF SO, RETURN
311c 311c d fe2c
311c 311c u 02 01
311c 311c s 			CP	','		;TEST FOR DELIMITER
311e 311e d c8
311e 311e u 01 01
311e 311e s 			RET Z			;IF SO, RETURN
311f 311f d fe0d
311f 311f u 02 01
311f 311f s 			CP	CR		;TEST FOR DELIMITER
3121 3121 d c8
3121 3121 u 01 01
3121 3121 s 			RET Z			;IF SO, RETURN
3122 3122 d fe22
3122 3122 u 02 01
3122 3122 s 			CP	'"'		;TEST FOR QUOTE
3124 3124 d cc2931
3124 3124 u 03 01
3124 3124 s 			CALL Z,	SKPQUO		;IF SO, ADVANCE TO NEXT QUOTE
3127 3127 d 18ee
3127 3127 u 02 01
3127 3127 s 			JR	SKIP1		;KEEP LOOKING
3129 3129 s 		; FIND NEXT QUOTE IN SOURCE
3129 3129 d 13
3129 3129 u 01 01
3129 3129 s 		SKPQUO	INC	DE		;ADVANCE TO NEXT CHARACTER IN SOURCE
312a 312a d 1a
312a 312a u 01 01
312a 312a s 			LD	A, (DE)		;GET THE CHARACTER
312b 312b d fe22
312b 312b u 02 01
312b 312b s 			CP	'"'		;IS IT A QUOTE?
312d 312d d c8
312d 312d u 01 01
312d 312d s 			RET Z			;IF SO, WE FOUND IT
312e 312e d fe0d
312e 312e u 02 01
312e 312e s 			CP	CR		;IF IT A CARRIAGE RETUEN
3130 3130 d 20f7
3130 3130 u 02 01
3130 3130 s 			JR NZ,	SKPQUO		;IF NOT, OK
3132 3132 d c37c2a
3132 3132 u 03 01
3132 3132 s 			JP	SYNT		;UNMATCHED QUOTES WHILE PARSING
3135 3135 s 		;
3135 3135 s 		; EVALUATES AN EXPRESSION POINTED TO BY D-E. RETURN WITH CARRY SET
3135 3135 s 		; INDICATES THAT EXPRESSION WAS A CHARACTER EXPRESSION
3135 3135 s 		;
3135 3135 d cd0f31
3135 3135 u 03 01
3135 3135 s 		EXPR	CALL	SKIP		;ADVANCE TO END OF EXPRESSION
3138 3138 d d5
3138 3138 u 01 01
3138 3138 s 			PUSH	DE		;SAVE POINTER TO END
3139 3139 d cd3e31
3139 3139 u 03 01
3139 3139 s 			CALL	DOEXP		;EVALUATE
313c 313c d d1
313c 313c u 01 01
313c 313c s 			POP	DE		;RESTORE POINTER TO END OF EXPRESSION
313d 313d d c9
313d 313d u 01 01
313d 313d s 			RET
313e 313e s 		; CALCULATES EXPRESSION BACKWARDS (LIKE APL)
313e 313e d 1b
313e 313e u 01 01
313e 313e s 		DOEXP	DEC	DE		;BACK UP IN SOURCE
313f 313f d cda033
313f 313f u 03 01
313f 313f s 			CALL	FE		;GET CHARACTER FROM SOURCE
3142 3142 d fe24
3142 3142 u 02 01
3142 3142 s 			CP	'$'		;TEST FOR CHARACTER VARIABLE
3144 3144 d cacc33
3144 3144 u 03 01
3144 3144 s 			JP Z,	CEXP		;IF SO, ITS A CHARACTER EXPRESSION
3147 3147 d fe22
3147 3147 u 02 01
3147 3147 s 			CP	'"'		;TEST FOR QUOTE
3149 3149 d cacc33
3149 3149 u 03 01
3149 3149 s 			JP Z,	CEXP		;IF SO, IT'S A CHARACTER EXRESSION
314c 314c d 13
314c 314c u 01 01
314c 314c s 			INC	DE		;ADVANCE
314d 314d d 3e3b
314d 314d u 02 01
314d 314d s 			LD	A,';'		;NULL OPERATOR TO START
314f 314f d e5
314f 314f u 01 01
314f 314f s 		EGO1	PUSH	HL		;SAVE OLD VALUE
3150 3150 d f5
3150 3150 u 01 01
3150 3150 s 			PUSH	AF
3151 3151 d 1b
3151 3151 u 01 01
3151 3151 s 			DEC	DE		;BACK UP TO VALUE
3152 3152 d cda033
3152 3152 u 03 01
3152 3152 s 			CALL	FE		;GET CHARACTER FROM SOURCE
3155 3155 d fe29
3155 3155 u 02 01
3155 3155 s 			CP	')'		;TEST FOR BRACKET
3157 3157 d cab931
3157 3157 u 03 01
3157 3157 s 			JP Z,	BRKTS		;IF SO, RECURSE
315a 315a d fe5d
315a 315a u 02 01
315a 315a s 			CP	']'		;TEST FOR ARRAY LOOKUP
315c 315c d cabf31
315c 315c u 03 01
315c 315c s 			JP Z,	ARYL		;IF SO, LOOK UP ARRAY VALUE
315f 315f d cdfc30
315f 315f u 03 01
315f 315f s 			CALL	CHAR		;TEST FOR VARIABLE
3162 3162 d d2c931
3162 3162 u 03 01
3162 3162 s 			JP NC,	LOOKU		;IF SO, LOOK IT UP
3165 3165 d fe3f
3165 3165 u 02 01
3165 3165 s 			CP	'?'		;TEST FOR RANDOM NUMBER RETERIVAL
3167 3167 d caad33
3167 3167 u 03 01
3167 3167 s 			JP Z,	RANDR		;GET RANDOM VALUE
316a 316a d fe23
316a 316a u 02 01
316a 316a s 			CP	'#'		;TEST FOR HEX CONSTANT
316c 316c d ca7b31
316c 316c u 03 01
316c 316c s 			JP Z,	HEXVL		;IF SO, GET HEV VALUE
316f 316f d cdc62a
316f 316f u 03 01
316f 316f s 			CALL	NUM		;TEST FOR A NUMBER
3172 3172 d da7c2a
3172 3172 u 03 01
3172 3172 s 			JP C,	SYNT		;IF NOT, I DON'T KNOW WHAT HE'S DOING
3175 3175 s 		; DECIMAL NUMBER
3175 3175 d cdda30
3175 3175 u 03 01
3175 3175 s 		CALN	CALL	EVAL		;EVALUATE DECIMAL NUMBER
3178 3178 d c3cd31
3178 3178 u 03 01
3178 3178 s 			JP	OLOOK		;LOOK FOR OPERATOR
317b 317b s 		; HEX. NUMBER
317b 317b d 1b
317b 317b u 01 01
317b 317b s 		HEXVL	DEC	DE		;BACK UP IN SOURCE
317c 317c d 3a3682
317c 317c u 03 01
317c 317c s 			LD	A, (PP)		;GET ENDING POSITION
317f 317f d bb
317f 317f u 01 01
317f 317f s 			CP	E		;TEST FOR PASSED THE LIMIT
3180 3180 d ca9131
3180 3180 u 03 01
3180 3180 s 			JP Z,	HEXGO		;IF SO, THATS IT
3183 3183 d 1a
3183 3183 u 01 01
3183 3183 s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
3184 3184 d cdc62a
3184 3184 u 03 01
3184 3184 s 			CALL	NUM		;TEST FOR VALID DIGIT
3187 3187 d d27b31
3187 3187 u 03 01
3187 3187 s 			JP NC,	HEXVL		;KEEP GOING TILL WE GET TO START OF STRING
318a 318a d d641
318a 318a u 02 01
318a 318a s 			SUB	'A'		;TEST FOR VALID LETTER
318c 318c d fe06
318c 318c u 02 01
318c 318c s 			CP	6		;OF 'A' TO 'F'
318e 318e d da7b31
318e 318e u 03 01
318e 318e s 			JP C,	HEXVL		;IF SO, KEEP LOOKING
3191 3191 d 210000
3191 3191 u 03 01
3191 3191 s 		HEXGO	LD	HL,0		;START WITH A ZERO
3194 3194 d 44
3194 3194 u 01 01
3194 3194 s 			LD	B,H		;FLAG TO SEE IF ANY DIGITS
3195 3195 d d5
3195 3195 u 01 01
3195 3195 s 			PUSH	DE		;SAVE POSITION IN SOURCE
3196 3196 d 13
3196 3196 u 01 01
3196 3196 s 		GETHX	INC	DE		;ADVANCE TO NEXT DIGIT OF HEX NUMBER
3197 3197 d 1a
3197 3197 u 01 01
3197 3197 s 			LD	A, (DE)		;GET DIGIT
3198 3198 d fe23
3198 3198 u 02 01
3198 3198 s 			CP	'#'		;TEST FOR END OF STRING
319a 319a d cab031
319a 319a u 03 01
319a 319a s 			JP Z,	HGON		;IF SO, WE ARE DONE
319d 319d d 47
319d 319d u 01 01
319d 319d s 			LD	B,A		;SET FLAG SO WE KNOW WE GOT AT LEAST ONE DIGIT
319e 319e d 29
319e 319e u 01 01
319e 319e s 			ADD	HL,HL		;SHIFT H-L
319f 319f d 29
319f 319f u 01 01
319f 319f s 			ADD	HL,HL		;RIGHT IN ORDER
31a0 31a0 d 29
31a0 31a0 u 01 01
31a0 31a0 s 			ADD	HL,HL		;TO MAKE ROOM FOR
31a1 31a1 d 29
31a1 31a1 u 01 01
31a1 31a1 s 			ADD	HL,HL		;THE NEW DIGIT
31a2 31a2 d d630
31a2 31a2 u 02 01
31a2 31a2 s 			SUB	'0'		;REDUCE TO BINARY
31a4 31a4 d fe0a
31a4 31a4 u 02 01
31a4 31a4 s 			CP	10		;TEST FOR FURTHER REDUCTION NEEDED
31a6 31a6 d daab31
31a6 31a6 u 03 01
31a6 31a6 s 			JP C,	HISG		;IF NOT, PROCESS
31a9 31a9 d d607
31a9 31a9 u 02 01
31a9 31a9 s 			SUB	7		;CONVERT LETTER TO BINARY
31ab 31ab d b5
31ab 31ab u 01 01
31ab 31ab s 		HISG	OR	L		;ADD IN BOTTOM DIGIT OF RESULT
31ac 31ac d 6f
31ac 31ac u 01 01
31ac 31ac s 			LD	L,A		;REPLACE IN RESULT
31ad 31ad d c39631
31ad 31ad u 03 01
31ad 31ad s 			JP	GETHX		;GET NEXT DIGIT
31b0 31b0 d d1
31b0 31b0 u 01 01
31b0 31b0 s 		HGON	POP	DE		;GET POSITION IN SOURCE BACK
31b1 31b1 d 78
31b1 31b1 u 01 01
31b1 31b1 s 			LD	A,B		;GET FLAG
31b2 31b2 d a7
31b2 31b2 u 01 01
31b2 31b2 s 			AND	A		;TEST FOR DIGIT'S PROCESSED
31b3 31b3 d c2cd31
31b3 31b3 u 03 01
31b3 31b3 s 			JP NZ,	OLOOK		;NO PROBLEM
31b6 31b6 d c37c2a
31b6 31b6 u 03 01
31b6 31b6 s 			JP	SYNT		;'#' WITH NO DIGITS... ERROR
31b9 31b9 s 		; A ')' HAS BEEN DETECTED
31b9 31b9 d cd3e31
31b9 31b9 u 03 01
31b9 31b9 s 		BRKTS	CALL	DOEXP		;RECURSE ON OURSELVES
31bc 31bc d c3cc31
31bc 31bc u 03 01
31bc 31bc s 			JP	DCLB		;CONTINUE WITH VALUE
31bf 31bf s 		; LOOK UP AN ARRAY VALUE
31bf 31bf d f1
31bf 31bf u 01 01
31bf 31bf s 		ARYL	POP	AF
31c0 31c0 d f5
31c0 31c0 u 01 01
31c0 31c0 s 			PUSH	AF
31c1 31c1 d fe3d
31c1 31c1 u 02 01
31c1 31c1 s 			CP	'='		;TEST FOR ASSIGNMENT
31c3 31c3 d c4892f
31c3 31c3 u 03 01
31c3 31c3 s 			CALL NZ, ALOOK		;IF NOT, GET VALUE
31c6 31c6 d c3cc31
31c6 31c6 u 03 01
31c6 31c6 s 			JP	DCLB		;CONTINUE WITH VALUE
31c9 31c9 s 		; GET VARIABLE CONTENTS
31c9 31c9 d cdf82f
31c9 31c9 u 03 01
31c9 31c9 s 		LOOKU	CALL	LOOK		;LOOK UP VALUE OF VARIABLE
31cc 31cc d 1b
31cc 31cc u 01 01
31cc 31cc s 		DCLB	DEC	DE		;BACK UP IN SOURCE
31cd 31cd d f1
31cd 31cd u 01 01
31cd 31cd s 		OLOOK	POP	AF
31ce 31ce d c1
31ce 31ce u 01 01
31ce 31ce s 			POP	BC		;GET OLD VALUE BACK
31cf 31cf s 		; 16 BIT ADDITION
31cf 31cf d fe2b
31cf 31cf u 02 01
31cf 31cf s 			CP	'+'		;TEST FOR ADDITION
31d1 31d1 d cae031
31d1 31d1 u 03 01
31d1 31d1 s 			JP Z,	ADD		;IF SO, PERFORM ADD
31d4 31d4 s 		; SIXTEEN BIT SUBTRACTION
31d4 31d4 d fe2d
31d4 31d4 u 02 01
31d4 31d4 s 			CP	'-'		;TEST FOR SUBTRACTION
31d6 31d6 d c2e431
31d6 31d6 u 03 01
31d6 31d6 s 			JP NZ,	MULT		;NO, TRY MULTIPLICATION
31d9 31d9 d 78
31d9 31d9 u 01 01
31d9 31d9 s 			LD	A,B		;GET B
31da 31da d 2f
31da 31da u 01 01
31da 31da s 			CPL			;COMPLEMENT
31db 31db d 47
31db 31db u 01 01
31db 31db s 			LD	B,A		;RESAVE
31dc 31dc d 79
31dc 31dc u 01 01
31dc 31dc s 			LD	A,C		;GET C
31dd 31dd d 2f
31dd 31dd u 01 01
31dd 31dd s 			CPL			;COMPLEMENT
31de 31de d 4f
31de 31de u 01 01
31de 31de s 			LD	C,A		;RESAVE
31df 31df d 03
31df 31df u 01 01
31df 31df s 			INC	BC		;ADD 1 GIVING TWO'S COMPLEMENT
31e0 31e0 d 09
31e0 31e0 u 01 01
31e0 31e0 s 		ADD	ADD	HL,BC		;ADD TO NEW VALUE
31e1 31e1 d c34333
31e1 31e1 u 03 01
31e1 31e1 s 			JP	EGO		;CONTINUE
31e4 31e4 s 		; 16 BIT MULTIPLICATION
31e4 31e4 d fe2a
31e4 31e4 u 02 01
31e4 31e4 s 		MULT	CP	'*'		;TEST FOR MULTIPLY
31e6 31e6 d c21332
31e6 31e6 u 03 01
31e6 31e6 s 			JP NZ,	DIV		;NO, TRY DIVIDE
31e9 31e9 d 78
31e9 31e9 u 01 01
31e9 31e9 s 			LD	A,B		;TEST OLD VALUE FOR ZERO
31ea 31ea d b1
31ea 31ea u 01 01
31ea 31ea s 			OR	C		;AS IT IS A
31eb 31eb d ca4033
31eb 31eb u 03 01
31eb 31eb s 			JP Z,	EGZ		;SPECIAL CASE
31ee 31ee d cdf431
31ee 31ee u 03 01
31ee 31ee s 			CALL	DMULT		;PERFORM THE MULTIPLY
31f1 31f1 d c34333
31f1 31f1 u 03 01
31f1 31f1 s 			JP	EGO		;AND CONTINUE
31f4 31f4 s 		; MULTIPLY SUBROUTINE (ALSO USED BY RANDOM NUMBER GENERATOR)
31f4 31f4 d d5
31f4 31f4 u 01 01
31f4 31f4 s 		DMULT	PUSH	DE		;SAVE POSITION IN SOURCE
31f5 31f5 d 110000
31f5 31f5 u 03 01
31f5 31f5 s 			LD	DE,0		;START OUT WITH A ZERO
31f8 31f8 d a7
31f8 31f8 u 01 01
31f8 31f8 s 		MUL1	AND	A		;INSURE CARRY CLEAR
31f9 31f9 d 78
31f9 31f9 u 01 01
31f9 31f9 s 			LD	A,B		;GET B
31fa 31fa d 1f
31fa 31fa u 01 01
31fa 31fa s 			RRA			;ROTATE
31fb 31fb d 47
31fb 31fb u 01 01
31fb 31fb s 			LD	B,A		;RESAVE
31fc 31fc d 79
31fc 31fc u 01 01
31fc 31fc s 			LD	A,C		;GET C
31fd 31fd d 1f
31fd 31fd u 01 01
31fd 31fd s 			RRA			;ROTATE WITH CARRY
31fe 31fe d 4f
31fe 31fe u 01 01
31fe 31fe s 			LD	C,A		;REPLACE
31ff 31ff d f5
31ff 31ff u 01 01
31ff 31ff s 			PUSH	AF
3200 3200 d b0
3200 3200 u 01 01
3200 3200 s 			OR	B		;TEST FOR B-C = ZER0
3201 3201 d ca0f32
3201 3201 u 03 01
3201 3201 s 			JP Z,	MEXIT		;IF SO, WE ARE DONE
3204 3204 d f1
3204 3204 u 01 01
3204 3204 s 			POP	AF
3205 3205 d d20b32
3205 3205 u 03 01
3205 3205 s 			JP NC,	NOMAD		;NO ONE BIT, DON'T ADD
3208 3208 d eb
3208 3208 u 01 01
3208 3208 s 			EX	DE, HL	
3209 3209 d 19
3209 3209 u 01 01
3209 3209 s 			ADD	HL,DE		;ADD TO D-E
320a 320a d eb
320a 320a u 01 01
320a 320a s 			EX	DE, HL	
320b 320b d 29
320b 320b u 01 01
320b 320b s 		NOMAD	ADD	HL,HL		;SHIFT H-L RIGHT BY ONE BIT
320c 320c d c3f831
320c 320c u 03 01
320c 320c s 			JP	MUL1		;KEEP GOING
320f 320f d 19
320f 320f u 01 01
320f 320f s 		MEXIT	ADD	HL,DE		;ADD RESULT
3210 3210 d f1
3210 3210 u 01 01
3210 3210 s 			POP	AF
3211 3211 d d1
3211 3211 u 01 01
3211 3211 s 			POP	DE		;RESTORE SOURCE POSITION
3212 3212 d c9
3212 3212 u 01 01
3212 3212 s 			RET
3213 3213 s 		; 16 BIT DIVISION
3213 3213 d fe25
3213 3213 u 02 01
3213 3213 s 		DIV	CP	'%'		;TEST FOR DIVIDE
3215 3215 d c26b32
3215 3215 u 03 01
3215 3215 s 			JP NZ,	FLOR		;NO, TRY FLOR
3218 3218 d 78
3218 3218 u 01 01
3218 3218 s 			LD	A,B		;TEST FOR AN OLD
3219 3219 d b1
3219 3219 u 01 01
3219 3219 s 			OR	C		;VALUE OF ZERO,
321a 321a d ca5f32
321a 321a u 03 01
321a 321a s 			JP Z,	DIVZE		;BECAUSE THAT IS  A BAD THING
321d 321d d d5
321d 321d u 01 01
321d 321d s 			PUSH	DE		;SAVE SOURCE POSITION
321e 321e d cd2932
321e 321e u 03 01
321e 321e s 			CALL	DODIV		;PERFORM DIVIDE OPERATION
3221 3221 d 222282
3221 3221 u 03 01
3221 3221 s 			LD	(VARS+34), HL	;SET 'R' REMAINDER VARIABLE
3224 3224 d eb
3224 3224 u 01 01
3224 3224 s 			EX	DE, HL	
3225 3225 d d1
3225 3225 u 01 01
3225 3225 s 			POP	DE		;RESTORE SOURCE POSITION
3226 3226 d c34333
3226 3226 u 03 01
3226 3226 s 			JP	EGO		;AND CARRY ON
3229 3229 s 		;
3229 3229 s 		; PERFORMS 16 BIT(HL) BY 16 BIT(BC) DIVIDE, RESULT IN DE, REM IN HL
3229 3229 s 		;
3229 3229 d 78
3229 3229 u 01 01
3229 3229 s 		DODIV	LD	A,B		;GET CONTENTS OV B
322a 322a d 2f
322a 322a u 01 01
322a 322a s 			CPL			;INVERT
322b 322b d 47
322b 322b u 01 01
322b 322b s 			LD	B,A		;REPLECE
322c 322c d 79
322c 322c u 01 01
322c 322c s 			LD	A,C		;GET CONTENTS IN C
322d 322d d 2f
322d 322d u 01 01
322d 322d s 			CPL			;INVERT
322e 322e d 4f
322e 322e u 01 01
322e 322e s 			LD	C,A		;REPLACE
322f 322f d 03
322f 322f u 01 01
322f 322f s 			INC	BC		;COMPLETE TWO COMPLEMENT OPERATION
3230 3230 d eb
3230 3230 u 01 01
3230 3230 s 			EX	DE, HL	
3231 3231 d 210000
3231 3231 u 03 01
3231 3231 s 			LD	HL,0		;ZERO HIGHER HALF
3234 3234 d cd3732
3234 3234 u 03 01
3234 3234 s 			CALL	DIVBYT		;PERFORM FIRST HALF
3237 3237 d 7a
3237 3237 u 01 01
3237 3237 s 		DIVBYT	LD	A,D		;GET UPPER HALF
3238 3238 d 53
3238 3238 u 01 01
3238 3238 s 			LD	D,E		;SAVE LOWER HALF
3239 3239 d 1e08
3239 3239 u 02 01
3239 3239 s 			LD	E,8		;GET LOOP COUNT
323b 323b d 29
323b 323b u 01 01
323b 323b s 		DIVTOP	ADD	HL,HL		;SHIFT LEFT
323c 323c d da5332
323c 323c u 03 01
323c 323c s 			JP C,	OVER1		;OVERFLOWED
323f 323f d 87
323f 323f u 01 01
323f 323f s 			ADD	A,A		;SHIFT  RESULT
3240 3240 d d24432
3240 3240 u 03 01
3240 3240 s 			JP NC,	SUBB		;IF NO CARRY, DON'T INC
3243 3243 d 23
3243 3243 u 01 01
3243 3243 s 			INC	HL		;ADVANCE UPPER VALUE
3244 3244 d e5
3244 3244 u 01 01
3244 3244 s 		SUBB	PUSH	HL		;SAVE VALUE
3245 3245 d 09
3245 3245 u 01 01
3245 3245 s 			ADD	HL,BC		;SUBTRACT LOWER HALF OF FRACTION
3246 3246 d da4d32
3246 3246 u 03 01
3246 3246 s 			JP C,	OKKK		;IF WRAP PAST ZERO
3249 3249 d e1
3249 3249 u 01 01
3249 3249 s 			POP	HL		;RESTORE VALUE
324a 324a d c35932
324a 324a u 03 01
324a 324a s 			JP	NXLP		;FINISH LOOP
324d 324d d 33
324d 324d u 01 01
324d 324d s 		OKKK	INC	SP		;FIX UP
324e 324e d 33
324e 324e u 01 01
324e 324e s 			INC	SP		;STACK
324f 324f d 3c
324f 324f u 01 01
324f 324f s 			INC	A		;ADVANCE RESULT
3250 3250 d c35932
3250 3250 u 03 01
3250 3250 s 			JP	NXLP		;FINISH LOOP
3253 3253 d 8f
3253 3253 u 01 01
3253 3253 s 		OVER1	ADC	A,A		;SHIFT RESULT, +1 FOR CARRY
3254 3254 d d25832
3254 3254 u 03 01
3254 3254 s 			JP NC,	OVRSUB		;IF NO WRAP
3257 3257 d 23
3257 3257 u 01 01
3257 3257 s 			INC	HL		;INC. VALUE
3258 3258 d 09
3258 3258 u 01 01
3258 3258 s 		OVRSUB	ADD	HL,BC		;SUBTRACT LOWER
3259 3259 d 1d
3259 3259 u 01 01
3259 3259 s 		NXLP	DEC	E		;REDUCE LOOP COUNTER
325a 325a d c23b32
325a 325a u 03 01
325a 325a s 			JP NZ,	DIVTOP		;LOOP IF NOT FINISHED
325d 325d d 5f
325d 325d u 01 01
325d 325d s 			LD	E,A		;LOWER BYTE OF RESULT
325e 325e d c9
325e 325e u 01 01
325e 325e s 			RET
325f 325f s 		;
325f 325f s 		; HE SHOULD KNOW THAT HE CAN'T DIVIDE BY ZERO, BUT JUST IN CASE...
325f 325f s 		; WE WILL TELL HIM ANYWAY
325f 325f s 		;
325f 325f d 219f35
325f 325f u 03 01
325f 325f s 		DIVZE	LD	HL,DER		;ADDRESS OF 'DIVIDE BYE ZERO MESSAGE'
3262 3262 d c3802a
3262 3262 u 03 01
3262 3262 s 			JP	ERR		;HANDLE LIKE ANY OTHER ERROR
3265 3265 s 		; COMPARES H-L TO B-C, Z=1 IF HL=BC, C=1 IF HL<BC
3265 3265 d 7c
3265 3265 u 01 01
3265 3265 s 		COMP	LD	A,H		;GET HIGH BYTE OF HL
3266 3266 d b8
3266 3266 u 01 01
3266 3266 s 			CP	B		;COMPARE WITH HIGH BYTE OF BC
3267 3267 d c0
3267 3267 u 01 01
3267 3267 s 			RET NZ			;IF NOT SAME, LOWER BYTE CAN BE IGNORED
3268 3268 d 7d
3268 3268 u 01 01
3268 3268 s 			LD	A,L		;GET LOW BYTE OF HL
3269 3269 d b9
3269 3269 u 01 01
3269 3269 s 			CP	C		;COMPARE WITH LOW BYTE OF BC
326a 326a d c9
326a 326a u 01 01
326a 326a s 			RET
326b 326b s 		; FLOOR, RETURNS THE LESSER OF THE TWO NUMBERS
326b 326b d fe5c
326b 326b u 02 01
326b 326b s 		FLOR:	CP	'\'		;IS IT FLOOR?
326d 326d d c27b32
326d 326d u 03 01
326d 326d s 			JP NZ,	CEIL		;NO, TRY CEILING
3270 3270 d cd6532
3270 3270 u 03 01
3270 3270 s 			CALL	COMP		;COMPARE NEW TO OLD
3273 3273 d da4333
3273 3273 u 03 01
3273 3273 s 			JP C,	EGO		;IF LESS, WE ARE OK (RESULT IS ALREADY IN HL)
3276 3276 d 60
3276 3276 u 01 01
3276 3276 s 		SWAP	LD	H,B		;MAKE OLD NUMBER..
3277 3277 d 69
3277 3277 u 01 01
3277 3277 s 			LD	L,C		;INTO THE NEW NUMBER..
3278 3278 d c34333
3278 3278 u 03 01
3278 3278 s 			JP	EGO		;CONTINUE
327b 327b s 		; CEILING, RETURNS THE GREATER OF THE TWO NUMBERS
327b 327b d fe2f
327b 327b u 02 01
327b 327b s 		CEIL	CP	'/'		;IS IT CEILING?
327d 327d d c28932
327d 327d u 03 01
327d 327d s 			JP NZ,	LAND		;NO, TRY LOGICAL AND
3280 3280 d cd6532
3280 3280 u 03 01
3280 3280 s 			CALL	COMP		;COMPARE NEW AND OLD
3283 3283 d d24333
3283 3283 u 03 01
3283 3283 s 			JP NC,	EGO		;IF GREATER, WE ARE OK (RESULT ALREADY IN HL)
3286 3286 d c37632
3286 3286 u 03 01
3286 3286 s 			JP	SWAP		;MAKE OLD NEW AND CONTINUE
3289 3289 s 		; LOGICAL AND
3289 3289 d fe26
3289 3289 u 02 01
3289 3289 s 		LAND	CP	'&'		;IF IT LOGICAL AND ?
328b 328b d c29632
328b 328b u 03 01
328b 328b s 			JP NZ,	LOR		;NO, TRY LOGICAL OR
328e 328e d 78
328e 328e u 01 01
328e 328e s 			LD	A,B		;GET HIGH BYTE OF OLD
328f 328f d a4
328f 328f u 01 01
328f 328f s 			AND	H		;AND WITH HIGH BYTE OF NEW
3290 3290 d 67
3290 3290 u 01 01
3290 3290 s 			LD	H,A		;AND REPLACE HIGH BYTE OF NEW
3291 3291 d 7d
3291 3291 u 01 01
3291 3291 s 			LD	A,L		;GET LOW BYTE OF OLD
3292 3292 d a1
3292 3292 u 01 01
3292 3292 s 			AND	C		;AND WITH LOW BYTE OF NEW
3293 3293 d c3a032
3293 3293 u 03 01
3293 3293 s 			JP	CPYL		;CONTINUE
3296 3296 s 		; LOGICAL OR
3296 3296 d fe7c
3296 3296 u 02 01
3296 3296 s 		LOR	CP	'|'		;TEST FOR LOGICAL OR
3298 3298 d c2a432
3298 3298 u 03 01
3298 3298 s 			JP NZ,	GRTR		;NO, TRY GREATER THAN
329b 329b d 7c
329b 329b u 01 01
329b 329b s 			LD	A,H		;GET HIGH BYTE OF NEW
329c 329c d b0
329c 329c u 01 01
329c 329c s 			OR	B		;OR WITH HIGH BYTE OF OLD
329d 329d d 67
329d 329d u 01 01
329d 329d s 			LD	H,A		;AND REPLACE HIGH BYTE OF NEW
329e 329e d 7d
329e 329e u 01 01
329e 329e s 			LD	A,L		;GET LOW BYTE OF NEW
329f 329f d b1
329f 329f u 01 01
329f 329f s 			OR	C		;OR WITH LOW BYTE OF OLD
32a0 32a0 d 6f
32a0 32a0 u 01 01
32a0 32a0 s 		CPYL	LD	L,A		;AND REPLACE LOW BYTE OF NEW
32a1 32a1 d c34333
32a1 32a1 u 03 01
32a1 32a1 s 			JP	EGO		;CONTINUE
32a4 32a4 s 		; GREATER THAN, RETURNS ONE OR ZERO
32a4 32a4 d fe3e
32a4 32a4 u 02 01
32a4 32a4 s 		GRTR	CP	'>'		;TEST FOR GREATER THAN
32a6 32a6 d c2b532
32a6 32a6 u 03 01
32a6 32a6 s 			JP NZ,	LETH		;IF NOT, TRY LESS THAN
32a9 32a9 d cd6532
32a9 32a9 u 03 01
32a9 32a9 s 			CALL	COMP		;COMPARE OLD AND NEW
32ac 32ac d ca4033
32ac 32ac u 03 01
32ac 32ac s 			JP Z,	EGZ		;FALSE IF EQUAL
32af 32af d da4033
32af 32af u 03 01
32af 32af s 			JP C,	EGZ		;FALSE IF LESS THAN
32b2 32b2 d c33a33
32b2 32b2 u 03 01
32b2 32b2 s 			JP	EG1		;TRUE IF NOT LESS OR EQUAL
32b5 32b5 s 		; LESS THAN, RETURNS ONE OR ZERO
32b5 32b5 d fe3c
32b5 32b5 u 02 01
32b5 32b5 s 		LETH	CP	'<'		;IS IT LESS THAN?
32b7 32b7 d c2c332
32b7 32b7 u 03 01
32b7 32b7 s 			JP NZ,	ENOP		;NO, TRY NO-OP OPERATOR
32ba 32ba d cd6532
32ba 32ba u 03 01
32ba 32ba s 			CALL	COMP		;COMPARE OLD AND NEW
32bd 32bd d da3a33
32bd 32bd u 03 01
32bd 32bd s 			JP C,	EG1		;TRUE IF LESS
32c0 32c0 d c34033
32c0 32c0 u 03 01
32c0 32c0 s 			JP	EGZ		;FALSE IF NOT LESS
32c3 32c3 s 		; NO-OP OPERATOR, RETURNS NEW VALUE ONLY
32c3 32c3 d fe3b
32c3 32c3 u 02 01
32c3 32c3 s 		ENOP	CP	';'		;IS IT NO-OP?
32c5 32c5 d ca4333
32c5 32c5 u 03 01
32c5 32c5 s 			JP Z,	EGO		;IF SO, DON'T DO ANYTHING
32c8 32c8 s 		; ASSIGNMENT, SET A VARIABLE'S VALUE
32c8 32c8 d fe3d
32c8 32c8 u 02 01
32c8 32c8 s 		ASST	CP	'='		;TEST FOR ASSIGNMENT
32ca 32ca d c20533
32ca 32ca u 03 01
32ca 32ca s 			JP NZ,	EQUAL		;IF NOT, TRY EQUALITY
32cd 32cd d 323782
32cd 32cd u 03 01
32cd 32cd s 			LD	(EFLAG), A	;SET ASSIGNMENT FLAG
32d0 32d0 d 13
32d0 32d0 u 01 01
32d0 32d0 s 			INC	DE		;BACK UP TO VARIABLE NAME
32d1 32d1 d 1a
32d1 32d1 u 01 01
32d1 32d1 s 			LD	A, (DE)		;GET VARIABLE CHARACTER
32d2 32d2 d fe5d
32d2 32d2 u 02 01
32d2 32d2 s 			CP	']'		;TEST FOR ARRAY STORAGE
32d4 32d4 d caeb32
32d4 32d4 u 03 01
32d4 32d4 s 			JP Z,	ASTOR		;IF SO, STORE INTO ARRAY
32d7 32d7 d 60
32d7 32d7 u 01 01
32d7 32d7 s 			LD	H,B		;GET OLD VALUE
32d8 32d8 d 69
32d8 32d8 u 01 01
32d8 32d8 s 			LD	L,C		;INTO H-L (WHERE STORE WANTS THEM)
32d9 32d9 d fe3f
32d9 32d9 u 02 01
32d9 32d9 s 			CP	'?'		;TEST FOR SETTING RANDOM SEED
32db 32db d cae532
32db 32db u 03 01
32db 32db s 			JP Z,	SRSEED		;IF SO, SET THE SEED
32de 32de d cde72f
32de 32de u 03 01
32de 32de s 			CALL	STOR		;STORE VALUE INTO VARIABLE
32e1 32e1 d 1b
32e1 32e1 u 01 01
32e1 32e1 s 		STRT	DEC	DE		;STEP BACK FROM VARIABLE
32e2 32e2 d c34333
32e2 32e2 u 03 01
32e2 32e2 s 			JP	EGO		;AND CONTINUE
32e5 32e5 s 		; SET THE RANDOM SEED
32e5 32e5 d 22fe81
32e5 32e5 u 03 01
32e5 32e5 s 		SRSEED	LD	(SEED), HL	;SO WE CAN STORE IN SEED
32e8 32e8 d c3e132
32e8 32e8 u 03 01
32e8 32e8 s 			JP	STRT		;AND CONTINUE
32eb 32eb s 		; SET THE VALUE OF AN ARRAY ELEMENT
32eb 32eb d e5
32eb 32eb u 01 01
32eb 32eb s 		ASTOR	PUSH	HL		;SAVE H-L
32ec 32ec d cd3e31
32ec 32ec u 03 01
32ec 32ec s 			CALL	DOEXP		;CALCULATE INDEX VALUE
32ef 32ef d 1b
32ef 32ef u 01 01
32ef 32ef s 			DEC	DE		;BACK UP PAST '['
32f0 32f0 d 1a
32f0 32f0 u 01 01
32f0 32f0 s 			LD	A, (DE)		;GET ARRAY NAME
32f1 32f1 d cd9e2f
32f1 32f1 u 03 01
32f1 32f1 s 			CALL	LOOKT		;LOOK UP IT'S ADDRESS IN THE TABLE
32f4 32f4 d 44
32f4 32f4 u 01 01
32f4 32f4 s 			LD	B,H		;GET ARRAY ADDRESS
32f5 32f5 d 4d
32f5 32f5 u 01 01
32f5 32f5 s 			LD	C,L		;INTO B-C
32f6 32f6 d e1
32f6 32f6 u 01 01
32f6 32f6 s 			POP	HL		;RERSTORE H-L
32f7 32f7 d 1a
32f7 32f7 u 01 01
32f7 32f7 s 			LD	A, (DE)		;GET ARRAY NAME BACK
32f8 32f8 d fe40
32f8 32f8 u 02 01
32f8 32f8 s 			CP	'@'		;TEST FOR 'MAGIC', MEMORY REFERENCE
32fa 32fa d ca0033
32fa 32fa u 03 01
32fa 32fa s 			JP Z,	STMEM		;IF SO, SET MEMORY LOCATION
32fd 32fd d 7c
32fd 32fd u 01 01
32fd 32fd s 			LD	A,H		;GET HIGH BYTE OF VALUE
32fe 32fe d 02
32fe 32fe u 01 01
32fe 32fe s 			LD	(BC), A		;STASH IN ARRAY
32ff 32ff d 03
32ff 32ff u 01 01
32ff 32ff s 			INC	BC		;POINT TO NEXT
3300 3300 d 7d
3300 3300 u 01 01
3300 3300 s 		STMEM	LD	A,L		;GET LOW BYTE OF VALUE
3301 3301 d 02
3301 3301 u 01 01
3301 3301 s 			LD	(BC), A		;STASH IN ARRAY
3302 3302 d c3e132
3302 3302 u 03 01
3302 3302 s 			JP	STRT		;CONTINUE
3305 3305 s 		; TEST FOR EQUALITY.  ('==')
3305 3305 d d681
3305 3305 u 02 01
3305 3305 s 		EQUAL	SUB	0x81		;IS A '=='?
3307 3307 d c21333
3307 3307 u 03 01
3307 3307 s 			JP NZ,	GEQL		;IF NOT, TRY GREATER OR EQUAL
330a 330a d cd6532
330a 330a u 03 01
330a 330a s 			CALL	COMP		;COMPARE OLD AND NEW
330d 330d d ca3a33
330d 330d u 03 01
330d 330d s 			JP Z,	EG1		;TRUE IF EQUAL
3310 3310 d c34033
3310 3310 u 03 01
3310 3310 s 			JP	EGZ		;FALSE IF NOT EQUAL
3313 3313 s 		; GREATER OR EQUAL.  ('>=')
3313 3313 d 3d
3313 3313 u 01 01
3313 3313 s 		GEQL	DEC	A		;TEST FOR '>='?
3314 3314 d c22033
3314 3314 u 03 01
3314 3314 s 			JP NZ,	LEQL		;NO, TRY LESS OR EQUAL
3317 3317 d cd6532
3317 3317 u 03 01
3317 3317 s 			CALL	COMP		;COMPARE OLD AND NEW
331a 331a d da4033
331a 331a u 03 01
331a 331a s 			JP C,	EGZ		;FALSE IF LESS THAN
331d 331d d c33a33
331d 331d u 03 01
331d 331d s 			JP	EG1		;TRUE IF GREATER OR EQUAL
3320 3320 s 		; LESS OR EQUAL.  ('<=')
3320 3320 d 3d
3320 3320 u 01 01
3320 3320 s 		LEQL	DEC	A		;TEST FOR '<='?
3321 3321 d c23033
3321 3321 u 03 01
3321 3321 s 			JP NZ,	NEQL		;IF NOT, TRY NOT EQUAL
3324 3324 d cd6532
3324 3324 u 03 01
3324 3324 s 			CALL	COMP		;COMPARE OLD AND NEW
3327 3327 d ca3a33
3327 3327 u 03 01
3327 3327 s 			JP Z,	EG1		;TRUE IF SAME
332a 332a d da3a33
332a 332a u 03 01
332a 332a s 			JP C,	EG1		;TRUE IF LESS THAN
332d 332d d c34033
332d 332d u 03 01
332d 332d s 			JP	EGZ		;FALSE OTHERWISE
3330 3330 s 		; TEST FOR NOT EQUAL.  ('-=')
3330 3330 d 3d
3330 3330 u 01 01
3330 3330 s 		NEQL	DEC	A		;IS IT '-='?
3331 3331 d c27c2a
3331 3331 u 03 01
3331 3331 s 			JP NZ,	SYNT		;BEATS ME WHAT IT IS!
3334 3334 d cd6532
3334 3334 u 03 01
3334 3334 s 			CALL	COMP		;COMPARE OLD AND NEW
3337 3337 d ca4033
3337 3337 u 03 01
3337 3337 s 			JP Z,	EGZ		;IF SAME, FALSE
333a 333a s 		; RETURN RESULT OF ONE
333a 333a d 210100
333a 333a u 03 01
333a 333a s 		EG1	LD	HL,1		;SET RESULT TO ONE
333d 333d d c34333
333d 333d u 03 01
333d 333d s 			JP	EGO		;PASS ON RESULT
3340 3340 s 		; RETURN RESULT OF ZERO
3340 3340 d 210000
3340 3340 u 03 01
3340 3340 s 		EGZ	LD	HL,0		;SET RESULT TO ZERO
3343 3343 s 		; END OF OPERATION, GET NEXT OPERATOR
3343 3343 d cda033
3343 3343 u 03 01
3343 3343 s 		EGO	CALL	FE		;GET NEXT CHARACTER
3346 3346 d c8
3346 3346 u 01 01
3346 3346 s 			RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT
3347 3347 d fe28
3347 3347 u 02 01
3347 3347 s 			CP	'('		;ARE WE RETURNING FROM A NEST?
3349 3349 s 			;RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT	
3349 3349 d 2028
3349 3349 u 02 01
3349 3349 s 			JR  NZ,	EGOP1
334b 334b s 						;CHECK FOR FUNCTION				
334b 334b d 3a3682
334b 334b u 03 01
334b 334b s 			LD	A, (PP)		;GET ADDRESS OF BEGINNING OF LINE
334e 334e d 1b
334e 334e u 01 01
334e 334e s 			DEC	DE
334f 334f d bb
334f 334f u 01 01
334f 334f s 			CP	E		;ARE WE THERE??
3350 3350 d 281b
3350 3350 u 02 01
3350 3350 s 			JR  Z,	EGOF1
3352 3352 d 1b
3352 3352 u 01 01
3352 3352 s 			DEC	DE
3353 3353 d bb
3353 3353 u 01 01
3353 3353 s 			CP	E		;ARE WE THERE??
3354 3354 d 2816
3354 3354 u 02 01
3354 3354 s 			JR  Z,	EGOF2
3356 3356 d 1a
3356 3356 u 01 01
3356 3356 s 			LD	A,(DE)
3357 3357 d fe49
3357 3357 u 02 01
3357 3357 s 			CP	'I'
3359 3359 d 2011
3359 3359 u 02 01
3359 3359 s 			JR NZ,	EGOF2
335b 335b d 13
335b 335b u 01 01
335b 335b s 			INC	DE
335c 335c d 1a
335c 335c u 01 01
335c 335c s 			LD	A,(DE)					
335d 335d d fe4e
335d 335d u 02 01
335d 335d s 			CP	'N'
335f 335f d 200c
335f 335f u 02 01
335f 335f s 			JR NZ,	EGOF1
3361 3361 s 			
3361 3361 d 1b
3361 3361 u 01 01
3361 3361 s 			DEC	DE
3362 3362 d c5
3362 3362 u 01 01
3362 3362 s 			PUSH	BC
3363 3363 d 4d
3363 3363 u 01 01
3363 3363 s 			LD	C,L
3364 3364 d ed78
3364 3364 u 02 01
3364 3364 s 			IN	A,(C)
3366 3366 d c1
3366 3366 u 01 01
3366 3366 s 			POP	BC
3367 3367 d 6f
3367 3367 u 01 01
3367 3367 s 			LD	L,A
3368 3368 d 2600
3368 3368 u 02 01
3368 3368 s 			LD	H,0
336a 336a s 			
336a 336a d 1802
336a 336a u 02 01
336a 336a s 			JR	EGOF0
336c 336c s 			
336c 336c d 13
336c 336c u 01 01
336c 336c s 		EGOF2	INC	DE
336d 336d d 13
336d 336d u 01 01
336d 336d s 		EGOF1	INC	DE
336e 336e d 3e28
336e 336e u 02 01
336e 336e s 		EGOF0	LD	A,'('
3370 3370 d fe28
3370 3370 u 02 01
3370 3370 s 			CP	'('
3372 3372 d c9
3372 3372 u 01 01
3372 3372 s 			RET			;IF SO, BACK UP ONE LEVEL
3373 3373 s 			
3373 3373 d fe5b
3373 3373 u 02 01
3373 3373 s 		EGOP1	CP	'['		;FINISHED AN ARRAY INDEX EVALUATION?
3375 3375 d c8
3375 3375 u 01 01
3375 3375 s 			RET Z			;RETURN TO MAIN EXPRESSION
3376 3376 d fe3d
3376 3376 u 02 01
3376 3376 s 			CP	'='		;IF IT A MULTI-CHARACTER OPERATOR
3378 3378 d c24f31
3378 3378 u 03 01
3378 3378 s 			JP NZ,	EGO1		;IF NOT, DON'T PRE-EVALUATE
337b 337b d 1b
337b 337b u 01 01
337b 337b s 			DEC	DE		;BACK UP TO PRECEDING CHARACTER
337c 337c d 1a
337c 337c u 01 01
337c 337c s 			LD	A, (DE)		;GET PRECEDING CHARACTER
337d 337d d fe3d
337d 337d u 02 01
337d 337d s 			CP	'='		;IS IT '=='?
337f 337f d 0681
337f 337f u 02 01
337f 337f s 			LD	B,0x81		;SET UNIQUE CODE
3381 3381 d ca9c33
3381 3381 u 03 01
3381 3381 s 			JP Z,	EGO2		;IF '==' THEN WE HAVE IT
3384 3384 d 03
3384 3384 u 01 01
3384 3384 s 			INC	BC		;NEXT UNIQUE CODE
3385 3385 d fe3e
3385 3385 u 02 01
3385 3385 s 			CP	'>'		;IS IT '>='?
3387 3387 d ca9c33
3387 3387 u 03 01
3387 3387 s 			JP Z,	EGO2		;IF SO, WE HAVE IT
338a 338a d 03
338a 338a u 01 01
338a 338a s 			INC	BC		;NEXT UNIQUE CODE
338b 338b d fe3c
338b 338b u 02 01
338b 338b s 			CP	'<'		;IS IT '<='?
338d 338d d ca9c33
338d 338d u 03 01
338d 338d s 			JP Z,	EGO2		;IF SO, WE HAVE IT
3390 3390 d 03
3390 3390 u 01 01
3390 3390 s 			INC	BC		;NEXT UNIQUE CODE
3391 3391 d fe2d
3391 3391 u 02 01
3391 3391 s 			CP	'-'		;IS IT '-='?
3393 3393 d ca9c33
3393 3393 u 03 01
3393 3393 s 			JP Z,	EGO2		;IF SO, WE HAVE IT
3396 3396 d 13
3396 3396 u 01 01
3396 3396 s 			INC	DE		;WASN'T A TWO CHARACTER OPERATOR. BACK UP
3397 3397 d 3e3d
3397 3397 u 02 01
3397 3397 s 			LD	A,'='		;MUST HAVE BEEN A SIMPLE '='
3399 3399 d c34f31
3399 3399 u 03 01
3399 3399 s 			JP	EGO1		;CONTINUE EVALUATING EXPRESSION
339c 339c d 78
339c 339c u 01 01
339c 339c s 		EGO2	LD	A,B		;SET OPERATOR TO OUR UNIQUE CODE
339d 339d d c34f31
339d 339d u 03 01
339d 339d s 			JP	EGO1		;AND CONTINUE EVALUATING EXPRESSION
33a0 33a0 s 		; FINDS NEXT CHARACTER IN EXPRESSION, SETS Z FLAG IF WE PASS THE BEGINNING
33a0 33a0 d 3a3682
33a0 33a0 u 03 01
33a0 33a0 s 		FE	LD	A, (PP)		;GET ADDRESS OF BEGINNING OF LINE
33a3 33a3 d bb
33a3 33a3 u 01 01
33a3 33a3 s 			CP	E		;ARE WE THERE??
33a4 33a4 d c8
33a4 33a4 u 01 01
33a4 33a4 s 			RET Z			;IF SO, WE ARE FINISHED
33a5 33a5 d 1a
33a5 33a5 u 01 01
33a5 33a5 s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
33a6 33a6 d fe20
33a6 33a6 u 02 01
33a6 33a6 s 			CP	' '		;IS A (USELESS) BLANK?
33a8 33a8 d c0
33a8 33a8 u 01 01
33a8 33a8 s 			RET NZ			;IF NOT, WE ARE FINISHED
33a9 33a9 d 1b
33a9 33a9 u 01 01
33a9 33a9 s 			DEC	DE		;BACK UP ANOTHER CHARACTER
33aa 33aa d c3a033
33aa 33aa u 03 01
33aa 33aa s 			JP	FE		;AND TRY AGAIN
33ad 33ad s 		; CALCULATE A PSEUDO-RANDOM VALUE
33ad 33ad d 2afe81
33ad 33ad u 03 01
33ad 33ad s 		RANDR	LD	HL, (SEED)	;GET RANDOM SEED
33b0 33b0 d 7c
33b0 33b0 u 01 01
33b0 33b0 s 			LD	A,H		;GET HIGH BYTE OF SEED
33b1 33b1 d e6f7
33b1 33b1 u 02 01
33b1 33b1 s 			AND	0xF7		;AND WITH HIGH MASK
33b3 33b3 d f5
33b3 33b3 u 01 01
33b3 33b3 s 			PUSH	AF
33b4 33b4 d 7d
33b4 33b4 u 01 01
33b4 33b4 s 			LD	A,L		;GET LOW BYTE OF SEED
33b5 33b5 d e642
33b5 33b5 u 02 01
33b5 33b5 s 			AND	0x42		;AND WITH LOW BYTE OF MASK
33b7 33b7 d f5
33b7 33b7 u 01 01
33b7 33b7 s 			PUSH	AF
33b8 33b8 d c1
33b8 33b8 u 01 01
33b8 33b8 s 			POP	BC		;GET FLAGS IN C
33b9 33b9 d 79
33b9 33b9 u 01 01
33b9 33b9 s 			LD	A,C		;COPY TO A
33ba 33ba d c1
33ba 33ba u 01 01
33ba 33ba s 			POP	BC		;GET FIRST SET OF FLAGS IN C
33bb 33bb d a9
33bb 33bb u 01 01
33bb 33bb s 			XOR	C		;COMPUTE PARITY FOR ENTIRE WORD
33bc 33bc d 0f
33bc 33bc u 01 01
33bc 33bc s 			RRCA			;MOVE COMPUTED
33bd 33bd d 0f
33bd 33bd u 01 01
33bd 33bd s 			RRCA			;PARITY INTO
33be 33be d 0f
33be 33be u 01 01
33be 33be s 			RRCA			;THE CARRY FLAG
33bf 33bf d 3f
33bf 33bf u 01 01
33bf 33bf s 			CCF			;COMP, SO SHIFT IN 1 IF EVEN
33c0 33c0 d 7d
33c0 33c0 u 01 01
33c0 33c0 s 			LD	A,L		;GET LOW BYTE OF SEED
33c1 33c1 d 17
33c1 33c1 u 01 01
33c1 33c1 s 			RLA			;SHIFT IN CARRY, OUT HIGH BIT
33c2 33c2 d 6f
33c2 33c2 u 01 01
33c2 33c2 s 			LD	L,A		;RESAVE
33c3 33c3 d 7c
33c3 33c3 u 01 01
33c3 33c3 s 			LD	A,H		;GET HIGH BYTE OF SEED
33c4 33c4 d 17
33c4 33c4 u 01 01
33c4 33c4 s 			RLA			;SHIFT IN CARRY (HIGH BIT OF OLD LOWER)
33c5 33c5 d 67
33c5 33c5 u 01 01
33c5 33c5 s 			LD	H,A		;RESAVE
33c6 33c6 d 22fe81
33c6 33c6 u 03 01
33c6 33c6 s 			LD	(SEED), HL	;RESULT IS NEW SEED
33c9 33c9 d c3cc31
33c9 33c9 u 03 01
33c9 33c9 s 			JP	DCLB		;KEEP GOING
33cc 33cc s 		;
33cc 33cc s 		; EVALUATES A CHARACTER EXPRESSION
33cc 33cc s 		;
33cc 33cc d cda334
33cc 33cc u 03 01
33cc 33cc s 		CEXP	CALL	CLBF		;CLEAR EXTRA BUFFER
33cf 33cf d 13
33cf 33cf u 01 01
33cf 33cf s 			INC	DE		;SKIP TO END OF EXPRESSION
33d0 33d0 d 3e2b
33d0 33d0 u 02 01
33d0 33d0 s 			LD	A,'+'		;TO BEGIN, CONCATINATE A NULL STRING
33d2 33d2 d f5
33d2 33d2 u 01 01
33d2 33d2 s 		CG1	PUSH	AF
33d3 33d3 d cdb034
33d3 33d3 u 03 01
33d3 33d3 s 			CALL	PUSHB		;COPY NEW BUFFER INTO OLD BUFFER
33d6 33d6 d cda334
33d6 33d6 u 03 01
33d6 33d6 s 			CALL	CLBF		;CLEAR THE NEW BUFFER
33d9 33d9 d 1b
33d9 33d9 u 01 01
33d9 33d9 s 			DEC	DE		;BACK UP IN SOURCE
33da 33da d cda033
33da 33da u 03 01
33da 33da s 			CALL	FE		;GET CHARACTER AND TEST FOR END
33dd 33dd d fe22
33dd 33dd u 02 01
33dd 33dd s 			CP	'"'		;TEST FOR QUOTE
33df 33df d caf733
33df 33df u 03 01
33df 33df s 			JP Z,	CQ		;IF SO, HANDLE QUOTED STRING
33e2 33e2 d fe24
33e2 33e2 u 02 01
33e2 33e2 s 			CP	'$'		;TEST FOR CHARACTER VARIABLE
33e4 33e4 d c27c2a
33e4 33e4 u 03 01
33e4 33e4 s 			JP NZ,	SYNT		;IF NOT, IT'S NOT ANYTHING I RECOGNISE
33e7 33e7 d 1b
33e7 33e7 u 01 01
33e7 33e7 s 		CV	DEC	DE		;BACK UP PAST DOLLAR SIGN
33e8 33e8 d 1a
33e8 33e8 u 01 01
33e8 33e8 s 			LD	A, (DE)		;GET VARIABLE NAME
33e9 33e9 d fe5d
33e9 33e9 u 02 01
33e9 33e9 s 			CP	']'		;TEST FOR INDEX INTO CHARACTER VARIABLE
33eb 33eb d cac334
33eb 33eb u 03 01
33eb 33eb s 			JP Z,	CINDX		;GET INDEX VALUE
33ee 33ee d cdb52f
33ee 33ee u 03 01
33ee 33ee s 			CALL	LTA		;GET ADDRESS OF VARIABLE
33f1 33f1 d d5
33f1 33f1 u 01 01
33f1 33f1 s 			PUSH	DE		;SAVE SOURCE POSITION
33f2 33f2 d eb
33f2 33f2 u 01 01
33f2 33f2 s 			EX	DE, HL	
33f3 33f3 d 1b
33f3 33f3 u 01 01
33f3 33f3 s 			DEC	DE		;BACK UP IN SOURCE
33f4 33f4 d c30434
33f4 33f4 u 03 01
33f4 33f4 s 			JP	Q0		;SAVE VARIABLE IN NEW BUFFER
33f7 33f7 s 		; BACKUP TO PRECEDING QUOTE
33f7 33f7 d 1b
33f7 33f7 u 01 01
33f7 33f7 s 		CQ	DEC	DE		;BACKUP IN SOURCE
33f8 33f8 d 1a
33f8 33f8 u 01 01
33f8 33f8 s 			LD	A, (DE)		;GET CHARACTER FROM SOURCE
33f9 33f9 d fe0d
33f9 33f9 u 02 01
33f9 33f9 s 			CP	CR		;TEST FOR END OF LINE
33fb 33fb d ca7c2a
33fb 33fb u 03 01
33fb 33fb s 			JP Z,	SYNT		;IF SO, THERE IS NO CLOSEING QUOTE
33fe 33fe d fe22
33fe 33fe u 02 01
33fe 33fe s 			CP	'"'		;TEST FOR CLOSEING QUOTE
3400 3400 d c2f733
3400 3400 u 03 01
3400 3400 s 			JP NZ,	CQ		;IF NO, KEEP LOOKING
3403 3403 d d5
3403 3403 u 01 01
3403 3403 s 			PUSH	DE		;SAVE ENDING POSITION
3404 3404 d 216480
3404 3404 u 03 01
3404 3404 s 		Q0	LD	HL,XBF		;GET ADDRESS OF NEW (EXTRA) BUFFER
3407 3407 d 13
3407 3407 u 01 01
3407 3407 s 		Q1	INC	DE		;ADVANCE TO SOURCE OR VARIABLE CHARACTER
3408 3408 d 1a
3408 3408 u 01 01
3408 3408 s 			LD	A, (DE)		;GET CHARACTER
3409 3409 d fe22
3409 3409 u 02 01
3409 3409 s 			CP	'"'		;TEST FOR CLOSEING QUOTE
340b 340b d ca1834
340b 340b u 03 01
340b 340b s 			JP Z,	Q2		;IF SO, STOP COPYING
340e 340e d feff
340e 340e u 02 01
340e 340e s 			CP	0xFF		;TEST FOR END OF VARIABLE
3410 3410 d ca1834
3410 3410 u 03 01
3410 3410 s 			JP Z,	Q2		;IF SO, STOP COPYING
3413 3413 d 77
3413 3413 u 01 01
3413 3413 s 			LD	(HL),A		;SAVE IN BUFFER
3414 3414 d 23
3414 3414 u 01 01
3414 3414 s 			INC	HL		;ADVANCE IN BUFFER
3415 3415 d c30734
3415 3415 u 03 01
3415 3415 s 			JP	Q1		;KEEP COPYING
3418 3418 d d1
3418 3418 u 01 01
3418 3418 s 		Q2	POP	DE		;GET POSITION BACK
3419 3419 d 1b
3419 3419 u 01 01
3419 3419 s 		Q3	DEC	DE		;BACK UP TO OPERATOR
341a 341a d f1
341a 341a u 01 01
341a 341a s 			POP	AF
341b 341b d fe2b
341b 341b u 02 01
341b 341b s 			CP	'+'		;TEST FOR CONCATIONATION
341d 341d d c23534
341d 341d u 03 01
341d 341d s 			JP NZ,	Q5		;NO, TRY ASSIGNMENT
3420 3420 s 		; CONCATONATION. XBF=XBF+TB
3420 3420 d 013280
3420 3420 u 03 01
3420 3420 s 		QPP	LD	BC,TB		;ADDRESS OF TEMPORARY BUFFER
3423 3423 d 0a
3423 3423 u 01 01
3423 3423 s 		Q4	LD	A, (BC)		;GET CHARACTER FROM BUFFER
3424 3424 d 77
3424 3424 u 01 01
3424 3424 s 			LD	(HL),A		;MOVE TO BUFFER
3425 3425 d 03
3425 3425 u 01 01
3425 3425 s 			INC	BC		;ADVANCE IN OLD
3426 3426 d 23
3426 3426 u 01 01
3426 3426 s 			INC	HL		;ADVANCE IN NEW
3427 3427 d 79
3427 3427 u 01 01
3427 3427 s 			LD	A,C		;GET ADDRESS IN OLD
3428 3428 d fe55
3428 3428 u 02 01
3428 3428 s 			CP	LOW (TB+35)		;TEST FOR OVER
342a 342a d da2334
342a 342a u 03 01
342a 342a s 			JP C,	Q4		;IF SO, STOP
342d 342d d 2a6480
342d 342d u 03 01
342d 342d s 			LD	HL, (XBF)	;GET CHARACTER FROM BUFFER
3430 3430 d 2600
3430 3430 u 02 01
3430 3430 s 			LD	H,0		;SET HIGH BYTE TO ZERO
3432 3432 d c37e34
3432 3432 u 03 01
3432 3432 s 			JP	Q9		;CONTINUE
3435 3435 s 		; ASSIGNMENT
3435 3435 d fe3d
3435 3435 u 02 01
3435 3435 s 		Q5	CP	'='		;TEST FOR ASSIGNMENT
3437 3437 d c24e34
3437 3437 u 03 01
3437 3437 s 			JP NZ,	Q6		;IF NOT, TRY EQUALITY
343a 343a d 13
343a 343a u 01 01
343a 343a s 			INC	DE		;SKIP TO VARIABLE NAME
343b 343b d 13
343b 343b u 01 01
343b 343b s 			INC	DE		;SKIP TO DOLLARSIGN
343c 343c d 1a
343c 343c u 01 01
343c 343c s 			LD	A, (DE)		;GET DOLLARSIGN
343d 343d d 1b
343d 343d u 01 01
343d 343d s 			DEC	DE		;BACK UP TO VARIABLE NAME
343e 343e d fe24
343e 343e u 02 01
343e 343e s 			CP	'$'		;TEST FOR DOLLAR SIGN
3440 3440 d c27c2a
3440 3440 u 03 01
3440 3440 s 			JP NZ,	SYNT		;IF NOT, THIS AIN'T NO CHARACTER VARIABLE
3443 3443 d 323782
3443 3443 u 03 01
3443 3443 s 			LD	(EFLAG), A	;SET ASSIGNMENT FLAG
3446 3446 d 1a
3446 3446 u 01 01
3446 3446 s 			LD	A, (DE)		;GET VARIABLE NAME
3447 3447 d 1b
3447 3447 u 01 01
3447 3447 s 			DEC	DE		;BACK UP BAST NAME
3448 3448 d cdb52f
3448 3448 u 03 01
3448 3448 s 			CALL	LTA		;GET IT'S ADDRESS
344b 344b d c32034
344b 344b u 03 01
344b 344b s 			JP	QPP		;COPY IT OVER
344e 344e s 		; TEST FOR EQUALITY
344e 344e d fe81
344e 344e u 02 01
344e 344e s 		Q6	CP	0x81		;TEST FOR '=='
3450 3450 d c27234
3450 3450 u 03 01
3450 3450 s 			JP NZ,	X0		;NO, TRY '=-'
3453 3453 d cd5934
3453 3453 u 03 01
3453 3453 s 			CALL	COMSTR		;COMPARE STRINGS
3456 3456 d c37e34
3456 3456 u 03 01
3456 3456 s 			JP	Q9		;CONTINUE
3459 3459 s 		; COMPARES STRINGS. SETS H-L TO 1 OR 0 IF EQUAL OR NOT EQUAL
3459 3459 d 013280
3459 3459 u 03 01
3459 3459 s 		COMSTR	LD	BC,TB		;GET ADDRESS OF OLD STRING
345c 345c d 216480
345c 345c u 03 01
345c 345c s 			LD	HL,XBF		;ADDRESS OF NEW STRING
345f 345f d 0a
345f 345f u 01 01
345f 345f s 		Q7	LD	A, (BC)		;GET CHARACTER FROM OLD
3460 3460 d be
3460 3460 u 01 01
3460 3460 s 			CP	(HL)		;TEST AGAINST NEW
3461 3461 d c26e34
3461 3461 u 03 01
3461 3461 s 			JP NZ,	Q8		;IF NOT, THEY ARE UNEQUAL
3464 3464 d 03
3464 3464 u 01 01
3464 3464 s 			INC	BC		;NEXT PLACE IN OLD
3465 3465 d 23
3465 3465 u 01 01
3465 3465 s 			INC	HL		;NEXT PLACE IN NEW
3466 3466 d 3c
3466 3466 u 01 01
3466 3466 s 			INC	A		;TEST FOR END OF STRING
3467 3467 d c25f34
3467 3467 u 03 01
3467 3467 s 			JP NZ,	Q7		;IF NOT, CONTINUE TESTING
346a 346a d 210100
346a 346a u 03 01
346a 346a s 			LD	HL,1		;INDICATE THEY ARE EQUAL
346d 346d d c9
346d 346d u 01 01
346d 346d s 			RET
346e 346e d 210000
346e 346e u 03 01
346e 346e s 		Q8	LD	HL,0		;INDICATE NOT EQUAL
3471 3471 d c9
3471 3471 u 01 01
3471 3471 s 			RET
3472 3472 s 		; NOT EQUAL .. '-='
3472 3472 d fe82
3472 3472 u 02 01
3472 3472 s 		X0	CP	0x82		;TEST FOR '-='
3474 3474 d c27c2a
3474 3474 u 03 01
3474 3474 s 			JP NZ,	SYNT		;BEATS ME, BUT IT ISN'T RIGHT
3477 3477 d cd5934
3477 3477 u 03 01
3477 3477 s 			CALL	COMSTR		;TEST STRINGS
347a 347a d 7d
347a 347a u 01 01
347a 347a s 			LD	A,L		;GET RESULT
347b 347b d ee01
347b 347b u 02 01
347b 347b s 			XOR	1		;AND COMPLEMENT IT
347d 347d d 6f
347d 347d u 01 01
347d 347d s 			LD	L,A		;REPLACE IN RESULT
347e 347e s 		; GET NEXT STRING
347e 347e d cda033
347e 347e u 03 01
347e 347e s 		Q9	CALL	FE		;GET NEXT CHARACTER
3481 3481 d 37
3481 3481 u 01 01
3481 3481 s 			SCF			;INDICATE CHARACTER EXPRESSION
3482 3482 d c8
3482 3482 u 01 01
3482 3482 s 			RET Z			;IF END OF LINE, QUIT
3483 3483 d fe28
3483 3483 u 02 01
3483 3483 s 			CP	'('		;TEST FOR END OF NUMERIC SUBSTRING
3485 3485 d c8
3485 3485 u 01 01
3485 3485 s 			RET Z			;QUIT, INDICATING NUMBERIC RESULT
3486 3486 d fe3d
3486 3486 u 02 01
3486 3486 s 			CP	'='		;TEST FOR EQUAL,ASSIGNMENT, OR NOT EQUALS
3488 3488 d c2d233
3488 3488 u 03 01
3488 3488 s 			JP NZ,	CG1		;NO, NO NEED TO TEST FURTHER
348b 348b d 1b
348b 348b u 01 01
348b 348b s 		QTST	DEC	DE		;BACK UP TO PREVIOUS CHARACTER
348c 348c d 1a
348c 348c u 01 01
348c 348c s 			LD	A, (DE)		;GET CHARACTER
348d 348d d 47
348d 348d u 01 01
348d 348d s 			LD	B,A		;SAVE FOR COMPARISON
348e 348e d fe3d
348e 348e u 02 01
348e 348e s 			CP	'='		;TEST FOR '=='
3490 3490 d 3e81
3490 3490 u 02 01
3490 3490 s 			LD	A,0x81		;INDICATE '=='
3492 3492 d cad233
3492 3492 u 03 01
3492 3492 s 			JP Z,	CG1		;CONTINUE
3495 3495 d 78
3495 3495 u 01 01
3495 3495 s 			LD	A,B		;GET CHARACTER BACK
3496 3496 d fe2d
3496 3496 u 02 01
3496 3496 s 			CP	'-'		;TEST FOR '-='
3498 3498 d 3e82
3498 3498 u 02 01
3498 3498 s 			LD	A,0x82		;INDICATE '-='
349a 349a d cad233
349a 349a u 03 01
349a 349a s 			JP Z,	CG1		;CONTINUE
349d 349d d 13
349d 349d u 01 01
349d 349d s 			INC	DE		;ADVANCE BACK TO PREVIOUS CHARACTER
349e 349e d 3e3d
349e 349e u 02 01
349e 349e s 			LD	A,'='		;INDICATE '='
34a0 34a0 d c3d233
34a0 34a0 u 03 01
34a0 34a0 s 			JP	CG1		;CONTINUE
34a3 34a3 s 		; CLEARS THE TEXT BUFFER
34a3 34a3 d 216480
34a3 34a3 u 03 01
34a3 34a3 s 		CLBF	LD	HL,XBF		;GET ADDRESS OF BUFFER
34a6 34a6 d 3e28
34a6 34a6 u 02 01
34a6 34a6 s 			LD	A,40		;CLEAR FOR LENGTH OF 40
34a8 34a8 d 36ff
34a8 34a8 u 02 01
34a8 34a8 s 		CL2	LD	(HL),0xFF	;CLEAR TO NULL CHARACTER
34aa 34aa d 23
34aa 34aa u 01 01
34aa 34aa s 			INC	HL		;NEXT POSITION IN BUFFER
34ab 34ab d 3d
34ab 34ab u 01 01
34ab 34ab s 			DEC	A		;REDUCE COUNT OF REMAINING
34ac 34ac d c2a834
34ac 34ac u 03 01
34ac 34ac s 			JP NZ,	CL2		;KEEP GOING TILL WE ARE FINISHED
34af 34af d c9
34af 34af u 01 01
34af 34af s 			RET
34b0 34b0 s 		; COPY'S NEW BUFFER INTO OLD BUFFER
34b0 34b0 d d5
34b0 34b0 u 01 01
34b0 34b0 s 		PUSHB	PUSH	DE		;SAVE POSITION IS SOURCE
34b1 34b1 d 116480
34b1 34b1 u 03 01
34b1 34b1 s 			LD	DE,XBF		;GET ADDRESS OF NEW BUFFER
34b4 34b4 d 213280
34b4 34b4 u 03 01
34b4 34b4 s 			LD	HL,TB		;GET ADDRESS OF OLD BUFFER
34b7 34b7 d 0628
34b7 34b7 u 02 01
34b7 34b7 s 			LD	B,40		;COPY 40 CHARACTERS
34b9 34b9 d 1a
34b9 34b9 u 01 01
34b9 34b9 s 		PU1	LD	A, (DE)		;GET CHARACTER FROM NEW
34ba 34ba d 77
34ba 34ba u 01 01
34ba 34ba s 			LD	(HL),A		;SAVE IN OLD
34bb 34bb d 23
34bb 34bb u 01 01
34bb 34bb s 			INC	HL		;NEXT POSITION IN OLD
34bc 34bc d 13
34bc 34bc u 01 01
34bc 34bc s 			INC	DE		;NEXT POSITION IN NEW
34bd 34bd d 0b
34bd 34bd u 01 01
34bd 34bd s 			DEC	BC		;REDUCE COUNT
34be 34be d c2b934
34be 34be u 03 01
34be 34be s 			JP NZ,	PU1		;KEEP GOING TILL 40 ARE MOVED
34c1 34c1 d d1
34c1 34c1 u 01 01
34c1 34c1 s 			POP	DE		;RESTORE POSITION IN SOURCE
34c2 34c2 d c9
34c2 34c2 u 01 01
34c2 34c2 s 			RET
34c3 34c3 s 		; INDEXED CHARACTER VARIABLE, EXTRACT A SINGLE CHARACTER
34c3 34c3 d cd3e31
34c3 34c3 u 03 01
34c3 34c3 s 		CINDX	CALL	DOEXP		;EVALUATE INDEX EXPRESSION
34c6 34c6 d 7d
34c6 34c6 u 01 01
34c6 34c6 s 			LD	A,L		;GET INDEX VALUE
34c7 34c7 d f5
34c7 34c7 u 01 01
34c7 34c7 s 			PUSH	AF
34c8 34c8 d 1b
34c8 34c8 u 01 01
34c8 34c8 s 			DEC	DE		;BACK UP TO VARIABLE NAME
34c9 34c9 d 1a
34c9 34c9 u 01 01
34c9 34c9 s 			LD	A, (DE)		;GET VARIABLE NAME
34ca 34ca d fe40
34ca 34ca u 02 01
34ca 34ca s 			CP	'@'		;TEST FOR 'MAGIC' CHR0x VARIABLE
34cc 34cc d cae334
34cc 34cc u 03 01
34cc 34cc s 			JP Z,	CHR		;IF SO, HANDLE SPECIAL CASE
34cf 34cf d cdb52f
34cf 34cf u 03 01
34cf 34cf s 			CALL	LTA		;GET TEXT VARIABLE ADDRESS
34d2 34d2 d f1
34d2 34d2 u 01 01
34d2 34d2 s 			POP	AF
34d3 34d3 d fe23
34d3 34d3 u 02 01
34d3 34d3 s 			CP	35		;TEST FOR TOO BIG
34d5 34d5 d d2af2f
34d5 34d5 u 03 01
34d5 34d5 s 			JP NC,	DIMERR		;IF SO, TELL HIM HE SCREWED UP
34d8 34d8 d 4f
34d8 34d8 u 01 01
34d8 34d8 s 			LD	C,A		;GET INTO A DOUBLE PAIR
34d9 34d9 d 09
34d9 34d9 u 01 01
34d9 34d9 s 			ADD	HL,BC		;SO WE CAN DAD IT TO THE ADDRESS
34da 34da d 7e
34da 34da u 01 01
34da 34da s 			LD	A,(HL)		;AND GET THE CHARACTER
34db 34db d 216480
34db 34db u 03 01
34db 34db s 		FILBUF	LD	HL,XBF		;ADDRESS OF TEXT BUFFER
34de 34de d 77
34de 34de u 01 01
34de 34de s 			LD	(HL),A		;PLACE CHARACTER THERE
34df 34df d 23
34df 34df u 01 01
34df 34df s 			INC	HL		;BUMP TO NEXT POSITION
34e0 34e0 d c31934
34e0 34e0 u 03 01
34e0 34e0 s 			JP	Q3		;AND FILL WITH NULLS
34e3 34e3 s 		;
34e3 34e3 s 		; 'MAGIC' CHARACTER ARRAY, RETURNS CHARACTER WITH VALUE OF IT'S INDEX
34e3 34e3 s 		;
34e3 34e3 d f1
34e3 34e3 u 01 01
34e3 34e3 s 		CHR	POP	AF
34e4 34e4 d c3db34
34e4 34e4 u 03 01
34e4 34e4 s 			JP	FILBUF		;SAVE IN BUFFER AND PAD WITH NULLS
34e7 34e7 s 			
34e7 34e7 s 		;*********************************************************************
34e7 34e7 s 		;                          PATCH I/O ROUTINES TO Z80MC
34e7 34e7 s 			
34e7 34e7 d cd5100
34e7 34e7 u 03 01
34e7 34e7 s 		CTRLC	CALL	BINCHR
34ea 34ea d fe03
34ea 34ea u 02 01
34ea 34ea s 			CP	3
34ec 34ec d c9
34ec 34ec u 01 01
34ec 34ec s 			RET
34ed 34ed d cd5100
34ed 34ed u 03 01
34ed 34ed s 		BGETCHR CALL	BINCHR
34f0 34f0 d 38fb
34f0 34f0 u 02 01
34f0 34f0 s 			JR C,	BGETCHR
34f2 34f2 d c9
34f2 34f2 u 01 01
34f2 34f2 s 			RET
34f3 34f3 s 		; END OF BASIC INTERPRETER CODE SECTION
34f3 34f3 s 		;	PAGE
34f3 34f3 s 		;
34f3 34f3 s 		;*********************************************************************
34f3 34f3 s 		;                          COMMAND TABLE
34f3 34f3 s 		;
34f3 34f3 s 		;   FORMAT IS:
34f3 34f3 s 		;               COMMAND WORDS, HIGH BIT SET ON LAST CHARACTER
34f3 34f3 s 		;               ADDRESS OF COMMAND PROCESSOR FOLLOWES
34f3 34f3 s 		;               ENTRY OF HEX 00 INDICATES LAST ENTRY IN TABLE (DEFAULT)
34f3 34f3 s 		;
34f3 34f3 s 		;*********************************************************************
34f3 34f3 s 		;
34f3 34f3 s 		; COMMANDS ALLOWED ONLY FROM WITHING A PROGRAM..
34f3 34f3 d 4e4558
34f3 34f3 u 03 02
34f3 34f3 s 		PTAB	DB	'NEX'
34f6 34f6 d d4
34f6 34f6 u 01 02
34f6 34f6 s 			DB	'T'+0x80
34f7 34f7 d e12d
34f7 34f7 u 02 02
34f7 34f7 s 			DW	NEXT
34f9 34f9 d 544845
34f9 34f9 u 03 02
34f9 34f9 s 			DB	'THE'
34fc 34fc d ce
34fc 34fc u 01 02
34fc 34fc s 			DB	'N'+0x80
34fd 34fd d 322d
34fd 34fd u 02 02
34fd 34fd s 			DW	THEN
34ff 34ff d 474f5355
34ff 34ff u 04 02
34ff 34ff s 			DB	'GOSU'
3503 3503 d c2
3503 3503 u 01 02
3503 3503 s 			DB	'B'+0x80
3504 3504 d 3b2d
3504 3504 u 02 02
3504 3504 s 			DW	GOSUB
3506 3506 d 5245545552
3506 3506 u 05 02
3506 3506 s 			DB	'RETUR'
350b 350b d ce
350b 350b u 01 02
350b 350b s 			DB	'N'+0x80
350c 350c d 6e2d
350c 350c u 02 02
350c 350c s 			DW	RETURN
350e 350e d 464f
350e 350e u 02 02
350e 350e s 			DB	'FO'
3510 3510 d d2
3510 3510 u 01 02
3510 3510 s 			DB	'R'+0x80
3511 3511 d 7b2d
3511 3511 u 02 02
3511 3511 s 			DW	FOR
3513 3513 d 49
3513 3513 u 01 02
3513 3513 s 			DB	'I'
3514 3514 d c6
3514 3514 u 01 02
3514 3514 s 			DB	'F'+0x80
3515 3515 d 162e
3515 3515 u 02 02
3515 3515 s 			DW	IF
3517 3517 d 444154
3517 3517 u 03 02
3517 3517 s 		DATCMD	DB	'DAT'
351a 351a d c1
351a 351a u 01 02
351a 351a s 			DB	'A'+0x80
351b 351b d 132d
351b 351b u 02 02
351b 351b s 			DW	RNEXT
351d 351d d 4c49
351d 351d u 02 02
351d 351d s 			DB	'LI'
351f 351f d c6
351f 351f u 01 02
351f 351f s 			DB	'F'+0x80
3520 3520 d 392e
3520 3520 u 02 02
3520 3520 s 			DW	LIF
3522 3522 s 		; COMMANDS ALLOWED FROM BOTH A PROGRAM, AND INTERACTIVE KEYBOARD ENTRY
3522 3522 d 474f54
3522 3522 u 03 02
3522 3522 s 		KTAB	DB	'GOT'
3525 3525 d cf
3525 3525 u 01 02
3525 3525 s 			DB	'O'+0x80
3526 3526 d 432d
3526 3526 u 02 02
3526 3526 s 			DW	GOTO
3528 3528 d 4f55
3528 3528 u 02 02
3528 3528 s 			DB	'OU'
352a 352a d d4
352a 352a u 01 02
352a 352a s 			DB	'T'+0x80	
352b 352b d 672e
352b 352b u 02 02
352b 352b s 			DW	OUTP
352d 352d d 4c45
352d 352d u 02 02
352d 352d s 			DB	'LE'
352f 352f d d4
352f 352f u 01 02
352f 352f s 			DB	'T'+0x80
3530 3530 d d22d
3530 3530 u 02 02
3530 3530 s 			DW	LET
3532 3532 d 5052494e
3532 3532 u 04 02
3532 3532 s 			DB	'PRIN'
3536 3536 d d4
3536 3536 u 01 02
3536 3536 s 			DB	'T'+0x80
3537 3537 d 8d2e
3537 3537 u 02 02
3537 3537 s 			DW	BPRINT
3539 3539 d 5553
3539 3539 u 02 02
3539 3539 s 			DB	'US'
353b 353b d d2
353b 353b u 01 02
353b 353b s 			DB	'R'+0x80
353c 353c d c82f
353c 353c u 02 02
353c 353c s 			DW	USR
353e 353e d 524541
353e 353e u 03 02
353e 353e s 			DB	'REA'
3541 3541 d c4
3541 3541 u 01 02
3541 3541 s 			DB	'D'+0x80
3542 3542 d 1f30
3542 3542 u 02 02
3542 3542 s 			DW	READ
3544 3544 d 504c4f
3544 3544 u 03 02
3544 3544 s 			DB	'PLO'
3547 3547 d d4
3547 3547 u 01 02
3547 3547 s 			DB	'T'+0x80
3548 3548 d 442e
3548 3548 u 02 02
3548 3548 s 			DW	PLOT
354a 354a d 5245
354a 354a u 02 02
354a 354a s 			DB	'RE'
354c 354c d cd
354c 354c u 01 02
354c 354c s 			DB	'M'+0x80
354d 354d d 152e
354d 354d u 02 02
354d 354d s 			DW	REM
354f 354f d 4449
354f 354f u 02 02
354f 354f s 			DB	'DI'
3551 3551 d cd
3551 3551 u 01 02
3551 3551 s 			DB	'M'+0x80
3552 3552 d 3e2f
3552 3552 u 02 02
3552 3552 s 			DW	DIM
3554 3554 d 5255
3554 3554 u 02 02
3554 3554 s 			DB	'RU'
3556 3556 d ce
3556 3556 u 01 02
3556 3556 s 			DB	'N'+0x80
3557 3557 d ec2c
3557 3557 u 02 02
3557 3557 s 			DW	RUN
3559 3559 d 4f524445
3559 3559 u 04 02
3559 3559 s 			DB	'ORDE'
355d 355d d d2
355d 355d u 01 02
355d 355d s 			DB	'R'+0x80
355e 355e d 0430
355e 355e u 02 02
355e 355e s 			DW	ORDER
3560 3560 d 494e5055
3560 3560 u 04 02
3560 3560 s 			DB	'INPU'
3564 3564 d d4
3564 3564 u 01 02
3564 3564 s 			DB	'T'+0x80
3565 3565 d cb2e
3565 3565 u 02 02
3565 3565 s 			DW	INPUT
3567 3567 d 434c4541
3567 3567 u 04 02
3567 3567 s 			DB	'CLEA'
356b 356b d d2
356b 356b u 01 02
356b 356b s 			DB	'R'+0x80
356c 356c d af2c
356c 356c u 02 02
356c 356c s 			DW	CLEAR
356e 356e d 53544f
356e 356e u 03 02
356e 356e s 			DB	'STO'
3571 3571 d d0
3571 3571 u 01 02
3571 3571 s 			DB	'P'+0x80
3572 3572 d 2c2d
3572 3572 u 02 02
3572 3572 s 			DW	STOP
3574 3574 d 454e
3574 3574 u 02 02
3574 3574 s 			DB	'EN'
3576 3576 d c4
3576 3576 u 01 02
3576 3576 s 			DB	'D'+0x80
3577 3577 d 1d2a
3577 3577 u 02 02
3577 3577 s 			DW	INIT
3579 3579 d 4c4953
3579 3579 u 03 02
3579 3579 s 			DB	'LIS'
357c 357c d d4
357c 357c u 01 02
357c 357c s 			DB	'T'+0x80
357d 357d d 6b2c
357d 357d u 02 02
357d 357d s 			DW	LIST
357f 357f d 4e45
357f 357f u 02 02
357f 357f s 			DB	'NE'
3581 3581 d d7
3581 3581 u 01 02
3581 3581 s 			DB	'W'+0x80
3582 3582 d 152a
3582 3582 u 02 02
3582 3582 s 			DW	NEW
3584 3584 d 53495a
3584 3584 u 03 02
3584 3584 s 			DB	'SIZ'
3587 3587 d c5
3587 3587 u 01 02
3587 3587 s 			DB	'E'+0x80
3588 3588 d a930
3588 3588 u 02 02
3588 3588 s 			DW	SIZE
358a 358a d 4c4f41
358a 358a u 03 02
358a 358a s 			DB	'LOA'
358d 358d d c4
358d 358d u 01 02
358d 358d s 			DB	'D'+0x80
358e 358e d c930
358e 358e u 02 02
358e 358e s 			DW	LOAD
3590 3590 d 534156
3590 3590 u 03 02
3590 3590 s 			DB	'SAV'
3593 3593 d c5
3593 3593 u 01 02
3593 3593 s 			DB	'E'+0x80
3594 3594 d cc30
3594 3594 u 02 02
3594 3594 s 			DW	SAVE
3596 3596 d 455849
3596 3596 u 03 02
3596 3596 s 			DB	'EXI'
3599 3599 d d4
3599 3599 u 01 02
3599 3599 s 			DB	'T'+0x80
359a 359a d 4200
359a 359a u 02 02
359a 359a s 			DW	BEXIT
359c 359c d 00
359c 359c u 01 02
359c 359c s 			DB	0		;UNRECOGNIZED COMMAND, ASSUME 'LET'
359d 359d d d22d
359d 359d u 02 02
359d 359d s 			DW	LET
359f 359f s 		;
359f 359f s 		;**************************************************************
359f 359f s 		;                    STRINGS AND MESSAGES
359f 359f s 		;**************************************************************
359f 359f s 		;
359f 359f s 		; ERROR MESSAGES..
359f 359f s 		;
359f 359f d 444956494445204259205a45524f00
359f 359f u 0f 02
359f 359f s 		DER	DB	'DIVIDE BY ZERO',0 ;DIVIDE BY ZERO
35ae 35ae d 4241442044415441202d2052455452590d0a00
35ae 35ae u 13 02
35ae 35ae s 		IERMS	DB	'BAD DATA - RETRY',CR,LF,0 ;BAD RESPONSE TO INPUT STATEMENT
35c1 35c1 d 4e455354494e4700
35c1 35c1 u 08 02
35c1 35c1 s 		CSTK	DB	'NESTING',0	;INVALID FOR/NEXT, GOSUB/RETURN NESTING
35c9 35c9 d 4c494e45204e554d42455200
35c9 35c9 u 0c 02
35c9 35c9 s 		LIN	DB	'LINE NUMBER',0	;GOTO, GOSUB, OR ORDER TO UNKNOWN LINE
35d5 35d5 d 4e4f2050524f4752414d00
35d5 35d5 u 0b 02
35d5 35d5 s 		NP	DB	'NO PROGRAM',0	;RUN OR SAVE EMPTY PROGRAM
35e0 35e0 d 20494e204c494e452000
35e0 35e0 u 0a 02
35e0 35e0 s 		INL	DB	' IN LINE ',0	;INDICATES LINE ERROR WAS IN
35ea 35ea d 53594e54415800
35ea 35ea u 07 02
35ea 35ea s 		SYN	DB	'SYNTAX',0	;DOES NOT FOLLOW SYNTAX RULES
35f1 35f1 d 4441544100
35f1 35f1 u 05 02
35f1 35f1 s 		DTXT	DB	'DATA',0	;BAD LINE OR DATA TYPE
35f6 35f6 d 44494d454e53494f4e00
35f6 35f6 u 0a 02
35f6 35f6 s 		OVM	DB	'DIMENSION',0	;TO MANY ARRAYS, ARGUMENT OUT OF RANGE
3600 3600 s 		;
3600 3600 s 		; INFORMATIONAL MESSAGES..
3600 3600 s 		;
3600 3600 d 0c204d4943524f2d424153494320434f50595249474854203139383320425920444156452044554e4649454c440d0a00
3600 3600 u 30 02
3600 3600 s 		INTRO	DB	0x0C,' MICRO-BASIC COPYRIGHT 1983 BY DAVE DUNFIELD',CR,LF,0
3630 3630 d 52454144590d0a00
3630 3630 u 08 02
3630 3630 s 		RDY	DB	'READY',CR,LF,0	;RREADY PROMPT
3638 3638 d 53544f5000
3638 3638 u 05 02
3638 3638 s 		STMSG	DB	'STOP',0	;INDICATES PROGRAM STOPPED
363d 363d d 204552524f5200
363d 363d u 07 02
363d 363d s 		EM	DB	' ERROR',0	;INDICATES ERROR OCCURED
3644 3644 d 2042595445530d0a00
3644 3644 u 09 02
3644 3644 s 		SIMSG	DB	' BYTES',CR,LF,0 ;DISPLAYED IN RESPONSE TO 'SIZE'
364d 364d s 		ENDIT	EQU	$
364d 364d s 		;	END	0
364d 364d s 			
364d 364d s 		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
364d 364d s 		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
364d 364d s 		;	Appendix_B	Future Use
364d 364d s 		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
364d 364d s 		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
364d 364d s 		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
364d 364d s 		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
364d 364d s 		;	Appendix_C	RAM. System Ram allocation
364d 364d s 		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
364d 364d s 		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
364d 364d s 		;                       ********      ***     **     **
364d 364d s 		;                       *********    *****    ***   ***
364d 364d s 		;                       **     **   *** ***   **** ****
364d 364d s 		;                       **     **  ***   ***  *********
364d 364d s 		;---------------------  ********   *********  ** *** **  ---------------------
364d 364d s 		;---------------------  ********   *********  ** *** **  ---------------------
364d 364d s 		;                       **  **     **     **  **     **
364d 364d s 		;                       **   **    **     **  **     **
364d 364d s 		;                       **    **   **     **  **     **
364d 364d s 		;                       **     **  **     **  **     **
364d 364d s 		RAM_LDRT	equ	0x8000
fa00 fa00 s 				ORG	0xFA00
fa00 fa00 s ;		LINE_BUFF	DS	128
fa00 fa00 s ;		LINE_BUFFEND	DS	2	;Room for CR,LF if needed
fa00 fa00 s ;		LI_FILESIZE	DS	4	;LINE INPUT FILE SIZE, counts down the bytes in the file as Lines are fetched
fa00 fa00 s ;		LI_SDBUFF_PTR	DS	2	;Pointer to Disk Buffer for next Line Read operation
fa00 fa00 s ;		LI_SDLOG_SEC	DS	2	;Logical Sector last read in Buffer
fa00 fa00 s 						;Read Hex File Performance counter
fa00 fa00 s ;		RHF_LINES	DS	2	;Line counter
fa00 fa00 s 		;----------------------------------------------------------------------------------------------------; RAM SPACE
fa00 fa00 s 		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
fa00 fa00 s 		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
fa00 fa00 s 		;----------------------------------------------------------------------------------------------------; RAM SPACE
fa00 fa00 s 		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fa00 fa00 s 		;Reserve space from 0xFB00 to FB1F for Stack
fa00 fa00 s 		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fb00 fb00 s 				ORG	0xFB00
fb00 fb00 s ;		StackTop	equ	$-2	; Stack = 0xFB00
fb00 fb00 s ;		STACKSPACE1	DS	40	;Stack space for ISR L1 calls  (Measured to only need 14 words, resv 20 words)
fb00 fb00 s ;		STACK_ISR1	EQU	$	;Points to top of stack
fb00 fb00 s ;		SP_ISR_SAVE	DS	2	;Space to save SP, Happens on first ISR call
fb00 fb00 s ;		HRAM_CODE	DS	ROM_CODE_LEN	;Code for Returning from ISR (may need to switch to RAM, so it must be here in High RAM)
fb00 fb00 s ;		ISR_DISPATCH	EQU	HRAM_CODE
fb00 fb00 s ;		ISR_RET		EQU	ISR_RET_OFF+HRAM_CODE ;Assign address in the HIGH RAM
fb00 fb00 s ;		GET_MEM		EQU	GET_MEM_OFF+HRAM_CODE ;Assign address in the HIGH RAM	
fb00 fb00 s ;		HR_EXE_GO	DS	HR_EXEC_GS_LEN	;Routine for Switching to RAM and Executing loaded program.
fb00 fb00 s ;		HERE1		EQU	$
fb00 fb00 s 			IF HERE1 > 0xFB80
fb00 fb00 s 			ENDIF
fb00 fb00 s 			
fb00 fb00 s 			;FREE RAM 25 BYTES
fb80 fb80 s 				ORG	0xFB80
fb80 fb80 s 		;SDFCB:
fb80 fb80 s 		FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
fb80 fb80 s 		FNAME		EQU	1	;DS 11	;+1  File name
fb80 fb80 s 		AFClus0		EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
fb80 fb80 s 		CRFClus		EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
fb80 fb80 s 		CAFClus		EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
fb80 fb80 s 		RFSec		EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
fb80 fb80 s 		SSOC		EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
fb80 fb80 s 		ABS_SEC		EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
fb80 fb80 s 		FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)
fb80 fb80 s 		;Warning: FCB's must never cross page boundaries.
fb80 fb80 s ;		SDISKA		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fb80 fb80 s ;		SDISKB		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fb80 fb80 s ;		SDISKC		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fb80 fb80 s ;		SDISKD		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fb80 fb80 s 		;
fb80 fb80 s 		;  ********   **     **  *********  *********  *********  ********
fb80 fb80 s 		;  *********  **     **  *********  *********  *********  *********
fb80 fb80 s 		;  **     **  **     **  **         **         **         **     **
fb80 fb80 s 		;  **     **  **     **  **         **         **         **     **
fb80 fb80 s 		;  ********   **     **  *******    *******    *******    ********
fb80 fb80 s 		;  ********   **     **  *******    *******    *******    ********
fb80 fb80 s 		;  **     **  **     **  **         **         **         **  **
fb80 fb80 s 		;  **     **  **     **  **         **         **         **   **
fb80 fb80 s 		;  *********  *********  **         **         *********  **    **
fb80 fb80 s 		;  ********    *******   **         **         *********  **     **
fb80 fb80 s 		;
fc00 fc00 s 				ORG	0xFC00
fc00 fc00 s ;		SD_RAM_BUFFER	DS	512	;FC00-FDFF 512 bytes of SD Sector Buffer space
fc00 fc00 s ;		RXBUFFER	DS	256	;FExx      256 bytes of RX Buffer space
fc00 fc00 s 		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fc00 fc00 s 		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fc00 fc00 s 		;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ff00 ff00 s 				ORG	0xFF00
ff00 ff00 s ;		BIT_TABLE	DS	8
ff00 ff00 s 		;Warning: FCB's must never cross page boundaries.
ff00 ff00 s ;		FCB_PTR		DS	2	;Pointer to Current FCB
ff00 ff00 s ;		FAT_CLEAR	EQU	$	;Clear bytes of RAM after this point on FAT_INIT
ff00 ff00 s ;		GH_START	DS	2	;HEX File, start address
ff00 ff00 s ;		VIEW_FLAGS	DS	1	;View File Load;  File Open View
ff00 ff00 s 						;BIT .0=View HEX Load, display file while reading HEX file
ff00 ff00 s 						;    .1=GH_START Address has been set
ff00 ff00 s 						;    .6=View FILE SIZE during File Open
ff00 ff00 s 						;    .7=View File Name & Found or Not status durin File Open
ff00 ff00 s ;		LOGICAL_SEC	DS	2	;Logical Sector for next Read Operation (Input paramater for the File Read)
ff00 ff00 s ;		DIRTY_DATA	DS	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
ff00 ff00 s ;		SD_CARD_TYPE	DS	1	;SD CARD TYPE
ff00 ff00 s ;		SDC_STATUS	DS	1	;SD Status Code returned
ff00 ff00 s ;		SD_PARAM	DS	4	;32 bit address parameter for SD Commands
ff00 ff00 s ;		SD_PART_TYPE	DS	1	;SD PARTITION TYPE
ff00 ff00 s ;		SD_PART_BASE	DS	4	;SD PARTITION STARTING RECORD
ff00 ff00 s ;		SD_PART_SIZE	DS	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
ff00 ff00 s ;		BYTE_P_SEC	DS	2	;0x0B Bytes per Sector (Almost always 512)
ff00 ff00 s ;		SEC_PER_CLUS	DS	1	;0x0D
ff00 ff00 s ;		RESERVED_SEC	DS	2	;0x0E - 0x0F
ff00 ff00 s ;		FAT_COPIES	DS	1	;0x10
ff00 ff00 s ;		ROOTDIR_SIZE	DS	2	;0x11 - 0x12
ff00 ff00 s ;		FILESYS_SEC	DS	4	;0x13 - 0x14 or 0x20 - 0x23
ff00 ff00 s ;		HIDDEN_SEC	DS	4	;0x1C - 0x1F
ff00 ff00 s ;		SEC_PER_FAT	DS	2	;0x16 - 0x17
ff00 ff00 s ;		FAT1START	DS	4	;Calculated Sector to FAT1
ff00 ff00 s ;		DIR_SECTOR	DS	4	;Calculated Sector to Root Directory
ff00 ff00 s ;		DATASTART	DS	4	;Calculated Sector to Data Area
ff00 ff00 s ;		SEC_PTR		DS	4	;Sector Pointer, general use variable that holds the last sector read
ff00 ff00 s ;		ENT_COUNT	DS	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
ff00 ff00 s ;		FAT_CLR_LEN	EQU	$ - FAT_CLEAR
ff00 ff00 s ;		FILENAME	DS	8	;File Name
ff00 ff00 s ;		FILEEXT		DS	3	;File Extension
ff00 ff00 s ;		FILESIZE	DS	4	;File Size
ff00 ff00 s ;		DIVIDE_FUNC	DS	2	;Pointer to the Divide Function
ff00 ff00 s ;		DF_SHIFTCNT	DS	1	;Count of shifts required for Fast Divide
ff00 ff00 s ;		MUL8		DS	1	;8 bit multiplier
ff00 ff00 s ;		MOD_FUNC	DS	2	;Pointer to the Mod Function
ff00 ff00 s ;		MODMASK		DS	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector
ff00 ff00 s ;		IK_HEXL		DS	1	;IMON HEX INPUT
ff00 ff00 s ;		IK_HEXH		DS	1	;IMON HEX INPUT
ff00 ff00 s ;		HEX_SOURCE	DS	2	;Pointer to the HEX INPUT Source (FILE or Serial Port)
ff00 ff00 s ;			IF $ >= 0xFF78
ff00 ff00 s ;			ENDIF
ff00 ff00 s ;		;*** BEGIN COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
ff00 ff00 s 		RAMSIGNATURE	equ	0xFF78	;RAM signature
ff00 ff00 s 						;Following bytes are cleared on COLD BOOT
ff00 ff00 s 		RC_TYPE		equ	0xFF80	;(1) Type of Reset (WARNING, Next 7 RC counters must end with lsb bits = 001,010,011,100,101,110,111)
ff00 ff00 s 		RC_SOFT		equ	0xFF81	;(1) Count of Resets by SOFT F-E SWITCH
ff00 ff00 s 		RC_STEP		equ	0xFF82	;(1) Count of Resets by SINGLE STEP
ff00 ff00 s 		RC_CC		equ	0xFF83	;(1) Count of Resets by CTRL-C
ff00 ff00 s 		RC_HALT		equ	0xFF84	;(1) Count of Resets by HALT INSTRUCTION
ff00 ff00 s 		RC_F0		equ	0xFF85	;(1) Count of Resets by pressing F & 0 keys
ff00 ff00 s 		RC_RST0		equ	0xFF86	;(1) Count of Resets by RST 0 INSTRUCTION
ff00 ff00 s 		RC_HARD		equ	0xFF87	;(1) Count of Resets by UNKNOWN RESET LINE
ff00 ff00 s 		ABUSS		equ	0xFF88	;(2)
ff00 ff00 s 		RegPtr		equ	0xFF8A	;(1) Ptr to Registers
ff00 ff00 s 		IoPtr		equ	0xFF8B	;(1)  I/O Ptr
ff00 ff00 s 		RX_ERR_LDRT	equ	0xFF8C	;(1) Counts False Start Bits (Noise Flag)
ff00 ff00 s 		RX_ERR_STOP	equ	0xFF8D	;(1) Counts Missing Stop Bits (Framing Error)
ff00 ff00 s 		RX_ERR_OVR	equ	0xFF8E	;(1) Counts Overrun Errors
ff00 ff00 s 		CS_CLR_LEN	equ	0xFF8F-RC_TYPE
ff00 ff00 s 		ACE_BAUD	equ	0xFF8F	;(1) Baudrate of ACE, 12=9600
ff00 ff00 s 						;PUTCHAR_EXE and INCHAR_EXE *must be consecutive in this order*
ff00 ff00 s 		PUTCHAR_EXE	equ	0xFF90	;(2) PutChar Execution (Set for PC_LED, PC_BIT, PC_ACE or PC_BOTH)
ff00 ff00 s 		INCHAR_EXE	equ	0xFF92	;(2) InChar Execution (Set for IN_KEY, IN_BIT, IN_ACE or IN_BOTH)
ff00 ff00 s 		;*** END COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
ff00 ff00 s 		HW_SETIO	equ	0xFF94	;Serial IO selected, 01=Bit, 02=ACE, 03=BIT & ACE
ff00 ff00 s 		HW_LIST		equ	0xFF95	;Hardware List, 00=NO Boards, 01=FP Only, 02=SIO only, 03=FP & SIO
ff00 ff00 s 						;Saved Registers
ff00 ff00 s 		RSSP		equ	0xFF96	;Value of SP upon REGISTER SAVE
ff00 ff00 s 		RSAF		equ	0xFF98	;Value of AF upon REGISTER SAVE
ff00 ff00 s 		RSBC		equ	0xFF9A	;Value of BC upon REGISTER SAVE
ff00 ff00 s 		RSDE		equ	0xFF9C	;Value of DE upon REGISTER SAVE
ff00 ff00 s 		RSHL		equ	0xFF9E	;Value of HL upon REGISTER SAVE
ff00 ff00 s 		RPC		equ	0xFFA0	;Value of PC upon REGISTER SAVE
ff00 ff00 s 		RSIX		equ	0xFFA2	;Value of IX upon REGISTER SAVE
ff00 ff00 s 		RSIY		equ	0xFFA4	;Value of IY upon REGISTER SAVE
ff00 ff00 s 		RSIR		equ	0xFFA6	;Value of IR upon REGISTER SAVE
ff00 ff00 s 		RSAF2		equ	0xFFA8	;Value of AF' upon REGISTER SAVE
ff00 ff00 s 		RSBC2		equ	0xFFAA	;Value of BC' upon REGISTER SAVE
ff00 ff00 s 		RSDE2		equ	0xFFAC	;Value of DE' upon REGISTER SAVE
ff00 ff00 s 		RSHL2		equ	0xFFAE	;Value of HL' upon REGISTER SAVE
ff00 ff00 s 		UiVec		equ	0xFFB0	;(2) User Interrupt Vector
ff00 ff00 s 		;*** BEGIN WARM_BOOT_INIT (RAM that is to be initialized on every boot) ***
ff00 ff00 s 						;WARNING, Following 34 bytes must be consecutive in this order for Block Write
ff00 ff00 s 		BEEP_TO		equ	0xFFB2	;(1) Count down the beep (beep duration)
ff00 ff00 s 		ANBAR_DEF	equ	0xFFB3	;(1) Base setting for the Annunciator LED's (after current function times out)
ff00 ff00 s 		GET_REG		equ	0xFFB4	;(2) Get Reg Routine (in monitor mode, registers fetched from RAM)
ff00 ff00 s 		PUT_REG		equ	0xFFB6	;(2) Put Reg Routine
ff00 ff00 s 		CTRL_C_CHK	equ	0xFFB8	;(2) Vector for CTRL-C Checking
ff00 ff00 s 		LDISPMODE	equ	0xFFBA	;(2) Last Display Mode (Holds DISPMODE while in HEX Entry)
ff00 ff00 s 		DISPMODE	equ	0xFFBC	;(2) Display Routine
ff00 ff00 s 		KEY_EVENT	equ	0xFFBE	;(2) Routine to call upon Key Press (changes based on user actions, see KEY_EVENT_DISPATCH)
ff00 ff00 s 		IK_TIMER	equ	0xFFC0	;(1) IMON TIMEOUT
ff00 ff00 s 		KEYBFMODE	equ	0xFFC1	;(1) KEY INPUT MODE. 8F=HEX INPUT, 90=Shiftable
ff00 ff00 s 		DISPLABEL	equ	0xFFC2	;(1) Display Label Refresh
ff00 ff00 s 		IK_HEXST	equ	0xFFC3	;(1) IMON HEX Input State
ff00 ff00 s 		HEX_CURSOR	equ	0xFFC4	;(2) HEX Input Cursor location
ff00 ff00 s 		HEX_READY	equ	0xFFC6	;(2) HEX Input Ready
ff00 ff00 s 		LED_CURSOR	equ	0xFFC8	;(2) Cursor location for LED Put_Char
ff00 ff00 s 		RXBHEAD		equ	0xFFCA	;(2) RS-232 RX BUFFER HEAD
ff00 ff00 s 		RXBTAIL		equ	0xFFCC	;(2) RS-232 RX BUFFER TAIL
ff00 ff00 s 		INT_VEC		equ	0xFFCE	;(2) Vector to Interrupt ISR
ff00 ff00 s 		SCAN_PTR	equ	0xFFD0	;(2) SCAN_PTR points to next LED_DISPLAY byte to output (will always be 1 more
ff00 ff00 s 						;    than the current hardware column because hardware automatically advances)
ff00 ff00 s 		HALT_TEST	equ	0xFFD2	;(2) HALT_TEST
ff00 ff00 s 		;*** END WARM_BOOT_INIT (RAM BLOCK that is to be initialized on every boot) ***
ff00 ff00 s 		CLEARED_SPACE	equ	0xFFD4	;Bytes here and later are cleared upon init (some initialized seperately)
ff00 ff00 s 		CLEARED_LEN	equ	0xFFFF - CLEARED_SPACE + 1
ff00 ff00 s 		SDISPMODE	equ	0xFFD4	;(2)
ff00 ff00 s 		POS_BIT		equ	0xFFD6	;(1) BIT Bang RS232 Character position
ff00 ff00 s 		POS_ACE		equ	0xFFD7	;(1) ACE RS232 Character position
ff00 ff00 s 		ISR_FLAGS	equ	0xFFD8	;(1) Indicates how many levels the ISR has nested
ff00 ff00 s 		RRSTATE		equ	0xFFD9	;(1) RAM/ROM SELECT STATE (FOR RETURN FROM ISR)	
ff00 ff00 s 		XTIMER_TIC	equ	0xFFDA	;(1) Counts Down tics until Extended Timer ISR_EXXTIMER
ff00 ff00 s 		READ_RAMROM	equ	0xFFDB	;(1) Selected RAMROM for Monitor READ Operations.  Bit0 for RAM/ROM, Bits1-4 for Bank
ff00 ff00 s 		NMI_VEC		equ	0xFFDC	;(2) NMI VEC.  Not used
ff00 ff00 s 		CTRL_C_TIMER	equ	0xFFDE	;Count down the CTRL-C condition
ff00 ff00 s 		SOFT_RST_FLAG	equ	0xFFDF	;Flag a Soft Reset (F-E Keys, Single Step)
ff00 ff00 s 						;Display/Serial Comms
ff00 ff00 s 		LED_DISPLAY	equ	0xFFE0	;8 Bytes of LED Output bytes to Scan to hardware
ff00 ff00 s 		;8 Bytes			;Warning, LED_DISPLAY must be nibble aligned at E0 (XXE0)
ff00 ff00 s 		LED_ANBAR	equ	0xFFE7	;LED Annunciator Bar (Part of LED_DISPLAY Buffer)
ff00 ff00 s 						;.0 = x7 = BEEPER
ff00 ff00 s 						;.1 = x6 = Run Mode
ff00 ff00 s 						;.2 = x5 = Monitor Mode (Default Mode upon Power up)
ff00 ff00 s 						;.3 = x4 = Send Data to Output Port
ff00 ff00 s 						;.4 = x3 = Alter Memory/Register
ff00 ff00 s 						;.5 = x2 = Enter Memory Location
ff00 ff00 s 						;.6 = x1 = Enter Register
ff00 ff00 s 		KBCOLSAMPLED	equ	0xFFE8	;Columns Sampled
ff00 ff00 s 		KBPORTSAMPLE	equ	0xFFE9	;Input Port sampled only once on each scan, saved here
ff00 ff00 s 		KBHEXSAMPLE	equ	0xFFEA	;KEY SAMPLER Input HEX format
ff00 ff00 s 		KEYBSCANPV	equ	0xFFEB	;KEY Input HEX format
ff00 ff00 s 		KEYBSCANTIMER	equ	0xFFEC	;KEY Input TIMER
ff00 ff00 s 		KEY_PRES_EV	equ	0xFFED	;KEY INPUT LAST & Currently Processing
ff00 ff00 s 		KEY_PRES_RTN	equ	0xFFEE	;KEY LAST, for Return To Normal between strokes
ff00 ff00 s 		KEY_PRESSED	equ	0xFFEF	;(1) KEY PRESSED
ff00 ff00 s 		TicCounter	equ	0xFFF0	;Tic Counter
ff00 ff00 s 		;TicCounter	equ	0xFFF1	;
ff00 ff00 s 		ECHO_STATE	equ	0xFFF2	;Echo characters
ff00 ff00 s 		XMSEQ		equ	0xFFF3	;XMODEM SEQUENCE NUMBER
ff00 ff00 s 		XMTYPE		equ	0xFFF4	;XMODEM BLOCK TYPE (CRC/CS)
ff00 ff00 s 		SCAN_LED	equ	0xFFF5	;Holds the next LED output
ff00 ff00 s 		LED_DISPLAY_SB	equ	0xFFF6	;10 Bytes FFF6=Start BIT, 7,8,9,A,B,C,D,E=Data bits, F=Stop BIT
ff00 ff00 s 		;10 bytes	equ	0xFFFF	;Warning, LED_DISPLAY_TBL must be at this address (XXF6) Roll over to xx00 tested
ff00 ff00 s 		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
ff00 ff00 s 		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
ff00 ff00 s 		;	Appendix_D	HOOK LOCATIONS
ff00 ff00 s 		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
ff00 ff00 s 		;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0042 0042 s 				org	0x0042
0042 0042 s ;		VMAIN_MENU	JP	MAIN_MENU	;MONITOR
0042 0042 s ;		VPUT_CHAR	JP	PUT_CHAR	;PUT_CHAR
0042 0042 s ;		VGET_POS	JP	GET_POS		;Return the Position of the cursor on the line
0042 0042 s ;		VGET_CHAR	JP	GET_CHAR
0042 0042 s ;		VRX_COUNT	JP	RX_COUNT	;Count of Characters waiting in the RX Buffer
0042 0042 s ;		VIN_CHAR	JP	IN_CHAR		;Returns a char or C=1 if none.
0042 0042 s ;		VTIMED_GETCHAR	JP	TIMED_GETCHAR
0042 0042 s ;		VPRINT		JP	PRINT
0042 0042 s ;		VBEEP		JP	BEEP
0042 0042 s ;		VSET_ECHO	JP	SET_ECHO
0042 0042 s ;		VDELAY_C	JP	DELAY_C		;Loop based on C, 100mSEC
0042 0042 s ;		VDELAY_A	JP	DELAY_A		;Milli seconds based on A, requires FP board
0042 0042 s ;				org	0x006B
0042 0042 s ;		VPUT_VERSION	JP	PUT_VERSION
0042 0042 s ;		VPUT_HEX	JP	PUT_HEX
0042 0042 s ;		VPUT_BYTE	JP	PUT_BYTE
0042 0042 s ;		VPUT_BC		JP	PUT_BC
0042 0042 s ;		VPUT_DE		JP	PUT_DE
0042 0042 s ;		VPUT_HL		JP	PUT_HL
0042 0042 s ;		VPUT_SPACE	JP	PUT_SPACE
0042 0042 s ;		VPUT_NEW_LINE	JP	PUT_NEW_LINE
0042 0042 s ;		VGET_BYTE	JP	GET_BYTE
0042 0042 s ;		VGET_WORD	JP	GET_WORD	;DE
0042 0042 s ;		VGET_HEX	JP	GET_HEX
0042 0042 s ;		VCLEAR_BLOCK	JP	CLEAR_BLOCK	;CLEAR_BLOCK
0042 0042 s ;		VLD_HL_HL	JP	LD_HL_HL
0042 0042 s ;		VADD_HL_A	JP	ADD_HL_A
0042 0042 s ;		VMOV_32_HL	JP	MOV_32_HL	;Move (HL) to 32 bit register BCDE
0042 0042 s ;		VMOV_HL_32	JP	MOV_HL_32	;Move 32 bit register BCDE to (HL)
0042 0042 s ;		VADD_32_HL	JP	ADD_32_HL	;ADD (HL) to 32 bit register BCDE - (returns with HL changed to last byte)
0042 0042 s ;		VCMP_HL_32	JP	CMP_HL_32	;Compare BCDE with 32bit word at HL
0042 0042 s ;		VINC_32		JP	INC_32		;INC BCDE
0042 0042 s ;		VDEC_32		JP	DEC_32		;DEC BCDE
0042 0042 s ;		VTSTZ_32	JP	TSTZ_32		;TEST_ZERO BCDE
0042 0042 s ;		VASC2BIN	JP	ASC2BIN
0042 0042 s ;		VASC2HEX	JP	ASC2HEX
0042 0042 s ;		VHEX2ASC	JP	HEX2ASC		
0042 0042 s ;		VTO_UPPER	JP	TO_UPPER
0042 0042 s ;		VSET_IO		JP	SET_IO
0042 0042 s ;		VIC_KEY		JP	IC_KEY
0042 0042 s ;		VLED_UPDATE	JP	LED_UPDATE	;Turn ON/OFF LED UPDATE & KEY MON
0042 0042 s ;		VLED_GET_POS	JP	LED_GET_POS
0042 0042 s ;		VLED_SET_POS	JP	LED_SET_POS
0042 0042 s ;		VLED_HOME	JP	LED_HOME
0042 0042 s ;		VLED_PUT_CHAR	JP	PC_LED		;C = CHAR
0042 0042 s ;		VLED_PRINT	JP	LED_PRINT
0042 0042 s ;		VLED_PUT_BYTE	JP	LED_PUT_BYTE
0042 0042 s ;		VLED_PUT_HEX	JP	LED_PUT_HEX
0042 0042 s ;		VLED_CLEAR	JP	LED_CLEAR
0042 0042 s ;		VLED_RIGHT	JP	LED_RIGHT
0042 0042 s ;		VLED_LEFT	JP	LED_LEFT
0042 0042 s ;		VPRINT_FNAME	JP	PRINT_FILENAME
0042 0042 s ;		VINPUT_FNAME	JP	INPUT_FILENAME
0042 0042 s ;		VSD_OPEN	JP	SD_OPEN			;Copy FCB to filename then search & open
0042 0042 s ;		VSD_OPEN_FILENAME JP	SD_OPEN_FILENAME	;Copy Filename to FCB then search & open
0042 0042 s ;		VPRINT_DIR	JP	PRINT_DIR
0042 0042 s ;		VDISK_READ	JP	DISK_READ
0042 0042 s ;		VSD_READ_SEC	JP	SD_READ_SEC
0042 0042 s ;		VLINE_INPUT	JP	LINE_INPUT
0042 0042 s 				ENd
0042 0042 f zmcv15.asm
0042 0042 s 
0042 0042 s 
0042 0042 s 
0042 0042 s 
0042 0042 s 
0042 0042 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0042 0042 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0042 0042 s ;	Appendix_B	Future Use
0042 0042 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0042 0042 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0042 0042 s 
0042 0042 s 
0042 0042 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0042 0042 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0042 0042 s ;	Appendix_C	RAM. System Ram allocation
0042 0042 s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
0042 0042 s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
0042 0042 s 
0042 0042 s 
0042 0042 s ;                       ********      ***     **     **
0042 0042 s ;                       *********    *****    ***   ***
0042 0042 s ;                       **     **   *** ***   **** ****
0042 0042 s ;                       **     **  ***   ***  *********
0042 0042 s ;---------------------  ********   *********  ** *** **  ---------------------
0042 0042 s ;---------------------  ********   *********  ** *** **  ---------------------
0042 0042 s ;                       **  **     **     **  **     **
0042 0042 s ;                       **   **    **     **  **     **
0042 0042 s ;                       **    **   **     **  **     **
0042 0042 s ;                       **     **  **     **  **     **
0042 0042 s 
0042 0042 s RAM_LDRT	equ	0x8000
0042 0042 s 
0042 0042 s 
fa00 fa00 s 		ORG	0xFA00
fa00 fa00 s LINE_BUFF	DS	128
fa80 fa80 s LINE_BUFFEND	DS	2	;Room for CR,LF if needed
fa82 fa82 s LI_FILESIZE	DS	4	;LINE INPUT FILE SIZE, counts down the bytes in the file as Lines are fetched
fa86 fa86 s LI_SDBUFF_PTR	DS	2	;Pointer to Disk Buffer for next Line Read operation
fa88 fa88 s LI_SDLOG_SEC	DS	2	;Logical Sector last read in Buffer
fa8a fa8a s 
fa8a fa8a s 
fa8a fa8a s 				;Read Hex File Performance counter
fa8a fa8a s RHF_LINES	DS	2	;Line counter
fa8c fa8c s 
fa8c fa8c s 
fa8c fa8c s ;----------------------------------------------------------------------------------------------------; RAM SPACE
fa8c fa8c s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
fa8c fa8c s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
fa8c fa8c s ;----------------------------------------------------------------------------------------------------; RAM SPACE
fa8c fa8c s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fa8c fa8c s ;Reserve space from 0xFB00 to FB1F for Stack
fa8c fa8c s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fb00 fb00 s 		ORG	0xFB00
fb00 fb00 s StackTop	equ	$-2	; Stack = 0xFB00
fb00 fb00 s 
fb00 fb00 s STACKSPACE1	DS	40	;Stack space for ISR L1 calls  (Measured to only need 14 words, resv 20 words)
fb28 fb28 s STACK_ISR1	EQU	$	;Points to top of stack
fb28 fb28 s SP_ISR_SAVE	DS	2	;Space to save SP, Happens on first ISR call
fb2a fb2a s 
fb2a fb2a s 
fb2a fb2a s HRAM_CODE	DS	ROM_CODE_LEN	;Code for Returning from ISR (may need to switch to RAM, so it must be here in High RAM)
fb53 fb53 s 
fb53 fb53 s ISR_DISPATCH	EQU	HRAM_CODE
fb53 fb53 s ISR_RET		EQU	ISR_RET_OFF+HRAM_CODE ;Assign address in the HIGH RAM
fb53 fb53 s GET_MEM		EQU	GET_MEM_OFF+HRAM_CODE ;Assign address in the HIGH RAM	
fb53 fb53 s 
fb53 fb53 s 
fb53 fb53 s HR_EXE_GO	DS	HR_EXEC_GS_LEN	;Routine for Switching to RAM and Executing loaded program.
fb5b fb5b s 
fb5b fb5b s HERE1		EQU	$
fb5b fb5b s 
fb5b fb5b s 	IF HERE1 > 0xFB80
fb5b fb5b s 	   ERROR RAM OVERLAP AT 0xFB80
fb5b fb5b s 	ENDIF
fb5b fb5b s 	
fb5b fb5b s 	;FREE RAM 25 BYTES
fb5b fb5b s 
fb80 fb80 s 		ORG	0xFB80
fb80 fb80 s ;SDFCB:
fb80 fb80 s FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
fb80 fb80 s FNAME		EQU	1	;DS 11	;+1  File name
fb80 fb80 s AFClus0		EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
fb80 fb80 s CRFClus		EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
fb80 fb80 s CAFClus		EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
fb80 fb80 s RFSec		EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
fb80 fb80 s SSOC		EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
fb80 fb80 s ABS_SEC		EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
fb80 fb80 s FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)
fb80 fb80 s 
fb80 fb80 s ;Warning: FCB's must never cross page boundaries.
fb80 fb80 s SDISKA		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fba0 fba0 s SDISKB		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fbc0 fbc0 s SDISKC		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fbe0 fbe0 s SDISKD		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
fc00 fc00 s 
fc00 fc00 s ;
fc00 fc00 s ;  ********   **     **  *********  *********  *********  ******** 
fc00 fc00 s ;  *********  **     **  *********  *********  *********  *********
fc00 fc00 s ;  **     **  **     **  **         **         **         **     **
fc00 fc00 s ;  **     **  **     **  **         **         **         **     **
fc00 fc00 s ;  ********   **     **  *******    *******    *******    ******** 
fc00 fc00 s ;  ********   **     **  *******    *******    *******    ******** 
fc00 fc00 s ;  **     **  **     **  **         **         **         **  **   
fc00 fc00 s ;  **     **  **     **  **         **         **         **   **  
fc00 fc00 s ;  *********  *********  **         **         *********  **    ** 
fc00 fc00 s ;  ********    *******   **         **         *********  **     **
fc00 fc00 s ;
fc00 fc00 s 		ORG	0xFC00
fc00 fc00 s SD_RAM_BUFFER	DS	512	;FC00-FDFF 512 bytes of SD Sector Buffer space
fe00 fe00 s 
fe00 fe00 s RXBUFFER	DS	256	;FExx      256 bytes of RX Buffer space
ff00 ff00 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ff00 ff00 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ff00 ff00 s ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ff00 ff00 s 
ff00 ff00 s 
ff00 ff00 s 		ORG	0xFF00
ff00 ff00 s BIT_TABLE	DS	8
ff08 ff08 s 
ff08 ff08 s ;Warning: FCB's must never cross page boundaries.
ff08 ff08 s FCB_PTR		DS	2	;Pointer to Current FCB
ff0a ff0a s 
ff0a ff0a s 
ff0a ff0a s FAT_CLEAR	EQU	$	;Clear bytes of RAM after this point on FAT_INIT
ff0a ff0a s GH_START	DS	2	;HEX File, start address
ff0c ff0c s VIEW_FLAGS	DS	1	;View File Load;  File Open View
ff0d ff0d s 				;BIT .0=View HEX Load, display file while reading HEX file
ff0d ff0d s 				;    .1=GH_START Address has been set
ff0d ff0d s 				;    .6=View FILE SIZE during File Open
ff0d ff0d s 				;    .7=View File Name & Found or Not status durin File Open
ff0d ff0d s 
ff0d ff0d s LOGICAL_SEC	DS	2	;Logical Sector for next Read Operation (Input paramater for the File Read)
ff0f ff0f s 
ff0f ff0f s DIRTY_DATA	DS	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
ff10 ff10 s SD_CARD_TYPE	DS	1	;SD CARD TYPE
ff11 ff11 s SDC_STATUS	DS	1	;SD Status Code returned
ff12 ff12 s SD_PARAM	DS	4	;32 bit address parameter for SD Commands
ff16 ff16 s SD_PART_TYPE	DS	1	;SD PARTITION TYPE
ff17 ff17 s SD_PART_BASE	DS	4	;SD PARTITION STARTING RECORD
ff1b ff1b s SD_PART_SIZE	DS	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
ff1f ff1f s BYTE_P_SEC	DS	2	;0x0B Bytes per Sector (Almost always 512)
ff21 ff21 s SEC_PER_CLUS	DS	1	;0x0D
ff22 ff22 s RESERVED_SEC	DS	2	;0x0E - 0x0F
ff24 ff24 s FAT_COPIES	DS	1	;0x10
ff25 ff25 s ROOTDIR_SIZE	DS	2	;0x11 - 0x12
ff27 ff27 s FILESYS_SEC	DS	4	;0x13 - 0x14 or 0x20 - 0x23
ff2b ff2b s HIDDEN_SEC	DS	4	;0x1C - 0x1F
ff2f ff2f s SEC_PER_FAT	DS	2	;0x16 - 0x17
ff31 ff31 s FAT1START	DS	4	;Calculated Sector to FAT1
ff35 ff35 s DIR_SECTOR	DS	4	;Calculated Sector to Root Directory
ff39 ff39 s DATASTART	DS	4	;Calculated Sector to Data Area
ff3d ff3d s SEC_PTR		DS	4	;Sector Pointer, general use variable that holds the last sector read
ff41 ff41 s ENT_COUNT	DS	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
ff43 ff43 s FAT_CLR_LEN	EQU	$ - FAT_CLEAR 
ff43 ff43 s FILENAME	DS	8	;File Name
ff4b ff4b s FILEEXT		DS	3	;File Extension
ff4e ff4e s FILESIZE	DS	4	;File Size
ff52 ff52 s 
ff52 ff52 s 
ff52 ff52 s DIVIDE_FUNC	DS	2	;Pointer to the Divide Function
ff54 ff54 s DF_SHIFTCNT	DS	1	;Count of shifts required for Fast Divide
ff55 ff55 s MUL8		DS	1	;8 bit multiplier
ff56 ff56 s MOD_FUNC	DS	2	;Pointer to the Mod Function
ff58 ff58 s MODMASK		DS	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector
ff59 ff59 s 
ff59 ff59 s IK_HEXL		DS	1	;IMON HEX INPUT
ff5a ff5a s IK_HEXH		DS	1	;IMON HEX INPUT
ff5b ff5b s HEX_SOURCE	DS	2	;Pointer to the HEX INPUT Source (FILE or Serial Port)
ff5d ff5d s 
ff5d ff5d s 	IF $ >= 0xFF78
ff5d ff5d s 	   ERROR RAM ALLOCATION ERROR
ff5d ff5d s 	ENDIF
ff5d ff5d s 
ff5d ff5d s ;*** BEGIN COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
ff5d ff5d s RAMSIGNATURE	equ	0xFF78	;RAM signature
ff5d ff5d s 				;Following bytes are cleared on COLD BOOT
ff5d ff5d s RC_TYPE		equ	0xFF80	;(1) Type of Reset (WARNING, Next 7 RC counters must end with lsb bits = 001,010,011,100,101,110,111)
ff5d ff5d s RC_SOFT		equ	0xFF81	;(1) Count of Resets by SOFT F-E SWITCH
ff5d ff5d s RC_STEP		equ	0xFF82	;(1) Count of Resets by SINGLE STEP
ff5d ff5d s RC_CC		equ	0xFF83	;(1) Count of Resets by CTRL-C
ff5d ff5d s RC_HALT		equ	0xFF84	;(1) Count of Resets by HALT INSTRUCTION
ff5d ff5d s RC_F0		equ	0xFF85	;(1) Count of Resets by pressing F & 0 keys
ff5d ff5d s RC_RST0		equ	0xFF86	;(1) Count of Resets by RST 0 INSTRUCTION
ff5d ff5d s RC_HARD		equ	0xFF87	;(1) Count of Resets by UNKNOWN RESET LINE
ff5d ff5d s 
ff5d ff5d s ABUSS		equ	0xFF88	;(2) 
ff5d ff5d s RegPtr		equ	0xFF8A	;(1) Ptr to Registers
ff5d ff5d s IoPtr		equ	0xFF8B	;(1)  I/O Ptr
ff5d ff5d s RX_ERR_LDRT	equ	0xFF8C	;(1) Counts False Start Bits (Noise Flag)
ff5d ff5d s RX_ERR_STOP	equ	0xFF8D	;(1) Counts Missing Stop Bits (Framing Error)
ff5d ff5d s RX_ERR_OVR	equ	0xFF8E	;(1) Counts Overrun Errors
ff5d ff5d s 
ff5d ff5d s CS_CLR_LEN	equ	0xFF8F-RC_TYPE
ff5d ff5d s 
ff5d ff5d s ACE_BAUD	equ	0xFF8F	;(1) Baudrate of ACE, 12=9600
ff5d ff5d s 
ff5d ff5d s 				;PUTCHAR_EXE and INCHAR_EXE *must be consecutive in this order*
ff5d ff5d s PUTCHAR_EXE	equ	0xFF90	;(2) PutChar Execution (Set for PC_LED, PC_BIT, PC_ACE or PC_BOTH)
ff5d ff5d s INCHAR_EXE	equ	0xFF92	;(2) InChar Execution (Set for IN_KEY, IN_BIT, IN_ACE or IN_BOTH)
ff5d ff5d s ;*** END COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
ff5d ff5d s 
ff5d ff5d s HW_SETIO	equ	0xFF94	;Serial IO selected, 01=Bit, 02=ACE, 03=BIT & ACE
ff5d ff5d s HW_LIST		equ	0xFF95	;Hardware List, 00=NO Boards, 01=FP Only, 02=SIO only, 03=FP & SIO
ff5d ff5d s 
ff5d ff5d s 				;Saved Registers
ff5d ff5d s RSSP		equ	0xFF96	;Value of SP upon REGISTER SAVE
ff5d ff5d s RSAF		equ	0xFF98	;Value of AF upon REGISTER SAVE
ff5d ff5d s RSBC		equ	0xFF9A	;Value of BC upon REGISTER SAVE
ff5d ff5d s RSDE		equ	0xFF9C	;Value of DE upon REGISTER SAVE
ff5d ff5d s RSHL		equ	0xFF9E	;Value of HL upon REGISTER SAVE
ff5d ff5d s RPC		equ	0xFFA0	;Value of PC upon REGISTER SAVE
ff5d ff5d s RSIX		equ	0xFFA2	;Value of IX upon REGISTER SAVE
ff5d ff5d s RSIY		equ	0xFFA4	;Value of IY upon REGISTER SAVE
ff5d ff5d s RSIR		equ	0xFFA6	;Value of IR upon REGISTER SAVE
ff5d ff5d s RSAF2		equ	0xFFA8	;Value of AF' upon REGISTER SAVE
ff5d ff5d s RSBC2		equ	0xFFAA	;Value of BC' upon REGISTER SAVE
ff5d ff5d s RSDE2		equ	0xFFAC	;Value of DE' upon REGISTER SAVE
ff5d ff5d s RSHL2		equ	0xFFAE	;Value of HL' upon REGISTER SAVE
ff5d ff5d s 
ff5d ff5d s UiVec		equ	0xFFB0	;(2) User Interrupt Vector
ff5d ff5d s 
ff5d ff5d s 
ff5d ff5d s ;*** BEGIN WARM_BOOT_INIT (RAM that is to be initialized on every boot) ***
ff5d ff5d s 				;WARNING, Following 34 bytes must be consecutive in this order for Block Write
ff5d ff5d s BEEP_TO		equ	0xFFB2	;(1) Count down the beep (beep duration)
ff5d ff5d s ANBAR_DEF	equ	0xFFB3	;(1) Base setting for the Annunciator LED's (after current function times out)
ff5d ff5d s GET_REG		equ	0xFFB4	;(2) Get Reg Routine (in monitor mode, registers fetched from RAM)
ff5d ff5d s PUT_REG		equ	0xFFB6	;(2) Put Reg Routine
ff5d ff5d s CTRL_C_CHK	equ	0xFFB8	;(2) Vector for CTRL-C Checking
ff5d ff5d s LDISPMODE	equ	0xFFBA	;(2) Last Display Mode (Holds DISPMODE while in HEX Entry)
ff5d ff5d s DISPMODE	equ	0xFFBC	;(2) Display Routine
ff5d ff5d s KEY_EVENT	equ	0xFFBE	;(2) Routine to call upon Key Press (changes based on user actions, see KEY_EVENT_DISPATCH)
ff5d ff5d s IK_TIMER	equ	0xFFC0	;(1) IMON TIMEOUT
ff5d ff5d s KEYBFMODE	equ	0xFFC1	;(1) KEY INPUT MODE. 8F=HEX INPUT, 90=Shiftable
ff5d ff5d s DISPLABEL	equ	0xFFC2	;(1) Display Label Refresh
ff5d ff5d s IK_HEXST	equ	0xFFC3	;(1) IMON HEX Input State
ff5d ff5d s HEX_CURSOR	equ	0xFFC4	;(2) HEX Input Cursor location
ff5d ff5d s HEX_READY	equ	0xFFC6	;(2) HEX Input Ready
ff5d ff5d s LED_CURSOR	equ	0xFFC8	;(2) Cursor location for LED Put_Char
ff5d ff5d s RXBHEAD		equ	0xFFCA	;(2) RS-232 RX BUFFER HEAD
ff5d ff5d s RXBTAIL		equ	0xFFCC	;(2) RS-232 RX BUFFER TAIL
ff5d ff5d s INT_VEC		equ	0xFFCE	;(2) Vector to Interrupt ISR
ff5d ff5d s SCAN_PTR	equ	0xFFD0	;(2) SCAN_PTR points to next LED_DISPLAY byte to output (will always be 1 more
ff5d ff5d s 				;    than the current hardware column because hardware automatically advances)
ff5d ff5d s HALT_TEST	equ	0xFFD2	;(2) HALT_TEST
ff5d ff5d s ;*** END WARM_BOOT_INIT (RAM BLOCK that is to be initialized on every boot) ***
ff5d ff5d s 
ff5d ff5d s 
ff5d ff5d s CLEARED_SPACE	equ	0xFFD4	;Bytes here and later are cleared upon init (some initialized seperately)
ff5d ff5d s CLEARED_LEN	equ	0xFFFF - CLEARED_SPACE + 1
ff5d ff5d s 
ff5d ff5d s SDISPMODE	equ	0xFFD4	;(2)
ff5d ff5d s POS_BIT		equ	0xFFD6	;(1) BIT Bang RS232 Character position
ff5d ff5d s POS_ACE		equ	0xFFD7	;(1) ACE RS232 Character position
ff5d ff5d s ISR_FLAGS	equ	0xFFD8	;(1) Indicates how many levels the ISR has nested
ff5d ff5d s RRSTATE		equ	0xFFD9	;(1) RAM/ROM SELECT STATE (FOR RETURN FROM ISR)	
ff5d ff5d s XTIMER_TIC	equ	0xFFDA	;(1) Counts Down tics until Extended Timer ISR_EXXTIMER
ff5d ff5d s READ_RAMROM	equ	0xFFDB	;(1) Selected RAMROM for Monitor READ Operations.  Bit0 for RAM/ROM, Bits1-4 for Bank
ff5d ff5d s 
ff5d ff5d s NMI_VEC		equ	0xFFDC	;(2) NMI VEC.  Not used
ff5d ff5d s 
ff5d ff5d s CTRL_C_TIMER	equ	0xFFDE	;Count down the CTRL-C condition
ff5d ff5d s SOFT_RST_FLAG	equ	0xFFDF	;Flag a Soft Reset (F-E Keys, Single Step)
ff5d ff5d s 
ff5d ff5d s 				;Display/Serial Comms
ff5d ff5d s LED_DISPLAY	equ	0xFFE0	;8 Bytes of LED Output bytes to Scan to hardware
ff5d ff5d s ;8 Bytes			;Warning, LED_DISPLAY must be nibble aligned at E0 (XXE0)
ff5d ff5d s LED_ANBAR	equ	0xFFE7	;LED Annunciator Bar (Part of LED_DISPLAY Buffer)
ff5d ff5d s 				;.0 = x7 = BEEPER
ff5d ff5d s 				;.1 = x6 = Run Mode
ff5d ff5d s 				;.2 = x5 = Monitor Mode (Default Mode upon Power up)
ff5d ff5d s 				;.3 = x4 = Send Data to Output Port
ff5d ff5d s 				;.4 = x3 = Alter Memory/Register
ff5d ff5d s 				;.5 = x2 = Enter Memory Location
ff5d ff5d s 				;.6 = x1 = Enter Register
ff5d ff5d s 
ff5d ff5d s KBCOLSAMPLED	equ	0xFFE8	;Columns Sampled
ff5d ff5d s KBPORTSAMPLE	equ	0xFFE9	;Input Port sampled only once on each scan, saved here
ff5d ff5d s KBHEXSAMPLE	equ	0xFFEA	;KEY SAMPLER Input HEX format
ff5d ff5d s KEYBSCANPV	equ	0xFFEB	;KEY Input HEX format
ff5d ff5d s KEYBSCANTIMER	equ	0xFFEC	;KEY Input TIMER
ff5d ff5d s KEY_PRES_EV	equ	0xFFED	;KEY INPUT LAST & Currently Processing
ff5d ff5d s KEY_PRES_RTN	equ	0xFFEE	;KEY LAST, for Return To Normal between strokes
ff5d ff5d s KEY_PRESSED	equ	0xFFEF	;(1) KEY PRESSED
ff5d ff5d s 
ff5d ff5d s TicCounter	equ	0xFFF0	;Tic Counter
ff5d ff5d s ;TicCounter	equ	0xFFF1	;
ff5d ff5d s ECHO_STATE	equ	0xFFF2	;Echo characters
ff5d ff5d s XMSEQ		equ	0xFFF3	;XMODEM SEQUENCE NUMBER
ff5d ff5d s XMTYPE		equ	0xFFF4	;XMODEM BLOCK TYPE (CRC/CS)
ff5d ff5d s SCAN_LED	equ	0xFFF5	;Holds the next LED output
ff5d ff5d s LED_DISPLAY_SB	equ	0xFFF6	;10 Bytes FFF6=Start BIT, 7,8,9,A,B,C,D,E=Data bits, F=Stop BIT
ff5d ff5d s ;10 bytes	equ	0xFFFF	;Warning, LED_DISPLAY_TBL must be at this address (XXF6) Roll over to xx00 tested
ff5d ff5d s 
ff5d ff5d s 
ff5d ff5d s 
ff5d ff5d s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
ff5d ff5d s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
ff5d ff5d s ;	Appendix_D	HOOK LOCATIONS
ff5d ff5d s ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
ff5d ff5d s ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
ff5d ff5d s 
0042 0042 s 		org	0x0042
0042 0042 d c3e203
0042 0042 u 03 01
0042 0042 s VMAIN_MENU	JP	MAIN_MENU	;MONITOR
0045 0045 d c3ec13
0045 0045 u 03 01
0045 0045 s VPUT_CHAR	JP	PUT_CHAR	;PUT_CHAR
0048 0048 d c3cd13
0048 0048 u 03 01
0048 0048 s VGET_POS	JP	GET_POS		;Return the Position of the cursor on the line
004b 004b d c3e013
004b 004b u 03 01
004b 004b s VGET_CHAR	JP	GET_CHAR
004e 004e d c30814
004e 004e u 03 01
004e 004e s VRX_COUNT	JP	RX_COUNT	;Count of Characters waiting in the RX Buffer
0051 0051 d c32114
0051 0051 u 03 01
0051 0051 s VIN_CHAR	JP	IN_CHAR		;Returns a char or C=1 if none.
0054 0054 d c34b14
0054 0054 u 03 01
0054 0054 s VTIMED_GETCHAR	JP	TIMED_GETCHAR
0057 0057 d c3bd0d
0057 0057 u 03 01
0057 0057 s VPRINT		JP	PRINT
005a 005a d c3d127
005a 005a u 03 01
005a 005a s VBEEP		JP	BEEP
005d 005d s 
005d 005d d c3d527
005d 005d u 03 01
005d 005d s VSET_ECHO	JP	SET_ECHO
0060 0060 d c32c0e
0060 0060 u 03 01
0060 0060 s VDELAY_C	JP	DELAY_C		;Loop based on C, 100mSEC
0063 0063 d c33a0e
0063 0063 u 03 01
0063 0063 s VDELAY_A	JP	DELAY_A		;Milli seconds based on A, requires FP board
0066 0066 s 
006b 006b s 		org	0x006B
006b 006b d c39b08
006b 006b u 03 01
006b 006b s VPUT_VERSION	JP	PUT_VERSION
006e 006e d c3090e
006e 006e u 03 01
006e 006e s VPUT_HEX	JP	PUT_HEX
0071 0071 d c3f60d
0071 0071 u 03 01
0071 0071 s VPUT_BYTE	JP	PUT_BYTE
0074 0074 d c3d80d
0074 0074 u 03 01
0074 0074 s VPUT_BC		JP	PUT_BC
0077 0077 d c3e10d
0077 0077 u 03 01
0077 0077 s VPUT_DE		JP	PUT_DE
007a 007a d c3ea0d
007a 007a u 03 01
007a 007a s VPUT_HL		JP	PUT_HL
007d 007d d c3190e
007d 007d u 03 01
007d 007d s VPUT_SPACE	JP	PUT_SPACE
0080 0080 d c31f0e
0080 0080 u 03 01
0080 0080 s VPUT_NEW_LINE	JP	PUT_NEW_LINE
0083 0083 s 
0083 0083 d c34c0d
0083 0083 u 03 01
0083 0083 s VGET_BYTE	JP	GET_BYTE
0086 0086 d c3790d
0086 0086 u 03 01
0086 0086 s VGET_WORD	JP	GET_WORD	;DE
0089 0089 d c3950d
0089 0089 u 03 01
0089 0089 s VGET_HEX	JP	GET_HEX
008c 008c s 
008c 008c d c3100c
008c 008c u 03 01
008c 008c s VCLEAR_BLOCK	JP	CLEAR_BLOCK	;CLEAR_BLOCK
008f 008f d c34a0e
008f 008f u 03 01
008f 008f s VLD_HL_HL	JP	LD_HL_HL
0092 0092 d c3450e
0092 0092 u 03 01
0092 0092 s VADD_HL_A	JP	ADD_HL_A
0095 0095 d c33e27
0095 0095 u 03 01
0095 0095 s VMOV_32_HL	JP	MOV_32_HL	;Move (HL) to 32 bit register BCDE
0098 0098 d c34927
0098 0098 u 03 01
0098 0098 s VMOV_HL_32	JP	MOV_HL_32	;Move 32 bit register BCDE to (HL)
009b 009b d c35427
009b 009b u 03 01
009b 009b s VADD_32_HL	JP	ADD_32_HL	;ADD (HL) to 32 bit register BCDE - (returns with HL changed to last byte)
009e 009e d c37827
009e 009e u 03 01
009e 009e s VCMP_HL_32	JP	CMP_HL_32	;Compare BCDE with 32bit word at HL
00a1 00a1 d c36527
00a1 00a1 u 03 01
00a1 00a1 s VINC_32		JP	INC_32		;INC BCDE
00a4 00a4 d c36b27
00a4 00a4 u 03 01
00a4 00a4 s VDEC_32		JP	DEC_32		;DEC BCDE
00a7 00a7 d c37327
00a7 00a7 u 03 01
00a7 00a7 s VTSTZ_32	JP	TSTZ_32		;TEST_ZERO BCDE
00aa 00aa s 
00aa 00aa d c3c227
00aa 00aa u 03 01
00aa 00aa s VASC2BIN	JP	ASC2BIN
00ad 00ad d c3980d
00ad 00ad u 03 01
00ad 00ad s VASC2HEX	JP	ASC2HEX
00b0 00b0 d c30f0e
00b0 00b0 u 03 01
00b0 00b0 s VHEX2ASC	JP	HEX2ASC		
00b3 00b3 d c3b227
00b3 00b3 u 03 01
00b3 00b3 s VTO_UPPER	JP	TO_UPPER
00b6 00b6 s 
00b6 00b6 d c38613
00b6 00b6 u 03 01
00b6 00b6 s VSET_IO		JP	SET_IO
00b9 00b9 d c3ba14
00b9 00b9 u 03 01
00b9 00b9 s VIC_KEY		JP	IC_KEY
00bc 00bc d c3d927
00bc 00bc u 03 01
00bc 00bc s VLED_UPDATE	JP	LED_UPDATE	;Turn ON/OFF LED UPDATE & KEY MON
00bf 00bf s 
00bf 00bf d c3e927
00bf 00bf u 03 01
00bf 00bf s VLED_GET_POS	JP	LED_GET_POS
00c2 00c2 d c3ef27
00c2 00c2 u 03 01
00c2 00c2 s VLED_SET_POS	JP	LED_SET_POS
00c5 00c5 d c37714
00c5 00c5 u 03 01
00c5 00c5 s VLED_HOME	JP	LED_HOME
00c8 00c8 d c38a14
00c8 00c8 u 03 01
00c8 00c8 s VLED_PUT_CHAR	JP	PC_LED		;C = CHAR
00cb 00cb d c3781c
00cb 00cb u 03 01
00cb 00cb s VLED_PRINT	JP	LED_PRINT
00ce 00ce d c3601c
00ce 00ce u 03 01
00ce 00ce s VLED_PUT_BYTE	JP	LED_PUT_BYTE
00d1 00d1 d c36c1c
00d1 00d1 u 03 01
00d1 00d1 s VLED_PUT_HEX	JP	LED_PUT_HEX
00d4 00d4 d c38014
00d4 00d4 u 03 01
00d4 00d4 s VLED_CLEAR	JP	LED_CLEAR
00d7 00d7 d c3f727
00d7 00d7 u 03 01
00d7 00d7 s VLED_RIGHT	JP	LED_RIGHT
00da 00da d c30c28
00da 00da u 03 01
00da 00da s VLED_LEFT	JP	LED_LEFT
00dd 00dd s 
00dd 00dd d c30521
00dd 00dd u 03 01
00dd 00dd s VPRINT_FNAME	JP	PRINT_FILENAME
00e0 00e0 d c32a21
00e0 00e0 u 03 01
00e0 00e0 s VINPUT_FNAME	JP	INPUT_FILENAME
00e3 00e3 d c3b61d
00e3 00e3 u 03 01
00e3 00e3 s VSD_OPEN	JP	SD_OPEN			;Copy FCB to filename then search & open
00e6 00e6 d c3a91d
00e6 00e6 u 03 01
00e6 00e6 s VSD_OPEN_FILENAME JP	SD_OPEN_FILENAME	;Copy Filename to FCB then search & open
00e9 00e9 d c35e1d
00e9 00e9 u 03 01
00e9 00e9 s VPRINT_DIR	JP	PRINT_DIR
00ec 00ec d c38821
00ec 00ec u 03 01
00ec 00ec s VDISK_READ	JP	DISK_READ
00ef 00ef d c39624
00ef 00ef u 03 01
00ef 00ef s VSD_READ_SEC	JP	SD_READ_SEC
00f2 00f2 d c3281e
00f2 00f2 u 03 01
00f2 00f2 s VLINE_INPUT	JP	LINE_INPUT
00f5 00f5 s 
00f5 00f5 s 		END	0
0000 e
2ccd a CLRARY
8032 v TB
2fc2 a V1
1e96 a LI_EOL
ffc0 v IK_TIMER
3472 a X0
320f a MEXIT
31ab a HISG
2f18 a Z1
2f28 a Z2
2f29 a Z3
310f a SKIP
ffd9 v RRSTATE
2b3d a MOVL
2201 a DR_SEEK_FAT
1da9 a SD_OPEN_FILENAME
00e6 a VSD_OPEN_FILENAME
00c2 v BITS_Q2
00c3 v BITS_Q3
1c93 a GO_SD_CARD
2d32 a THEN
1007 a XMR_CRC
22b2 a DR_SAME_CLUS
080b a PORT_SPEED
2105 a PRINT_FILENAME
fa00 a LINE_BUFF
0018 v CAN
1f8e a RHF_ERR_ON_LINE
0cc7 a GRR_SUB_AF
33d2 a CG1
0ccf a GRR_SUB_BC
34e3 a CHR
0cd2 a GRR_SUB_DE
34a8 a CL2
1738 a IKEY1_UP
2a4e a CMD
0cd5 a GRR_SUB_HL
223b a DR_SEEK_1
0cec a GRR_SUB_IR
0ce4 a GRR_SUB_IX
0ce8 a GRR_SUB_IY
198f a HEX2OUT_PORT
fb80 a SDISKA
fba0 a SDISKB
fbc0 a SDISKC
fbe0 a SDISKD
81fb v CSP
0cdd a GRR_SUB_PC
27f7 a LED_RIGHT
0f52 a XMS_SEND
fb28 a SP_ISR_SAVE
30ee a ESP1
ff10 a SD_CARD_TYPE
007a v NEGTEXT
3630 a RDY
2e15 a REM
13a2 a SIO_OK
3037 a CDAT
0e4f a GETHEXFILE
1796 a IK_KEYDN_EVENT
2e11 a NOMORE
fb2a a HRAM_CODE
0b11 a PUT_3C_SPACES
ffa0 v RPC
00e0 a VINPUT_FNAME
273e a MOV_32_HL
2cec a RUN
1668 a IRXD_SAVE
087a a DISP_RRBANK
101e a XMR_CS
1be7 a IDISP_IN_DATA
0042 v BEXIT
175d a IKEYP_NCOS
103a a XMR_LP
14ba a IC_KEY
307e a DAT1
8238 v DATA
235a a INITFAT_TFS_OK
ffbc v DISPMODE
0e26 a TINC
0150 a RTHW_LP
0011 v DC1
0013 v DC3
015d a RTHW_OK
2bb6 a DEL
359f a DER
0c06 a PORT_OUT
2f3e a DIM
3213 a DIV
0942 a REGORDER
07ba a PUT_IOMSG
13e6 a GET_CHAR_LP
0010 v DLE
1e28 a LINE_INPUT
13da a GET_CHAR_NE
0e0f a HEX2ASC
0892 a DRR_ROM
0cb1 a PURR_TBL
124a a RT3_LP1
1252 a RT3_LP2
1253 a RT3_LP3
125d a RT3_LP4
125e a RT3_LP5
ff22 a RESERVED_SEC
ffdc v NMI_VEC
1a05 a IDRR_ROM
80f9 v LSTCHR
00ce a VLED_PUT_BYTE
1eba a CLEAR_LINE_BUFF
07da a WHICH_PORT
34db a FILBUF
00c7 v ACE_RESET
006e a VPUT_HEX
8237 v EFLAG
30df a ETOP
32eb a ASTOR
00a4 a VDEC_32
0ec3 a READ_SERIAL
3305 a EQUAL
ff8a v RegPtr
16ec a DO_HALT_TEST
ffba v LDISPMODE
0c8d a PURRS_RET
3048 a SL1
00c5 a VLED_HOME
0001 v SOH
26a5 a SDC_1
26ac a SDC_2
ffec v KEYBSCANTIMER
327b a CEIL
22d5 a DR_READ_IT
2b9e a ELOOP
0b60 a GO_EXEC_T
35ea a SYN
0b0b a CP_HL_DE
005d a VSET_ECHO
00c0 v SDCLK
00ef a VSD_READ_SEC
308c a GDEND
ff25 a ROOTDIR_SIZE
33cc a CEXP
324d a OKKK
17ff a UiVec_RET
0af8 a DL_P2K1
0afe a DL_P2K2
0aed a DL_PSE2
0340 a R_STEP
148a a PC_LED
333a a EG1
0ae3 a DL_PSL2
3343 a EGO
3340 a EGZ
ff78 v RAMSIGNATURE
ff8d v RX_ERR_STOP
154d a PC_LP0
ff94 v HW_SETIO
2c57 a HPOUT
2c4e a EOF
0000 v EOS
0004 v EOT
1477 a LED_HOME
1af4 a ICMD_SR_OK
2a80 a ERR
ffb8 v CTRL_C_CHK
0051 a VIN_CHAR
240d a INITFAT_C4_LP
2032 a GH_EXEC
2382 a INITFAT_C1_DONE
14f6 a ACE_SET_BAUD
1f30 a RHF_LINE
27d5 a SET_ECHO
34ed a BGETCHR
2bbf a DELLP
2483 a TEST_SIGNATURE
0e2f a DELAY_LP
2bba a DELNX
17cf a IKC_REFRESH
2b07 a OKPRT
155a a PC_NOFP
2a2c a TOP
0000 v FSTAT
1218 a RT4_NX
2d43 a GOTO
2c26 a TRY
348b a QTST
fb3b v ISR_RET
1920 a HEX2ABUSS
31cc a DCLB
2d5e a NOON
0100 a RESETLDRT
0a5f a MEM_DUMP
019b a RAMSIG_LP
0045 v BPUTCHR
08f8 a PVH_0
0906 a PVH_1
163b a ISR_RXD
ff4b a FILEEXT
0194 a CHK_RESET
80fb v CURSOR
144e a TGC_LP1
1450 a TGC_LP2
ffee v KEY_PRES_RTN
1480 a LED_CLEAR
20cb a SD_LDIR1
20e0 a SD_LDIRN
1817 a CTRL_C_TEST
30da a EVAL
0dba a GHC_NRET
2d7b a FOR
00cb v ACE_LCR
0cc1 a GRR_SUB
2cdf a RESET
309b a VER1
ff80 v RC_TYPE
1d4a a DO_DIR
1277 a RT3_NX1
2eb2 a DECPRT
140e a RXC_DO
000c v AFClus0
1ef4 a READ_HEX_FILE
07b4 a SW2_BOTH
2f31 a INERR
2aa2 a FSOL
325f a DIVZE
ffe0 v LED_DISPLAY
ffc3 v IK_HEXST
2754 a ADD_32_HL
ff92 v INCHAR_EXE
1c8d a LED_PRINTI
0dd8 a PUT_BC
1c7a a LED_PRINT_LP
0de1 a PUT_DE
144b a TIMED_GETCHAR
2fc8 a USR
0dea a PUT_HL
0011 v ISR_RET_OFF
2d6e a RETURN
ff0c a VIEW_FLAGS
0d98 a ASC2HEX
0f86 a XMS_CS
0f4a a XMS_DO
20bd a SD_FIND_FILE
0ca1 a GRR_TBL
1403 a PC_NCR
3229 a DODIV
2a51 a TLP0
00da a VLED_LEFT
1461 a RXC_BOTH
2b6d a GF0
2b6c a GF1
2b79 a GF2
2b7a a GF3
ffb6 v PUT_REG
fff3 v XMSEQ
1d74 a SDLF_LP
fa80 a LINE_BUFFEND
3289 a LAND
0479 a PRINT_MENU
1938 a ICMD_BYTE
32e5 a SRSEED
ffd2 v HALT_TEST
ff8e v RX_ERR_OVR
3253 a OVER1
0c10 a CLEAR_BLOCK
823a v LAST
02f1 a NOT_COLD
0c39 a REGNAMES
1440 a DGC_DOT
2f9e a LOOKT
31c9 a LOOKU
00ce v ACE_MSR
2ef2 a RETRY
2ad7 a LOOP1
ff90 v PUTCHAR_EXE
1c1c a IDISP_OUT_DATA
30fc a CHAR
80ff v IOCON
ff98 v RSAF
26f8 a WNB_LP
ff9a v RSBC
ffeb v KEYBSCANPV
280c a LED_LEFT
ff9c v RSDE
0a15 a MEM_ENTER
31cd a OLOOK
ff9e v RSHL
ffa6 v RSIR
ffa2 v RSIX
ffa4 v RSIY
10b3 a XMGET_HDR
26cf a SDC_LP
ff96 v RSSP
0c94 a SHORTNWAY
00b6 a VSET_IO
2bea a IL01
2c0a a IL02
3019 a DERR
2b8a a GINST
0e2a a DELAY_100mS
2a00 a BASIC
0ad4 a DL_P1E
00a7 a VTSTZ_32
0ac1 a DL_P1L
09f2 a LB_0
09f8 a LB_1
0a03 a LB_2
0aef a DL_P2L
ff8f v ACE_BAUD
2730 a DBS_LP
1541 a PC_REDO
0a2f a MEN_CHK
00aa a VASC2BIN
17df a IKEY_DONE
0eeb a RS_TIMEOUT
313e a DOEXP
017e a RTHW_SIO_EXIT
1969 a ICMD_BYTE2
1187 a RT2_LP0
1188 a RT2_LP1
1191 a RT2_LP2
1197 a RT2_LP3
119d a RT2_LP4
1639 a PC_RET1
202c a IS_CRLF
1c53 a LED_PUT_HEX_HL
000e v CRFClus
007d a VPUT_SPACE
3135 a EXPR
0316 a RS232_SPLASH
0080 a VPUT_NEW_LINE
2f7d a TABENT
0ecb a RS_LP
168b a IRXD_RESET
00cf v ACE_SCRATCH
165b a IRXD_STP
24cd a SD_RS_0
24dc a SD_RS_1
0d95 a GET_HEX
00e9 a VPRINT_DIR
1a95 a ISINGLE_LP
0045 a VPUT_CHAR
31f8 a MUL1
ff55 a MUL8
00cb a VLED_PRINT
31e4 a MULT
32a4 a GRTR
2b58 a GRUB
2f5c a DLOOP
00bf a VLED_GET_POS
ffca v RXBHEAD
23c3 a INITFAT_C3_ERR
000f v CS_CLR_LEN
27ef a LED_SET_POS
0db8 a GHC_ARET
25ca a INIT_FAIL
0374 a SPLASH_VERSION
3644 a SIMSG
2e44 a PLOT
2583 a SP_RET
091f a REG_DISP_ALL
2bd0 a ILP
2b18 a IND
35e0 a INL
2bc7 a INS
0345 a R_CC
13ec a PUT_CHAR
2c1f a LINEF
205c a GH_EXEC_GO2
0357 a R_F0
ffde v CTRL_C_TIMER
ffd8 v ISR_FLAGS
217d a CMPF_RETFAIL
3258 a OVRSUB
0012 v RFSec
80f7 v STACK
8064 v XBF
267d a SD_DESELECT
ff0f a DIRTY_DATA
0048 a VGET_POS
00cc v ACE_OUT
2771 a DEC_32NB
13a0 a SIO_ZERO
224f a DRS_0
0b12 a PUT_3C_SPACES_L
20c0 a SDFF_LP
ffb0 v UiVec
ff84 v RC_HALT
2803 a LEDR_LP
1b9c a IDISP_MEM
ff87 v RC_HARD
10fb a CRC_UPC
fb28 v STACK_ISR1
0c1d a WRITE_BLOCK
8235 v IFLAG
182e a CTRL_C_CHK_ON
00b3 a VTO_UPPER
2baf a EDIT
31b9 a BRKTS
276b a DEC_32
208b a SDV_FIND_FILE
8100 v EDBUF
005a a VBEEP
2d3b a GOSUB
027c a LED_SPLASH_TBL
02ea a RAMSIGN_LP
2688 a SD_SELECT
17ae a IK_NOKEY_EVENT
17be a IKC_RESET_CMD
fff0 v TicCounter
323b a DIVTOP
0c16 a FILL_BLOCK
80fd v USROUT
16b9 a ISR_EXTIMER
0c2e a GET_REGNAME
ffa8 v RSAF2
11ac a RT2_NX1
33ad a RANDR
2faf a DIMERR
1432 a DOT_GETCHAR
1ce8 a SDC_MENU
0083 a VGET_BYTE
27b2 a TO_UPPER
24f4 a SD_WRITE_SEC
336e a EGOF0
336d a EGOF1
336c a EGOF2
ff8c v RX_ERR_LDRT
1ae9 a ICMB_REG
2188 a DISK_READ
00d1 a VLED_PUT_HEX
18f4 a ICMD_WORDN1
00e3 a VSD_OPEN
3373 a EGOP1
1f47 a RHF_OK1
1f79 a RHF_OK2
1fac a RHF_OK3
1fc8 a RHF_OK4
1fdc a RHF_OK5
200c a RHF_OK6
2024 a RHF_OK7
0054 a VTIMED_GETCHAR
2a1d a INIT
ffb2 v BEEP_TO
0a82 a GET_CONTINUE
1700 a ISR_EXTIMER_RET
2abd a INLF
2bdf a INLN
1370 a ABORT_CHECK
0915 a REG_MENU
2b2c a INOK
2edf a INP1
0014 v SSOC
ffd4 v SDISPMODE
1622 a PC_RET
ff12 a SD_PARAM
0d4c a GET_BYTE
3117 a SKIP1
305d a GETDAT
0ea8 a GHENDTO
14a8 a PCLC_LP
2c51 a PNUM
3320 a LEQL
1835 a CTRL_C_CHK_OFF
09b7 a LOOP_BACK_TEST
13fc a PC_POS_UPDATE
32b5 a LETH
ffaa v RSBC2
23da a INITFAT_C3_0
23fd a INITFAT_C3_1
259b a INIT_SDCARD
0921 a RM_LP
81fd v ARYLOC
0278 a LSPLASH_CNT
1f01 a RHF_LOOP
1788 a IK_KEYUP_EVENT
0051 v BINCHR
12e2 a RT_FAIL1
1305 a RT_FAIL2
1328 a RT_FAIL3
14b4 a PCL_RET2
134a a RT_FAIL5
111c a RT_GO
14b1 a PCL_RETC
09ab a RM_DUMP_REG
34a3 a CLBF
19dd a IRAMROMBANK
1470 a PC_BOTH
1c94 a GSC_INIT
31bf a ARYL
1c2c a IDISP_OFF
17f6 a IKEY_SCAN_END
00c8 a VLED_PUT_CHAR
ff0a v FAT_CLEAR
07ac a SW2_ACE
2f42 a DIM0
2d2c a STOP
2fe7 a STOR
0b43 a MEM_EXEC
145e a TGC_RET
32e1 a STRT
0039 v FAT_CLR_LEN
1c05 a IDISP_OUT
2d84 a FINTO
2dd2 a LET
2dc7 a POPD
2db4 a POPS
2e39 a LIF
35c9 a LIN
0dc8 a PRINT_RET
2c62 a POUT
1aef a ICMD_SET_REG
3296 a LOR
2ad0 a GLINE
2fb5 a LTA
1c87 a LED_PRINT_RET
112f a RT1_LP0
1132 a RT1_LP1
1134 a RT1_LP2
113e a RT1_LP3
1144 a RT1_LP4
1149 a RT1_LP5
114f a RT1_LP6
115e a RT1_LP7
2412 a INITFAT_C4_1
2428 a INITFAT_C4_2
242d a INITFAT_C4_3
2c19 a FNDLIN
30bb a GETEOF
10c8 a GS_SEQ
0c86 a PUT_REG_MON
0063 a VDELAY_A
0060 a VDELAY_C
ff5b a HEX_SOURCE
0b71 a GO_EXEC
1bd0 a IDISP_IN
00c2 a VLED_SET_POS
32c8 a ASST
2a65 a CMD1
0d76 a SPACE_GET_WORD
03e2 a MAIN_MENU
2290 a DRSS_SHIFT
1421 a IN_CHAR
2a52 a CMDL
2818 a LEDL_LP
0df3 a SPACE_PUT_BYTE
23a1 a INITFAT_C2_DONE
01cf a WARM_START
3244 a SUBB
0d6e a GB_RET1
8000 v RAM_LDRT
1c40 a IDISP_DELAY
ff95 v HW_LIST
2778 a CMP_HL_32
0006 v RST38_LEN
ffb3 v ANBAR_DEF
07a4 a SW2_BIT
1685 a IRXD_BAD
35ae a IERMS
142a a PURGE
314f a EGO1
339c a EGO2
25bf a ISD_LP1
2629 a ISD_LP2
1a75 a ISINGLE
1acf a ICMA_IO
ffc8 v LED_CURSOR
ff21 a SEC_PER_CLUS
104f a XMR_TSEQ
2b49 a GADV
2083 a HR_EXEC_GO_SUB
ffc6 v HEX_READY
2cad a LIRET
2a6f a GOTCMD
268e a SD_DELAY100
ffac v RSDE2
0391 a AUTO_BOOT_MENU
ff2f a SEC_PER_FAT
002c v CLEARED_LEN
2029 a RHF_DO_NEXTL
089b a PUT_VERSION
2163 a CMP_FILENAME
258d a SD_CLEAR_ARG
0ca0 a VCALL_HL
1b0a a ICMD_AMEM
1386 a SET_IO
211d a PRINT_BS
0b1d a MEM_EDIT
fb45 v GET_MEM
2269 a DR_SEEK_DONE
0806 a WP_NOACE
10a7 a XMR_NAK
30e6 a ZLOOP
0dbe a PRINT_LP
00d7 a VLED_RIGHT
1e22 a SDO_RET
2749 a MOV_HL_32
1754 a IKEY_DEBOUNCE
1773 a IKEYP_EVENT
0d35 a PURR_SUB_AFA
fff5 v SCAN_LED
2455 a INITFAT_FAIL1
34b0 a PUSHB
2dbd a PUSHD
2da9 a PUSHS
0d57 a GB_1
0d6b a GB_2
0015 v NAK
3237 a DIVBYT
2a15 a NEW
0095 a VMOV_32_HL
0b5d a ME_1
00ad a VASC2HEX
2a6e a GOTDEF
1f4d a RHF_BYTE_LP
ffea v KBHEXSAMPLE
0a37 a MEN_1
00c8 v ACE_DATA
164c a IRXD_NB
1654 a IRXD_NI
2ac6 a NUM
fc00 a SD_RAM_BUFFER
0adc a DL_P2
282d a ROM_CODE
163d a IRXD_VS
16a4 a IRXD_WS
1035 a XMR_RECV
2a00 a GO_BASIC
3104 a PARSE1
0018 v ABS_SEC
0001 v FNAME
1714 a ISR_EXXTIMER
ffbe v KEY_EVENT
fff4 v XMTYPE
1c4a a LED_PUT_BYTE_HL
1800 a ICMD_BREAK
30cc a SAVE
1ac8 a ICMA_REG
2acd a BADLN
039b a AUTO_BOOT_DO
ff81 v RC_SOFT
3459 a COMSTR
3276 a SWAP
03c1 a AUTO_BOOT_GO
07f6 a WP_NOBIT
1b67 a IDISP_REG
308b a COMA
17e3 a IDISP_RET
3265 a COMP
1688 a IRXD_TINC
03b6 a AUTO_BOOT_LP
ff00 a BIT_TABLE
3259 a NXLP
278d a CH3_R1
278e a CH3_R2
278f a CH3_R3
0d3a a PURR_SUB_BCA
14ae a PCLC_1
27d9 a LED_UPDATE
1f4b a RHF_BYTE_LP2
27cb a ABF_GOODHEX
0d87 a GW_LP
1802 a ICMD_BREAK_RET
ff2b a HIDDEN_SEC
1063 a XMR_SEQ_OK
0a61 a MEM_DUMP_0
1e66 a LI_1
1e81 a LI_2
1e8d a LI_3
1e91 a LI_4
0d73 a GB_RET
00c8 v ACE_BAUD0
00c9 v ACE_BAUD1
0170 a RTHW_SIOT_LP
2e67 a OUTP
2714 a DIV16BY8SPC
0326 a R_COLD
1e7d a LI_1B
2b67 a GFIND
fb53 a HR_EXE_GO
2f0c a GCHR
301f a READ
01f8 a WS_NOFP
2b0e a RECT
0160 a RTHW_ADV
27bb a IS_LETTER
3004 a ORDER
2773 a TSTZ_32
2c6b a LIST
1f29 a RHF_DO
35f6 a OVM
fff6 v LED_DISPLAY_SB
ffd4 v CLEARED_SPACE
2a1a a RESV
0092 a VADD_HL_A
0010 v CAFClus
0f11 a XMDN_LP
14cf a IC_ACE
1c8a a LED_HOME_PRINTI
272c a DIVBYSHIFT
1248 a BIT_MARCH
14e0 a PC_ACE
3103 a PARSE
0387 a WB_NOT_STEP
2717 a DIV16BY8
2496 a SD_READ_SEC
ff86 v RC_RST0
23dc a INITFAT_C3_LP2
23ec a INITFAT_C3_LP3
0871 a SET_BANK
fa88 a LI_SDLOG_SEC
32a0 a CPYL
ff41 a ENT_COUNT
14c4 a RXC_ACE
ff43 a FILENAME
00dd a VPRINT_FNAME
1449 a TIMED1_GETCHAR
1e63 a LI_LP
1984 a HEX2MEM
2dae a PSH1
2daf a PSH2
2fdd a URET
22dc a INIT_FAT
0e45 a ADD_HL_A
1e56 a LI_TP
ffce v INT_VEC
2a78 a VCHAR
1afa a ICMB_IO
2059 a GH_EXEC_GO
0a18 a MEM_ENTER_NEXTL
009e a VCMP_HL_32
ffc4 v HEX_CURSOR
0a7e a MEM_DUMP_PAGED
34b9 a PU1
2ea5 a PV1
1c34 a IDO_LP
2c92 a PRINS
0dbd a PRINT
1c60 a LED_PUT_BYTE
2c46 a NOTFND
19ec a IDDR_DISP
ff16 a SD_PART_TYPE
00d4 a VLED_CLEAR
26f4 a WAIT_NOT_BUSY
09e7 a LOOP_BACK_LP
271d a DIV16BY8_LP
1517 a IC_BIT
034e a R_HALT
001c v FSIZE
3129 a SKPQUO
1538 a PC_BIT
2726 a DIV16BY8_SK
183c a ISET_PRESSED
0369 a R_HARD
13cd a GET_POS
fb5b v HERE1
0d3f a PURR_SUB_DEA
34f3 a PTAB
2a7c a SYNT
ff08 a FCB_PTR
0cf3 a GRR_SUB_AFA
009b a VADD_32_HL
27c6 a ABF1
01a5 a COLD_START
1509 a RXC_BIT
33f7 a CQ
000d v CR
81fa v CS
33e7 a CV
1000 a XMR_INIT
250c a SD_WR_LP
363d a EM
33a0 a FE
2c89 a GO
1104 a RAM_TEST
2e16 a IF
0210 a INIT_SYSTEM
000a v LF
20af a SDV_FOUND
35d5 a NP
174b a IKEYF_UP
086e a UR_RET1
8236 v PP
3420 a QPP
3404 a Q0
3407 a Q1
3418 a Q2
3419 a Q3
3423 a Q4
3435 a Q5
2ea8 a PZ
344e a Q6
345f a Q7
347e a Q9
346e a Q8
1779 a IKEYP_EVENT_DN
ff11 a SDC_STATUS
ff88 v ABUSS
3313 a GEQL
ff1f a BYTE_P_SEC
00c4 v SDCS
ffda v XTIMER_TIC
ffe7 v LED_ANBAR
2cfc a RGON
ffae v RSHL2
3330 a NEQL
00cd v ACE_STATUS
8000 v BUFF
2ecb a INPUT
2361 a INITFAT_TFS_DONE
0c91 a PUT_REG_RUN
0d08 a PURR_SUB_AF
ffc2 v DISPLABEL
0d0f a PURR_SUB_BC
00c5 v SDTX
2de1 a NEXT
0d12 a PURR_SUB_DE
1a2a a IDRRC_2ROM
2739 a MODBYMASK
0d19 a PURR_SUB_HL
0d2e a PURR_SUB_IR
0d26 a PURR_SUB_IX
0d2a a PURR_SUB_IY
31f4 a DMULT
0d20 a PURR_SUB_PC
1297 a RT5_LP1
12a0 a RT5_LP2
12af a RT5_LP3
0d07 a PURR_SUB_SP
1857 a IMON_TBL
0cf8 a GRR_SUB_BCA
1db6 a SD_OPEN
004b a VGET_CHAR
2204 a DR_SEEK_LP
008c a VCLEAR_BLOCK
ff4e a FILESIZE
ffd0 v SCAN_PTR
2eb7 a DECP1
ff58 a MODMASK
24b4 a SD_RS_FORCED
0ec9 a RS_CLP
0f26 a XMUP_LP
0edc a RS_COK
26fa a WNB_LP2
1a40 a GO_SINGLE
1ec3 a READ_HEX_EXEC
fa82 a LI_FILESIZE
2797 a GET_STRING
0c17 a FB_LP
ff5a a IK_HEXH
ff59 a IK_HEXL
81fe v SEED
1978 a HEX2IN_Ptr
106b a XMR_BLK_LP
2e1b a FTHEN
1aec a ICMD0_R
0008 v HR_EXEC_GS_LEN
00b0 a VHEX2ASC
13e0 a GET_CHAR
2fda a CSAV
0831 a USE_RAM
ffb4 v GET_REG
00a1 a VINC_32
fb00 a STACKSPACE1
0e3f a DlyLp
0e09 a PUT_HEX
270a a WNB_0
26dc a SDC_RET
0c71 a GET_REG_MON
fa86 a LI_SDBUFF_PTR
35c1 a CSTK
320b a NOMAD
ff24 a FAT_COPIES
ffe8 v KBCOLSAMPLED
ff31 a FAT1START
1d3b a BOOT_SDVIEW
34e7 a CTRLC
ff1b a SD_PART_SIZE
2e8b a OUTPR
3517 a DATCMD
0185 a EXEC_RAM_2F8
ff39 a DATASTART
3094 a VERDAT
0f69 a XMS_BLP
0a06 a LB_OUT
184f a ICMD4_EXEC
1a2b a IDRRC_RET
18ca a ICMD_WORD
2557 a SD_WR_FAIL
27e9 a LED_GET_POS
0bfc a PORT_INP
0204 a WS_SET
1a26 a IDRRC_ROM
0e19 a PUT_SPACE
00c1 v RAMROM
ff82 v RC_STEP
17f0 a IKEY_NO_BEEP
00f2 a VLINE_INPUT
0e3a a DELAY_A
0e2c a DELAY_C
1d97 a DD_TAB_LP
0f35 a XMS_INIT_LP
1d5e a PRINT_DIR
fa8a a RHF_LINES
1c78 a LED_PRINT
0f45 a XMS_INIT_RT
12a4 a RT5_NX1
12b3 a RT5_NX2
094f a RM_NOTALL
0cfd a GRR_SUB_DEA
00b9 a VIC_KEY
ffef v KEY_PRESSED
0f4e a XMS_RESEND
14e6 a PCA_LP
0bdb a GE_STACKFAIL
0c82 a PUT_REGISTER
32c3 a ENOP
0a68 a MEM_DUMP_LP
21d0 a DR_NEW_SEC
09aa a RM_DUMP_REG_C
0db6 a GHC_NOT_RET
0167 a RTHW_EXIT
231b a INITFAT_PGOOD
1680 a IRXD_INC
1b4a a ICMD_IO_OUT
11db a BYTEMARCH2
1901 a ICMD_WORD1
1908 a ICMD_WORD2
10c5 a GS_ESC
17b2 a CTRL_C_RET
ff52 a DIVIDE_FUNC
fff2 v ECHO_STATE
0f04 a XMDN
2e3c a LNXT
16ac a ISR_TIMER
26e4 a SPI_TX_LP
0e1f a PUT_NEW_LINE
0fba a XM_DONE
2821 a LOAD_HIGH_RAM
2aaf a STLIN
10d6 a CRC_UPDATE
2c39 a NEXTL
2180 a CMP_STRING
0f1f a XMUP
2920 a LED_FONT
2d01 a RNEWL
ff8b v IoPtr
21b3 a DR_1
0029 v ROM_CODE_LEN
2d13 a RNEXT
ffcc v RXBTAIL
2390 a INITFAT_C2_LP
2f89 a ALOOK
25a0 a ISD_0
25db a ISD_1
25fc a ISD_2
2616 a ISD_3
263f a ISD_4
266f a ISD_5
2678 a ISD_6
13b9 a SIO_RET
1da4 a DD_NEXT
2695 a SD_CMD
2d75 a NSTERR
1929 a HEX2REG
0d44 a PURR_SUB_HLA
00ec a VDISK_READ
30c9 a LOAD
17d5 a IKR_QREFRESH
30c9 a LOD1
0b21 a ME_LP
0eee a XMODEM
326b a FLOR
ffc1 v KEYBFMODE
ff0a a GH_START
1a13 a IRAMROMBANK_CHG
1447 a DGC_RET
24bf a SD_RS_LP0
24cf a SD_RS_LP1
24df a SD_RS_LP2
2b95 a GIN1
2ff8 a LOOK
0dd0 a PRINTB
0dca a PRINTI
0057 v PRINTM
306b a ENDAT
3300 a STMEM
ffdb v READ_RAMROM
364d v ENDIT
1578 a PC_0
157a a PC_1
157f a PC_2
1587 a PC_3
1590 a PC_4
159f a PC_5
15a6 a PC_6
15ab a PC_7
15b5 a PC_8
15b8 a PC_9
3600 a INTRO
2d68 a BADLIN
1c6c a LED_PUT_HEX
0146 a FILL_BT
02bc a SKIP_TABLE1
0377 a SKIP_TABLE2
26de a SPI_RX
26e0 a SPI_TX
ffed v KEY_PRES_EV
823e v TEMP
0333 a R_SOFT
3638 a STMSG
172f a IKEY0_UP
2cc6 a CVL1
2cb9 a CVLP
197e a HEX2OUT_Ptr
8600 v TEXT
ff27 a FILESYS_SEC
2ab4 a FIXIT
11dd a RT4_LP0
11e2 a RT4_LP1
11e4 a RT4_LP2
11ed a RT4_LP3
11f4 a RT4_LP4
11fc a RT4_LP5
1201 a RT4_LP6
120e a RT4_LP7
121d a RT4_LP8
0865 a UR_NOTRAM
2288 a DRSS_LP
0d49 a SPACE_GET_BYTE
21f9 a DR_BIGGER_CLUS
008f a VLD_HL_HL
212a a INPUT_FILENAME
17a0 a IK_RTN
0a0f a LB_RET
0080 v BPUTNL
fb2a v ISR_DISPATCH
007d v BPUTSP
109d a XMR_ACK
3051 a MORDAT
3175 a CALN
2cda a CALS
004e a VRX_COUNT
1a9c a ISINGLE_DONE
1ea2 a LI_GETDATA
31b0 a HGON
1b45 a ICMD_IO
823c v SIGT
0fa6 a XMS_EOT
2791 a CMP_DE_HL
27c2 a ASC2BIN
ff56 a MOD_FUNC
1f60 a RHF_NOT_HEX
20d7 a SD_FETCH
fe00 a RXBUFFER
2690 a SD_DELAY
fafe v StackTop
0e4a a LD_HL_HL
1842 a IMON_CMD
0074 a VPUT_BC
0006 v ACK
086b a UR_RET
31e0 a ADD
07cd a IO_MSG
30a9 a SIZE
0077 a VPUT_DE
0fda a XM_CANCEL
0361 a R_RST0
007a a VPUT_HL
0086 a VGET_WORD
0986 a RM_ERR
20dd a SD_TEST
0071 a VPUT_BYTE
ff17 a SD_PART_BASE
ffd7 v POS_ACE
3191 a HEXGO
3522 a KTAB
149d a PCL_CTRL
00c6 v GREEN_LED
3196 a GETHX
1408 a RX_COUNT
0089 a VGET_HEX
0042 a VMAIN_MENU
2b9b a GETLN
35f1 a DTXT
0aaa a DUMP_LINE
0a29 a MEN_RET
317b a HEXVL
2572 a SET_PARAM
27d1 a BEEP
16f9 a SKIP_HALT_TEST
0966 a RM_2
0971 a RM_3
0976 a RM_4
098c a RM_5
099a a RM_6
ffe9 v KBPORTSAMPLE
1897 a ICMD0
199b a ICMD1
199b a ICMD2
199b a ICMD3
199b a ICMD4
199b a ICMD5
19b8 a ICMD6
1a30 a ICMD7
1ab5 a ICMDA
1ad6 a ICMDB
1b01 a ICMDD
18ad a ICMDE
ff35 a DIR_SECTOR
ff0d a LOGICAL_SEC
0040 v Port40
13bd a IOD_TABLE
ff83 v RC_CC
ff85 v RC_F0
0d79 a GET_WORD
00bc a VLED_UPDATE
0df6 a PUT_BYTE
2e8d a BPRINT
007f v DELETE
15c1 a PC_10
15c4 a PC_11
15ce a PC_12
15d3 a PC_13
15d8 a PC_14
15e5 a PC_15
15e6 a PC_16
15f3 a PC_17
15f8 a PC_18
15fd a PC_19
0136 a RSIS_LP
1dc8 a SDO_DO
1609 a PC_20
0057 a VPRINT
0141 a RSIS_OK
246b a INITFAT_FAIL
0a1f a MEN_LP
001b v GET_MEM_OFF
2a92 a PERR
1825 a CTRL_C_IN_Q
1aa9 a GET_DISPMODE
146a a IC_BOTH
2b86 a ABFND
34c3 a CINDX
23ad a INITFAT_C3_LP
0c7c a GET_REG_RUN
8200 v VARS
8234 v RFLAG
ffd6 v POS_BIT
0c6d a GET_REGISTER
21f0 a DR_DIFF_CLUS
190f a ICMD_WORD_RET
0d02 a GRR_SUB_HLA
1b79 a IDISP_REG_DATA
1a6e a GS_OK
0098 a VMOV_HL_32
1bb4 a IDISP_MEM_DATA
2caf a CLEAR
ff54 a DF_SHIFTCNT
1b29 a ICMD_REG
ffdf v SOFT_RST_FLAG
2900 a LED_HEX
2765 a INC_32
006b a VPUT_VERSION
2d53 a GLPD
2d4b a GLPO
30c0 a GLPX
2d04 a RLOOP
ff3d a SEC_PTR
1094 a XMR_CCS
0f2e a XMS_INIT
