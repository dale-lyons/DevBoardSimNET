   1:				;Z80 Membership Card Firmware with SD support, Version 1.5, July 23, 2017
   2:				;File: ZMCv15.asm
   3:				;
   4:				;	MACRO 	VERSION_MSG
   5:				;	DB	CR,LF,"Z80 MEMBERSHIP CARD MICRO-SD, v1.5beta July 23, 2017",CR,LF,EOS
   6:				;	ENDM
   7:				;	Table of Contents
   8:				;	Preface_i	Acknowledgments, Revisions, notes
   9:				;	Preface_ii	Description, Operation
  10:				;	Preface_iii	Memory Mapping, I/O Mapping
  11:				;	Chapter_1	Page 0 interrupt & restart locations
  12:				;	Chapter_2	Startup Code
  13:				;	Chapter_3	Main Loop, MENU selection
  14:				;	Chapter_4	Menu operations. Loop back, Memory Enter/Dump/Execute, Port I/O
  15:				;	Chapter_5	Supporting routines. GET_BYTE, GET_WORD, PUT_BYTE, PUT_HL, PRINT, DELAY, GET/PUT_REGISTER
  16:				;	Chapter_6	Menu operations. ASCII HEXFILE TRANSFER
  17:				;	Chapter_7	Menu operations. XMODEM FILE TRANSFER
  18:				;	Chapter_8	Menu operations. RAM TEST
  19:				;	Chapter_9	Menu operations. DISASSEMBLER - Deleted
  20:				;	Chapter_10	BIOS.  PUT_CHAR (RS-232 & LED), GET_CHAR (RS-232), IN_KEY (Keyboard)
  21:				;	Chapter_11	ISR.  RS-232 Receive, LED & Keyboard scanning, Timer tic counting
  22:				;	Chapter_12	SD-CARD
  23:				;	Chapter_13	FILE operations
  24:				;	Chapter_14	FILE Support Routines
  25:				;	Chapter_15	SD Memory Card Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
  26:				;	Chapter_16	General Support Routines, 32 Bit stuff and other math
  27:				;	Chapter_17	High RAM routines
  28:				;	Appendix_A	LED FONT
  29:				;	Appendix_B	Future Use
  30:				;	Appendix_C	RAM. System Ram allocation (LED_Buffer, KEY_Status, RX Buffer, etc)
  31:				;	Appendix_D	HOOK LOCATIONS
  32:				;	Appendix_E	Z80 Instruction Reference
  33:				
  34:				
  35:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  36:				;	Preface_i - Acknowledgments, Revisions, notes
  37:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38:				;
  39:				;Assemble using ver 2.0 of the ASMX assembler by Bruce Tomlin
  40:				;
  41:				;Command to assemble:
  42:				;
  43:				;   asmx20 -l -o -e -C Z80 ZMCv12.asm
  44:				;
  45:				;
  46:				;Z80 Membership Card hardware by Lee Hart.
  47:				;
  48:				;V1.x -Operation, Documentation and Consultation by Herb Johnson
  49:				;
  50:				;Firmware by Josh Bensadon. Date: Feb 10, 2014
  51:				;
  52:				;FP LED & Keyboard operation concepts adapted from the Heathkit H8 computer.
  53:				;
  54:				;Revision.
  55:				;
  56:				;
  57:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  58:				;	Preface_ii - Description, Operation
  59:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  60:				;
  61:				;- - - HARDWARE - - -
  62:				;
  63:				;The Hardware is comprised of up to three boards, the CPU board, SIO board and Front Panel (FP) board.
  64:				;
  65:				;CPU Board:
  66:				; Z80 CPU, 4Mhz Clock, 5V Regulator, 32K EPROM (w/firmware), 32K RAM, 8 bit input port, 8 bit output port
  67:				;
  68:				;SIO Board:
  69:				; Additional RAM, up to 512K bytes to bank switch the lower 32K ROM on CPU Board
  70:				; ACE 8250 UART with RS-232 or FTDI232 (5V TTL Level) connection
  71:				; Micro SD Card Slot
  72:				;
  73:				;Front Panel Board:
  74:				; Terminal for Power & RS-232 connection, Timer for 1mSec interrupt, LED Display Driver & Keyboard Matrix.
  75:				;
  76:				; LED Display: 7 x 7-Segment displays (d1 to d7) and 7 annunciator leds (x1 to x7) below the 7 digits.
  77:				;
  78:				;    d1   d2   d3   d4   d5   d6   d7
  79:				;    _    _    _    _    _    _    _
  80:				;   |_|  |_|  |_|  |_|  |_|  |_|  |_|
  81:				;   |_|  |_|  |_|  |_|  |_|  |_|  |_|
  82:				;    _   _      _   _     _   _     _
  83:				;    x1  x2     x3  x4    x5  x6    x7
  84:				;
  85:				; Keyboard: 16 keys labeled "0" to "F" designated as a HEX keyboard
  86:				; The "F" key is wired to a separate input line, so it can be used as a "Shift" key to produce an extended number of key codes.
  87:				; The "F" and "0" keys are also wired directly to an AND gate, so that pressing both these keys produces a HARD reset.
  88:				;
  89:				;- - - FIRMWARE - - -
  90:				;
  91:				;The Firmware provides a means to control the system through two interfaces.
  92:				;Control is reading/writing to memory, registers, I/O ports; having the Z80 execute programs in memory or halting execution.
  93:				;The two interfaces are:
  94:				; 1. The Keyboard and LED display
  95:				; 2. A terminal (or PC) connected at 9600,N,8,1 to the RS-232 port.
  96:				;
  97:				;- - - The Keyboard and LED display interface - - -
  98:				;
  99:				;While entering commands or data, the annunciator LED's will light according to the state of the operation or system as follows:
 100:				;
 101:				; x1 = Enter Register
 102:				; x2 = Enter Memory Location
 103:				; x3 = Alter Memory/Register
 104:				; x4 = Send Data to Output Port
 105:				; x5 = Monitor Mode (Default Mode upon Power up)
 106:				; x6 = Run Mode
 107:				; x7 = Beeper (on key press)
 108:				;
 109:				;Keyboard Functions:
 110:				;
 111:				; "F" & "0" - Force a HARD reset to the Z80 and restarts the system.  See System Starting for additional details.
 112:				;
 113:				; "0" - Display a Register.  x1 lights and you have a few seconds to select which register to display.
 114:				; "E" - Display Memory.  x2 lights and you have a few seconds to enter a memory location.
 115:				; "5" - Display Input Port.  x2 lights and you have a few seconds to enter a port address.
 116:				; "6" - Output Port. x2 lights and you have a few seconds to enter a port address,
 117:				;	then x4 lights and you can enter data to output, new data may be sent while x4 remains lit.
 118:				; "A" - Advance Display Element.  Advances to next Register, Memory address or Port address.
 119:				; "B" - Backup Display Element.  Backs up to previous Register, Memory address or Port address.
 120:				; "4" - Go. Preloads all the registers including the PC, thus causes execution at the current PC register.
 121:				; "7" - Single Step.
 122:				; "D" - Alter/Output.  Depending on the display, Selects a different Register, Memory Address, Port or Sends Port Output.
 123:				;	Note, "D" will only send to that Output Port, to change port, reuse Command 6.
 124:				; "F" & "E" - Does a SOFT reset when Running.
 125:				;
 126:				;
 127:				;- - - The Terminal interface - - -
 128:				;
 129:				;Through a Terminal, there are more features you can use.  Entering a question mark (?) or another unrecognized command will display a list of available commands.
 130:				;Most commands are easy to understand, given here are the few which could use a better explaination.
 131:				;
 132:				; C - Continous Dump.	Works like the D command but without pausing on the page boundaries.  This is to allow the text capturing of a dump.
 133:				;			The captured file can then be later sent back to the system by simply sending the text file through an ASCII upload.
 134:				; M - Multiple Input.	Allows the entering of data in a format that was previously sent & saved in an ASCII text file.
 135:				; R - Register.		Entering R without specifiying the register will display all the registers.
 136:				;			A specific register can be displayed or set if specified.  eg. R HL<CR>, R HL=1234<CR>
 137:				; T - Test RAM		Specify the first and last page to test, eg T 80 8F will test RAM from 8000 to 8FFF.
 138:				; X - Xmodem Transfers	Transfers a binary file through the XModem protocol.  Enter the command, then configure your PC to receive or send a file.
 139:				;			eg. X U 8000<CR> will transfer a file from your PC to the RAM starting at 8000 for the length of the file (rounded up to the next 128 byte block).
 140:				;			eg. X D 8000 0010 will transfer a file from RAM to your PC, starting at 8000 for 10 (16 decimal) blocks, hence file size = 2K.
 141:				; : - ASCII HEX Upload	The ":" character is not entered manually, it is part of the Intel HEX file you can upload through ASCII upload.
 142:				;			eg. While at the prompt, just instruct your terminal program to ASCII upload (or send text file) a .HEX file.
 143:				;
 144:				;
 145:				;- - - System Starting - - -
 146:				;When the Z80 starts execution of the firmware at 0000, all the registers are saved to memory for examination or modification.
 147:				;There are many ways the Z80 can come to execute at 0000.  The firmware tries to deterimine the cause of the start up and will respond differently.
 148:				;Regardless of why, the firmware first saves all the registers to RAM and saves the last Stack word *assuming* it was the PC.
 149:				;A test is done to check if the FP board or SIO board is present.
 150:				;-If there is no FP board, then the firmware will either RUN code in RAM @8002 (if there's a valid signature of 2F8 @8000) or HALT.
 151:				;Next, 8 bytes of RAM is tested & set for/with a signature.
 152:				;-If there isn't a signature, it is assumed the system is starting from a powered up condition (COLD Start), no further testing is done.
 153:				;When the signature is good (WARM Start), more tests are done as follows:
 154:				;Test Keyboard for "F"&"E" = Soft Reset from Keyboard
 155:				;Test Keyboard for "F"|"0" = Hard Reset from Keyboard
 156:				;Test Last instruction executed (assuming PC was on Stack) for RST 0 (C7) = Code Break
 157:				;Test RS-232 Buffer for Ctrl-C (03) = Soft Reset from Terminal
 158:				;If cause cannot be deterimined, it is assumed an external source asserted the RESET line.
 159:				;
 160:				;The Display will indicate the cause of reset as:
 161:				;	"COLD 00"  (Power up detected by lack of RAM Signature)
 162:				;	"SOFT ##"  (F-E keys pressed)
 163:				;	"STEP ##"  (Single Step)
 164:				;	"^C   ##"  (Ctrl-C)
 165:				;	"HALT ##"  (HALT Instruction executed)
 166:				;	"F-0  ##"  (F-0 Hard Reset)
 167:				;	"RST0 ##"  (RST0 Instruction executed)
 168:				;	"HARD ##"  (HARD Reset by other)
 169:				;
 170:				;Where the number after the reset shows the total number of resets.
 171:				;
 172:				;The PC will be changed to 8000 on Cold resets.
 173:				;
 174:				;
 175:				;- - - Firmware BIOS - - -
 176:				;
 177:				;There are routines which can be called from your program to access the RS-232 Bit banging interface, Keyboard or Display inteface or Timer interrupt services.
 178:				;
 179:				;Label		Addr.	Description
 180:				;Put_Char	xxxx	Sends the ASCII character in A to the RS-232 port or LED Display (no registers, including A, are affected)
 181:				;Put_HEX	xxxx	Converts the low nibble of A to an ASCII character 0 to F and sends to RS-232 or LED Display
 182:				;Put_Byte	xxxx	Converts/sends both high and low nibbles of A (sends 2 ASCII Character) to RS-232 or LED Display
 183:				
 184:				;Warning: FCB's must never cross page boundaries.
 185:				
 186:				
 187:				
 188:				; Z80 - Registers
 189:				;
 190:				; A F   A' F'
 191:				; B C   B' C'
 192:				; D E   D' E'
 193:				; H L   H' L'
 194:				;    I R
 195:				;    IX
 196:				;    IY
 197:				;    SP
 198:				;    PC
 199:				
 200:				
 201:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 202:				;	Preface_iii- Memory Mapping, I/O Mapping
 203:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 204:				
 205:				;String equates
 206:     -	000D          	CR		equ	0x0D
 207:     -	000A          	LF		equ	0x0A
 208:     -	0000          	EOS		equ	0x00
 209:				
 210:				
 211:				;Memory Mapping
 212:				;
 213:				;0x0000 - 0x7FFF	EPROM or RAM (BANK SWITCHED)
 214:				;0x8000 - 0xFFFF	RAM
 215:				
 216:				; Notes on Z80MC CPU board.
 217:				; Memory Mapping
 218:				; Holding /ROM high will inhibit the ROM from being enabled on the Data bus.
 219:				; Holding /RAM high will inhibit the RAM from being enabled on the Data bus.
 220:				; /ROM is loosely pulled low on Memrq & A15 low (ie, ROM 0000-7FFF)
 221:				; /RAM is loosely pulled low on Memrq & A15 high (ie, RAM 8000-FFFF)
 222:				; 
 223:				; 
 224:				; Notes on Z80 SRS board.
 225:				; Memory (SDC-RAM)
 226:				; The RAM on the SD card and the /ROM signal for the CPU board are both generated by U4.
 227:				; The Y output is the value of the addressed Data input pin or Low if strobe (G) is high.
 228:				; The W output is always the inverted value of Y.
 229:				; Y goes to /ROM and W goes to RAM /CE.  
 230:				; Therefore, when Y is high /ROM is inhibited and RAM /CE is low
 231:				; When Y is low /ROM is unhindered (and ROM is allowed to be accessed on A15=0)
 232:				; 
 233:				; When NOT requesting any Memory operation, /MREQ=1, Y is LOW.  This is irrelevant to
 234:				; the CPU ROM and RAM, but it ensures that the SDC-RAM is NOT enabled.
 235:				; With A15=0:
 236:				;  >Reading, Y is controled by Q1 (0=ROM, 1=RAM)
 237:				;  >Writing, Y is high, thus SDC-RAM is enabled to accept the write
 238:				;  
 239:				; With A15=1:
 240:				;  >Reading or Writing, Y is low, thus SDC-RAM is disabled and CPU-RAM is enabled
 241:				 
 242:				
 243:				; Notes on Z80MC CPU board.
 244:				; I/O Mapping
 245:				; /OUT is loosely pulled low on A7 low, A6 high, A5 low and /WR low  (ie, 40-5F)
 246:				; /IN  is loosely pulled low on A7 low, A6 high, A5 low and /RD low  (ie, 40-5F)
 247:				;I/O
 248:				;0x40	Input/Output
 249:				;	Output bits	*Any write to output will clear /INT AND advance the Scan/Column Counter U2A.
 250:				;	0 = Segment D OR LED7       --4--
 251:				;	1 = Segment E OR LED6      2|   |3
 252:				;	2 = Segment F OR LED5       |   |
 253:				;	3 = Segment B OR LED4       --5--
 254:				;	4 = Segment A OR LED3      1|   |6
 255:				;	5 = Segment G OR LED2       |   |
 256:				;	6 = Segment C OR LED1       --0--
 257:				;	7 = RS-232 TXD (Bit Banged) = 1 when line idle, 0=start BIT
 258:				;
 259:				;	Input Bits
 260:				;	0 = Column Counter BIT 0 (Display AND Keyboard)
 261:				;	1 = Column Counter BIT 1 (Display AND Keyboard)
 262:				;	2 = Column Counter BIT 2 (Display AND Keyboard)
 263:				;	3 = 0 when Keys 0-7 are pressed (otherwise = 1), Row 0
 264:				;	4 = 0 when Keys 8-E are pressed (otherwise = 1), Row 1
 265:				;	5 = 1 when Key F is pressed (otherwise = 0), Key F is separate so it may be used as A Shift Key
 266:				;	6 = 1 when U2B causes an interrupt, Timer Interrupt (Send Output to reset)
 267:				;	7 = RS-232 RXD (Bit Banged) = 1 when not connected OR line idle, 0=first start BIT
 268:				;
 269:				;	Bit 5 allows Key F to be read separately to act as A "Shift" key when needed.
 270:				;	Bits 0-2 can be read to ascertain the Display Column currently being driven.
 271:				;
 272:				; Notes on Z80 SIO board.
 273:				; I/O 
 274:				; C0-C8, write single bit (D0) to BIT LATCH U5.
 275:				; C0=Q0 SPI_CLK
 276:				; C1=Q1 BANK 0=ROM, 1=RAM
 277:				; C2=Q2
 278:				; C3=Q3
 279:				; C4=Q4 SD /CS
 280:				; C5=Q5 SD MOSI
 281:				; C6=Q6 
 282:				; C7=Q7 ACE MASTER RESET (1=RESET UART)
 283:				; 
 284:				; Q0  SPI_CLK
 285:				; 0   HIGH (Always)
 286:				; 1   LOW and PULSED HIGH BY I/O 88  (NO NEED TO I/O TWICE HIGH/LOW FOR A PULSE)
 287:				;
 288:				;
 289:				; IN C0 = SD Clock Pulse
 290:				;  
 291:				; 	LD	A,1
 292:				; 	OUT	(0xC0),A	;ENABLE CLK LOW
 293:				; 	
 294:				; 				;SINGLE I/O TO PULSE SPI_CLK
 295:				; 	IN	A,(0xC0)	;PULSE SPI_CLK HIGH WITH A SINGLE I/O
 296:				; 
 297:				; 
 298:				; C8-CF, write/read bytes to 8250 UART
 299:				; C8 TXBUFFER/RXBUFFER
 300:				; C9 Interrupt enable reg
 301:				; CA Interrupt ID reg
 302:				; CB Line  Control Reg (LCR) word len, stop bits, parity
 303:				; CC Modem Control Reg (MCR) 0, 0, 0, Loop, OUT2, OUT1, RTS, DTR
 304:				; CD Line Status Reg (LSR) TX/RX Buffer Empty
 305:				; CE Modem Status Reg (MSR) DCD, RI, DSR, CTS, DDCD, TERI, DDSR, DCTS
 306:				; CF Scratch Register (SCR) General read/write
 307:				; 
 308:				; Outputs in Modem Control Reg B (MCR) control the High 4 address bits of the
 309:				; extended RAM. These 4 bits are inverted and on a MR, the outputs all go high.
 310:				; CC.0  /DTR  B15
 311:				; CC.1  /RTS  B16
 312:				; CC.2  /OUT1 B17
 313:				; CC.3  /OUT2 B18
 314:				; 
 315:				; Inputs from Modem Status Reg 
 316:				; CE.7  /DCD  MISO (Inverted Data from SD Card)
 317:				; 
 318:				; Inputs from Line Status Register indicate UART condition
 319:				; CD.0  Data Read 1=RX Data ready to read
 320:				; CD.5  Data TX Holding Register Empty 1=Empty (ie ok to send next byte) Mask 0x20
 321:				;
 322:				
 323:     -	0040          	Port40		equ	0x40	;LED DISPLAY, RS-232 TXD/RXD AND KEYBOARD
 324:				
 325:								;U5 - 74LS259 Bit Addressable Latch
 326:     -	00C0          	SDCLK		equ	0xC0	;SD Clk and Clk Pulse
 327:     -	00C1          	RAMROM		equ	0xC1	;RAM /ROM selection
 328:     -	00C2          	BITS_Q2		equ	0xC2	;PIN 6
 329:     -	00C3          	BITS_Q3		equ	0xC3	;PIN 7
 330:     -	00C4          	SDCS		equ	0xC4	;SD Card /CS
 331:     -	00C5          	SDTX		equ	0xC5	;SD Card TX Data
 332:     -	00C6          	GREEN_LED	equ	0xC6	;GREEN_LED, PIN 11
 333:     -	00C7          	ACE_RESET	equ	0xC7	;ACE Reset
 334:				
 335:     -	00C8          	ACE_DATA	equ	0xC8	;ACE TX and RX register
 336:     -	00C8          	ACE_BAUD0	equ	0xC8	;ACE Baudrate Low
 337:     -	00C9          	ACE_BAUD1	equ	0xC9	;ACE Baudrate High
 338:     -	00CB          	ACE_LCR		equ	0xCB	;ACE Word len/bit setup
 339:     -	00CC          	ACE_OUT		equ	0xCC	;ACE RAM Bank Selection.  Lower 4 bits map to Bank Select.
 340:     -	00CD          	ACE_STATUS	equ	0xCD	;ACE RX/TX status
 341:     -	00CE          	ACE_MSR		equ	0xCE	;ACE Modem Status Register
 342:     -	00CF          	ACE_SCRATCH	equ	0xCF	;ACE Scratch Register (not used, because not available on all UARTs)
 343:				
 344:				;	Chapter_1	Page 0 interrupt & restart locations
 345:				;
 346:				;                        *******    *******    *******    *******
 347:				;                       *********  *********  *********  *********
 348:				;                       **     **  **     **  **     **  **     **
 349:				;                       **     **  **     **  **     **  **     **
 350:				;---------------------  **     **  **     **  **     **  **     **  ---------------------
 351:				;---------------------  **     **  **     **  **     **  **     **  ---------------------
 352:				;                       **     **  **     **  **     **  **     **
 353:				;                       **     **  **     **  **     **  **     **
 354:				;                       *********  *********  *********  *********
 355:				;                        *******    *******    *******    *******
 356:				
 357:				
 358:     -	0000          			org	0x0000
 359:									; Z80 CPU LDRTS HERE
 360:    0+4	0000  F3      			DI			; Disable Interrupts
 361:    4+10	0001  C30001  			JP	RESETLDRT
 362:				
 363:     -	0008          			org	0x0008		; RST	0x08
 364:   14+10	0008  C9      			RET
 365:				
 366:     -	0010          			org	0x0010		; RST	0x10
 367:   24+10	0010  C9      			RET
 368:						
 369:     -	0018          			org	0x0018		; RST	0x18
 370:   34+10	0018  C9      			RET
 371:						
 372:     -	0020          			org	0x0020		; RST	0x20
 373:   44+10	0020  C9      			RET
 374:				
 375:     -	0028          			org	0x0028		; RST	0x28
 376:   54+10	0028  C9      			RET
 377:				
 378:     -	0030          			org	0x0030		; RST	0x30
 379:   64+10	0030  C9      			RET
 380:				
 381:				;Interrupts:
 382:				;The Serial bit banger uses an interrupt on the fall of the start bit, therefore we must count
 383:				;clock cycles to the data bits.  Interrupts can happen in the middle of any instruction.  
 384:				;With most common instructions being between 4 and 16 tc, the count starts at 10 tc
 385:				;An Interrupt is really a RST 38 instruction (with 2 extra wait cycles)
 386:						;Previous Instruction	;10
 387:						;RST	0x38		;13  (11 + 2 wait cycles)
 388:     -	0038          			org	0x0038
 389:   74+4	0038  08      			EX	AF,AF'		;4
 390:   78+4	0039  D9      			EXX			;4
 391:   82+16	003A  2ACEFF  			LD	HL,(INT_VEC)	;16 Typical Calls are to ISR_DISPATCH
 392:   98+4	003D  E9      			JP	(HL)		;4
 393:				
 394:     -	0006          	RST38_LEN	EQU	$-0x0038
 395:				
 396:				;What the stack looks like on Interrupts...
 397:				;
 398:				;OLD-STACK    ISR-STACK
 399:				;   PC	
 400:				;		HL
 401:				;		AF
 402:				;SP		PC	(Call to ISR_DISPATCH from High Ram Dispatch)
 403:				;		PC	(Call to GET_REGISTER from ISR)
 404:				
 405:     -	0066          			org	0x0066		; NMI Service Routine
 406:  102+11	0066  E5      			PUSH	HL
 407:  113+16	0067  2ADCFF  			LD	HL,(NMI_VEC)
 408:  129+4	006A  E9      			JP	(HL)
 409:				;NMI_VEC:	RETN			;
 410:				
 411:				
 412:				
 413:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 414:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 415:				;	Chapter_2	Startup Code
 416:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 417:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 418:				
 419:     -	0100          			ORG	0x0100
 420:				;-------------------------------------------------------------------------------- RESET LDRTUP CODE
 421:     -	0100          	RESETLDRT:
 422:				;Save Registers & SET sp
 423:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 424:  133+8	0100  ED56    			IM	1		; Interrupts cause RST 0x38
 425:				
 426:									;No need to select ROM, we are already here.
 427:  141+16	0102  229EFF  			LD	(RSHL),HL
 428:				
 429:  157+10	0105  E1      			POP	HL		;Fetch PC
 430:  167+16	0106  22A0FF  			LD	(RPC),HL	;Save the PC
 431:  183+20	0109  ED7396FF			LD	(RSSP),SP	;Save the SP
 432:				
 433:  203+10	010D  319EFF  			LD	SP,RSDE+2	;Set Stack to save registers DE,BC,AF
 434:  213+11	0110  D5      			PUSH	DE
 435:  224+11	0111  C5      			PUSH	BC
 436:  235+11	0112  F5      			PUSH	AF
 437:				
 438:  246+7	0113  3E01    			LD	A,1
 439:  253+11	0115  D3C7    			OUT	(ACE_RESET),A	;RESET ACE
 440:				
 441:  264+4	0117  08      			EX	AF,AF'		;Save Alternate register set
 442:  268+4	0118  D9      			EXX			;Save Alternate register set
 443:  272+10	0119  31B0FF  			LD	SP,RSHL2+2	;Set Stack to save registers HL',DE',BC',AF'
 444:  282+11	011C  E5      			PUSH	HL
 445:  293+11	011D  D5      			PUSH	DE
 446:  304+11	011E  C5      			PUSH	BC
 447:  315+11	011F  F5      			PUSH	AF
 448:  326+4	0120  08      			EX	AF,AF'
 449:  330+4	0121  D9      			EXX
 450:				
 451:  334+9	0122  ED57    			LD	A,I		;Fetch IR
 452:  343+4	0124  47      			LD	B,A
 453:  347+9	0125  ED5F    			LD	A,R
 454:  356+4	0127  4F      			LD	C,A
 455:  360+11	0128  C5      			PUSH	BC		;Save IR
 456:				
 457:  371+15	0129  FDE5    			PUSH	IY
 458:  386+15	012B  DDE5    			PUSH	IX
 459:				
 460:  401+10	012D  31FEFA  			LD	SP, StackTop	; Stack = 0xFF80 (Next Stack Push Location = 0xFF7F,0xFF7E)
 461:				
 462:				
 463:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 464:				;Save Input State, Set default Output state
 465:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 466:				
 467:  411+7	0130  0E40    			LD	C,Port40	;Select I/O Port
 468:  418+7	0132  1E80    			LD	E,0x80		;Advance Column		
 469:  425+7	0134  0608    			LD	B,8		; 8 Tries to get to Column 0
 470:  432+12	0136  ED59    	RSIS_LP		OUT	(C),E		; Clear LED Display & Set RS-232 TXD to inactive state
 471:  444+12	0138  ED78    			IN	A,(C)		;Fetch Column
 472:  456+4	013A  57      			LD	D,A		;Save IN D (For RESET Test)
 473:  460+7	013B  E607    			AND	7		;Mask Column only
 474:  467+7+5	013D  2802    			JR   Z,	RSIS_OK		;When 0, exit Test Loop
 475:  474+8+5	013F  10F5    			DJNZ	RSIS_LP
 476:     -	0141          	RSIS_OK					;Input State upon reset saved IN Register D
 477:				
 478:				
 479:  482+10	0141  2100FF  			LD	HL,BIT_TABLE	;BIT_TABLE = 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80
 480:  492+7	0144  3E01    			LD	A,1
 481:  499+7	0146  77      	FILL_BT		LD	(HL),A
 482:  506+6	0147  23      			INC	HL
 483:  512+4	0148  07      			RLCA
 484:  516+7+5	0149  30FB    			JR  NC,	FILL_BT
 485:				
 486:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 487:				;Test Hardware - FP Board Present?
 488:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 489:				
 490:									;Verify FP board is present
 491:  523+10	014B  010018  			LD	BC,0x1800	; Several Loops through Column 0 proves FP board is working
 492:  533+7	014E  1E0A    			LD	E,10		; 10 Retries if not expected Column
 493:				
 494:  540+11	0150  DB40    	RTHW_LP		IN	A,(Port40)	;Fetch Column
 495:  551+7	0152  E607    			AND	7
 496:  558+4	0154  B9      			CP	C
 497:  562+10	0155  CA5D01  			JP  Z,	RTHW_OK		;Jump if Column = expected value
 498:				
 499:  572+4	0158  1D      			DEC	E		;If not expected, count the errors.
 500:  576+7+5	0159  280C    			JR  Z,	RTHW_EXIT	;If error chances down to zero, there's no FP
 501:  583+12	015B  1803    			JR	RTHW_ADV
 502:				
 503:  595+4	015D  0C      	RTHW_OK		INC	C		; Advance expected value
 504:  599+8	015E  CB99    			RES	3,C		; Limit expected value to 0-7
 505:  607+7	0160  3E80    	RTHW_ADV	LD	A,0x80		;Advance Column
 506:  614+11	0162  D340    			OUT	(Port40),A	; Clear LED Display & Set RS-232 TXD to inactive state
 507:  625+8+5	0164  10EA    			DJNZ	RTHW_LP
 508:  633+4	0166  5F      			LD	E,A
 509:     -	0167          	RTHW_EXIT				;E=80 FP present, (D still holding input state)
 510:									;E=00 NO FP
 511:				
 512:				
 513:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 514:				;Test Hardware - SIO Board Present?
 515:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 516:				
 517:  637+4	0167  AF      			XOR	A
 518:  641+11	0168  D3C7    			OUT	(ACE_RESET),A	;Cancel RESET of ACE
 519:						
 520:  652+7	016A  0600    			LD	B,0		;Count 256 times	
 521:  659+7	016C  3E80    			LD	A,0x80		;Set baud rate
 522:  666+11	016E  D3CB    			OUT	(ACE_LCR),A
 523:				
 524:  677+4	0170  78      	RTHW_SIOT_LP	LD	A,B		;Use the counter to test for the presence 
 525:  681+11	0171  D3C8    			OUT	(ACE_BAUD0),A	;of the ACE SCRATCH Register
 526:  692+11	0173  DBC8    			IN	A,(ACE_BAUD0)
 527:  703+4	0175  B8      			CP	B
 528:  707+7+5	0176  2006    			JR NZ,	RTHW_SIO_EXIT
 529:  714+8+5	0178  10F6    			DJNZ	RTHW_SIOT_LP
 530:  722+4	017A  1C      			INC	E		;All tests OK, Advance E so the LSD is 1
 531:  726+17	017B  CD7D26  			CALL	SD_DESELECT	;DISABLE SD CARD, LED's OFF
 532:  743+4	017E  7B      	RTHW_SIO_EXIT	LD	A,E
 533:  747+4	017F  07      			RLCA
 534:  751+13	0180  3295FF  			LD	(HW_LIST),A	;Save HW List
 535:									;00 NO Boards
 536:									;01 FP only
 537:									;02 SIO only
 538:									;03 FP & SIO
 539:				
 540:				
 541:  764+12	0183  180F    			JR 	CHK_RESET	;Ignore EXEC_RAM_2F8
 542:				
 543:				;		OR	A
 544:				;		JR NZ,	CHK_RESET	;Jump if any board is present
 545:				
 546:				
 547:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 548:				;Execute RAM program if NO FP Board Present
 549:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 550:									;If scan counter not running, then either Execute RAM OR HALT
 551:  776+16	0185  2A0080  	EXEC_RAM_2F8	LD	HL,(0x8000)	;Address of RAM Valid Signature
 552:  792+10	0188  01F802  			LD	BC,0x2F8	;(FP board probably not present)
 553:  802+4	018B  AF      			XOR	A		;Verify RAM valid with 2F8 signature at 0x8000
 554:  806+15	018C  ED42    			SBC	HL,BC
 555:  821+10	018E  CA0280  			JP	Z,0x8002	;Execute RAM
 556:  831+10	0191  C39101  			JP	$		;Or HALT
 557:				
 558:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 559:				;Determine Reason for RESET ie entering Monitor Mode (D=Key Input from save state section)
 560:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 561:									;Determine why the CPU is executing A RESET.
 562:									;  -Power on (RAM signature will be wrong)
 563:									;  -F-0 Reset Switch (one of the switches will still be pressed)
 564:									;  -RST 0 (look for C7 at previous location given by stack)
 565:									;  -External /RESET OR User program branches to 0000
 566:									;
 567:									;RC_TYPE
 568:									;0	COLD RESET (NO RAM SIGNATURE)
 569:									;1	F-E Soft Reset (SOFT_RST_FLAG = FE)
 570:									;2	Single Step (SOFT_RST_FLAG = D1)
 571:									;3	<Ctrl>-C (SOFT_RST_FLAG = CC)
 572:									;4	HALT (SOFT_RST_FLAG = 76)
 573:									;5	F-0 (F or 0 key on FP still down)
 574:									;6	RST0 ( M(PC-1) = C7)
 575:									;7	HARD RESET (Default if SOFT_RST_FLAG not set)
 576:				
 577:									;Test RAM Signature for Cold Start Entry
 578:  841+10	0194  2178FF  	CHK_RESET	LD	HL,RAMSIGNATURE		
 579:  851+7	0197  3EF0    			LD	A,0xF0		;First signature byte expected
 580:  858+7	0199  0608    			LD	B,8		;#bytes in signature (loop)
 581:  865+7	019B  BE      	RAMSIG_LP	CP	(HL)
 582:  872+7+5	019C  2007    			JR  NZ,	COLD_START
 583:  879+4	019E  2C      			INC	L
 584:  883+7	019F  D60F    			SUB	0xF
 585:  890+8+5	01A1  10F8    			DJNZ	RAMSIG_LP
 586:  898+12	01A3  182A    			JR	WARM_START
 587:				
 588:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 589:  910+10	01A5  2180FF  	COLD_START	LD	HL,RC_TYPE
 590:  920+7	01A8  060F    			LD	B,CS_CLR_LEN
 591:  927+17	01AA  CD100C  			CALL	CLEAR_BLOCK
 592:				
 593:						;DB	0		;(RC_TYPE)
 594:						;DB	0		;(RC_SOFT)
 595:						;DB	0		;(RC_STEP)
 596:						;DB	0		;(RC_CC)
 597:						;DB	0		;(RC_HALT)
 598:						;DB	0		;(RC_F0)
 599:						;DB	0		;(RC_RST0)
 600:						;DB	0		;(RC_HARD)
 601:						;DB	0		;(RegPtr)
 602:						;DW	0		;(ABUSS)
 603:						;DB	0		;(IoPtr)
 604:						;DB	0		;(RX_ERR_LDRT)
 605:						;DB	0		;(RX_ERR_STOP)
 606:						;DB	0		;(RX_ERR_OVR)
 607:						
 608:  944+7	01AD  3E0C    			LD	A,12
 609:  951+13	01AF  328FFF  			LD	(ACE_BAUD),A
 610:				
 611:  964+10	01B2  21FF17  			LD	HL,UiVec_RET
 612:  974+16	01B5  22B0FF  			LD	(UiVec),HL
 613:				
 614:  990+13	01B8  3A95FF  			LD	A,(HW_LIST)	;Fetch HW List
 615: 1003+7	01BB  E603    			AND	3		;00 NO FP
 616: 1010+4	01BD  4F      			LD	C,A		;01 FP only
 617: 1014+17	01BE  CD8613  			CALL	SET_IO		;02 SIO only
 618:									;03 SIO & FP
 619:						
 620: 1031+10	01C1  21FCFA  			LD	HL,StackTop-2
 621: 1041+16	01C4  2296FF  			LD	(RSSP),HL
 622: 1057+10	01C7  210080  			LD	HL,RAM_LDRT
 623: 1067+16	01CA  22A0FF  			LD	(RPC),HL
 624: 1083+12	01CD  1841    			JR	INIT_SYSTEM
 625:				
 626:									;Determine Warm Start condition
 627:									;Input: Various tests
 628:									;(D=Key Input from save state section)
 629:									;Output: HL=Pointer to Reset Codes (RC_????)
 630: 1095+10	01CF  2181FF  	WARM_START	LD	HL,RC_SOFT	;HL=RC_SOFT
 631: 1105+13	01D2  3ADFFF  			LD	A,(SOFT_RST_FLAG)
 632: 1118+7	01D5  FEFE    			CP	0xFE		;'FE' is the keyboard code for holding F & E
 633: 1125+7+5	01D7  282B    			JR  Z,	WS_SET
 634: 1132+4	01D9  2C      			INC	L		;HL=RC_STEP
 635: 1136+7	01DA  FED1    			CP	0xD1		;'D1' is the code for Do One step
 636: 1143+7+5	01DC  2826    			JR  Z,	WS_SET
 637: 1150+4	01DE  2C      			INC	L		;HL=RC_CC
 638: 1154+7	01DF  FECC    			CP	0xCC		;'CC' is the code for <Ctrl>-C
 639: 1161+7+5	01E1  2821    			JR  Z,	WS_SET
 640: 1168+4	01E3  2C      			INC	L		;HL=RC_HALT
 641: 1172+7	01E4  FE76    			CP	0x76		;'76' is the code and opcode for HALT
 642: 1179+7+5	01E6  281C    			JR  Z,	WS_SET
 643: 1186+4	01E8  2C      			INC	L		;HL=RC_F0
 644:						
 645: 1190+13	01E9  3A95FF  			LD	A,(HW_LIST)
 646: 1203+4	01EC  1F      			RRA
 647: 1207+7+5	01ED  3009    			JR  NC,	WS_NOFP
 648:						
 649: 1214+4	01EF  7A      			LD	A,D		;Fetch Input of Column 0
 650: 1218+8	01F0  CB6F    			BIT	5,A		;
 651: 1226+7+5	01F2  2010    			JR NZ,	WS_SET		;Jump if F switch pressed
 652: 1233+8	01F4  CB5F    			BIT	3,A		;
 653: 1241+7+5	01F6  280C    			JR  Z,	WS_SET		;Jump if 0 switch pressed
 654:						
 655: 1248+4	01F8  2C      	WS_NOFP		INC	L		;HL=RC_RST0
 656: 1252+20	01F9  ED5BA0FF			LD	DE,(RPC)
 657: 1272+6	01FD  1B      			DEC	DE
 658: 1278+7	01FE  1A      			LD	A,(DE)
 659: 1285+7	01FF  FEC7    			CP	0xC7		;Did we get here by a RESTART 0 instruction?
 660: 1292+7+5	0201  2801    			JR  Z,	WS_SET		;Jump if RST 0 Instruction
 661: 1299+4	0203  2C      			INC	L		;HL=RC_HARD
 662:				
 663: 1303+4	0204  7D      	WS_SET		LD	A,L		;Low address of Pointer & 7 = Reset code type
 664: 1307+13	0205  32DFFF  			LD	(SOFT_RST_FLAG),A ;Nuke flag until next time
 665: 1320+7	0208  E607    			AND	7
 666: 1327+13	020A  3280FF  			LD	(RC_TYPE),A
 667: 1340+17	020D  CD260E  			CALL	TINC		;Advance the reset counter
 668:				
 669:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 670:				;Init all System RAM, enable interrupts
 671:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 672: 1357+10	0210  2100FE  	INIT_SYSTEM	LD	HL,RXBUFFER
 673: 1367+7	0213  0600    			LD	B,0
 674: 1374+17	0215  CD100C  			CALL	CLEAR_BLOCK
 675:				
 676: 1391+10	0218  21D4FF  			LD	HL,CLEARED_SPACE
 677: 1401+7	021B  062C    			LD	B,CLEARED_LEN
 678: 1408+17	021D  CD100C  			CALL	CLEAR_BLOCK
 679:				
 680: 1425+16	0220  2ABCFF  			LD	HL,(DISPMODE)
 681: 1441+16	0223  22D4FF  			LD	(SDISPMODE),HL
 682:				
 683: 1457+17	0226  CD1D0C  			CALL	WRITE_BLOCK
 684:     -	0229  B2FF    			DW	BEEP_TO		;Where to write
 685:     -	022B  2200    			DW	34		;Bytes to write
 686:     -	022D  01      			DB	1		;(BEEP_TO)
 687:     -	022E  84      			DB	0x84		;(ANBAR_DEF) = MON MODE
 688:     -	022F  710C    			DW	GET_REG_MON	;(GET_REG)
 689:     -	0231  860C    			DW	PUT_REG_MON	;(PUT_REG)
 690:     -	0233  B217    			DW	CTRL_C_RET	;(CTRL_C_CHK)
 691:     -	0235  E317    			DW	IDISP_RET	;(LDISPMODE)
 692:     -	0237  E317    			DW	IDISP_RET	;(DISPMODE)
 693:     -	0239  4218    			DW	IMON_CMD	;(KEY_EVENT) Initialize to Command Mode
 694:     -	023B  01      			DB	1		;(IK_TIMER)
 695:     -	023C  90      			DB	0x90		;(KEYBFMODE) HEX Keyboard Mode (F on release)
 696:     -	023D  01      			DB	1		;(DISPLABEL)
 697:     -	023E  FF      			DB	-1		;(IK_HEXST)
 698:     -	023F  E0FF    			DW	LED_DISPLAY	;(HEX_CURSOR) @d1
 699:     -	0241  2019    			DW	HEX2ABUSS	;(HEX_READY)
 700:     -	0243  E0FF    			DW	LED_DISPLAY	;(LED_CURSOR)
 701:     -	0245  00FE    			DW	RXBUFFER	;(RXBHEAD)
 702:     -	0247  00FE    			DW	RXBUFFER	;(RXBTAIL)
 703:     -	0249  2AFB    			DW	ISR_DISPATCH	;(INT_VEC)
 704:     -	024B  E0FF    			DW	LED_DISPLAY	;(SCAN_PTR)
 705:     -	024D  EC16    			DW	DO_HALT_TEST	;(HALT_TEST)
 706:				
 707: 1474+7	024F  3E80    			LD	A,0x80		;Advance Column / Clear Counter for Interrupt
 708: 1481+11	0251  D340    			OUT	(Port40),A	; Clear LED Display & Set RS-232 TXD to inactive state
 709: 1492+17	0253  CD2A0E  			CALL	DELAY_100mS
 710:				
 711: 1509+10	0256  217C02  			LD	HL,LED_SPLASH_TBL
 712: 1519+13	0259  3A80FF  			LD	A,(RC_TYPE)
 713: 1532+4	025C  07      			RLCA
 714: 1536+4	025D  07      			RLCA
 715: 1540+4	025E  07      			RLCA
 716: 1544+17	025F  CD450E  			CALL	ADD_HL_A
 717: 1561+17	0262  CD781C  			CALL	LED_PRINT
 718:				
 719: 1578+13	0265  3A80FF  			LD	A,(RC_TYPE)
 720: 1591+4	0268  B7      			OR	A
 721: 1595+7+5	0269  280D    			JR  Z,	LSPLASH_CNT
 722: 1602+10	026B  2180FF  			LD	HL, RC_TYPE	;Print count of reset type
 723: 1612+17	026E  CD450E  			CALL	ADD_HL_A
 724: 1629+7	0271  7E      			LD	A,(HL)
 725: 1636+10	0272  21E5FF  			LD	HL,LED_DISPLAY+5
 726: 1646+17	0275  CD4A1C  			CALL	LED_PUT_BYTE_HL
 727: 1663+10	0278  3680    	LSPLASH_CNT	LD	(HL),0x80	;Annunciator LED's OFF
 728:				
 729: 1673+12	027A  1840    			JR	SKIP_TABLE1
 730:				
 731:     -	027C  2D44454C	LED_SPLASH_TBL	DB	"-DELAY-",EOS
	              41592D00
 732:     -	0284  536F6674			DB	"Soft   ",EOS
	              20202000
 733:     -	028C  53744570			DB	"StEp   ",EOS
	              20202000
 734:     -	0294  5E432020			DB	"^C     ",EOS
	              20202000
 735:     -	029C  48414C74			DB	"HALt   ",EOS
	              20202000
 736:     -	02A4  462D3020			DB	"F-0    ",EOS
	              20202000
 737:     -	02AC  52737430			DB	"Rst0   ",EOS
	              20202000
 738:     -	02B4  48415244			DB	"HARD   ",EOS
	              20202000
 739:				
 740:     -	02BC          	SKIP_TABLE1	
 741:						
 742: 1685+17	02BC  CD7108  			CALL	SET_BANK	;Bank 0
 743:						
 744: 1702+17	02BF  CD2128  			CALL	LOAD_HIGH_RAM	;Copy subroutines to HIGH RAM
 745:				
 746: 1719+17	02C2  CDF614  			CALL	ACE_SET_BAUD	;Set Baud & Word to saved setting (might have been changed from 9600)
 747:				
 748: 1736+4	02C5  FB      			EI			;************** Interrupts ON!!!!
 749:				
 750:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 751:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 752:				;	Chapter_3	Main Loop, RS-232 MONITOR, MENU selection
 753:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 754:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 755:				
 756: 1740+7	02C6  3E80    			LD	A,0x80		;
 757: 1747+13	02C8  32F5FF  			LD	(SCAN_LED),A
 758: 1760+11	02CB  D340    			OUT	(Port40),A	;Reset Timer interrupt
 759:				
 760: 1771+13	02CD  3A80FF  			LD	A,(RC_TYPE)
 761:						;CALL	PRINTI
 762:						;DB	CR,LF,"RT_TYPE=",EOS		
 763:						;CALL	PUT_BYTE
 764: 1784+4	02D0  B7      			OR	A
 765: 1788+7+5	02D1  201E    			JR NZ,	NOT_COLD
 766:				
 767: 1795+7	02D3  0E14    			LD	C,20		;2 Seconds
 768: 1802+17	02D5  CD2C0E  			CALL	DELAY_C		;Delay in 100mSEC
 769:				
 770: 1819+17	02D8  CD8A1C  			CALL	LED_HOME_PRINTI
 771:     -	02DB  434F4C44			DB	"COLD 00",EOS
	              20303000
 772:						
 773: 1836+10	02E3  2178FF  			LD	HL,RAMSIGNATURE
 774: 1846+7	02E6  3EF0    			LD	A,0xF0		;First signature byte expected
 775: 1853+7	02E8  0608    			LD	B,8		;#bytes in signature (loop)
 776: 1860+7	02EA  77      	RAMSIGN_LP	LD	(HL),A		;Save Signature
 777: 1867+4	02EB  2C      			INC	L
 778: 1871+7	02EC  D60F    			SUB	0xF
 779: 1878+8+5	02EE  10FA    			DJNZ	RAMSIGN_LP
 780: 1886+4	02F0  AF      			XOR	A
 781:						
 782: 1890+4	02F1  07      	NOT_COLD	RLCA
 783: 1894+10	02F2  211603  			LD	HL,RS232_SPLASH
 784: 1904+17	02F5  CD450E  			CALL	ADD_HL_A
 785: 1921+17	02F8  CD4A0E  			CALL	LD_HL_HL
 786: 1938+17	02FB  CD1F0E  			CALL	PUT_NEW_LINE		
 787: 1955+17	02FE  CDBD0D  			CALL	PRINT
 788: 1972+13	0301  3A80FF  			LD	A,(RC_TYPE)
 789: 1985+4	0304  B7      			OR	A
 790: 1989+7+5	0305  286D    			JR   Z,	SPLASH_VERSION
 791: 1996+10	0307  2180FF  			LD	HL, RC_TYPE	;Print count of reset type
 792: 2006+17	030A  CD450E  			CALL	ADD_HL_A
 793: 2023+7	030D  7E      			LD	A,(HL)
 794: 2030+17	030E  CDF30D  			CALL	SPACE_PUT_BYTE
 795: 2047+17	0311  CD1F09  			CALL	REG_DISP_ALL
 796: 2064+12	0314  1861    			JR	SKIP_TABLE2
 797:				
 798:     -	0316  2603    	RS232_SPLASH	DW	R_COLD
 799:     -	0318  3303    			DW	R_SOFT
 800:     -	031A  4003    			DW	R_STEP
 801:     -	031C  4503    			DW	R_CC
 802:     -	031E  4E03    			DW	R_HALT
 803:     -	0320  5703    			DW	R_F0
 804:     -	0322  6103    			DW	R_RST0
 805:     -	0324  6903    			DW	R_HARD
 806:				
 807:     -	0326  436F6C64	R_COLD		DB	"Cold Start",CR,LF,EOS
	              20537461
	              72740D0A
	              00
 808:     -	0333  536F6674	R_SOFT		DB	"Soft Restart",EOS
	              20526573
	              74617274
	              00
 809:     -	0340  53746570	R_STEP		DB	"Step",EOS
	              00
 810:     -	0345  3C437472	R_CC		DB	"<Ctrl>-C",EOS
	              6C3E2D43
	              00
 811:     -	034E  43505520	R_HALT		DB	"CPU HALT",EOS
	              48414C54
	              00
 812:     -	0357  462D3020	R_F0		DB	"F-0 Reset",EOS
	              52657365
	              7400
 813:     -	0361  3C427265	R_RST0		DB	"<Break>",EOS
	              616B3E00
 814:     -	0369  48617264	R_HARD		DB	"Hard Reset",EOS
	              20526573
	              657400
 815:				
 816: 2076+17	0374  CD9B08  	SPLASH_VERSION	CALL 	PUT_VERSION
 817:				
 818: 2093+13	0377  3A80FF  	SKIP_TABLE2	LD	A,(RC_TYPE)
 819: 2106+7	037A  FE02    			CP	2		;If returning from Single Step, restore Monitor Display
 820: 2113+7+5	037C  2009    			JR NZ,	WB_NOT_STEP
 821: 2120+16	037E  2AD4FF  			LD	HL,(SDISPMODE)
 822: 2136+16	0381  22BAFF  			LD	(LDISPMODE),HL
 823: 2152+16	0384  22BCFF  			LD	(DISPMODE),HL
 824:     -	0387          	WB_NOT_STEP	
 825:				
 826:				
 827:				;                 ******       *****      *****    *********
 828:				;                 *******     *******    *******   *********
 829:				;                 **    **   ***   ***  ***   ***     ***
 830:				;                 **    **   **     **  **     **     ***
 831:				;                 *******    **     **  **     **     ***
 832:				;                 *******    **     **  **     **     ***
 833:				;                 **    **   **     **  **     **     ***
 834:				;                 **    **   ***   ***  ***   ***     ***
 835:				;                 *******     *******    *******      ***
 836:				;                 ******       *****      *****       ***
 837:				
 838:				
 839:				
 840:				
 841: 2168+13	0387  3A80FF  			LD	A,(RC_TYPE)	;Auto boot option for cold start or RESET only
 842: 2181+4	038A  B7      			OR	A
 843: 2185+7+5	038B  2804    			JR Z,	AUTO_BOOT_MENU
 844: 2192+7	038D  FE07    			CP	7
 845: 2199+7+5	038F  2051    			JR NZ,	MAIN_MENU
 846:				
 847:					;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
 848:				
 849: 2206+13	0391  3A95FF  	AUTO_BOOT_MENU	LD	A,(HW_LIST)	;Auto boot if no card or SD card
 850: 2219+4	0394  B7      			OR	A
 851: 2223+7+5	0395  2804    			JR   Z,	AUTO_BOOT_DO
 852: 2230+7	0397  E602    			AND	2
 853: 2237+7+5	0399  2847    			JR   Z,	MAIN_MENU	;No Option to boot from SD Card
 854:						
 855: 2244+17	039B  CDCA0D  	AUTO_BOOT_DO	CALL	PRINTI		;Monitor Start, Display Welcome Message
 856:     -	039E  0D0A5072			DB	CR,LF,"Press M for Monitor",EOS
	              65737320
	              4D20666F
	              72204D6F
	              6E69746F
	              7200
 857:						
 858: 2261+7	03B4  061E    			LD	B,30
 859: 2268+17	03B6  CD3214  	AUTO_BOOT_LP	CALL	DOT_GETCHAR	;C=1 if dots timed out or <TAB>, or C=0 and A=char
 860: 2285+7+5	03B9  3806    			JR  C,	AUTO_BOOT_GO
 861: 2292+7	03BB  FE4D    			CP	'M'
 862: 2299+7+5	03BD  2823    			JR  Z,	MAIN_MENU	;M? Go Monitor
 863: 2306+12	03BF  18F5    			JR	AUTO_BOOT_LP
 864:						
 865: 2318+10	03C1  2180FF  	AUTO_BOOT_GO	LD	HL,RC_TYPE	;Flag auto boot
 866: 2328+15	03C4  CBFE    			SET	7,(HL)		
 867: 2343+13	03C6  3A95FF  			LD	A,(HW_LIST)	;Auto boot to BASIC if no board
 868: 2356+4	03C9  B7      			OR	A
 869: 2360+10	03CA  CA002A  			JP   Z,	GO_BASIC
 870: 2370+17	03CD  CD1D0C  			CALL	WRITE_BLOCK
 871:     -	03D0  43FF    			DW	FILENAME	;Where to write
 872:     -	03D2  0B00    			DW	11		;Bytes to write
 873:     -	03D4  5A38304D			DB	'Z80MC_GOHEX'
	              435F474F
	              484558
 874: 2387+17	03DF  CD931C  			CALL	GO_SD_CARD	;Do a CALL, let any returns go to Monitor
 875:						
 876:						
 877:						
 878:				
 879:				;************************************************************************************
 880:				;************************************************************************************
 881:				;************************************************************************************
 882:				;************************************************************************************
 883:				;
 884:				;
 885:				;                 ***        ***    *********    **       **     **       **
 886:				;                 ****      ****    *********    ***      **     **       **
 887:				;                 ** **    ** **    **           ****     **     **       **
 888:				;                 **  **  **  **    **           ** **    **     **       **
 889:				;                 **   ****   **    *******      **  **   **     **       **
 890:				;                 **    **    **    *******      **   **  **     **       **
 891:				;                 **          **    **           **    ** **     **       **
 892:				;                 **          **    **           **     ****     ***     ***
 893:				;                 **          **    *********    **      ***      ********* 
 894:				;                 **          **    *********    **       **        *****  
 895:				
 896:				
 897:				;Monitor
 898:				;Functions:
 899:				; -Dump, Edit & Execute Memory.
 900:				; -Input Port and Output Port.
 901:				; -RAM Test
 902:				; -ASCII Upload intel HEX file
 903:				; -XMODEM up/down load to Memory
 904:				;
 905:				; D XXXX YYYY	Dump memory from XXXX to YYYY
 906:				; E XXXX	Edit memory starting at XXXX (type an X and press enter to exit entry)
 907:				; G XXXX	GO starting at address XXXX (Monitor program address left on stack)
 908:				; I XX		Input from I/O port XX and display as hex
 909:				; O XX YY	Output to I/O port XX byte YY
 910:				; L		Loop back test
 911:				; X U XXXX	XMODEM Upload to memory at XXXX (CRC or CHECKSUM)
 912:				; X D XXXX CCCC	XMODEM Download from memory at XXXX for CCCC number of 128 byte blocks
 913:				; :ssHHLLttDDDDDD...CS   -ASCII UPLOAD Intel HEX file to Memory.  Monitor auto downloads with the reception of a colon.
 914:				; R XX YY	RAM TEST from pages XX to YY
 915:				; V		Report Version
 916:				
 917:				
 918:				;----------------------------------------------------------------------------------------------------; MAIN MENU
 919:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 920:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 921:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 922:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 923:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 924:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 925:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 926:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 927:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 928:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 929:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 930:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 931:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 932:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 933:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 934:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 935:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
 936:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
 937:				;----------------------------------------------------------------------------------------------------; MAIN MENU
 938:				
 939: 2404+10	03E2  31FEFA  	MAIN_MENU:	LD	SP, StackTop	; Reset Stack = 0xFF80
 940: 2414+4	03E5  AF      			XOR	A
 941:							
 942: 2418+13	03E6  3243FF  			LD	(FILENAME),A	;Nuke any Auto Run
 943: 2431+10	03E9  21E203  			LD	HL, MAIN_MENU	;Push Mainmenu onto stack as default return address
 944: 2441+11	03EC  E5      			PUSH	HL
 945:						
 946: 2452+17	03ED  CD2A14  			CALL	PURGE
 947:						
 948: 2469+17	03F0  CDCA0D  			CALL	PRINTI		;Monitor Start, Display Welcome Message
 949:     -	03F3  0D0A4D61			DB	CR,LF,"Main Menu >",EOS
	              696E204D
	              656E7520
	              3E00
 950:						
 951: 2486+7	0401  3EFF    			LD	A,0xFF
 952: 2493+17	0403  CDD527  			CALL	SET_ECHO	;Echo on
 953:				
 954: 2510+17	0406  CDE013  			CALL 	GET_CHAR	;get char
 955:				
 956: 2527+7	0409  FE31    			CP 	'1'
 957: 2534+10	040B  CAA407  			JP Z,	SW2_BIT
 958: 2544+7	040E  FE32    			CP 	'2'
 959: 2551+10	0410  CAAC07  			JP Z,	SW2_ACE
 960: 2561+7	0413  FE33    			CP 	'3'
 961: 2568+10	0415  CAB407  			JP Z,	SW2_BOTH		
 962:				
 963: 2578+7	0418  E65F    			AND 	0x5F		;to upper case
 964: 2585+7	041A  FE42    			CP 	'B'		;
 965: 2592+10	041C  CA002A  			JP Z, 	GO_BASIC	; B = GO BASIC
 966: 2602+7	041F  FE43    			CP 	'C'		;
 967: 2609+10	0421  CA5F0A  			JP Z, 	MEM_DUMP	; C = Memory Dump (Continuous)
 968: 2619+7	0424  FE44    			CP 	'D'		;
 969: 2626+10	0426  CA7E0A  			JP Z, 	MEM_DUMP_PAGED	; D = Memory Dump
 970: 2636+7	0429  FE45    			CP 	'E'
 971: 2643+10	042B  CA1D0B  			JP Z, 	MEM_EDIT	; E = Edit Memory
 972: 2653+7	042E  FE47    			CP 	'G'
 973: 2660+10	0430  CA430B  			JP Z, 	MEM_EXEC	; G = Go (Execute at)
 974: 2670+7	0433  FE48    			CP	'H'
 975: 2677+10	0435  CA4F0E  			JP Z,	GETHEXFILE	; H = START HEX FILE LOAD
 976: 2687+7	0438  FE49    			CP 	'I'
 977: 2694+10	043A  CAFC0B  			JP Z, 	PORT_INP	; I = Input from Port
 978: 2704+7	043D  FE4C    			CP 	'L'
 979: 2711+10	043F  CAB709  			JP Z,	LOOP_BACK_TEST	; L = Loop Back Test
 980: 2721+7	0442  FE4D    			CP 	'M'
 981: 2728+10	0444  CA150A  			JP Z,	MEM_ENTER	; M = ENTER INTO MEMORY
 982: 2738+7	0447  FE4F    			CP 	'O'
 983: 2745+10	0449  CA060C  			JP Z, 	PORT_OUT	; O = Output to port
 984: 2755+7	044C  FE50    			CP 	'P'
 985: 2762+10	044E  CA0B08  			JP Z,	PORT_SPEED	; P = Port Speed for ACE
 986: 2772+7	0451  FE52    			CP 	'R'
 987: 2779+10	0453  CA1509  			JP Z,	REG_MENU	; R = REGISTER OPERATIONS
 988: 2789+7	0456  FE53    			CP 	'S'		;
 989: 2796+10	0458  CA931C  			JP Z, 	GO_SD_CARD	; S = BOOT SD CARD
 990: 2806+7	045B  FE54    			CP 	'T'
 991: 2813+10	045D  CA0411  			JP Z,	RAM_TEST	; T = RAM TEST
 992: 2823+7	0460  FE55    			CP 	'U'
 993: 2830+10	0462  CA3108  			JP Z,	USE_RAM		; U = USE RAM/ROM
 994: 2840+7	0465  FE56    			CP 	'V'
 995: 2847+10	0467  CA9B08  			JP Z,	PUT_VERSION	; V = Version
 996: 2857+7	046A  FE57    			CP 	'W'
 997: 2864+10	046C  CA401A  			JP Z, 	GO_SINGLE	; W = Single Step
 998: 2874+7	046F  FE58    			CP 	'X'
 999: 2881+10	0471  CAEE0E  			JP Z, 	XMODEM		; X = XMODEM
1000: 2891+7	0474  FE59    			CP 	'Y'
1001: 2898+10	0476  CADA07  			JP Z,	WHICH_PORT	; Y = Display Which port
1002:				
1003: 2908+17	0479  CDCA0D  	PRINT_MENU	CALL 	PRINTI		;Display Help when input is invalid
1004:     -	047C  0D0A4845			DB	CR,LF,"HELP"		
	              4C50
1005:     -	0482  0D0A4420			DB	CR,LF,"D XXXX YYYY    Dump memory from XXXX to YYYY"
	              58585858
	              20595959
	              59202020
	              2044756D
	              70206D65
	              6D6F7279
	              2066726F
	              6D205858
	              58582074
	              6F205959
	              5959
1006:     -	04B0  0D0A4320			DB	CR,LF,"C XXXX YYYY    Continous Dump (no pause)"
	              58585858
	              20595959
	              59202020
	              20436F6E
	              74696E6F
	              75732044
	              756D7020
	              286E6F20
	              70617573
	              6529
1007:     -	04DA  0D0A4520			DB	CR,LF,"E XXXX         Edit memory starting at XXXX"
	              58585858
	              20202020
	              20202020
	              20456469
	              74206D65
	              6D6F7279
	              20737461
	              7274696E
	              67206174
	              20585858
	              58
1008:     -	0507  0D0A4D20			DB	CR,LF,"M XXXX YY..YY  Enter many bytes into memory at XXXX"
	              58585858
	              2059592E
	              2E595920
	              20456E74
	              6572206D
	              616E7920
	              62797465
	              7320696E
	              746F206D
	              656D6F72
	              79206174
	              20585858
	              58
1009:     -	053C  0D0A4720			DB	CR,LF,"G [XXXX]       GO (PC Optional)"
	              5B585858
	              585D2020
	              20202020
	              20474F20
	              28504320
	              4F707469
	              6F6E616C
	              29
1010:     -	055D  0D0A5720			DB	CR,LF,"W              Single Step"
	              20202020
	              20202020
	              20202020
	              2053696E
	              676C6520
	              53746570
1011:     -	0579  0D0A4920			DB	CR,LF,"I XX           Input from I/O"
	              58582020
	              20202020
	              20202020
	              20496E70
	              75742066
	              726F6D20
	              492F4F
1012:     -	0598  0D0A4F20			DB	CR,LF,"O XX YY        Output to I/O"
	              58582059
	              59202020
	              20202020
	              204F7574
	              70757420
	              746F2049
	              2F4F
1013:     -	05B6  0D0A5220			DB	CR,LF,"R rr [=xx]     Register"
	              7272205B
	              3D78785D
	              20202020
	              20526567
	              69737465
	              72
1014:     -	05CF  0D0A4C20			DB	CR,LF,"L              Loop back test"
	              20202020
	              20202020
	              20202020
	              204C6F6F
	              70206261
	              636B2074
	              657374
1015:     -	05EE  0D0A5420			DB	CR,LF,"T XX YY        RAM TEST from pages XX to YY"
	              58582059
	              59202020
	              20202020
	              2052414D
	              20544553
	              54206672
	              6F6D2070
	              61676573
	              20585820
	              746F2059
	              59
1016:     -	061B  0D0A5620			DB	CR,LF,"V              Version"
	              20202020
	              20202020
	              20202020
	              20566572
	              73696F6E
1017:     -	0633  0D0A4820			DB	CR,LF,"H              UPLOAD Intel HEX file"
	              20202020
	              20202020
	              20202020
	              2055504C
	              4F414420
	              496E7465
	              6C204845
	              58206669
	              6C65
1018:     -	0659  0D0A5820			DB	CR,LF,"X U XXXX       XMODEM Upload to memory at XXXX"
	              55205858
	              58582020
	              20202020
	              20584D4F
	              44454D20
	              55706C6F
	              61642074
	              6F206D65
	              6D6F7279
	              20617420
	              58585858
1019:     -	0689  0D0A5820			DB	CR,LF,"X D XXXX CCCC  XMODEM Download from XXXX for CCCC #of 128 byte blocks"
	              44205858
	              58582043
	              43434320
	              20584D4F
	              44454D20
	              446F776E
	              6C6F6164
	              2066726F
	              6D205858
	              58582066
	              6F722043
	              43434320
	              236F6620
	              31323820
	              62797465
	              20626C6F
	              636B73
1020:     -	06D0  0D0A5020			DB	CR,LF,"P              Port Speed (ACE Only)"
	              20202020
	              20202020
	              20202020
	              20506F72
	              74205370
	              65656420
	              28414345
	              204F6E6C
	              7929
1021:     -	06F6  0D0A312C			DB	CR,LF,"1,2,3          Switch Console Input"
	              322C3320
	              20202020
	              20202020
	              20537769
	              74636820
	              436F6E73
	              6F6C6520
	              496E7075
	              74
1022:     -	071B  0D0A5920			DB	CR,LF,"Y              Identify Port"
	              20202020
	              20202020
	              20202020
	              20496465
	              6E746966
	              7920506F
	              7274
1023:     -	0739  0D0A5520			DB	CR,LF,"U              Use ROM or RAM BANK"
	              20202020
	              20202020
	              20202020
	              20557365
	              20524F4D
	              206F7220
	              52414D20
	              42414E4B
1024:     -	075D  0D0A5320			DB	CR,LF,"S              SD CARD BOOT"
	              20202020
	              20202020
	              20202020
	              20534420
	              43415244
	              20424F4F
	              54
1025:     -	077A  0D0A4220			DB	CR,LF,"B              BASIC - DAVE DUNFIELD"
	              20202020
	              20202020
	              20202020
	              20424153
	              4943202D
	              20444156
	              45204455
	              4E464945
	              4C44
1026:     -	07A0  0D0A00  			DB	CR,LF,EOS
1027: 2925+10	07A3  C9      			RET
1028:				
1029:				
1030:				;1,2,3          Switch Console Input"
1031:				
1032:				;A
1033:				;B BASIC
1034:				;C Continous Dump (no pause)
1035:				;D Dump memory
1036:				;E Edit memory
1037:				;F
1038:				;G GO (PC Optional)
1039:				;H UPLOAD Intel HEX file
1040:				;I Input from I/O
1041:				;J
1042:				;K
1043:				;L Loop back test
1044:				;M Enter many bytes
1045:				;N
1046:				;O Output to I/O
1047:				;P Port Speed
1048:				;Q
1049:				;R Register
1050:				;S SD CARD BOOT
1051:				;T RAM TEST
1052:				;U Use ROM or RAM BANK
1053:				;V Version
1054:				;W Single Step
1055:				;X XMODEM
1056:				;Y Identify Port
1057:				;Z
1058:				
1059:				
1060:				
1061: 2935+7	07A4  0E01    	SW2_BIT		LD	C,1
1062: 2942+17	07A6  CD8613  			CALL	SET_IO
1063: 2959+5+6	07A9  D8      			RET  C
1064: 2964+12	07AA  180E    			JR	PUT_IOMSG
1065:				
1066: 2976+7	07AC  0E02    	SW2_ACE		LD	C,2
1067: 2983+17	07AE  CD8613  			CALL	SET_IO
1068: 3000+5+6	07B1  D8      			RET  C
1069: 3005+12	07B2  1806    			JR	PUT_IOMSG
1070:				
1071: 3017+7	07B4  0E03    	SW2_BOTH	LD	C,3
1072: 3024+17	07B6  CD8613  			CALL	SET_IO
1073: 3041+5+6	07B9  D8      			RET  C
1074:				
1075: 3046+17	07BA  CD1F0E  	PUT_IOMSG	CALL	PUT_NEW_LINE
1076: 3063+13	07BD  3A94FF  			LD	A,(HW_SETIO)
1077: 3076+4	07C0  3D      			DEC	A
1078: 3080+4	07C1  07      			RLCA
1079: 3084+4	07C2  07      			RLCA
1080: 3088+10	07C3  21CD07  			LD	HL,IO_MSG
1081: 3098+17	07C6  CD450E  			CALL	ADD_HL_A
1082: 3115+17	07C9  CDBD0D  			CALL	PRINT
1083: 3132+10	07CC  C9      			RET
1084:				
1085:     -	07CD  42495400	IO_MSG		DB	"BIT",EOS
1086:     -	07D1  41434500			DB	"ACE",EOS
1087:     -	07D5  424F5448			DB	"BOTH",EOS
	              00
1088:				
1089:				
1090: 3142+17	07DA  CD8A1C  	WHICH_PORT	CALL	LED_HOME_PRINTI		
1091:     -	07DD  4C454420			DB	"LED ",EOS
	              00
1092: 3159+13	07E2  3A94FF  			LD	A,(HW_SETIO)
1093: 3172+4	07E5  47      			LD	B,A
1094: 3176+7	07E6  0E01    			LD	C,1
1095: 3183+17	07E8  CD8613  			CALL	SET_IO
1096: 3200+7+5	07EB  3809    			JR C,	WP_NOBIT
1097: 3207+17	07ED  CDCA0D  			CALL	PRINTI		
1098:     -	07F0  0D0A4249			DB	CR,LF,"BIT",EOS
	              5400
1099: 3224+7	07F6  0E02    	WP_NOBIT	LD	C,2
1100: 3231+17	07F8  CD8613  			CALL	SET_IO
1101: 3248+7+5	07FB  3809    			JR C,	WP_NOACE
1102: 3255+17	07FD  CDCA0D  			CALL	PRINTI		
1103:     -	0800  0D0A4143			DB	CR,LF,"ACE",EOS		
	              4500
1104: 3272+4	0806  48      	WP_NOACE	LD	C,B
1105: 3276+17	0807  CD8613  			CALL	SET_IO
1106: 3293+10	080A  C9      			RET
1107:				
1108: 3303+17	080B  CDCA0D  	PORT_SPEED	CALL	PRINTI		
1109:     -	080E  0D0A2830			DB	CR,LF,"(0C=9600) BAUD:",EOS
	              433D3936
	              30302920
	              42415544
	              3A00
1110: 3320+13	0820  3A8FFF  			LD	A,(ACE_BAUD)
1111: 3333+17	0823  CDF60D  			CALL	PUT_BYTE
1112: 3350+17	0826  CD490D  			CALL	SPACE_GET_BYTE
1113: 3367+5+6	0829  D8      			RET  C
1114: 3372+13	082A  328FFF  			LD	(ACE_BAUD),A
1115: 3385+17	082D  CDF614  			CALL	ACE_SET_BAUD
1116: 3402+10	0830  C9      			RET
1117:				
1118: 3412+17	0831  CDCA0D  	USE_RAM		CALL	PRINTI		
1119:     -	0834  0D0A4375			DB	CR,LF,"Currently using:",EOS
	              7272656E
	              746C7920
	              7573696E
	              673A00
1120: 3429+17	0847  CD7A08  			CALL	DISP_RRBANK
1121: 3446+17	084A  CDCA0D  			CALL	PRINTI		
1122:     -	084D  0D0A456E			DB	CR,LF,"Enter 0-F,R ",EOS
	              74657220
	              302D462C
	              522000
1123: 3463+17	085C  CD950D  			CALL	GET_HEX
1124: 3480+7+5	085F  3804    			JR   C,	UR_NOTRAM
1125: 3487+4	0861  07      			RLCA
1126: 3491+4	0862  3C      			INC	A
1127: 3495+12	0863  1806    			JR	UR_RET
1128: 3507+7	0865  E65F    	UR_NOTRAM	AND	0x5F		;To upper case
1129: 3514+7	0867  D652    			SUB	'R'		;If ='R', Use ROM (A=0)
1130: 3521+7+5	0869  2003    			JR  NZ,	UR_RET1		
1131: 3528+13	086B  32DBFF  	UR_RET		LD	(READ_RAMROM),A
1132: 3541+17	086E  CD7A08  	UR_RET1		CALL	DISP_RRBANK
1133: 3558+13	0871  3ADBFF  	SET_BANK	LD	A,(READ_RAMROM)
1134: 3571+4	0874  1F      			RRA
1135: 3575+7	0875  E60F    			AND	0xF
1136: 3582+11	0877  D3CC    			OUT	(ACE_OUT),A	;SET Bank
1137: 3593+10	0879  C9      			RET
1138:								
1139: 3603+13	087A  3ADBFF  	DISP_RRBANK	LD	A,(READ_RAMROM)
1140: 3616+4	087D  1F      			RRA
1141: 3620+7+5	087E  3012    			JR  NC,	DRR_ROM
1142: 3627+17	0880  CDCA0D  			CALL	PRINTI
1143:     -	0883  2052414D			DB	" RAM BANK:",EOS		
	              2042414E
	              4B3A00
1144: 3644+17	088E  CD090E  			CALL	PUT_HEX
1145: 3661+10	0891  C9      			RET
1146: 3671+17	0892  CDCA0D  	DRR_ROM		CALL	PRINTI
1147:     -	0895  20524F4D			DB	" ROM",EOS
	              00
1148: 3688+10	089A  C9      			RET
1149:						
1150:				
1151:				
1152:				
1153:						
1154:				
1155:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1156:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1157:				;	Chapter_4	Menu operations
1158:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1159:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1160:				
1161:				;=============================================================================
1162:				;Display Version
1163:				;-----------------------------------------------------------------------------
1164: 3698+17	089B  CDCA0D  	PUT_VERSION	CALL	PRINTI
1165:     -	089E  0D0A5A38		DB	CR,LF,"Z80 MEMBERSHIP CARD MICRO-SD, v1.5beta July 23, 2017",CR,LF,EOS
	              30204D45
	              4D424552
	              53484950
	              20434152
	              44204D49
	              43524F2D
	              53442C20
	              76312E35
	              62657461
	              204A756C
	              79203233
	              2C203230
	              31370D0A
	              00
1166:				;		VERSION_MSG
1167: 3715+17	08D7  CDCA0D  			CALL	PRINTI		
1168:     -	08DA  48617264			DB	"Hardware: ",EOS	
	              77617265
	              3A2000
1169: 3732+13	08E5  3A95FF  			LD	A,(HW_LIST)	;00 NO FP
1170: 3745+17	08E8  CDF60D  			CALL	PUT_BYTE	;01 FP only
1171: 3762+4	08EB  B7      			OR	A		;02 SIO only
1172: 3766+7+5	08EC  200A    			JR NZ,	PVH_0		;03 FP & SIO
1173: 3773+17	08EE  CDCA0D  			CALL	PRINTI		
1174:     -	08F1  204E6F6E			DB	" None",EOS
	              6500
1175: 3790+10	08F7  C9      			RET
1176:						
1177: 3800+4	08F8  0F      	PVH_0		RRCA
1178: 3804+7	08F9  0E20    			LD	C,' '
1179: 3811+7+5	08FB  3009    			JR NC,	PVH_1
1180: 3818+7	08FD  0E2C    			LD	C,','
1181: 3825+17	08FF  CDCA0D  			CALL	PRINTI		
1182:     -	0902  20465000			DB	" FP",EOS
1183: 3842+4	0906  0F      	PVH_1		RRCA
1184: 3846+5+6	0907  D0      			RET NC
1185: 3851+4	0908  79      			LD	A,C
1186: 3855+17	0909  CDEC13  			CALL	PUT_CHAR
1187: 3872+17	090C  CDCA0D  			CALL	PRINTI		
1188:     -	090F  2053494F			DB	" SIO",EOS
	              00
1189: 3889+10	0914  C9      			RET			
1190:									
1191:								
1192:				
1193:				;=============================================================================
1194:				;Register Display/Set
1195:				;-----------------------------------------------------------------------------
1196: 3899+17	0915  CD190E  	REG_MENU	CALL	PUT_SPACE
1197: 3916+17	0918  CDE013  			CALL	GET_CHAR
1198: 3933+7	091B  FE0D    			CP	CR
1199: 3940+7+5	091D  2030    			JR  NZ,	RM_NOTALL
1200:				
1201:				;12345678901234567890123456789012345678901234567890123456789012345678901234567890  80 COLUMNS
1202:				;AF=xxxx  BC=xxxx  DE=xxxx  HL=xxxx  AF'=xxxx  BC'=xxxx  DE'=xxxx  HL'=xxxx
1203:				;IX=xxxx  IY=xxxx  IR=xxxx  PC=xxxx  SP=xxxx
1204:				
1205:     -	091F          	REG_DISP_ALL				;Dump ALL registers
1206: 3947+7	091F  060D    			LD	B,13		;13 Registers to dump
1207: 3954+10	0921  214209  	RM_LP		LD	HL,REGORDER
1208: 3964+4	0924  78      			LD	A,B
1209: 3968+4	0925  3D      			DEC	A
1210: 3972+17	0926  CD450E  			CALL	ADD_HL_A
1211: 3989+7	0929  7E      			LD	A,(HL)
1212: 3996+4	092A  B7      			OR	A
1213: 4000+10+7	092B  FC1F0E  			CALL M,	PUT_NEW_LINE
1214: 4010+7	092E  E60F    			AND	0xF
1215: 4017+17	0930  CD2E0C  			CALL	GET_REGNAME
1216: 4034+17	0933  CDBD0D  			CALL	PRINT
1217: 4051+17	0936  CDAB09  			CALL	RM_DUMP_REG
1218: 4068+17	0939  CDCA0D  			CALL	PRINTI
1219:     -	093C  202000  			DB	'  ',EOS
1220: 4085+8+5	093F  10E0    			DJNZ	RM_LP
1221: 4093+10	0941  C9      			RET
1222:				
1223:     -	0942  00      	REGORDER	DB	0		;Registers to dump (Numbers shifted left)
1224:     -	0943  05      			DB	5		;LSB will indicate a NEW LINE
1225:     -	0944  08      			DB	8
1226:     -	0945  07      			DB	7
1227:     -	0946  86      			DB	6 + 0x80
1228:     -	0947  0C      			DB	12
1229:     -	0948  0B      			DB	11
1230:     -	0949  0A      			DB	10
1231:     -	094A  89      			DB	9 + 0x80
1232:     -	094B  04      			DB	4
1233:     -	094C  03      			DB	3
1234:     -	094D  02      			DB	2
1235:     -	094E  81      			DB	1 + 0x80	;First Register to Dump
1236:				
1237: 4103+17	094F  CDB227  	RM_NOTALL	CALL	TO_UPPER
1238: 4120+17	0952  CDBB27  			CALL	IS_LETTER	;A contains first letter of register
1239: 4137+7+5	0955  382F    			JR  C,	RM_ERR		;abort if not a letter
1240: 4144+4	0957  5F      			LD	E,A		;E=first letter of register
1241: 4148+17	0958  CDE013  			CALL	GET_CHAR	;input 2nd letter of register
1242: 4165+17	095B  CDB227  			CALL	TO_UPPER
1243: 4182+17	095E  CDBB27  			CALL	IS_LETTER	;
1244: 4199+7+5	0961  3823    			JR  C,	RM_ERR		;Abort if 2nd char is not a letter
1245: 4206+4	0963  57      			LD	D,A		;D=2nd letter
1246:				
1247: 4210+7	0964  2E00    			LD	L,0
1248: 4217+17	0966  CDE013  	RM_2		CALL	GET_CHAR	;Get the 3rd char command
1249: 4234+7	0969  FE27    			CP	0x27		;Apostrophe Char
1250: 4241+7+5	096B  2004    			JR  NZ,	RM_3		;if 3rd char is apostrophe, 
1251: 4248+7	096D  2E01    			LD	L,1		;L=1 if Alternate Register
1252: 4255+12	096F  18F5    			JR	RM_2		;and loop back for a 4th char command
1253:						
1254: 4267+8	0971  CB1D    	RM_3		RR	L		;Put Alternate flag into CARRY
1255: 4275+11	0973  F5      			PUSH	AF		;Save last key input before proceeding to Search for Register
1256:				
1257: 4286+7	0974  060D    			LD	B,13		;Loop through all 13 registers
1258: 4293+4	0976  78      	RM_4		LD	A,B
1259: 4297+4	0977  3D      			DEC	A		;adjust to base 0
1260: 4301+17	0978  CD2E0C  			CALL	GET_REGNAME	;HL=PTR TO NAME
1261: 4318+17	097B  CD4A0E  			CALL	LD_HL_HL	;HL = ASCII name of Register
1262: 4335+4	097E  B7      			OR	A		;CLEAR CARRY
1263: 4339+15	097F  ED52    			SBC	HL,DE		;Test if DE=HL
1264: 4354+7+5	0981  2809    			JR  Z,	RM_5		;Jump if NAME FOUND
1265: 4361+8+5	0983  10F1    			DJNZ	RM_4
1266:				
1267: 4369+10	0985  F1      			POP	AF
1268: 4379+7	0986  3E3F    	RM_ERR		LD	A,'?'		;Register Name not found
1269: 4386+17	0988  CDEC13  			CALL	PUT_CHAR
1270: 4403+10	098B  C9      			RET
1271:						
1272: 4413+4	098C  48      	RM_5		LD	C,B		;C=Register Ptr
1273: 4417+4	098D  0D      			DEC	C
1274: 4421+10	098E  F1      			POP	AF		;Restore saved command (and alternate register selection)
1275: 4431+4	098F  57      			LD	D,A		;D=Command
1276: 4435+7+5	0990  3808    			JR  C,	RM_6		;Jump if Alternate (Selection would be correct)
1277: 4442+4	0992  79      			LD	A,C
1278: 4446+7	0993  FE09    			CP	9
1279: 4453+7+5	0995  3803    			JR  C,	RM_6		;Jump if NOT Registers AF,BC,DE or HL
1280: 4460+7	0997  D608    			SUB	8		;Subtract 8 to convert AF' to AF, etc
1281: 4467+4	0999  4F      			LD	C,A
1282: 4471+4	099A  7A      	RM_6		LD	A,D		;RESUME Decoding command line
1283: 4475+7	099B  FE0D    			CP	CR		;if CR, dump Register
1284: 4482+7+5	099D  280B    			JR  Z,	RM_DUMP_REG_C
1285: 4489+7	099F  FE3D    			CP	'='		;if '=', then Assign new value to Register
1286: 4496+7+5	09A1  20E3    			JR  NZ,	RM_ERR
1287:				
1288: 4503+17	09A3  CD790D  			CALL	GET_WORD	;DE = Word from Command
1289: 4520+4	09A6  79      			LD	A,C
1290: 4524+17	09A7  CD820C  			CALL	PUT_REGISTER
1291:				
1292: 4541+4	09AA  79      	RM_DUMP_REG_C	LD	A,C
1293: 4545+17	09AB  CDCA0D  	RM_DUMP_REG	CALL	PRINTI
1294:     -	09AE  3D00    			DB	'=',0
1295: 4562+17	09B0  CD6D0C  			CALL	GET_REGISTER
1296: 4579+17	09B3  CDEA0D  			CALL	PUT_HL
1297: 4596+10	09B6  C9      			RET
1298:				
1299:				
1300:				;=============================================================================
1301:				;Loop back test
1302:				;-----------------------------------------------------------------------------
1303: 4606+7	09B7  3E00    	LOOP_BACK_TEST	LD	A,0		;Turn off LED update & enable key entry
1304: 4613+17	09B9  CDD927  			CALL	LED_UPDATE
1305:				
1306: 4630+17	09BC  CDCA0D  			CALL	PRINTI
1307:     -	09BF  0D0A    			DB	CR,LF
1308:     -	09C1  4C4F4F50			DB	'LOOP BACK, <Esc>-EXIT',CR,LF,0
	              20424143
	              4B2C203C
	              4573633E
	              2D455849
	              540D0A00
1309: 4647+17	09D9  CD8A1C  			CALL	LED_HOME_PRINTI
1310:     -	09DC  4C4F4F50			DB	'LOOPBAC',0
	              42414300
1311: 4664+17	09E4  CD7714  			CALL	LED_HOME
1312:						
1313:						
1314: 4681+17	09E7  CD2114  	LOOP_BACK_LP	CALL	IN_CHAR	;Test for any RS-232 input
1315: 4698+7+5	09EA  3806    			JR   C,	LB_0	;Jump if no input
1316: 4705+7	09EC  FE1B    			CP	27	;<Esc> to quit
1317: 4712+7+5	09EE  281F    			JR   Z,	LB_RET
1318: 4719+12	09F0  1814    			JR	LB_OUT	;Display
1319:						
1320: 4731+17	09F2  CDBA14  	LB_0		CALL 	IC_KEY		;Test regular HEX input
1321: 4748+10	09F5  CAE709  			JP   Z,	LOOP_BACK_LP	;
1322:				
1323: 4758+8	09F8  CB67    	LB_1		BIT	4,A
1324: 4766+7+5	09FA  2807    			JR   Z,	LB_2	;Jump if NOT shifted
1325: 4773+11	09FC  F5      			PUSH	AF		;If Shifted, then output a carret before the key
1326: 4784+7	09FD  3E5E    			LD	A,'^'
1327: 4791+17	09FF  CDEC13  			CALL	Put_Char
1328: 4808+10	0A02  F1      			POP	AF
1329:				
1330: 4818+17	0A03  CD0F0E  	LB_2		CALL	HEX2ASC	;Convert Keypad input to ASCII
1331:				
1332: 4835+17	0A06  CDEC13  	LB_OUT		CALL	PUT_CHAR
1333: 4852+4	0A09  4F      			LD	C,A
1334: 4856+17	0A0A  CD8A14  			CALL	PC_LED
1335: 4873+12	0A0D  18D8    			JR	LOOP_BACK_LP
1336:				
1337: 4885+7	0A0F  3E01    	LB_RET		LD	A,1
1338: 4892+17	0A11  CDD927  			CALL	LED_UPDATE
1339: 4909+10	0A14  C9      			RET
1340:				
1341:				
1342:				;=============================================================================
1343:				;MEMORY ENTER.  M XXXX YY..YY,  ENTERS AS MANY BYTES AS THERE ARE ON THE LINE.
1344:				;-----------------------------------------------------------------------------
1345: 4919+10	0A15  010000  	MEM_ENTER	LD	BC,0		;Clear count
1346: 4929+17	0A18  CD790D  	MEM_ENTER_NEXTL	CALL	GET_WORD	;DE = Word from console, A=non-hex character following word (space)
1347: 4946+7	0A1B  FE20    			CP	' '	;Test delimiting character, must be a space
1348: 4953+5+6	0A1D  C0      			RET 	NZ		;Main Menu
1349: 4958+4	0A1E  EB      			EX	DE,HL		;HL = Start
1350: 4962+17	0A1F  CD4C0D  	MEN_LP		CALL	GET_BYTE	;A = Byte or A=non-hex character (Carry Set)
1351: 4979+7+5	0A22  380B    			JR C,	MEN_CHK		;Jump if non-hex input
1352: 4986+7	0A24  77      			LD	(HL),A		;else, save the byte
1353: 4993+6	0A25  23      			INC	HL		;advance memory pointer
1354: 4999+6	0A26  03      			INC	BC		;count bytes
1355: 5005+12	0A27  18F6    			JR	MEN_LP		;repeat for next byte input
1356:				
1357: 5017+17	0A29  CDDA13  	MEN_RET		CALL	GET_CHAR_NE	;ignore rest of line before returning to main menu
1358: 5034+17	0A2C  CDEC13  			CALL	PUT_CHAR
1359: 5051+7	0A2F  FE0D    	MEN_CHK		CP	0x0D		;wait until we get the <CR>
1360: 5058+7+5	0A31  2804    			JR Z,	MEN_1
1361: 5065+7	0A33  FE0A    			CP	0x0A		;wait until we get the <LF>
1362: 5072+7+5	0A35  20F2    			JR NZ,	MEN_RET
1363: 5079+7	0A37  3E04    	MEN_1		LD	A,4		;Wait up to 2 seconds for another M command or return to main menu
1364: 5086+17	0A39  CD4B14  			CALL	TIMED_GETCHAR	;
1365: 5103+17	0A3C  CDEC13  			CALL	PUT_CHAR
1366: 5120+7	0A3F  FE4D    			CP	'M'		;If another M command comes in, process it
1367: 5127+7+5	0A41  28D5    			JR Z,	MEM_ENTER_NEXTL
1368: 5134+7	0A43  FE0A    			CP	0x0A		;Skip LF
1369: 5141+7+5	0A45  28F0    			JR Z,	MEN_1
1370: 5148+17	0A47  CDCA0D  			CALL	PRINTI
1371:     -	0A4A  0D0A4259			DB	CR,LF,"BYTES ENTERED=",EOS
	              54455320
	              454E5445
	              5245443D
	              00
1372: 5165+17	0A5B  CDD80D  			CALL	PUT_BC
1373: 5182+10	0A5E  C9      			RET			;If not, return to main menu prompt
1374:				
1375:				
1376:				;=============================================================================
1377:				;MEMORY DUMP - Continous
1378:				;-----------------------------------------------------------------------------
1379: 5192+7	0A5F  06FF    	MEM_DUMP:	LD	B,0xFF		;Continuous Dump, No pausing
1380: 5199+17	0A61  CD760D  	MEM_DUMP_0	CALL	SPACE_GET_WORD	;Input start address
1381: 5216+4	0A64  EB      			EX	DE,HL			;HL = Start
1382: 5220+17	0A65  CD760D  			CALL	SPACE_GET_WORD	;Input end address (DE = end)
1383:				
1384: 5237+17	0A68  CD1F0E  	MEM_DUMP_LP:	CALL	PUT_NEW_LINE
1385: 5254+17	0A6B  CDAA0A  			CALL	DUMP_LINE	;Dump 16 byte lines (advances HL)
1386: 5271+5+6	0A6E  C8      			RET Z			;RETURN WHEN HL=DE
1387: 5276+17	0A6F  CD2114  			CALL	IN_CHAR		;Exit on <Esc>
1388: 5293+7	0A72  FE1B    			CP	27
1389: 5300+5+6	0A74  C8      			RET	Z
1390: 5305+4	0A75  7D      			LD	A,L
1391: 5309+4	0A76  B0      			OR	B
1392: 5313+7+5	0A77  20EF    			JR  NZ,	MEM_DUMP_LP	;Dump 1 Page, then prompt for continue
1393: 5320+17	0A79  CD820A  			CALL	GET_CONTINUE
1394: 5337+12	0A7C  18EA    			JR	MEM_DUMP_LP
1395:				;=============================================================================
1396:				;MEMORY DUMP - Paged
1397:				;-----------------------------------------------------------------------------
1398: 5349+7	0A7E  0600    	MEM_DUMP_PAGED	LD	B,0		;Paused Dump
1399: 5356+12	0A80  18DF    			JR	MEM_DUMP_0
1400:				
1401:				;-----------------------------------------------------------------------------
1402: 5368+17	0A82  CD1F0E  	GET_CONTINUE	CALL	PUT_NEW_LINE
1403: 5385+17	0A85  CDCA0D  			CALL	PRINTI
1404:     -	0A88  50726573			DB	"Press any key to continue",EOS
	              7320616E
	              79206B65
	              7920746F
	              20636F6E
	              74696E75
	              6500
1405: 5402+17	0AA2  CDE013  			CALL	GET_CHAR
1406: 5419+7	0AA5  FE1B    			CP	27
1407: 5426+5+6	0AA7  C0      			RET NZ
1408: 5431+10	0AA8  E1      			POP	HL		;Scrap return address
1409: 5441+10	0AA9  C9      			RET
1410:				
1411:				
1412:				;-----------------------------------------------------------------------------
1413:				;DUMP_LINE -- Dumps a line
1414:				;xxx0:  <pre spaces> XX XX XX XX XX After spaces | ....ASCII....
1415:				;-----------------------------------------------------------------------------
1416: 5451+11	0AAA  C5      	DUMP_LINE:	PUSH	BC		;+1
1417: 5462+11	0AAB  E5      			PUSH	HL		;+2 Save H for 2nd part of display
1418: 5473+11	0AAC  E5      			PUSH	HL		;+3 Start line with xxx0 address
1419: 5484+7	0AAD  3E4D    			LD	A,'M'
1420: 5491+17	0AAF  CDEC13  			CALL	Put_Char
1421: 5508+17	0AB2  CDEA0D  			CALL	PUT_HL		;Print Address
1422: 5525+17	0AB5  CD190E  			CALL	PUT_SPACE
1423: 5542+10	0AB8  E1      			POP	HL		;-3
1424: 5552+4	0AB9  7D      			LD	A,L
1425: 5556+7	0ABA  E60F    			AND	0x0F		;Fetch how many prespaces to print
1426: 5563+4	0ABC  4F      			LD	C,A
1427: 5567+4	0ABD  47      			LD	B,A		;Save count of prespaces for part 2 of display
1428: 5571+17	0ABE  CD110B  			CALL	PUT_3C_SPACES
1429:				
1430: 5588+17	0AC1  CD45FB  	DL_P1L		CALL	GET_MEM
1431: 5605+17	0AC4  CDF30D  			CALL	SPACE_PUT_BYTE
1432: 5622+17	0AC7  CD0B0B  			CALL	CP_HL_DE
1433: 5639+7+5	0ACA  2808    			JR Z,	DL_P1E
1434: 5646+6	0ACC  23      			INC	HL
1435: 5652+4	0ACD  7D      			LD	A,L
1436: 5656+7	0ACE  E60F    			AND	0x0F
1437: 5663+7+5	0AD0  20EF    			JR  NZ,	DL_P1L
1438: 5670+12	0AD2  1808    			JR	DL_P2
1439:				
1440: 5682+4	0AD4  7D      	DL_P1E		LD	A,L
1441: 5686+4	0AD5  2F      			CPL
1442: 5690+7	0AD6  E60F    			AND	0x0F
1443: 5697+4	0AD8  4F      			LD	C,A
1444: 5701+17	0AD9  CD110B  			CALL	PUT_3C_SPACES
1445:				
1446: 5718+17	0ADC  CDCA0D  	DL_P2		CALL	PRINTI		;Print Seperator between part 1 and part 2
1447:     -	0ADF  203B2000			DB	" ; ",EOS
1448:				
1449: 5735+4	0AE3  78      	DL_PSL2		LD	A,B		;Print prespaces for part 2
1450: 5739+4	0AE4  B7      			OR	A
1451: 5743+7+5	0AE5  2806    			JR Z,	DL_PSE2
1452: 5750+17	0AE7  CD190E  			CALL	PUT_SPACE
1453: 5767+4	0AEA  05      			DEC	B
1454: 5771+12	0AEB  18F6    			JR	DL_PSL2
1455:     -	0AED          	DL_PSE2
1456: 5783+10	0AED  E1      			POP	HL		;-2
1457: 5793+10	0AEE  C1      			POP	BC		;-1
1458: 5803+17	0AEF  CD45FB  	DL_P2L		CALL	GET_MEM
1459: 5820+7	0AF2  FE20    			CP	' '		;A - 20h	Test for Valid ASCII characters
1460: 5827+7+5	0AF4  3002    			JR NC,	DL_P2K1
1461: 5834+7	0AF6  3E2E    			LD	A,'.'				;Replace with . if not ASCII
1462: 5841+7	0AF8  FE7F    	DL_P2K1		CP	0x7F		;A - 07Fh
1463: 5848+7+5	0AFA  3802    			JR C,	DL_P2K2
1464: 5855+7	0AFC  3E2E    			LD	A,'.'
1465: 5862+17	0AFE  CDEC13  	DL_P2K2		CALL	Put_Char
1466:				
1467: 5879+17	0B01  CD0B0B  			CALL	CP_HL_DE
1468: 5896+5+6	0B04  C8      			RET Z
1469: 5901+6	0B05  23      			INC	HL
1470: 5907+4	0B06  7D      			LD	A,L
1471: 5911+7	0B07  E60F    			AND	0x0F
1472: 5918+7+5	0B09  20E4    			JR  NZ,	DL_P2L
1473:				
1474:				;-----------------------------------------------------------------------------
1475:				;Compare HL with DE
1476:				;Exit:		Z=1 if HL=DE
1477:				;		M=1 if DE > HL
1478: 5925+4	0B0B  7C      	CP_HL_DE	LD	A,H
1479: 5929+4	0B0C  BA      			CP	D		;H-D
1480: 5933+5+6	0B0D  C0      			RET NZ			;M flag set if D > H
1481: 5938+4	0B0E  7D      			LD	A,L
1482: 5942+4	0B0F  BB      			CP	E		;L-E
1483: 5946+10	0B10  C9      			RET
1484:				
1485:				
1486: 5956+4	0B11  0C      	PUT_3C_SPACES	INC	C		;Print 3C Spaces
1487: 5960+4	0B12  0D      	PUT_3C_SPACES_L	DEC	C		;Count down Prespaces
1488: 5964+5+6	0B13  C8      			RET Z
1489: 5969+17	0B14  CDCA0D  			CALL	PRINTI		;Print pre spaces
1490:     -	0B17  20202000			DB "   ",EOS
1491: 5986+12	0B1B  18F5    			JR	PUT_3C_SPACES_L
1492:				
1493:				
1494:				;-----------------------------------------------------------------------------
1495:				;EDIT MEMORY
1496:				;Edit memory from a starting address until X is pressed.
1497:				;Display mem loc, contents, and results of write.
1498:				;-----------------------------------------------------------------------------
1499: 5998+17	0B1D  CD760D  	MEM_EDIT:	CALL	SPACE_GET_WORD	;Input Address
1500: 6015+4	0B20  EB      			EX	DE,HL			;HL = Address to edit
1501: 6019+17	0B21  CD1F0E  	ME_LP		CALL	PUT_NEW_LINE
1502: 6036+17	0B24  CDEA0D  			CALL	PUT_HL		;Print current contents of memory
1503: 6053+17	0B27  CD190E  			CALL	PUT_SPACE
1504: 6070+7	0B2A  3E3A    			LD	A, ':'
1505: 6077+17	0B2C  CDEC13  			CALL	Put_Char
1506: 6094+17	0B2F  CD45FB  			CALL	GET_MEM
1507: 6111+17	0B32  CDF30D  			CALL	SPACE_PUT_BYTE
1508: 6128+17	0B35  CD490D  			CALL	SPACE_GET_BYTE	;Input new value or Exit if invalid
1509: 6145+5+6	0B38  D8      			RET C			;Exit to Command Loop
1510: 6150+7	0B39  77      			LD	(HL), A		;or Save new value
1511: 6157+17	0B3A  CD45FB  			CALL	GET_MEM
1512: 6174+17	0B3D  CDF30D  			CALL	SPACE_PUT_BYTE
1513: 6191+6	0B40  23      			INC	HL		;Advance to next location
1514: 6197+12	0B41  18DE    			JR	ME_LP		;repeat input
1515:				
1516:				
1517:				;=============================================================================
1518:				;	MEM_EXEC - Execute at
1519:				;	Get an address and jump to it
1520:				;-----------------------------------------------------------------------------
1521: 6209+17	0B43  CD760D  	MEM_EXEC:	CALL	SPACE_GET_WORD	;Input address
1522: 6226+10	0B46  D25D0B  			JP NC,	ME_1		;Jump if no hex input
1523: 6236+7	0B49  FE1B    			CP	27
1524: 6243+5+6	0B4B  C8      			RET Z			;Exit if <ESC> pressed
1525: 6248+20	0B4C  ED53A0FF			LD	(RPC),DE
1526:				
1527: 6268+17	0B50  CDCA0D  			CALL	PRINTI
1528:     -	0B53  2050433D			DB	' PC=',EOS
	              00
1529: 6285+17	0B58  CDE10D  			CALL	PUT_DE
1530: 6302+12	0B5B  1803    			JR	GO_EXEC_T
1531:				
1532: 6314+7	0B5D  FE0D    	ME_1		CP	13		;No hex input (user just typed G and something not HEX)
1533: 6321+5+6	0B5F  C0      			RET NZ			;Exit if NOT <CR> pressed
1534:						
1535: 6326+16	0B60  2A96FF  	GO_EXEC_T	LD	HL,(RSSP)	;20 Fetch SP
1536: 6342+6	0B63  2B      			DEC	HL
1537: 6348+6	0B64  2B      			DEC	HL
1538: 6354+7	0B65  3EAA    			LD	A,0xAA
1539: 6361+7	0B67  77      			LD	(HL),A
1540: 6368+7	0B68  BE      			CP	(HL)
1541: 6375+7+5	0B69  2070    			JR NZ,	GE_STACKFAIL
1542: 6382+4	0B6B  2F      			CPL
1543: 6386+7	0B6C  77      			LD	(HL),A
1544: 6393+7	0B6D  BE      			CP	(HL)
1545: 6400+7+5	0B6E  206B    			JR NZ,	GE_STACKFAIL
1546:				
1547: 6407+4	0B70  F3      			DI			;
1548: 6411+7	0B71  3E82    	GO_EXEC		LD	A,0x82		;7  (ANBAR_DEF) = RUN MODE
1549: 6418+13	0B73  32B3FF  			LD	(ANBAR_DEF),A	;13
1550: 6431+10	0B76  217C0C  			LD	HL,GET_REG_RUN	;10
1551: 6441+16	0B79  22B4FF  			LD	(GET_REG),HL	;16
1552: 6457+10	0B7C  21910C  			LD	HL,PUT_REG_RUN	;10
1553: 6467+16	0B7F  22B6FF  			LD	(PUT_REG),HL	;16
1554: 6483+10	0B82  211718  			LD	HL,CTRL_C_TEST	;10
1555: 6493+16	0B85  22B8FF  			LD	(CTRL_C_CHK),HL	;16
1556:						
1557: 6509+13	0B88  3AB3FF  			LD	A,(ANBAR_DEF)	;13 Refresh Display
1558: 6522+13	0B8B  32E7FF  			LD	(LED_ANBAR),A	;13 
1559:									;\\\ 124
1560:				
1561: 6535+4	0B8E  08      			EX	AF,AF'		;4  Fetch Alternate register set
1562: 6539+10	0B8F  31A8FF  			LD	SP,RSAF2	;10 Set Stack to get register AF'
1563: 6549+10	0B92  F1      			POP	AF		;10
1564: 6559+4	0B93  08      			EX	AF,AF'		;4
1565: 6563+4	0B94  D9      			EXX			;4  Fetch Alternate register set
1566: 6567+20	0B95  ED4BAAFF			LD	BC,(RSBC2)	;20
1567: 6587+20	0B99  ED5BACFF			LD	DE,(RSDE2)	;20
1568: 6607+16	0B9D  2AAEFF  			LD	HL,(RSHL2)	;20
1569: 6623+4	0BA0  D9      			EXX			;4
1570:				
1571: 6627+20	0BA1  ED4BA6FF			LD	BC,(RSIR)	;20 Fetch IR
1572: 6647+4	0BA5  79      			LD	A,C		;4
1573: 6651+9	0BA6  ED4F    			LD	R,A		;9
1574: 6660+4	0BA8  78      			LD	A,B		;4
1575: 6664+9	0BA9  ED47    			LD	I,A		;9 
1576:									;\\\ 142
1577:									
1578: 6673+7	0BAB  3EC3    			LD	A,0xC3		;7  Set Jump instruction
1579: 6680+13	0BAD  3253FB  			LD	(HR_EXE_GO),A	;13
1580: 6693+16	0BB0  2AA0FF  			LD	HL,(RPC)	;16 Fetch PC
1581: 6709+16	0BB3  2254FB  			LD	(HR_EXE_GO+1),HL;16
1582:				
1583: 6725+10	0BB6  3198FF  			LD	SP,RSAF		;10 Set Stack to Fetch register AF
1584: 6735+10	0BB9  F1      			POP	AF		;10
1585:				
1586: 6745+20	0BBA  ED7B96FF			LD	SP,(RSSP)	;20 Fetch SP
1587: 6765+6	0BBE  33      			INC	SP		;6
1588: 6771+6	0BBF  33      			INC	SP		;6
1589: 6777+10	0BC0  210000  			LD	HL,0		;10 Set Default return address as 0000 (Restart/Save Registers)
1590: 6787+11	0BC3  E5      			PUSH	HL		;11   & Put on stack
1591:									;\\\ 125
1592:						
1593: 6798+20	0BC4  ED4B9AFF			LD	BC,(RSBC)	;20
1594: 6818+20	0BC8  ED5B9CFF			LD	DE,(RSDE)	;20
1595: 6838+16	0BCC  2A9EFF  			LD	HL,(RSHL)	;20
1596: 6854+20	0BCF  DD2AA2FF			LD	IX,(RSIX)	;20
1597: 6874+20	0BD3  FD2AA4FF			LD	IY,(RSIY)	;20
1598:				
1599: 6894+4	0BD7  FB      			EI			;4
1600: 6898+10	0BD8  C353FB  			JP	HR_EXE_GO	;10 PC=(STACK)   
1601:						
1602:				;HR_EXE_GO	JP	(RSPC)		;10 Final jump to code
1603:									;\\\ 124
1604:									;Total = 515
1605:				
1606: 6908+17	0BDB  CDCA0D  	GE_STACKFAIL	CALL	PRINTI
1607:     -	0BDE  20535441			DB	' STACK NOT IN RAM',EOS
	              434B204E
	              4F542049
	              4E205241
	              4D00
1608: 6925+17	0BF0  CD8A1C  			CALL	LED_HOME_PRINTI
1609:     -	0BF3  53502045			DB	'SP ERR ',EOS
	              52522000
1610: 6942+10	0BFB  C9      			RET
1611:						
1612:				
1613:				;===============================================
1614:				;Input from port, print contents
1615: 6952+17	0BFC  CD490D  	PORT_INP:	CALL	SPACE_GET_BYTE
1616: 6969+4	0BFF  4F      			LD	C, A
1617: 6973+12	0C00  ED78    			IN	A,(C)
1618: 6985+17	0C02  CDF30D  			CALL	SPACE_PUT_BYTE
1619: 7002+10	0C05  C9      			RET
1620:				
1621:				;Get a port address, write byte out
1622: 7012+17	0C06  CD490D  	PORT_OUT:	CALL	SPACE_GET_BYTE
1623: 7029+4	0C09  4F      			LD	C, A
1624: 7033+17	0C0A  CD490D  			CALL	SPACE_GET_BYTE
1625: 7050+12	0C0D  ED79    			OUT	(C),A
1626: 7062+10	0C0F  C9      			RET
1627:				
1628:				
1629:				
1630:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1631:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1632:				;	Chapter_5	Supporting routines. GET_BYTE, GET_WORD, PUT_BYTE, PUT_WORD
1633:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
1634:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
1635:				
1636:				
1637: 7072+10	0C10  3600    	CLEAR_BLOCK	LD	(HL),0
1638: 7082+6	0C12  23      			INC	HL
1639: 7088+8+5	0C13  10FB    			DJNZ	CLEAR_BLOCK
1640: 7096+10	0C15  C9      			RET
1641:				
1642:				;-----------------------------------------------------------------------------------------------------
1643:				;	FILL_BLOCK, Fills a block of RAM with value in A
1644:				;	Input:	A = value
1645:				;		HL = Start Address
1646:				;		B = Length of Fill (MAX = 0 = 256 bytes)
1647:				;-----------------------------------------------------------------------------------------------------
1648: 7106+11	0C16  E5      	FILL_BLOCK	PUSH	HL
1649: 7117+7	0C17  77      	FB_LP		LD	(HL),A
1650: 7124+6	0C18  23      			INC	HL
1651: 7130+8+5	0C19  10FC    			DJNZ	FB_LP
1652: 7138+10	0C1B  E1      			POP	HL
1653: 7148+10	0C1C  C9      			RET
1654:									;Critical Timing in effect for GO_EXEC
1655: 7158+19	0C1D  E3      	WRITE_BLOCK	EX	(SP),HL		;19 HL=PC Total = 137 + 21 * BC
1656: 7177+11	0C1E  D5      			PUSH	DE		;11
1657: 7188+11	0C1F  C5      			PUSH	BC		;11
1658: 7199+7	0C20  5E      			LD	E,(HL)		;7
1659: 7206+6	0C21  23      			INC	HL		;6
1660: 7212+7	0C22  56      			LD	D,(HL)		;7
1661: 7219+6	0C23  23      			INC	HL		;6
1662: 7225+7	0C24  4E      			LD	C,(HL)		;7
1663: 7232+6	0C25  23      			INC	HL		;6
1664: 7238+7	0C26  46      			LD	B,(HL)		;7
1665: 7245+6	0C27  23      			INC	HL		;6
1666: 7251+16+5	0C28  EDB0    			LDIR			;21/16  21*BC-5
1667: 7267+10	0C2A  C1      			POP	BC		;10
1668: 7277+10	0C2B  D1      			POP	DE		;10
1669: 7287+19	0C2C  E3      			EX	(SP),HL		;19 PC=HL
1670: 7306+10	0C2D  C9      			RET			;10
1671:						
1672: 7316+11	0C2E  F5      	GET_REGNAME	PUSH	AF
1673: 7327+4	0C2F  07      			RLCA
1674: 7331+4	0C30  07      			RLCA
1675: 7335+10	0C31  21390C  			LD	HL,REGNAMES
1676: 7345+17	0C34  CD450E  			CALL	ADD_HL_A
1677: 7362+10	0C37  F1      			POP	AF
1678: 7372+10	0C38  C9      			RET
1679:				
1680:     -	0C39  53502000	REGNAMES	DB	'SP ',0		;0
1681:     -	0C3D  41462000			DB	'AF ',0		;1
1682:     -	0C41  42432000			DB	'BC ',0		;2
1683:     -	0C45  44452000			DB	'DE ',0		;3
1684:     -	0C49  484C2000			DB	'HL ',0		;4
1685:     -	0C4D  50432000			DB	'PC ',0		;5
1686:     -	0C51  49582000			DB	'IX ',0		;6
1687:     -	0C55  49592000			DB	'IY ',0		;7
1688:     -	0C59  49522000			DB	'IR ',0		;8
1689:     -	0C5D  41462700			DB	'AF',0x27,0	;9
1690:     -	0C61  42432700			DB	'BC',0x27,0	;10
1691:     -	0C65  44452700			DB	'DE',0x27,0	;11
1692:     -	0C69  484C2700			DB	'HL',0x27,0	;12
1693:				
1694: 7382+16	0C6D  2AB4FF  	GET_REGISTER	LD	HL,(GET_REG)	;16
1695: 7398+4	0C70  E9      			JP	(HL)		;4
1696:				
1697: 7402+10	0C71  2196FF  	GET_REG_MON	LD	HL,RSSP		;
1698: 7412+4	0C74  07      			RLCA
1699: 7416+17	0C75  CD450E  			CALL	ADD_HL_A	;17+18 HL=Where to find Register
1700: 7433+17	0C78  CD4A0E  			CALL	LD_HL_HL	;HL=(HL)
1701: 7450+10	0C7B  C9      			RET
1702:				
1703: 7460+10	0C7C  21A10C  	GET_REG_RUN	LD	HL,GRR_TBL	;10
1704: 7470+10	0C7F  C3940C  			JP	SHORTNWAY	;10
1705:				
1706: 7480+16	0C82  2AB6FF  	PUT_REGISTER	LD	HL,(PUT_REG)
1707: 7496+4	0C85  E9      			JP	(HL)
1708:				
1709: 7500+10	0C86  2196FF  	PUT_REG_MON	LD	HL,RSSP
1710: 7510+4	0C89  07      			RLCA
1711: 7514+17	0C8A  CD450E  			CALL	ADD_HL_A	;HL=Where to find Register
1712: 7531+7	0C8D  73      	PURRS_RET	LD	(HL),E
1713: 7538+6	0C8E  23      			INC	HL
1714: 7544+7	0C8F  72      			LD	(HL),D
1715: 7551+10	0C90  C9      			RET
1716:				
1717: 7561+10	0C91  21B10C  	PUT_REG_RUN	LD	HL,PURR_TBL
1718:									;40 to get here
1719: 7571+7	0C94  E60F    	SHORTNWAY	AND	0xF		;7
1720: 7578+17	0C96  CD450E  			CALL	ADD_HL_A	;14+18
1721: 7595+7	0C99  7E      			LD	A,(HL)		;7
1722: 7602+10	0C9A  21C10C  			LD	HL,GRR_SUB	;10
1723: 7612+17	0C9D  CD450E  			CALL	ADD_HL_A	;17+18
1724: 7629+4	0CA0  E9      	VCALL_HL	JP	(HL)		;4  st=138
1725:				
1726:     -	0CA1  00      	GRR_TBL		DB	0
1727:     -	0CA2  06      			DB	GRR_SUB_AF - GRR_SUB
1728:     -	0CA3  0E      			DB	GRR_SUB_BC - GRR_SUB
1729:     -	0CA4  11      			DB	GRR_SUB_DE - GRR_SUB
1730:     -	0CA5  14      			DB	GRR_SUB_HL - GRR_SUB
1731:     -	0CA6  1C      			DB	GRR_SUB_PC - GRR_SUB
1732:     -	0CA7  23      			DB	GRR_SUB_IX - GRR_SUB
1733:     -	0CA8  27      			DB	GRR_SUB_IY - GRR_SUB
1734:     -	0CA9  2B      			DB	GRR_SUB_IR - GRR_SUB
1735:     -	0CAA  32      			DB	GRR_SUB_AFA - GRR_SUB
1736:     -	0CAB  37      			DB	GRR_SUB_BCA - GRR_SUB
1737:     -	0CAC  3C      			DB	GRR_SUB_DEA - GRR_SUB
1738:     -	0CAD  41      			DB	GRR_SUB_HLA - GRR_SUB
1739:     -	0CAE  00      			DB	0
1740:     -	0CAF  00      			DB	0
1741:     -	0CB0  00      			DB	0
1742:				
1743:     -	0CB1  46      	PURR_TBL	DB	PURR_SUB_SP - GRR_SUB
1744:     -	0CB2  47      			DB	PURR_SUB_AF - GRR_SUB
1745:     -	0CB3  4E      			DB	PURR_SUB_BC - GRR_SUB
1746:     -	0CB4  51      			DB	PURR_SUB_DE - GRR_SUB
1747:     -	0CB5  58      			DB	PURR_SUB_HL - GRR_SUB
1748:     -	0CB6  5F      			DB	PURR_SUB_PC - GRR_SUB
1749:     -	0CB7  65      			DB	PURR_SUB_IX - GRR_SUB
1750:     -	0CB8  69      			DB	PURR_SUB_IY - GRR_SUB
1751:     -	0CB9  6D      			DB	PURR_SUB_IR - GRR_SUB
1752:     -	0CBA  74      			DB	PURR_SUB_AFA - GRR_SUB
1753:     -	0CBB  79      			DB	PURR_SUB_BCA - GRR_SUB
1754:     -	0CBC  7E      			DB	PURR_SUB_DEA - GRR_SUB
1755:     -	0CBD  83      			DB	PURR_SUB_HLA - GRR_SUB
1756:     -	0CBE  00      			DB	0
1757:     -	0CBF  00      			DB	0
1758:     -	0CC0  00      			DB	0
1759:				
1760:						;Stack holds:
1761:						;SP	RETURN TO ISR	(CALL PUT_REG)
1762:						;SP+2	RETURN TO VECTOR DISPATCH (CALL VCALL_HL)
1763:						;SP+4	AF
1764:						;SP+6	HL
1765:						;
1766:						;PREVIOUS STACK SAVED AT SP_ISR_SAVE
1767:						;	RETURN TO MAIN CODE (PC)
1768:						;
1769:						
1770: 7633+16	0CC1  2A28FB  	GRR_SUB		LD	HL,(SP_ISR_SAVE)	;Get SP;True value of SP (prior to ISR)
1771: 7649+6	0CC4  23      			INC	HL
1772: 7655+6	0CC5  23      			INC	HL
1773: 7661+10	0CC6  C9      			RET
1774: 7671+10	0CC7  210400  	GRR_SUB_AF	LD	HL,4		;Get AF
1775: 7681+11	0CCA  39      			ADD	HL,SP
1776: 7692+17	0CCB  CD4A0E  			CALL	LD_HL_HL	;HL=(HL)
1777: 7709+10	0CCE  C9      			RET
1778: 7719+11	0CCF  C5      	GRR_SUB_BC	PUSH	BC
1779: 7730+10	0CD0  E1      			POP	HL
1780: 7740+10	0CD1  C9      			RET
1781: 7750+11	0CD2  D5      	GRR_SUB_DE	PUSH	DE
1782: 7761+10	0CD3  E1      			POP	HL
1783: 7771+10	0CD4  C9      			RET
1784: 7781+10	0CD5  210600  	GRR_SUB_HL	LD	HL,6		;Get HL
1785: 7791+11	0CD8  39      			ADD	HL,SP
1786: 7802+17	0CD9  CD4A0E  			CALL	LD_HL_HL	;HL=(HL)
1787: 7819+10	0CDC  C9      			RET
1788: 7829+16	0CDD  2A28FB  	GRR_SUB_PC	LD	HL,(SP_ISR_SAVE) ;Get PC
1789: 7845+17	0CE0  CD4A0E  			CALL	LD_HL_HL	;HL=(HL)
1790: 7862+10	0CE3  C9      			RET
1791: 7872+15	0CE4  DDE5    	GRR_SUB_IX	PUSH	IX
1792: 7887+10	0CE6  E1      			POP	HL
1793: 7897+10	0CE7  C9      			RET
1794: 7907+15	0CE8  FDE5    	GRR_SUB_IY	PUSH	IY
1795: 7922+10	0CEA  E1      			POP	HL
1796: 7932+10	0CEB  C9      			RET
1797: 7942+9	0CEC  ED57    	GRR_SUB_IR	LD	A,I
1798: 7951+4	0CEE  67      			LD	H,A
1799: 7955+9	0CEF  ED5F    			LD	A,R
1800: 7964+4	0CF1  6F      			LD	L,A
1801: 7968+10	0CF2  C9      			RET
1802: 7978+4	0CF3  08      	GRR_SUB_AFA	EX	AF,AF'
1803: 7982+11	0CF4  F5      			PUSH	AF
1804: 7993+4	0CF5  08      			EX	AF,AF'
1805: 7997+10	0CF6  E1      			POP	HL
1806: 8007+10	0CF7  C9      			RET
1807: 8017+4	0CF8  D9      	GRR_SUB_BCA	EXX
1808: 8021+11	0CF9  C5      			PUSH	BC
1809: 8032+4	0CFA  D9      			EXX
1810: 8036+10	0CFB  E1      			POP	HL
1811: 8046+10	0CFC  C9      			RET
1812: 8056+4	0CFD  D9      	GRR_SUB_DEA	EXX
1813: 8060+11	0CFE  D5      			PUSH	DE
1814: 8071+4	0CFF  D9      			EXX
1815: 8075+10	0D00  E1      			POP	HL
1816: 8085+10	0D01  C9      			RET
1817: 8095+4	0D02  D9      	GRR_SUB_HLA	EXX
1818: 8099+11	0D03  E5      			PUSH	HL
1819: 8110+4	0D04  D9      			EXX
1820: 8114+10	0D05  E1      			POP	HL
1821: 8124+10	0D06  C9      			RET
1822:				
1823:				
1824:						;SP	RETURN TO ISR
1825:						;SP+2	DE
1826:						;SP+4	RETURN TO VECTOR DISPATCH (CALL VCALL_HL)
1827:						;SP+6	RRSTATE
1828:						;SP+8	AF
1829:						;SP+10	HL
1830:						;PREVIOUS STACK SAVED AT SP_ISR_SAVE
1831:						;	RETURN TO MAIN CODE (PC)
1832:				
1833: 8134+10	0D07  C9      	PURR_SUB_SP	RET		;Do we really want to change the SP during RUN mode??? Suicide!
1834: 8144+10	0D08  210800  	PURR_SUB_AF	LD	HL,8		;Get DE
1835: 8154+11	0D0B  39      			ADD	HL,SP
1836: 8165+10	0D0C  C38D0C  			JP	PURRS_RET
1837: 8175+11	0D0F  D5      	PURR_SUB_BC	PUSH	DE
1838: 8186+10	0D10  C1      			POP	BC
1839: 8196+10	0D11  C9      			RET
1840: 8206+10	0D12  210200  	PURR_SUB_DE	LD	HL,2		;10 Get DE
1841: 8216+11	0D15  39      			ADD	HL,SP		;11
1842: 8227+10	0D16  C38D0C  			JP	PURRS_RET	;10  st=31
1843: 8237+10	0D19  210A00  	PURR_SUB_HL	LD	HL,10		;Get HL
1844: 8247+11	0D1C  39      			ADD	HL,SP
1845: 8258+10	0D1D  C38D0C  			JP	PURRS_RET
1846: 8268+16	0D20  2A28FB  	PURR_SUB_PC	LD	HL,(SP_ISR_SAVE) ;Get PC
1847: 8284+10	0D23  C38D0C  			JP	PURRS_RET
1848: 8294+11	0D26  D5      	PURR_SUB_IX	PUSH	DE
1849: 8305+14	0D27  DDE1    			POP	IX
1850: 8319+10	0D29  C9      			RET
1851: 8329+11	0D2A  D5      	PURR_SUB_IY	PUSH	DE
1852: 8340+14	0D2B  FDE1    			POP	IY
1853: 8354+10	0D2D  C9      			RET
1854: 8364+4	0D2E  7A      	PURR_SUB_IR	LD	A,D
1855: 8368+9	0D2F  ED47    			LD	I,A
1856: 8377+4	0D31  7B      			LD	A,E
1857: 8381+9	0D32  ED4F    			LD	R,A
1858: 8390+10	0D34  C9      			RET
1859: 8400+11	0D35  D5      	PURR_SUB_AFA	PUSH	DE
1860: 8411+4	0D36  08      			EX	AF,AF'
1861: 8415+10	0D37  F1      			POP	AF
1862: 8425+4	0D38  08      			EX	AF,AF'
1863: 8429+10	0D39  C9      			RET
1864: 8439+11	0D3A  D5      	PURR_SUB_BCA	PUSH	DE
1865: 8450+4	0D3B  D9      			EXX
1866: 8454+10	0D3C  C1      			POP	BC
1867: 8464+4	0D3D  D9      			EXX
1868: 8468+10	0D3E  C9      			RET
1869: 8478+11	0D3F  D5      	PURR_SUB_DEA	PUSH	DE
1870: 8489+4	0D40  D9      			EXX
1871: 8493+10	0D41  D1      			POP	DE
1872: 8503+4	0D42  D9      			EXX
1873: 8507+10	0D43  C9      			RET
1874: 8517+11	0D44  D5      	PURR_SUB_HLA	PUSH	DE
1875: 8528+4	0D45  D9      			EXX
1876: 8532+10	0D46  E1      			POP	HL
1877: 8542+4	0D47  D9      			EXX
1878: 8546+10	0D48  C9      			RET
1879:				
1880:				
1881:				;=============================================================================
1882: 8556+17	0D49  CD190E  	SPACE_GET_BYTE	CALL	PUT_SPACE
1883:				
1884:				;=============================================================================
1885:				;GET_BYTE -- Get byte from console as hex
1886:				;
1887:				;in:	Nothing
1888:				;out:	A = Byte (if CY=0)  (last 2 hex characters)  Exit if Space Entered
1889:				;	A = non-hex char input (if CY=1)
1890:				;-----------------------------------------------------------------------------
1891: 8573+17	0D4C  CD950D  	GET_BYTE:	CALL	GET_HEX	;Get 1st HEX CHAR
1892: 8590+7+5	0D4F  3006    			JR  NC,	GB_1
1893: 8597+7	0D51  FE20    			CP	' '		;Exit if not HEX CHAR (ignoring SPACE)
1894: 8604+7+5	0D53  28F7    			JR Z,	GET_BYTE	;Loop back if first char is a SPACE
1895: 8611+4	0D55  37      			SCF			;Set Carry
1896: 8615+10	0D56  C9      			RET			;or EXIT with delimiting char
1897: 8625+11	0D57  D5      	GB_1		PUSH	DE		;Process 1st HEX CHAR
1898: 8636+4	0D58  07      			RLCA
1899: 8640+4	0D59  07      			RLCA
1900: 8644+4	0D5A  07      			RLCA
1901: 8648+4	0D5B  07      			RLCA
1902: 8652+7	0D5C  E6F0    			AND	0xF0
1903: 8659+4	0D5E  57      			LD	D,A
1904: 8663+17	0D5F  CD950D  			CALL	GET_HEX
1905: 8680+7+5	0D62  3007    			JR  NC,	GB_2		;If 2nd char is HEX CHAR
1906: 8687+7	0D64  FE20    			CP	' '
1907: 8694+7+5	0D66  2806    			JR Z,	GB_RET1
1908: 8701+4	0D68  37      			SCF			;Set Carry
1909: 8705+10	0D69  D1      			POP	DE
1910: 8715+10	0D6A  C9      			RET			;or EXIT with delimiting char
1911: 8725+4	0D6B  B2      	GB_2		OR	D
1912: 8729+10	0D6C  D1      			POP	DE
1913: 8739+10	0D6D  C9      			RET
1914: 8749+4	0D6E  7A      	GB_RET1		LD	A,D
1915: 8753+4	0D6F  0F      			RRCA
1916: 8757+4	0D70  0F      			RRCA
1917: 8761+4	0D71  0F      			RRCA
1918: 8765+4	0D72  0F      			RRCA
1919: 8769+4	0D73  B7      	GB_RET		OR	A
1920: 8773+10	0D74  D1      			POP	DE
1921: 8783+10	0D75  C9      			RET
1922:				
1923:				
1924:				;=============================================================================
1925: 8793+17	0D76  CD190E  	SPACE_GET_WORD	CALL	PUT_SPACE
1926:				
1927:				;=============================================================================
1928:				;GET_WORD -- Get word from console as hex (ignores initial spaces)
1929:				;
1930:				;in:	Nothing
1931:				;out:	c=1	A = non-hex char input (Typically Space, CR or ESC)
1932:				;		DE = Word
1933:				;out:	c=0	A = non-hex char input (No Word in DE)
1934:				;-----------------------------------------------------------------------------
1935: 8810+10	0D79  110000  	GET_WORD:	LD	DE,0
1936: 8820+17	0D7C  CD950D  			CALL	GET_HEX	;Get 1st HEX CHAR ;out:	A = Value of HEX Char when CY=0
1937:											;	A = Received (non-hex) char when CY=1
1938: 8837+7+5	0D7F  3006    			JR  NC,	GW_LP
1939: 8844+7	0D81  FE20    			CP	' '		;Exit if not HEX CHAR (ignoring SPACE)
1940: 8851+7+5	0D83  28F4    			JR Z,	GET_WORD	;Loop back if first char is a SPACE
1941: 8858+4	0D85  B7      			OR	A		;Clear Carry
1942: 8862+10	0D86  C9      			RET			;or EXIT with delimiting char
1943: 8872+4	0D87  5F      	GW_LP		LD	E,A		;Save first/combined char in E
1944: 8876+17	0D88  CD950D  			CALL	GET_HEX	;Get next char
1945: 8893+5+6	0D8B  D8      			RET C			;EXIT when a delimiting char is entered
1946: 8898+4	0D8C  EB      			EX	DE,HL		;Else, shift new HEX Char Value into DE
1947: 8902+11	0D8D  29      			ADD	HL,HL		;Shift DE up 1 nibble
1948: 8913+11	0D8E  29      			ADD	HL,HL
1949: 8924+11	0D8F  29      			ADD	HL,HL
1950: 8935+11	0D90  29      			ADD	HL,HL
1951: 8946+4	0D91  EB      			EX	DE,HL
1952: 8950+4	0D92  B3      			OR	E		;Combine new char with E
1953: 8954+12	0D93  18F2    			JR	GW_LP
1954:				
1955:				
1956:				
1957:				;===============================================
1958:				;Get HEX CHAR
1959:				;in:	Nothing
1960:				;out:	A = Value of HEX Char when CY=0
1961:				;	A = Received (non-hex) char when CY=1
1962:				;-----------------------------------------------
1963: 8966+17	0D95  CDE013  	GET_HEX:	CALL	GET_CHAR
1964:						
1965:				;in:	A = CHAR
1966:				;out:	A = Value of HEX Char when CY=0
1967:				;	A = Received (non-hex) char when CY=1
1968: 8983+7	0D98  FE30    	ASC2HEX		CP	'0'
1969: 8990+10	0D9A  FAB60D  			JP M,	GHC_NOT_RET
1970: 9000+7	0D9D  FE3A    			CP	'9'+1
1971: 9007+10	0D9F  FABA0D  			JP M,	GHC_NRET
1972: 9017+7	0DA2  FE41    			CP	'A'
1973: 9024+10	0DA4  FAB60D  			JP M,	GHC_NOT_RET
1974: 9034+7	0DA7  FE47    			CP	'F'+1
1975: 9041+10	0DA9  FAB80D  			JP M,	GHC_ARET
1976: 9051+7	0DAC  FE61    			CP	'a'
1977: 9058+10	0DAE  FAB60D  			JP M,	GHC_NOT_RET
1978: 9068+7	0DB1  FE67    			CP	'f'+1
1979: 9075+10	0DB3  FAB80D  			JP M,	GHC_ARET
1980: 9085+4	0DB6  37      	GHC_NOT_RET	SCF
1981: 9089+10	0DB7  C9      			RET
1982: 9099+7	0DB8  D607    	GHC_ARET	SUB	07h
1983: 9106+7	0DBA  E60F    	GHC_NRET	AND	0Fh
1984: 9113+10	0DBC  C9      			RET
1985:						
1986:				
1987:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1988:				;PRINT -- Print A null-terminated string @(HL)
1989:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1990: 9123+11	0DBD  F5      	PRINT:		PUSH	AF
1991: 9134+7	0DBE  7E      	PRINT_LP	LD	A, (HL)
1992: 9141+6	0DBF  23      			INC	HL
1993: 9147+4	0DC0  B7      			OR	A
1994: 9151+7+5	0DC1  2805    			JR Z,	PRINT_RET
1995: 9158+17	0DC3  CDEC13  			CALL	Put_Char
1996: 9175+12	0DC6  18F6    			JR	PRINT_LP
1997: 9187+10	0DC8  F1      	PRINT_RET	POP	AF
1998: 9197+10	0DC9  C9      			RET
1999:				
2000:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2001:				;PRINT IMMEDIATE
2002:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2003: 9207+19	0DCA  E3      	PRINTI:		EX	(SP),HL	;HL = Top of Stack
2004: 9226+17	0DCB  CDBD0D  			CALL	PRINT
2005: 9243+19	0DCE  E3      			EX	(SP),HL	;Move updated return address back to stack
2006: 9262+10	0DCF  C9      			RET
2007:				
2008:				;===============================================
2009:				;PRINT B-LENGTH
2010:				;-----------------------------------------------
2011: 9272+7	0DD0  7E      	PRINTB:		LD	A, (HL)
2012: 9279+17	0DD1  CDEC13  			CALL	PUT_CHAR
2013: 9296+6	0DD4  23      			INC	HL
2014: 9302+8+5	0DD5  10F9    			DJNZ	PRINTB
2015: 9310+10	0DD7  C9      			RET
2016:				
2017:				;===============================================
2018:				;PUT_BC Prints BC Word
2019:				;-----------------------------------------------
2020: 9320+4	0DD8  78      	PUT_BC:		LD	A, B
2021: 9324+17	0DD9  CDF60D  			CALL	PUT_BYTE
2022: 9341+4	0DDC  79      			LD	A, C
2023: 9345+17	0DDD  CDF60D  			CALL	PUT_BYTE
2024: 9362+10	0DE0  C9      			RET
2025:				
2026:				;===============================================
2027:				;PUT_DE Prints DE Word
2028:				;-----------------------------------------------
2029: 9372+4	0DE1  7A      	PUT_DE:		LD	A, D
2030: 9376+17	0DE2  CDF60D  			CALL	PUT_BYTE
2031: 9393+4	0DE5  7B      			LD	A, E
2032: 9397+17	0DE6  CDF60D  			CALL	PUT_BYTE
2033: 9414+10	0DE9  C9      			RET
2034:				
2035:				;===============================================
2036:				;PUT_HL Prints HL Word
2037:				;-----------------------------------------------
2038: 9424+4	0DEA  7C      	PUT_HL:		LD	A, H
2039: 9428+17	0DEB  CDF60D  			CALL	PUT_BYTE
2040: 9445+4	0DEE  7D      			LD	A, L
2041: 9449+17	0DEF  CDF60D  			CALL	PUT_BYTE
2042: 9466+10	0DF2  C9      			RET
2043:				
2044:				
2045:				;===============================================
2046:				;SPACE_PUT_BYTE -- Output (SPACE) & byte to console as hex
2047:				;
2048:				;pre:	A register contains byte to be output
2049:				;post:	Destroys A
2050:				;-----------------------------------------------
2051: 9476+17	0DF3  CD190E  	SPACE_PUT_BYTE	CALL	PUT_SPACE
2052:						
2053:				;===============================================
2054:				;PUT_BYTE -- Output byte to console as hex
2055:				;
2056:				;pre:	A register contains byte to be output
2057:				;-----------------------------------------------
2058: 9493+11	0DF6  F5      	PUT_BYTE:	PUSH	AF
2059: 9504+11	0DF7  F5      			PUSH	AF
2060: 9515+4	0DF8  0F      			RRCA
2061: 9519+4	0DF9  0F      			RRCA
2062: 9523+4	0DFA  0F      			RRCA
2063: 9527+4	0DFB  0F      			RRCA
2064: 9531+7	0DFC  E60F    			AND	0x0F
2065: 9538+17	0DFE  CD090E  			CALL	PUT_HEX
2066: 9555+10	0E01  F1      			POP	AF
2067: 9565+7	0E02  E60F    			AND	0x0F
2068: 9572+17	0E04  CD090E  			CALL	PUT_HEX
2069: 9589+10	0E07  F1      			POP	AF
2070: 9599+10	0E08  C9      			RET
2071:				
2072:				;===============================================
2073:				;PUT_HEX -- Convert nibble to ASCII char
2074:				;-----------------------------------------------
2075: 9609+17	0E09  CD0F0E  	PUT_HEX:	CALL	HEX2ASC
2076: 9626+10	0E0C  C3EC13  			JP	Put_Char
2077:				
2078:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2079:				;HEX2ASC - Convert nibble to ASCII char
2080:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2081: 9636+7	0E0F  E60F    	HEX2ASC:	AND	0xF
2082: 9643+7	0E11  C630    			ADD	A,0x30
2083: 9650+7	0E13  FE3A    			CP	0x3A
2084: 9657+5+6	0E15  D8      			RET C
2085: 9662+7	0E16  C607    			ADD	A,0x7
2086: 9669+10	0E18  C9      			RET
2087:				
2088:				
2089:				;===============================================
2090:				;PUT_SPACE -- Print a space to the console
2091:				;
2092:				;pre: none
2093:				;post: 0x20 printed to console
2094:				;-----------------------------------------------
2095: 9679+17	0E19  CDCA0D  	PUT_SPACE:	CALL	PRINTI
2096:     -	0E1C  2000    			DB	' ',EOS
2097: 9696+10	0E1E  C9      			RET
2098:				
2099:				;===============================================
2100:				;PUT_NEW_LINE -- Start a new line on the console
2101:				;
2102:				;pre: none
2103:				;post: 
2104:				;-----------------------------------------------
2105: 9706+17	0E1F  CDCA0D  	PUT_NEW_LINE:	CALL	PRINTI
2106:     -	0E22  0D0A00  			DB	CR,LF,EOS
2107: 9723+10	0E25  C9      			RET
2108:				
2109:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2110:				;Terminal Increment byte at (HL).  Do not pass 0xFF
2111: 9733+11	0E26  34      	TINC:		INC	(HL)
2112: 9744+5+6	0E27  C0      			RET	NZ
2113: 9749+11	0E28  35      			DEC	(HL)
2114: 9760+10	0E29  C9      			RET
2115:				
2116:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2117: 9770+7	0E2A  0E01    	DELAY_100mS	LD	C,1
2118: 9777+11	0E2C  C5      	DELAY_C		PUSH	BC
2119: 9788+7	0E2D  0600    			LD	B,0
2120: 9795+11	0E2F  C5      	DELAY_LP	PUSH	BC
2121: 9806+8+5	0E30  10FE    			DJNZ	$		;13   * 256 / 4 = 832uSec
2122: 9814+10	0E32  C1      			POP	BC
2123: 9824+8+5	0E33  10FA    			DJNZ	DELAY_LP	;~100mSEC
2124: 9832+4	0E35  0D      			DEC	C
2125: 9836+7+5	0E36  20F7    			JR  NZ,	DELAY_LP	;*4 ~= 7mSec
2126: 9843+10	0E38  C1      			POP	BC
2127: 9853+10	0E39  C9      			RET
2128:				
2129:				;============================================================================
2130:				;	Subroutine	Delay_A
2131:				;
2132:				;	Entry:	A = Millisecond count
2133:				;============================================================================
2134: 9863+11	0E3A  E5      	DELAY_A:	PUSH	HL			; Save count
2135: 9874+10	0E3B  21F0FF  			LD	HL,TicCounter
2136: 9884+7	0E3E  86      			ADD	A,(HL)			; A = cycle count
2137: 9891+7	0E3F  BE      	DlyLp		CP	(HL)			; Wait required TicCounter times
2138: 9898+10	0E40  C23F0E  			JP	NZ,DlyLp		;  loop if not done
2139: 9908+10	0E43  E1      			POP	HL
2140: 9918+10	0E44  C9      			RET
2141:				
2142:				
2143:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2144: 9928+4	0E45  85      	ADD_HL_A	ADD	A,L		;4
2145: 9932+4	0E46  6F      			LD	L,A		;4
2146: 9936+5+6	0E47  D0      			RET NC			;10
2147: 9941+4	0E48  24      			INC	H
2148: 9945+10	0E49  C9      			RET
2149:				
2150:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2151: 9955+7	0E4A  7E      	LD_HL_HL	LD      A,(HL)		;7
2152: 9962+6	0E4B  23      			INC     HL		;6
2153: 9968+7	0E4C  66      			LD      H,(HL)		;7
2154: 9975+4	0E4D  6F      			LD      L,A		;4
2155: 9979+10	0E4E  C9      			RET			;10
2156:				
2157:				
2158:				
2159:				
2160:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2161:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2162:				;	Chapter_6	Menu operations. ASCII HEXFILE TRANSFER
2163:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2164:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2165:				;----------------------------------------------------------------------------------------------------; ASCII HEXFILE TRANSFER
2166: 9989+17	0E4F  CDCA0D  	GETHEXFILE	CALL	PRINTI
2167:     -	0E52  0D0A5741			DB	CR,LF,"WAITING FOR HEX TRANSFER",EOS
	              4954494E
	              4720464F
	              52204845
	              58205452
	              414E5346
	              455200
2168:				
2169:10006+10	0E6D  21C30E  			LD	HL,READ_SERIAL	;Set Serial Port as the source for the hex file
2170:10016+16	0E70  225BFF  			LD	(HEX_SOURCE),HL
2171:10032+10	0E73  210CFF  			LD	HL,VIEW_FLAGS	;Clear BIT .0= No View HEX Load
2172:10042+15	0E76  CB86    			RES	0,(HL)
2173:10057+17	0E78  CDF41E  			CALL	READ_HEX_FILE	;CY=1 ERROR encountered,  Z=0 Time Out
2174:10074+7+5	0E7B  202B    			JR  NZ,	GHENDTO
2175:10081+5+6	0E7D  D8      			RET	C		;If Error, exit without displaying "Complete" message
2176:						
2177:10086+17	0E7E  CDCA0D  			CALL	PRINTI
2178:     -	0E81  0D0A4845			DB	CR,LF,"HEX TRANSFER COMPLETE, LINES=",EOS
	              58205452
	              414E5346
	              45522043
	              4F4D504C
	              4554452C
	              204C494E
	              45533D00
2179:10103+16	0EA1  2A8AFA  			LD	HL,(RHF_LINES)
2180:10119+17	0EA4  CDEA0D  			CALL	PUT_HL
2181:10136+10	0EA7  C9      			RET
2182:				
2183:10146+17	0EA8  CDCA0D  	GHENDTO		CALL	PRINTI
2184:     -	0EAB  0D0A4845			DB	CR,LF,"HEX TRANSFER TIMEOUT",EOS
	              58205452
	              414E5346
	              45522054
	              494D454F
	              555400
2185:10163+10	0EC2  C9      			RET
2186:				
2187:						;FILL LINE_BUFF WITH A SINGLE LINE FROM SERIAL PORT
2188:						;RETURN Z=0 IF TIMED OUT (RET NZ)		
2189:10173+17	0EC3  CDBA1E  	READ_SERIAL	CALL	CLEAR_LINE_BUFF
2190:				
2191:10190+10	0EC6  2100FA  			LD	HL, LINE_BUFF	;Data desination @HL
2192:10200+7	0EC9  0602    	RS_CLP		LD	B,2		;Enable ':' search for 1st char
2193:						
2194:10207+7	0ECB  3E75    	RS_LP		LD	A,117		;20 Second Timeout for Get char
2195:10214+17	0ECD  CD4B14  			CALL	TIMED_GETCHAR
2196:10231+7+5	0ED0  3819    			JR  C, 	RS_TIMEOUT
2197:10238+7	0ED2  FE1B    			CP	27
2198:10245+7+5	0ED4  2815    			JR  Z,	RS_TIMEOUT
2199:				
2200:10252+7	0ED6  FE3A    			CP	':'
2201:10259+7+5	0ED8  2802    			JR  Z,	RS_COK
2202:10266+8+5	0EDA  10ED    			DJNZ	RS_CLP
2203:						
2204:10274+7	0EDC  0601    	RS_COK		LD	B,1		;Disable ':' search
2205:10281+7	0EDE  77      			LD	(HL),A
2206:10288+7	0EDF  FE0D    			CP	CR		;Test for CR
2207:10295+5+6	0EE1  C8      			RET	Z			
2208:10300+7	0EE2  FE0A    			CP	LF		;Test if LF
2209:10307+5+6	0EE4  C8      			RET	Z
2210:				
2211:10312+6	0EE5  23      			INC	HL		
2212:10318+4	0EE6  7D      			LD	A,L
2213:10322+7	0EE7  FE80    			CP	LOW LINE_BUFFEND
2214:10329+7+5	0EE9  20E0    			JR  NZ,	RS_LP
2215:						
2216:10336+4	0EEB  AF      	RS_TIMEOUT	XOR	A	;C=0,Z=1
2217:10340+4	0EEC  3D      			DEC	A	;Z=0
2218:10344+10	0EED  C9      			RET
2219:				
2220:				
2221:				
2222:				
2223:				
2224:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2225:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2226:				;	Chapter_7	Menu operations. XMODEM FILE TRANSFER
2227:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2228:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2229:				;----------------------------------------------------------------------------------------------------; XMODEM ROUTINES
2230:				
2231:     -	0001          	SOH	equ	1	;Start of Header
2232:     -	0004          	EOT	equ	4	;End of Transmission
2233:     -	0006          	ACK	equ	6
2234:     -	0010          	DLE	equ	16
2235:     -	0011          	DC1	equ	17	; (X-ON)
2236:     -	0013          	DC3	equ	19	; (X-OFF)
2237:     -	0015          	NAK	equ	21
2238:				;SYN	equ	22
2239:     -	0018          	CAN	equ	24	;(Cancel)
2240:				
2241:				;---------------------------------------------------------------------------------
2242:				;XMODEM MENU
2243:				;ENTRY:	TOP OF LDCK HOLDS RETURN ADDRESS (EXIT MECHANDSM IF XMODEM IS CANCELLED)
2244:				;---------------------------------------------------------------------------------
2245:10354+17	0EEE  CD190E  	XMODEM		CALL	PUT_SPACE
2246:10371+17	0EF1  CDE013  			CALL	GET_CHAR	;get char
2247:10388+7	0EF4  E65F    			AND	0x5F		;to upper case
2248:10395+7	0EF6  FE44    			CP	'D'
2249:10402+7+5	0EF8  280A    			JR Z,	XMDN		; D = DOWNLOAD (from memory to serial port)
2250:10409+7	0EFA  FE55    			CP	'U'
2251:10416+7+5	0EFC  2821    			JR Z,	XMUP		; U = UPLOAD (to memory from serial port)
2252:10423+17	0EFE  CDCA0D  			CALL 	PRINTI
2253:     -	0F01  3F00    			DB	"?",EOS
2254:10440+10	0F03  C9      			RET
2255:				
2256:				;---------------------------------------------------------------------------------
2257:				;XMDN - XMODEM DOWNLOAD (send file from IMSAI to Terminal)
2258:				;INPUT STARTING ADDRESS AND COUNT OF BLOCKS (WORD)
2259:				;WAIT FOR 'C' OR NAK FROM HOST TO START CRC/CS TRANSFER
2260:				;---------------------------------------------------------------------------------
2261:10450+17	0F04  CD760D  	XMDN		CALL	SPACE_GET_WORD	;Input Address
2262:10467+4	0F07  EB      			EX	DE,HL		;HL = Address to SAVE DATA
2263:10471+17	0F08  CD760D  			CALL	SPACE_GET_WORD	;Input #Blocks to Send
2264:									;DE = Count of Blocks
2265:				
2266:10488+4	0F0B  7A      			LD	A,D
2267:10492+4	0F0C  B3      			OR	E
2268:10496+5+6	0F0D  C8      			RET Z			;Exit if Block Count = 0
2269:				
2270:					;HL = Address of data to send from the IMSAI 8080
2271:					;DE = Count of Blocks to send.
2272:				
2273:10501+17	0F0E  CD2E0F  			CALL	XMS_INIT	;Starts the Seq, Sets the CS/CRC format
2274:									;Cancelled Transfers will cause a RET
2275:				
2276:10518+17	0F11  CD520F  	XMDN_LP		CALL	XMS_SEND	;Sends the packet @HL, Resends if NAK
2277:									;Cancelled Transfers will cause a RET
2278:10535+6	0F14  1B      			DEC	DE
2279:10541+4	0F15  7A      			LD	A,D
2280:10545+4	0F16  B3      			OR	E
2281:10549+7+5	0F17  20F8    			JR  NZ,	XMDN_LP
2282:				
2283:10556+17	0F19  CDA60F  			CALL	XMS_EOT		;Send End of Transmission
2284:10573+10	0F1C  C32A14  			JP	PURGE
2285:				
2286:				
2287:				;---------------------------------------------------------------------------------
2288:				;XMUP - XMODEM UPLOAD (receive file from Terminal to IMSAI 8080)
2289:				;INPUT STARTING ADDRESS
2290:				;SEND 'C' OR NAK TO HOST TO START CRC/CS TRANSFER
2291:				;---------------------------------------------------------------------------------
2292:10583+17	0F1F  CD760D  	XMUP		CALL	SPACE_GET_WORD	;Input Address
2293:10600+4	0F22  EB      			EX	DE,HL		;HL = Address to SAVE DATA
2294:				
2295:					;HL = Address of data to send from the IMSAI 8080
2296:				
2297:10604+17	0F23  CD0010  			CALL	XMR_INIT	;Starts the transfer & Receives first PACKET
2298:									;Cancelled Transfers will cause a RET
2299:				
2300:10621+17	0F26  CD3510  	XMUP_LP		CALL	XMR_RECV	;Receives the next packet @HL, Resends if NAK
2301:									;Cancelled Transfers will cause a RET
2302:10638+7+5	0F29  38FB    			JR C,	XMUP_LP		;Jump until EOT Received
2303:10645+10	0F2B  C32A14  			JP	PURGE
2304:				
2305:				
2306:				
2307:				;---------------------------------------------------------------------------------
2308:				;INIT FOR SENDING XMODEM PROTOCOL, GET NAK OR 'C', SAVE THE XMTYPE
2309:				;---------------------------------------------------------------------------------
2310:10655+7	0F2E  3E01    	XMS_INIT	LD	A,1		;First SEQ number
2311:10662+13	0F30  32F3FF  			LD	(XMSEQ),A
2312:				
2313:10675+7	0F33  0621    			LD	B,33		;33 retries for initiating the transfer
2314:10682+7	0F35  3E0A    	XMS_INIT_LP	LD	A,10		;GET CHAR, 5 SECONDS TIMEOUT (EXPECT C OR NAK)
2315:10689+17	0F37  CD4B14  			CALL	TIMED_GETCHAR
2316:10706+10	0F3A  DA450F  			JP C,	XMS_INIT_RT	;Cancel if Host Timed out
2317:				
2318:10716+7	0F3D  FE15    			CP	NAK		;If NAK, Start Checksum Download
2319:10723+7+5	0F3F  2809    			JR Z,	XMS_DO
2320:10730+7	0F41  FE43    			CP	'C'		;If C, Start CRC Download
2321:10737+7+5	0F43  2805    			JR Z,	XMS_DO
2322:10744+8+5	0F45  10EE    	XMS_INIT_RT	DJNZ	XMS_INIT_LP	;Count down Retries
2323:10752+10	0F47  C3DA0F  			JP	XM_CANCEL	;Cancel XModem if all retries exhausted
2324:				
2325:10762+13	0F4A  32F4FF  	XMS_DO		LD	(XMTYPE),A
2326:10775+10	0F4D  C9      			RET
2327:				
2328:				;---------------------------------------------------------------------------------
2329:				;SEND A PACKET (RESEND UPON NAK)
2330:				;---------------------------------------------------------------------------------
2331:10785+10	0F4E  0180FF  	XMS_RESEND	LD	BC,0xFF80
2332:10795+11	0F51  09      			ADD	HL,BC
2333:10806+11	0F52  D5      	XMS_SEND	PUSH	DE
2334:10817+7	0F53  3E01    			LD	A,SOH		;SEND THE HEADER FOR CRC OR CHECKSUM
2335:10824+17	0F55  CDEC13  			CALL	Put_Char
2336:10841+13	0F58  3AF3FF  			LD	A,(XMSEQ)
2337:10854+17	0F5B  CDEC13  			CALL	Put_Char
2338:10871+4	0F5E  2F      			CPL
2339:10875+17	0F5F  CDEC13  			CALL	Put_Char
2340:10892+10	0F62  110000  			LD	DE,0x0000	;Init DE=0000 (CRC Accumulator)
2341:10902+7	0F65  0E00    			LD	C,0		;Init C=00 (CS Accumulator)
2342:10909+7	0F67  0680    			LD	B,128		;Count 128 bytes per block
2343:10916+17	0F69  CD45FB  	XMS_BLP		CALL	GET_MEM		;Fetch bytes to send  -------------------\
2344:10933+11	0F6C  F5      			PUSH	AF
2345:10944+17	0F6D  CDEC13  			CALL	Put_Char	;Send them
2346:10961+17	0F70  CDD610  			CALL	CRC_UPDATE	;Update the CRC
2347:10978+10	0F73  F1      			POP	AF
2348:10988+4	0F74  81      			ADD	A,C		;Update the CS
2349:10992+4	0F75  4F      			LD	C,A
2350:10996+6	0F76  23      			INC	HL		;Advance to next byte in block
2351:11002+4	0F77  05      			DEC	B		;Count down bytes sent
2352:11006+7+5	0F78  20EF    			JR NZ,	XMS_BLP		;Loop back until 128 bytes are sent -----^
2353:11013+13	0F7A  3AF4FF  			LD	A,(XMTYPE)
2354:11026+7	0F7D  FE15    			CP	NAK		;If NAK, send Checksum
2355:11033+7+5	0F7F  2805    			JR Z,	XMS_CS		;----------------------v
2356:11040+4	0F81  7A      			LD	A,D		;else, Send the CRC next
2357:11044+17	0F82  CDEC13  			CALL	Put_Char
2358:11061+4	0F85  4B      			LD	C,E
2359:11065+4	0F86  79      	XMS_CS		LD	A,C		;----------------------/
2360:11069+17	0F87  CDEC13  			CALL	Put_Char
2361:									;Packet Sent, get Ack/Nak Response
2362:11086+7	0F8A  3E78    			LD	A,120		;GET CHAR, 60 SECONDS TIMEOUT (EXPECT C OR NAK)
2363:11093+17	0F8C  CD4B14  			CALL	TIMED_GETCHAR
2364:11110+10	0F8F  D1      			POP	DE
2365:11120+7+5	0F90  3848    			JR C,	XM_CANCEL	;Cancel download if no response within 45 seconds
2366:11127+7	0F92  FE15    			CP	NAK
2367:11134+7+5	0F94  28B8    			JR Z,	XMS_RESEND	;Loop back to resend packet
2368:11141+7	0F96  FE18    			CP	CAN
2369:11148+7+5	0F98  2840    			JR Z,	XM_CANCEL
2370:11155+7	0F9A  FE06    			CP	ACK
2371:11162+7+5	0F9C  203C    			JR NZ,	XM_CANCEL
2372:				
2373:11169+13	0F9E  3AF3FF  			LD	A,(XMSEQ)
2374:11182+4	0FA1  3C      			INC	A		;NEXT SEQ
2375:11186+13	0FA2  32F3FF  			LD	(XMSEQ),A
2376:11199+10	0FA5  C9      			RET
2377:				
2378:				
2379:				;---------------------------------------------------------------------------------
2380:				;XMDN - DOWNLOAD XMODEM PACKET
2381:				;---------------------------------------------------------------------------------
2382:11209+7	0FA6  3E04    	XMS_EOT		LD	A,EOT		;HANDLE THE END OF TRANSFER FOR CRC OR CHECKSUM
2383:11216+17	0FA8  CDEC13  			CALL	Put_Char
2384:11233+7	0FAB  3E78    			LD	A,120		;GET CHAR, 60 SECONDS TIMEOUT (EXPECT C OR NAK)
2385:11240+17	0FAD  CD4B14  			CALL	TIMED_GETCHAR
2386:11257+7+5	0FB0  3828    			JR C,	XM_CANCEL
2387:11264+7	0FB2  FE15    			CP	NAK
2388:11271+7+5	0FB4  28F0    			JR Z,	XMS_EOT
2389:11278+7	0FB6  FE06    			CP	ACK
2390:11285+7+5	0FB8  2020    			JR NZ,	XM_CANCEL
2391:				
2392:11292+17	0FBA  CD2A14  	XM_DONE		CALL	PURGE
2393:11309+17	0FBD  CDCA0D  			CALL	PRINTI
2394:     -	0FC0  0D0A5452			DB	CR,LF,"TRANSFER COMPLETE\r\n",EOS
	              414E5346
	              45522043
	              4F4D504C
	              4554455C
	              725C6E00
2395:11326+4	0FD8  AF      			XOR	A		;CLEAR A, CY
2396:11330+10	0FD9  C9      			RET
2397:				
2398:				;FINISHING CODE PRIOR TO LEAVING XMODEM
2399:11340+7	0FDA  3E18    	XM_CANCEL	LD	A,CAN
2400:11347+17	0FDC  CDEC13  			CALL	Put_Char
2401:11364+17	0FDF  CDEC13  			CALL	Put_Char
2402:11381+17	0FE2  CD2A14  			CALL	PURGE
2403:11398+17	0FE5  CDCA0D  			CALL	PRINTI
2404:     -	0FE8  5452414E			DB	"TRANSFER CANCELED\r\n",EOS
	              53464552
	              2043414E
	              43454C45
	              445C725C
	              6E00
2405:11415+10	0FFE  C1      			POP	BC		;SCRAP CALLING ROUTINE AND HEAD TO PARENT
2406:11425+10	0FFF  C9      			RET
2407:				
2408:				
2409:				
2410:				
2411:				
2412:				
2413:				;---------------------------------------------------------------------------------
2414:				;START XMODEM RECEIVING and RECEIVE FIRST PACKET
2415:				;---------------------------------------------------------------------------------
2416:11435+7	1000  1E14    	XMR_INIT	LD	E,20		;20 ATTEMPTS TO INITIATE XMODEM CRC TRANSFER
2417:11442+7	1002  3E01    			LD	A,1		;EXPECTED SEQ NUMBER starts at 1
2418:11449+13	1004  32F3FF  			LD	(XMSEQ),A
2419:11462+17	1007  CD2A14  	XMR_CRC		CALL	PURGE
2420:11479+7	100A  3E43    			LD	A,'C'		;Send C
2421:11486+13	100C  32F4FF  			LD	(XMTYPE),A	;Save as XM Type (CRC or CS)
2422:11499+17	100F  CDEC13  			CALL	Put_Char
2423:11516+17	1012  CDB310  			CALL	XMGET_HDR	;Await a packet
2424:11533+7+5	1015  3038    			JR NC,	XMR_TSEQ	;Jump if first packet received
2425:11540+7+5	1017  20C1    			JR NZ,	XM_CANCEL	;Cancel if there was a response that was not a header
2426:11547+4	1019  1D      			DEC	E		;Otherwise, if no response, retry a few times
2427:11551+7+5	101A  20EB    			JR NZ,	XMR_CRC
2428:				
2429:11558+7	101C  1E14    			LD	E,20		;20 ATTEMPTS TO INITIATE XMODEM CHECKSUM TRANSFER
2430:11565+17	101E  CD2A14  	XMR_CS		CALL	PURGE
2431:11582+7	1021  3E15    			LD	A,NAK		;Send NAK
2432:11589+13	1023  32F4FF  			LD	(XMTYPE),A	;Save as XM Type (CRC or CS)
2433:11602+17	1026  CDEC13  			CALL	Put_Char
2434:11619+17	1029  CDB310  			CALL	XMGET_HDR	;Await a packet
2435:11636+7+5	102C  3021    			JR NC,	XMR_TSEQ	;Jump if first packet received
2436:11643+7+5	102E  20AA    			JR NZ,	XM_CANCEL	;Cancel if there was a response that was not a header
2437:11650+4	1030  1D      			DEC	E		;Otherwise, if no response, retry a few times
2438:11654+7+5	1031  20EB    			JR NZ,	XMR_CS
2439:11661+12	1033  18A5    			JR	XM_CANCEL	;Abort
2440:				
2441:				
2442:				;--------------------- XMODEM RECEIVE
2443:				;Entry:	XMR_TSEQ in the middle of the routine
2444:				;Pre:	C=1 (expected first block as received when negogiating CRC or Checksum)
2445:				;	HL=Memory to dump the file to
2446:				;Uses:	B to count the 128 bytes per block
2447:				;	C to track Block Number expected
2448:				;	DE as CRC (Within Loop) (D is destroyed when Getting Header)
2449:				;------------------------------------
2450:11673+7	1035  3E06    	XMR_RECV	LD	A,ACK		;Send Ack to start Receiving next packet
2451:11680+17	1037  CDEC13  			CALL	Put_Char
2452:11697+17	103A  CDB310  	XMR_LP		CALL	XMGET_HDR
2453:11714+7+5	103D  3010    			JR NC,	XMR_TSEQ
2454:11721+11	103F  E5      			PUSH	HL
2455:11732+7+5	1040  2865    			JR Z,	XMR_NAK		;NACK IF TIMED OUT
2456:11739+10	1042  E1      			POP	HL
2457:11749+7	1043  FE04    			CP	EOT
2458:11756+7+5	1045  2093    			JR NZ,	XM_CANCEL	;CANCEL IF CAN RECEIVED (OR JUST NOT EOT)
2459:11763+7	1047  3E06    			LD	A,ACK
2460:11770+17	1049  CDEC13  			CALL	Put_Char
2461:11787+10	104C  C3BA0F  			JP	XM_DONE
2462:				
2463:11797+4	104F  4F      	XMR_TSEQ	LD	C,A
2464:11801+13	1050  3AF3FF  			LD	A,(XMSEQ)
2465:11814+4	1053  B9      			CP	C		;CHECK IF THIS SEQ IS EXPECTED
2466:11818+7+5	1054  280D    			JR Z,	XMR_SEQ_OK	;Jump if CORRECT SEQ
2467:11825+4	1056  3D      			DEC	A		;Else test if Previous SEQ
2468:11829+13	1057  32F3FF  			LD	(XMSEQ),A
2469:11842+4	105A  B9      			CP	C
2470:11846+10	105B  C2DA0F  			JP NZ,	XM_CANCEL	;CANCEL IF SEQUENCE ISN'T PREVIOUS BLOCK
2471:11856+17	105E  CD2A14  			CALL	PURGE		;ELSE, PURGE AND SEND ACK (ASSUMING PREVIOUS ACK WAS NOT RECEIVED)
2472:11873+12	1061  183A    			JR	XMR_ACK
2473:				
2474:11885+7	1063  0680    	XMR_SEQ_OK	LD	B,128		;128 BYTES PER BLOCK
2475:11892+7	1065  0E00    			LD	C,0		;Clear Checksum
2476:11899+10	1067  110000  			LD	DE,0x0000	;CLEAR CRC
2477:11909+11	106A  E5      			PUSH	HL		;Save HL where block is to go
2478:11920+17	106B  CD4914  	XMR_BLK_LP	CALL	TIMED1_GETCHAR
2479:11937+7+5	106E  3837    			JR C,	XMR_NAK
2480:11944+7	1070  77      			LD	(HL),A		;SAVE DATA BYTE
2481:11951+17	1071  CDD610  			CALL	CRC_UPDATE
2482:11968+7	1074  7E      			LD	A,(HL)		;Update checksum
2483:11975+4	1075  81      			ADD	A,C
2484:11979+4	1076  4F      			LD	C,A
2485:11983+6	1077  23      			INC	HL		;ADVANCE
2486:11989+4	1078  05      			DEC	B
2487:11993+7+5	1079  20F0    			JR NZ,	XMR_BLK_LP
2488:									;After 128 byte packet, verify error checking byte(s)
2489:12000+13	107B  3AF4FF  			LD	A,(XMTYPE)	;Determine if we are using CRC or Checksum
2490:12013+7	107E  FE15    			CP	NAK		;If NAK, then use Checksum
2491:12020+7+5	1080  2812    			JR Z,	XMR_CCS
2492:12027+17	1082  CD4914  			CALL	TIMED1_GETCHAR
2493:12044+7+5	1085  3820    			JR C,	XMR_NAK
2494:12051+4	1087  BA      			CP	D
2495:12055+7+5	1088  201D    			JR NZ,	XMR_NAK
2496:12062+17	108A  CD4914  			CALL	TIMED1_GETCHAR
2497:12079+7+5	108D  3818    			JR C,	XMR_NAK
2498:12086+4	108F  BB      			CP	E
2499:12090+7+5	1090  2015    			JR NZ,	XMR_NAK
2500:12097+12	1092  1809    			JR	XMR_ACK
2501:				
2502:12109+17	1094  CD4914  	XMR_CCS		CALL	TIMED1_GETCHAR
2503:12126+10	1097  DAA710  			JP C,	XMR_NAK
2504:12136+4	109A  B9      			CP	C
2505:12140+7+5	109B  200A    			JR NZ,	XMR_NAK
2506:				
2507:						;If we were transfering to a FILE, this is where we would write the
2508:						;sector and reset HL to the same 128 byte sector buffer.
2509:						;CALL	WRITE_SECTOR
2510:				
2511:     -	109D          	XMR_ACK		;LD	A,ACK		;The sending of the Ack is done by
2512:						;CALL	Put_Char	;the calling routine, to allow writes to disk
2513:12147+13	109D  3AF3FF  			LD	A,(XMSEQ)
2514:12160+4	10A0  3C      			INC	A		;Advance to next SEQ BLOCK
2515:12164+13	10A1  32F3FF  			LD	(XMSEQ),A
2516:12177+10	10A4  C1      			POP	BC
2517:12187+4	10A5  37      			SCF			;Carry set when NOT last packet
2518:12191+10	10A6  C9      			RET
2519:				
2520:12201+10	10A7  E1      	XMR_NAK		POP	HL		;Return HL to start of block
2521:12211+17	10A8  CD2A14  			CALL	PURGE
2522:12228+7	10AB  3E15    			LD	A,NAK
2523:12235+17	10AD  CDEC13  			CALL	Put_Char
2524:12252+10	10B0  C33A10  			JP	XMR_LP
2525:				
2526:				
2527:				;--------------------- XMODEM - GET HEADER
2528:				;
2529:				;pre:	Nothing
2530:				;post:	Carry Set: A=0, (Zero set) if Timeout
2531:				;	Carry Set: A=CAN (Not Zero) if Cancel received
2532:				;	Carry Set: A=EOT (Not Zero) if End of Tranmission received
2533:				;	Carry Clear and A = B = Seq if Header found and is good
2534:				;------------------------------------------
2535:12262+7	10B3  3E06    	XMGET_HDR	LD	A,6		;GET CHAR, 3 SECONDS TIMEOUT (EXPECT SOH)
2536:12269+17	10B5  CD4B14  			CALL	TIMED_GETCHAR
2537:12286+5+6	10B8  D8      			RET C			;Return if Timed out
2538:12291+7	10B9  FE01    			CP	SOH		;TEST IF START OF HEADER
2539:12298+7+5	10BB  280B    			JR Z,	GS_SEQ		;IF SOH RECEIVED, GET SEQ NEXT
2540:12305+7	10BD  FE04    			CP	EOT		;TEST IF END OF TRANSMISSION
2541:12312+7+5	10BF  2804    			JR Z,	GS_ESC		;IF EOT RECEIVED, TERMINATE XMODEM
2542:12319+7	10C1  FE18    			CP	CAN		;TEST IF CANCEL
2543:12326+7+5	10C3  20EE    			JR NZ,	XMGET_HDR
2544:12333+4	10C5  B7      	GS_ESC		OR	A		;Clear Z flag (because A<>0)
2545:12337+4	10C6  37      			SCF
2546:12341+10	10C7  C9      			RET
2547:12351+17	10C8  CD4914  	GS_SEQ		CALL	TIMED1_GETCHAR	;GET SEQ CHAR
2548:12368+5+6	10CB  D8      			RET C			;Return if Timed out
2549:12373+4	10CC  47      			LD	B,A		;SAVE SEQ
2550:12377+17	10CD  CD4914  			CALL	TIMED1_GETCHAR	;GET SEQ COMPLEMENT
2551:12394+5+6	10D0  D8      			RET C			;Return if Timed out
2552:12399+4	10D1  2F      			CPL
2553:12403+4	10D2  B8      			CP	B		;TEST IF SEQ VALID
2554:12407+7+5	10D3  20DE    			JR NZ,	XMGET_HDR	;LOOP BACK AND TRY AGAIN IF HEADER INCORRECT (SYNC FRAME)
2555:12414+10	10D5  C9      			RET
2556:				
2557:				;------------------------------------------ CRC_UPDATE
2558:				;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
2559:				;Total Time=775 cycles = 388uSec
2560:				;In:	A  = New char to roll into CRC accumulator
2561:				;	DE = 16bit CRC accumulator
2562:				;Out:	DE = 16bit CRC accumulator
2563:				;------------------------------------------
2564:				;CRC_UPDATE	XOR	D		;4
2565:				;		LD	D,A		;5
2566:				;		PUSH	BC		;11
2567:				;		LD	B,8		;7	PRELOOP=27
2568:				;CRCU_LP	OR	A		;4	CLEAR CARRY
2569:				;		LD	A,E		;5
2570:				;		RLA			;4
2571:				;		LD	E,A		;5
2572:				;		LD	A,D		;5
2573:				;		RLA			;4
2574:				;		LD	D,A		;5
2575:				;		JP NC,	CRCU_NX		;10
2576:				;		LD	A,D		;5
2577:				;		XOR	0x10		;7
2578:				;		LD	D,A		;5
2579:				;		LD	A,E		;5
2580:				;		XOR	0x21		;7
2581:				;		LD	E,A		;5
2582:				;CRCU_NX	DEC	B		;5
2583:				;		JP NZ,	CRCU_LP		;10	LOOP=91*8 (WORSE CASE)
2584:				;		POP	BC		;10	POSTLOOP=20
2585:				;		RET			;10
2586:				
2587:				
2588:				;------------------------------------------ CRC_UPDATE
2589:				;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
2590:				;Total Time=604 cycles = 302uSec MAX
2591:				;In:	A  = New char to roll into CRC accumulator
2592:				;	DE = 16bit CRC accumulator
2593:				;Out:	DE = 16bit CRC accumulator
2594:				;------------------------------------------
2595:12424+4	10D6  EB      	CRC_UPDATE	EX	DE,HL			;4
2596:12428+4	10D7  AC      			XOR	H		;4
2597:12432+4	10D8  67      			LD	H,A		;5
2598:12436+11	10D9  29      			ADD	HL,HL		;10	Shift HL Left 1
2599:12447+10+7	10DA  DCFB10  			CALL C,	CRC_UPC		;17 (10/61)
2600:12457+11	10DD  29      			ADD	HL,HL		;10	Shift HL Left 2
2601:12468+10+7	10DE  DCFB10  			CALL C,	CRC_UPC		;17
2602:12478+11	10E1  29      			ADD	HL,HL		;10	Shift HL Left 3
2603:12489+10+7	10E2  DCFB10  			CALL C,	CRC_UPC		;17
2604:12499+11	10E5  29      			ADD	HL,HL		;10	Shift HL Left 4
2605:12510+10+7	10E6  DCFB10  			CALL C,	CRC_UPC		;17
2606:12520+11	10E9  29      			ADD	HL,HL		;10	Shift HL Left 5
2607:12531+10+7	10EA  DCFB10  			CALL C,	CRC_UPC		;17
2608:12541+11	10ED  29      			ADD	HL,HL		;10	Shift HL Left 6
2609:12552+10+7	10EE  DCFB10  			CALL C,	CRC_UPC		;17
2610:12562+11	10F1  29      			ADD	HL,HL		;10	Shift HL Left 7
2611:12573+10+7	10F2  DCFB10  			CALL C,	CRC_UPC		;17
2612:12583+11	10F5  29      			ADD	HL,HL		;10	Shift HL Left 8
2613:12594+10+7	10F6  DCFB10  			CALL C,	CRC_UPC		;17
2614:12604+4	10F9  EB      			EX	DE,HL			;4
2615:12608+10	10FA  C9      			RET			;10
2616:				
2617:12618+4	10FB  7C      	CRC_UPC		LD	A,H		;5
2618:12622+7	10FC  EE10    			XOR	0x10		;7
2619:12629+4	10FE  67      			LD	H,A		;5
2620:12633+4	10FF  7D      			LD	A,L		;5
2621:12637+7	1100  EE21    			XOR	0x21		;7
2622:12644+4	1102  6F      			LD	L,A		;5
2623:12648+10	1103  C9      			RET			;10
2624:				
2625:				
2626:				;XModem implementation on 8080 Monitor (CP/M-80)
2627:				;
2628:				;Terminal uploads to 8080 system:
2629:				;-Terminal user enters command "XU aaaa"
2630:				;-8080 "drives" the protocol since it's the receiver
2631:				;-8080 sends <Nak> every 10 seconds until the transmitter sends a packet
2632:				;-if transmitter does not begin within 10 trys (100 seconds), 8080 aborts XMODEM
2633:				;-a packet is:
2634:				; <SOH> [seq] [NOT seq] [128 bytes of data] [checksum or CRC]
2635:				;
2636:				;<SOH> = 1 (Start of Header)
2637:				;<EOT> = 4 (End of Transmission)
2638:				;<ACK> = 6
2639:				;<DLE> = 16
2640:				;<DC1> = 17 (X-ON)
2641:				;<DC3> = 19 (X-OFF)
2642:				;<NAK> = 21
2643:				;<SYN> = 22
2644:				;<CAN> = 24 (Cancel)
2645:				;
2646:				;Checksum is the ModuLOW 256 sum of all 128 data bytes
2647:				;
2648:				;                                     <<<<<          [NAK]
2649:				;       [SOH][001][255][...][csum]    >>>>>
2650:				;                                     <<<<<          [ACK]
2651:				;       [SOH][002][254][...][csum]    >>>>>
2652:				;                                     <<<<<          [ACK]
2653:				;       [SOH][003][253][...][csum]    >>>>>
2654:				;                                     <<<<<          [ACK]
2655:				;       [EOT]                         >>>>>
2656:				;                                     <<<<<          [ACK]
2657:				;
2658:				;-if we get <EOT> then ACK and terminate XModem
2659:				;-if we get <CAN> then terminate XModem
2660:				;-if checksum invalid, then NAK
2661:				;-if seq number not correct as per [NOT seq], then NAK
2662:				;-if seq number = previous number, then ACK (But ignore block)
2663:				;-if seq number not the expected number, then <CAN><CAN> and terminate XModem
2664:				;-if data not received after 10 seconds, then NAK (inc Timeout Retry)
2665:				;-if timeout retry>10 then <CAN><CAN> and terminate XModem
2666:				;
2667:				;-To keep synchronized,
2668:				;  -Look for <SOH>, qualify <SOH> by checking the [seq] / [NOT seq]
2669:				;  -if no <SOH> found after 135 chars, then NAK
2670:				;
2671:				;-False EOT condtion
2672:				;  -NAK the first EOT
2673:				;  -if the next char is EOT again, then ACK and leave XModem
2674:				;
2675:				;-False <CAN>, expect a 2nd <CAN> ?
2676:				;
2677:				;-Using CRC, send "C" instead of <NAK> for the first packet
2678:				;  -Send "C" every 3 seconds for 3 tries, then degrade to checksums by sending <NAK>
2679:				;
2680:				;
2681:				;
2682:				;* The character-receive subroutine should be called with a
2683:				;parameter specifying the number of seconds to wait.  The
2684:				;receiver should first call it with a time of 10, then <nak> and
2685:				;try again, 10 times.
2686:				;  After receiving the <soh>, the receiver should call the
2687:				;character receive subroutine with a 1-second timeout, for the
2688:				;remainder of the message and the <cksum>.  Since they are sent
2689:				;as a continuous stream, timing out of this implies a serious
2690:				;like glitch that caused, say, 127 characters to be seen instead
2691:				;of 128.
2692:				;
2693:				;* When the receiver wishes to <nak>, it should call a "PURGE"
2694:				;subroutine, to wait for the line to clear.  Recall the sender
2695:				;tosses any characters in its UART buffer immediately upon
2696:				;completing sending a block, to ensure no glitches were mis-
2697:				;interpreted.
2698:				;  The most common technique is for "PURGE" to call the
2699:				;character receive subroutine, specifying a 1-second timeout,
2700:				;and looping back to PURGE until a timeout occurs.  The <nak> is
2701:				;then sent, ensuring the other end will see it.
2702:				;
2703:				;* You may wish to add code recommended by Jonh Mahr to your
2704:				;character receive routine - to set an error flag if the UART
2705:				;shows framing error, or overrun.  This will help catch a few
2706:				;more glitches - the most common of which is a hit in the high
2707:				;bits of the byte in two consecutive bytes.  The <cksum> comes
2708:				;out OK since counting in 1-byte produces the same result of
2709:				;adding 80H + 80H as with adding 00H + 00H.
2710:				
2711:				
2712:				
2713:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2714:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2715:				;	Chapter_8	Menu operations. RAM TEST
2716:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2717:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2718:				;----------------------------------------------------------------------------------------------------; RAM TEST
2719:				;B=START PAGE
2720:				;C=END PAGE
2721:12658+17	1104  CD490D  	RAM_TEST:	CALL	SPACE_GET_BYTE
2722:12675+4	1107  47      			LD	B, A
2723:12679+17	1108  CD490D  			CALL	SPACE_GET_BYTE
2724:12696+4	110B  4F      			LD	C, A
2725:				
2726:12700+10	110C  217C0C  			LD	HL,GET_REG_RUN
2727:12710+16	110F  22B4FF  			LD	(GET_REG),HL
2728:12726+17	1112  CD1C11  			CALL	RT_GO
2729:12743+10	1115  21710C  			LD	HL,GET_REG_MON
2730:12753+16	1118  22B4FF  			LD	(GET_REG),HL
2731:12769+10	111B  C9      			RET
2732:				
2733:				;Page March Test.  1 Sec/K
2734:				;
2735:				; FOR E = 00 TO FF STEP FF   'March 00 then March FF
2736:				;   FOR H = B TO C
2737:				;      PAGE(H) = E
2738:				;   NEXT H
2739:				;   FOR D = B TO C
2740:				;      PAGE(D) = NOT E
2741:				;      FOR H = B TO C
2742:				;         A = E
2743:				;         IF H = D THEN A = NOT E
2744:				;         IF PAGE(H) <> A THEN ERROR1
2745:				;      NEXT H
2746:				;   NEXT D
2747:				; NEXT E
2748:				;
2749:				
2750:12779+17	111C  CDCA0D  	RT_GO		CALL	PRINTI
2751:     -	111F  0D0A5445			DB	CR,LF,"TESTING RAM",EOS
	              5354494E
	              47205241
	              4D00
2752:12796+7	112D  1EFF    			LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
2753:				
2754:				;Clear/Set all pages
2755:12803+4	112F  60      	RT1_LP0		LD	H,B		;HL = BASE RAM ADDRESS
2756:12807+7	1130  2E00    			LD	L,0
2757:12814+4	1132  7B      	RT1_LP1		LD	A,E		;CLEAR A
2758:12818+4	1133  2F      			CPL
2759:12822+7	1134  77      	RT1_LP2		LD	(HL),A		;WRITE PAGE
2760:12829+4	1135  2C      			INC	L
2761:12833+7+5	1136  20FC    			JR NZ,	RT1_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
2762:12840+4	1138  7C      			LD	A,H
2763:12844+4	1139  24      			INC	H		;ADVANCE TO NEXT PAGE
2764:12848+4	113A  B9      			CP	C		;COMPARE WITH END PAGE
2765:12852+7+5	113B  20F5    			JR NZ,	RT1_LP1		;LOOP UNTIL = END PAGE
2766:				
2767:				;March 1 PAGE through RAM
2768:12859+4	113D  50      			LD	D,B		;Begin with START PAGE
2769:				
2770:				;Write FF to page D
2771:12863+4	113E  62      	RT1_LP3		LD	H,D		;HL = Marched Page ADDRESS
2772:						;LD	L,0
2773:12867+17	113F  CD7013  			CALL	ABORT_CHECK
2774:				
2775:12884+4	1142  7A      			LD	A,D
2776:12888+4	1143  2F      			CPL
2777:				;		OUT	FPLED
2778:						;LD	A,E		;SET A
2779:12892+7	1144  73      	RT1_LP4		LD	(HL),E		;WRITE PAGE
2780:12899+4	1145  2C      			INC	L
2781:12903+7+5	1146  20FC    			JR  NZ,	RT1_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
2782:				
2783:				;Test all pages for 0 (except page D = FF)
2784:12910+4	1148  60      			LD	H,B		;HL = BASE RAM ADDRESS
2785:						;LD	L,0
2786:				
2787:12914+4	1149  7C      	RT1_LP5		LD	A,H		;IF H = D
2788:12918+4	114A  BA      			CP	D
2789:12922+4	114B  7B      			LD	A,E		;THEN Value = FF
2790:12926+7+5	114C  2801    			JR Z,	RT1_LP6
2791:12933+4	114E  2F      			CPL			;ELSE Value = 00
2792:				
2793:12937+7	114F  BE      	RT1_LP6		CP	(HL)		;TEST RAM
2794:12944+10	1150  C2E212  			JP NZ,	RT_FAIL1
2795:12954+4	1153  2C      			INC	L
2796:12958+7+5	1154  20F9    			JR NZ,	RT1_LP6		;LOOP TO QUICKLY TEST 1 PAGE
2797:12965+4	1156  7C      			LD	A,H
2798:12969+4	1157  24      			INC	H		;ADVANCE TO NEXT PAGE
2799:12973+4	1158  B9      			CP	C		;COMPARE WITH END PAGE
2800:12977+7+5	1159  20EE    			JR NZ,	RT1_LP5		;LOOP UNTIL = END PAGE
2801:				
2802:				;Write 00 back to page D
2803:12984+4	115B  62      			LD	H,D		;HL = Marched Page ADDRESS
2804:						;LD	L,0
2805:12988+4	115C  7B      			LD	A,E
2806:12992+4	115D  2F      			CPL
2807:12996+7	115E  77      	RT1_LP7		LD	(HL),A		;WRITE PAGE
2808:13003+4	115F  2C      			INC	L
2809:13007+7+5	1160  20FC    			JR NZ,	RT1_LP7		;LOOP TO QUICKLY WRITE 1 PAGE
2810:				
2811:13014+4	1162  7A      			LD	A,D
2812:13018+4	1163  14      			INC	D		;ADVANCE TO NEXT PAGE
2813:13022+4	1164  B9      			CP	C		;COMPARE WITH END PAGE
2814:13026+7+5	1165  20D7    			JR NZ,	RT1_LP3		;LOOP UNTIL = END PAGE
2815:				
2816:13033+4	1167  1C      			INC	E
2817:13037+7+5	1168  28C5    			JR Z,	RT1_LP0
2818:				
2819:13044+17	116A  CDCA0D  			CALL	PRINTI
2820:     -	116D  0D0A5241			DB	CR,LF,"RAM PAGE MARCH PASSED",EOS
	              4D205041
	              4745204D
	              41524348
	              20504153
	              53454400
2821:				
2822:				
2823:				;Byte March Test.  7 Sec/K
2824:				;
2825:				; FOR E = 00 TO FF STEP FF   'March 00 then March FF
2826:				;   FOR H = B TO C
2827:				;      PAGE(H) = E
2828:				;      FOR D = 00 TO FF
2829:				;         PAGE(H).D = NOT E
2830:				;         FOR L=0 TO FF
2831:				;            IF PAGE(H).L <> E THEN
2832:				;               IF PAGE(H).L <> NOT E THEN ERROR2
2833:				;               IF L<>D THEN ERROR2
2834:				;            ENDIF
2835:				;         NEXT L
2836:				;      NEXT D
2837:				;   NEXT H
2838:				; NEXT E
2839:				
2840:13061+7	1185  1EFF    			LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
2841:				
2842:				;Clear/Set all pages
2843:				
2844:13068+4	1187  60      	RT2_LP0		LD	H,B		;HL = BASE RAM ADDRESS
2845:13072+7	1188  2E00    	RT2_LP1		LD	L,0
2846:13079+17	118A  CD7013  			CALL	ABORT_CHECK
2847:				
2848:13096+4	118D  7C      			LD	A,H
2849:13100+4	118E  2F      			CPL
2850:				;		OUT	FPLED
2851:				
2852:13104+4	118F  7B      			LD	A,E		;CLEAR A
2853:13108+4	1190  2F      			CPL
2854:13112+7	1191  77      	RT2_LP2		LD	(HL),A		;WRITE PAGE
2855:13119+4	1192  2C      			INC	L
2856:13123+7+5	1193  20FC    			JR NZ,	RT2_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
2857:				
2858:				
2859:13130+7	1195  1600    			LD	D,0		;Starting with BYTE 00 of page
2860:				
2861:13137+4	1197  6A      	RT2_LP3		LD	L,D		;Save at byte march ptr
2862:13141+4	1198  7B      			LD	A,E		;SET A
2863:13145+7	1199  77      			LD	(HL),A
2864:				
2865:						;LD	A,E
2866:13152+4	119A  2F      			CPL			;CLEAR A
2867:13156+7	119B  2E00    			LD	L,0
2868:				
2869:13163+7	119D  BE      	RT2_LP4		CP	(HL)		;TEST BYTE FOR CLEAR
2870:13170+7+5	119E  280C    			JR Z,	RT2_NX1
2871:13177+4	11A0  2F      			CPL			;SET A
2872:13181+7	11A1  BE      			CP	(HL)		;TEST BYTE FOR SET
2873:13188+10	11A2  C20513  			JP NZ,	RT_FAIL2	;IF NOT FULLY SET, THEN DEFINITELY FAIL
2874:13198+4	11A5  7D      			LD	A,L		;ELSE CHECK WE ARE ON MARCHED BYTE
2875:13202+4	11A6  BA      			CP	D
2876:13206+10	11A7  C20513  			JP NZ,	RT_FAIL2
2877:13216+4	11AA  7B      			LD	A,E		;CLEAR A
2878:13220+4	11AB  2F      			CPL
2879:13224+4	11AC  2C      	RT2_NX1		INC	L
2880:13228+7+5	11AD  20EE    			JR NZ,	RT2_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
2881:				
2882:13235+4	11AF  6A      			LD	L,D		;Save at byte march ptr
2883:13239+4	11B0  7B      			LD	A,E
2884:13243+4	11B1  2F      			CPL			;CLEAR A
2885:13247+7	11B2  77      			LD	(HL),A
2886:				
2887:13254+4	11B3  14      			INC	D
2888:13258+7+5	11B4  20E1    			JR NZ,	RT2_LP3
2889:				
2890:13265+4	11B6  7C      			LD	A,H
2891:13269+4	11B7  24      			INC	H		;ADVANCE TO NEXT PAGE
2892:13273+4	11B8  B9      			CP	C		;COMPARE WITH END PAGE
2893:13277+7+5	11B9  20CD    			JR NZ,	RT2_LP1		;LOOP UNTIL = END PAGE
2894:				
2895:13284+4	11BB  1C      			INC	E
2896:13288+7+5	11BC  28C9    			JR Z,	RT2_LP0
2897:				
2898:13295+17	11BE  CDCA0D  			CALL	PRINTI
2899:     -	11C1  0D0A5241			DB	CR,LF,"RAM BYTE MARCH 1 PASSED",EOS
	              4D204259
	              5445204D
	              41524348
	              20312050
	              41535345
	              4400
2900:				
2901:				;26 Sec/K
2902:				
2903:     -	11DB          	BYTEMARCH2
2904:13312+7	11DB  1EFF    			LD	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
2905:				
2906:13319+7	11DD  1600    	RT4_LP0		LD	D,0		;Starting with BYTE 00 of page
2907:				
2908:				;CLEAR all pages
2909:				
2910:13326+4	11DF  60      			LD	H,B		;HL = BASE RAM ADDRESS
2911:13330+7	11E0  2E00    			LD	L,0
2912:				
2913:13337+4	11E2  7B      	RT4_LP1		LD	A,E		;CLEAR A
2914:13341+4	11E3  2F      			CPL
2915:13345+7	11E4  77      	RT4_LP2		LD	(HL),A		;WRITE PAGE
2916:13352+4	11E5  2C      			INC	L
2917:13356+7+5	11E6  20FC    			JR NZ,	RT4_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
2918:				
2919:13363+4	11E8  7C      			LD	A,H
2920:13367+4	11E9  24      			INC	H		;ADVANCE TO NEXT PAGE
2921:13371+4	11EA  B9      			CP	C		;COMPARE WITH END PAGE
2922:13375+7+5	11EB  20F5    			JR NZ,	RT4_LP1		;LOOP UNTIL = END PAGE
2923:				
2924:				
2925:13382+17	11ED  CD7013  	RT4_LP3		CALL	ABORT_CHECK
2926:13399+4	11F0  7A      			LD	A,D
2927:13403+4	11F1  2F      			CPL
2928:				;		OUT	FPLED
2929:				
2930:									;Write SET byte at "D" in every page
2931:13407+4	11F2  60      			LD	H,B		;HL = BASE RAM ADDRESS
2932:13411+4	11F3  6A      			LD	L,D		;Save at byte march ptr
2933:13415+7	11F4  73      	RT4_LP4		LD	(HL),E
2934:				
2935:13422+4	11F5  7C      			LD	A,H
2936:13426+4	11F6  24      			INC	H		;ADVANCE TO NEXT PAGE
2937:13430+4	11F7  B9      			CP	C		;COMPARE WITH END PAGE
2938:13434+7+5	11F8  20FA    			JR NZ,	RT4_LP4		;LOOP UNTIL = END PAGE
2939:				
2940:				
2941:13441+7	11FA  2E00    			LD	L,0
2942:				
2943:13448+4	11FC  60      	RT4_LP5		LD	H,B		;HL = BASE RAM ADDRESS
2944:13452+4	11FD  7D      			LD	A,L
2945:13456+4	11FE  BA      			CP	D
2946:13460+7+5	11FF  280D    			JR Z,	RT4_LP7		;Test for marked byte in all pages
2947:				
2948:13467+4	1201  7B      	RT4_LP6		LD	A,E
2949:13471+4	1202  2F      			CPL			;CLEAR A
2950:13475+7	1203  BE      			CP	(HL)		;TEST BYTE FOR CLEAR
2951:13482+10	1204  C20513  			JP NZ,	RT_FAIL2
2952:				
2953:13492+4	1207  7C      			LD	A,H
2954:13496+4	1208  24      			INC	H		;ADVANCE TO NEXT PAGE
2955:13500+4	1209  B9      			CP	C		;COMPARE WITH END PAGE
2956:13504+7+5	120A  20F5    			JR NZ,	RT4_LP6		;LOOP UNTIL = END PAGE
2957:13511+12	120C  180A    			JR	RT4_NX
2958:				
2959:13523+4	120E  7B      	RT4_LP7		LD	A,E
2960:13527+7	120F  BE      			CP	(HL)		;TEST BYTE FOR SET
2961:13534+10	1210  C20513  			JP NZ,	RT_FAIL2
2962:				
2963:13544+4	1213  7C      			LD	A,H
2964:13548+4	1214  24      			INC	H		;ADVANCE TO NEXT PAGE
2965:13552+4	1215  B9      			CP	C		;COMPARE WITH END PAGE
2966:13556+7+5	1216  20F6    			JR NZ,	RT4_LP7		;LOOP UNTIL = END PAGE
2967:				
2968:13563+4	1218  2C      	RT4_NX		INC	L
2969:13567+7+5	1219  20E1    			JR NZ,	RT4_LP5
2970:				
2971:									;Write CLEAR byte at "D" in every page
2972:13574+4	121B  60      			LD	H,B		;HL = BASE RAM ADDRESS
2973:13578+4	121C  6A      			LD	L,D		;Save at byte march ptr
2974:13582+4	121D  7B      	RT4_LP8		LD	A,E
2975:13586+4	121E  2F      			CPL
2976:13590+7	121F  77      			LD	(HL),A
2977:				
2978:13597+4	1220  7C      			LD	A,H
2979:13601+4	1221  24      			INC	H		;ADVANCE TO NEXT PAGE
2980:13605+4	1222  B9      			CP	C		;COMPARE WITH END PAGE
2981:13609+7+5	1223  20F8    			JR NZ,	RT4_LP8		;LOOP UNTIL = END PAGE
2982:				
2983:13616+4	1225  14      			INC	D
2984:13620+7+5	1226  20C5    			JR NZ,	RT4_LP3
2985:				
2986:				
2987:13627+4	1228  1C      			INC	E
2988:13631+7+5	1229  28B2    			JR Z,	RT4_LP0
2989:				
2990:13638+17	122B  CDCA0D  			CALL	PRINTI
2991:     -	122E  0D0A5241			DB	CR,LF,"RAM BYTE MARCH 2 PASSED",EOS
	              4D204259
	              5445204D
	              41524348
	              20322050
	              41535345
	              4400
2992:				
2993:				
2994:     -	1248          	BIT_MARCH
2995:				;Bit March Test.  0.1 Sec/K
2996:				
2997:13655+7	1248  1E01    			LD	E,01		;E selects the bit to march
2998:				
2999:				;Clear/Set all pages
3000:				
3001:13662+4	124A  60      	RT3_LP1		LD	H,B		;HL = BASE RAM ADDRESS
3002:13666+7	124B  2E00    			LD	L,0
3003:				
3004:13673+17	124D  CD7013  			CALL	ABORT_CHECK
3005:				
3006:13690+4	1250  7B      			LD	A,E		;Display bit pattern on LED PORT
3007:13694+4	1251  2F      			CPL
3008:				;		OUT	FPLED
3009:				
3010:13698+4	1252  7B      	RT3_LP2		LD	A,E		;FETCH MARCHING BIT PATTERN
3011:13702+7	1253  77      	RT3_LP3		LD	(HL),A		;WRITE PAGE
3012:13709+4	1254  2C      			INC	L
3013:13713+7+5	1255  20FC    			JR NZ,	RT3_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
3014:				
3015:13720+4	1257  7C      			LD	A,H
3016:13724+4	1258  24      			INC	H		;ADVANCE TO NEXT PAGE
3017:13728+4	1259  B9      			CP	C		;COMPARE WITH END PAGE
3018:13732+7+5	125A  20F6    			JR NZ,	RT3_LP2		;LOOP UNTIL = END PAGE
3019:				
3020:13739+4	125C  60      			LD	H,B		;HL = BASE RAM ADDRESS
3021:				;		LD	L,0
3022:				
3023:13743+4	125D  7B      	RT3_LP4		LD	A,E		;FETCH MARCHING BIT PATTERN
3024:13747+7	125E  BE      	RT3_LP5		CP	(HL)
3025:13754+10	125F  C22813  			JP NZ,	RT_FAIL3
3026:13764+4	1262  2C      			INC	L
3027:13768+7+5	1263  20F9    			JR NZ,	RT3_LP5		;LOOP TO QUICKLY WRITE 1 PAGE
3028:				
3029:13775+4	1265  7C      			LD	A,H
3030:13779+4	1266  24      			INC	H		;ADVANCE TO NEXT PAGE
3031:13783+4	1267  B9      			CP	C		;COMPARE WITH END PAGE
3032:13787+7+5	1268  20F3    			JR NZ,	RT3_LP4		;LOOP UNTIL = END PAGE
3033:				
3034:				
3035:									;0000 0010
3036:									;...
3037:									;1000 0000
3038:				
3039:13794+4	126A  7B      			LD	A,E
3040:13798+4	126B  17      			RLA			;ROTATE THE 01 UNTIL 00
3041:13802+4	126C  7B      			LD	A,E
3042:13806+4	126D  07      			RLCA
3043:13810+4	126E  5F      			LD	E,A
3044:13814+7	126F  FE01    			CP	1
3045:13821+7+5	1271  2004    			JR NZ,	RT3_NX1
3046:13828+4	1273  2F      			CPL			;INVERT ALL BITS
3047:13832+4	1274  5F      			LD	E,A
3048:13836+12	1275  18D3    			JR	RT3_LP1
3049:13848+7	1277  FEFE    	RT3_NX1		CP	0xFE
3050:13855+7+5	1279  20CF    			JR NZ,	RT3_LP1
3051:				
3052:13862+17	127B  CDCA0D  			CALL	PRINTI
3053:     -	127E  0D0A5241			DB	CR,LF,"RAM BIT MARCH PASSED",EOS
	              4D204249
	              54204D41
	              52434820
	              50415353
	              454400
3054:				
3055:				
3056:13879+7	1295  1E01    			LD	E,01		;E selects the start sequence
3057:				
3058:				;Clear/Set all pages
3059:				
3060:13886+17	1297  CD7013  	RT5_LP1		CALL	ABORT_CHECK
3061:				
3062:13903+4	129A  7B      			LD	A,E		;Display bit pattern on LED PORT
3063:13907+4	129B  2F      			CPL
3064:				;		OUT	FPLED
3065:				
3066:13911+4	129C  60      			LD	H,B		;HL = BASE RAM ADDRESS
3067:13915+7	129D  2E00    			LD	L,0
3068:13922+4	129F  53      			LD	D,E
3069:				
3070:13926+4	12A0  14      	RT5_LP2		INC	D
3071:13930+7+5	12A1  2001    			JR NZ,	RT5_NX1
3072:13937+4	12A3  14      			INC	D
3073:13941+7	12A4  72      	RT5_NX1		LD	(HL),D		;WRITE PAGE
3074:13948+4	12A5  2C      			INC	L
3075:13952+7+5	12A6  20F8    			JR NZ,	RT5_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
3076:				
3077:13959+4	12A8  7C      			LD	A,H
3078:13963+4	12A9  24      			INC	H		;ADVANCE TO NEXT PAGE
3079:13967+4	12AA  B9      			CP	C		;COMPARE WITH END PAGE
3080:13971+7+5	12AB  20F3    			JR NZ,	RT5_LP2		;LOOP UNTIL = END PAGE
3081:				
3082:13978+4	12AD  60      			LD	H,B		;HL = BASE RAM ADDRESS
3083:						;LD	L,0
3084:13982+4	12AE  53      			LD	D,E
3085:				
3086:13986+4	12AF  14      	RT5_LP3		INC	D
3087:13990+7+5	12B0  2001    			JR NZ,	RT5_NX2
3088:13997+4	12B2  14      			INC	D
3089:14001+4	12B3  7A      	RT5_NX2		LD	A,D
3090:14005+7	12B4  BE      			CP	(HL)		;TEST
3091:14012+10	12B5  C24A13  			JP NZ,	RT_FAIL5
3092:14022+4	12B8  2C      			INC	L
3093:14026+7+5	12B9  20F4    			JR NZ,	RT5_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
3094:				
3095:14033+4	12BB  7C      			LD	A,H
3096:14037+4	12BC  24      			INC	H		;ADVANCE TO NEXT PAGE
3097:14041+4	12BD  B9      			CP	C		;COMPARE WITH END PAGE
3098:14045+7+5	12BE  20EF    			JR NZ,	RT5_LP3		;LOOP UNTIL = END PAGE
3099:				
3100:14052+4	12C0  1C      			INC	E
3101:14056+7+5	12C1  20D4    			JR NZ,	RT5_LP1
3102:				
3103:14063+17	12C3  CDCA0D  			CALL	PRINTI
3104:     -	12C6  0D0A5241			DB	CR,LF,"RAM SEQUENCE TEST PASSED",EOS
	              4D205345
	              5155454E
	              43452054
	              45535420
	              50415353
	              454400
3105:14080+10	12E1  C9      			RET
3106:				
3107:14090+17	12E2  CDCA0D  	RT_FAIL1	CALL	PRINTI
3108:     -	12E5  0D0A5241			DB	CR,LF,"RAM FAILED PAGE MARCH AT:",EOS
	              4D204641
	              494C4544
	              20504147
	              45204D41
	              52434820
	              41543A00
3109:14107+17	1301  CDEA0D  			CALL	PUT_HL
3110:14124+10	1304  C9      			RET
3111:				
3112:14134+17	1305  CDCA0D  	RT_FAIL2	CALL	PRINTI
3113:     -	1308  0D0A5241			DB	CR,LF,"RAM FAILED BYTE MARCH AT:",EOS
	              4D204641
	              494C4544
	              20425954
	              45204D41
	              52434820
	              41543A00
3114:14151+17	1324  CDEA0D  			CALL	PUT_HL
3115:14168+10	1327  C9      			RET
3116:				
3117:14178+17	1328  CDCA0D  	RT_FAIL3	CALL	PRINTI
3118:     -	132B  0D0A5241			DB	CR,LF,"RAM FAILED BIT MARCH AT:",EOS
	              4D204641
	              494C4544
	              20424954
	              204D4152
	              43482041
	              543A00
3119:14195+17	1346  CDEA0D  			CALL	PUT_HL
3120:14212+10	1349  C9      			RET
3121:				
3122:14222+17	134A  CDCA0D  	RT_FAIL5	CALL	PRINTI
3123:     -	134D  0D0A5241			DB	CR,LF,"RAM FAILED SEQUENCE TEST AT:",EOS
	              4D204641
	              494C4544
	              20534551
	              55454E43
	              45205445
	              53542041
	              543A00
3124:14239+17	136C  CDEA0D  			CALL	PUT_HL
3125:14256+10	136F  C9      			RET
3126:				
3127:14266+17	1370  CD2114  	ABORT_CHECK	CALL	IN_CHAR
3128:14283+5+6	1373  D8      			RET C
3129:14288+7	1374  FE1B    			CP	27
3130:14295+5+6	1376  C0      			RET NZ
3131:14300+10	1377  E1      			POP	HL			;SCRAP RETURN ADDRESS AND GO TO PARENT ROUTINE
3132:14310+17	1378  CDCA0D  			CALL	PRINTI
3133:     -	137B  0D0A4142			DB	CR,LF,"ABORTED",EOS
	              4F525445
	              4400
3134:14327+10	1385  C9      			RET
3135:				
3136:				
3137:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3138:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3139:				;	Chapter_10	BIOS.
3140:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3141:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3142:				;SET_IO		Sets the IO pointed to by PUT_CHAR AND IN_CHAR
3143:				;GET_CHAR_NE	Uses IN_CHAR
3144:				;GET_CHAR	Uses IN_CHAR
3145:				;Put_Char	
3146:				;RX_COUNT	Returns count of bytes recieved
3147:				;IN_CHAR	Returns received char or CF=1 if no char
3148:				;PURGE		
3149:				;TIMED1_GETCHAR	
3150:				;TIMED_GETCHAR	
3151:				;
3152:				;RXC_BOTH	BOTH BIT AND ACE
3153:				;IC_BOTH		
3154:				;PC_BOTH		
3155:				;
3156:				;LED_HOME	LED
3157:				;IC_KEY		
3158:				;PC_LED		
3159:				;
3160:				;RXC_ACE	ACE	
3161:				;IC_ACE		
3162:				;PC_ACE		
3163:				;
3164:				;RXC_BIT	BITBANG	
3165:				;IC_BIT		
3166:				;PC_POS_UPDATE	
3167:				;PC_BIT		
3168:				
3169:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3170:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3171:				;----------------------------------------------------------------------------------------------------; CONSOLE BIOS
3172:				
3173:				
3174:								;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
3175:								;Input C: 00=BIT, 01=BIT, 02=ACE, 03=BOTH, 04=LED
3176:14337+11	1386  E5      	SET_IO		PUSH	HL
3177:14348+11	1387  D5      			PUSH	DE
3178:14359+11	1388  C5      			PUSH	BC		
3179:14370+11	1389  F5      			PUSH	AF
3180:14381+10	138A  2195FF  			LD	HL,HW_LIST	;Only set the new I/O if Hardware is present
3181:14391+4	138D  79      			LD	A,C
3182:14395+4	138E  B7      			OR	A
3183:14399+7+5	138F  280F    			JR  Z,	SIO_ZERO	;Special case, No FP & No SIO
3184:14406+7	1391  A6      			AND	(HL)
3185:14413+4	1392  4F      			LD	C,A
3186:14417+7+5	1393  200D    			JR NZ,	SIO_OK
3187:14424+4	1395  79      			LD	A,C		;Handle special LED case.
3188:14428+4	1396  0F      			RRCA			;Shift LED (04) to FP hardware (01)
3189:14432+4	1397  0F      			RRCA
3190:14436+7	1398  A6      			AND	(HL)
3191:14443+4	1399  79      			LD	A,C
3192:14447+7+5	139A  2006    			JR NZ,	SIO_OK
3193:14454+10	139C  F1      			POP	AF
3194:14464+4	139D  37      			SCF
3195:14468+12	139E  1819    			JR 	SIO_RET
3196:						
3197:14480+4	13A0  0C      	SIO_ZERO	INC	C
3198:14484+4	13A1  3C      			INC	A
3199:14488+13	13A2  3294FF  	SIO_OK		LD	(HW_SETIO),A	;Save set IO configuration
3200:14501+4	13A5  0D      			DEC	C
3201:14505+8	13A6  CB21    			SLA	C		;x2 for word
3202:14513+8	13A8  CB21    			SLA	C		;x2 for 2 words
3203:14521+7	13AA  0600    			LD	B,0
3204:14528+10	13AC  21BD13  			LD	HL,IOD_TABLE
3205:14538+11	13AF  09      			ADD	HL,BC
3206:14549+10	13B0  1190FF  			LD	DE,PUTCHAR_EXE
3207:14559+7	13B3  0E04    			LD	C,4
3208:14566+16+5	13B5  EDB0    			LDIR
3209:14582+10	13B7  F1      			POP	AF
3210:14592+4	13B8  B7      			OR	A		;CY=0
3211:14596+10	13B9  C1      	SIO_RET		POP	BC
3212:14606+10	13BA  D1      			POP	DE
3213:14616+10	13BB  E1      			POP	HL
3214:14626+10	13BC  C9      			RET
3215:				
3216:     -	13BD  3815    	IOD_TABLE	DW	PC_BIT		;FP       (PUTCHAR_EXE)
3217:     -	13BF  1715    			DW	IC_BIT		;FP       (INCHAR_EXE)
3218:     -	13C1  E014    			DW	PC_ACE		;SIO      (PUTCHAR_EXE)
3219:     -	13C3  CF14    			DW	IC_ACE		;SIO 	  (INCHAR_EXE)
3220:     -	13C5  7014    			DW	PC_BOTH		;FP & SIO (PUTCHAR_EXE)
3221:     -	13C7  6A14    			DW	IC_BOTH		;FP & SIO (INCHAR_EXE)
3222:     -	13C9  8A14    			DW	PC_LED		;LED      (PUTCHAR_EXE)
3223:     -	13CB  BA14    			DW	IC_KEY		;LED      (INCHAR_EXE)
3224:				
3225:				
3226:								;HW_SETIO: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
3227:14636+13	13CD  3A94FF  	GET_POS		LD	A,(HW_SETIO)
3228:14649+4	13D0  0F      			RRCA
3229:14653+4	13D1  0F      			RRCA
3230:14657+13	13D2  3AD7FF  			LD	A,(POS_ACE)
3231:14670+5+6	13D5  D8      			RET	C	;Exit with POS_ACE if ACE Selected
3232:14675+13	13D6  3AD6FF  			LD	A,(POS_BIT)
3233:14688+10	13D9  C9      			RET
3234:				
3235:				
3236:				;===============================================
3237:				;GET_CHAR -- Get a char from the console NO ECHO
3238:				;-----------------------------------------------
3239:				;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
3240:14698+17	13DA  CD2114  	GET_CHAR_NE:	CALL	IN_CHAR
3241:14715+7+5	13DD  38FB    			JR C,	GET_CHAR_NE
3242:14722+10	13DF  C9      			RET
3243:				
3244:				;===============================================
3245:				;GET_CHAR -- Get a char from the console
3246:				;-----------------------------------------------
3247:14732+13	13E0  3AF2FF  	GET_CHAR:	LD	A,(ECHO_STATE)
3248:14745+4	13E3  B7      			OR	A
3249:14749+7+5	13E4  28F4    			JR Z,	GET_CHAR_NE
3250:14756+17	13E6  CDDA13  	GET_CHAR_LP	CALL	GET_CHAR_NE
3251:14773+7	13E9  FE20    			CP	' '	;Do not echo control chars
3252:14780+5+6	13EB  F8      			RET M
3253:						;RET		;ECHO THE CHAR
3254:								;FALL INTO PUT_CHAR
3255:				
3256:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3257:				;Send A byte to Bitbanged RS-232, ACE RS-232 or LED
3258:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3259:14785+11	13EC  F5      	PUT_CHAR:	PUSH	AF
3260:14796+11	13ED  C5      			PUSH	BC		;Save registers
3261:14807+11	13EE  D5      			PUSH	DE
3262:14818+11	13EF  E5      			PUSH	HL
3263:14829+4	13F0  4F      			LD	C,A		;Put character to send IN C for shifting
3264:				
3265:14833+16	13F1  2A90FF  			LD	HL,(PUTCHAR_EXE)
3266:14849+17	13F4  CDA00C  			CALL	VCALL_HL	;JP	(HL)
3267:				
3268:14866+10	13F7  E1      			POP HL
3269:14876+10	13F8  D1      			POP DE
3270:14886+10	13F9  C1      			POP BC
3271:14896+10	13FA  F1      			POP AF
3272:14906+10	13FB  C9      			RET
3273:				
3274:				;Update position of PUT_CHAR (Used later to create aligned columns)
3275:14916+7	13FC  FE0D    	PC_POS_UPDATE	CP	13
3276:14923+7+5	13FE  2003    			JR NZ,	PC_NCR
3277:14930+10	1400  3600    			LD	(HL),0
3278:14940+10	1402  C9      			RET
3279:14950+7	1403  FE20    	PC_NCR		CP	' '
3280:14957+5+6	1405  F8      			RET M
3281:14962+11	1406  34      			INC	(HL)
3282:14973+10	1407  C9      			RET
3283:				
3284:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3285:				;RS-232 RX Buffer Count
3286:14983+11	1408  E5      	RX_COUNT	PUSH	HL
3287:14994+17	1409  CD0E14  			CALL	RXC_DO	;Create a routine without stack management
3288:15011+10	140C  E1      			POP	HL
3289:15021+10	140D  C9      			RET
3290:				
3291:15031+13	140E  3A92FF  	RXC_DO		LD	A,(INCHAR_EXE)	;Test which INCHAR routine is active
3292:15044+7	1411  FE17    			CP	LOW IC_BIT
3293:15051+10	1413  CA0915  			JP Z,	RXC_BIT
3294:15061+7	1416  FECF    			CP	LOW IC_ACE
3295:15068+10	1418  CAC414  			JP Z,	RXC_ACE
3296:15078+7	141B  FE6A    			CP	LOW IC_BOTH
3297:15085+7+5	141D  2842    			JR Z,	RXC_BOTH
3298:15092+4	141F  AF      			XOR	A
3299:15096+10	1420  C9      			RET
3300:				
3301:				
3302:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3303:				;Check for A byte
3304:				;	Exit:	C=0, A=Byte from Buffer
3305:				;		C=1, Buffer Empty, no byte
3306:				;		w/call, tcy if no byte = ACE:141, BIT:181, BOTH:269
3307:15106+11	1421  E5      	IN_CHAR:	PUSH	HL		;11
3308:15117+16	1422  2A92FF  			LD	HL,(INCHAR_EXE)	;16
3309:15133+17	1425  CDA00C  			CALL	VCALL_HL	;17 +4 +routine ACE=56, BIT=96, Both=32+ACE+BIT   JP (HL)
3310:15150+10	1428  E1      			POP HL			;10
3311:15160+10	1429  C9      			RET			;10
3312:				
3313:				
3314:				;===============================================
3315:				;PURGE - Clears all in coming bytes until the line is clear for a full 2 seconds
3316:				;-----------------------------------------------
3317:15170+7	142A  3E01    	PURGE		LD	A,1	;1 seconds for time out
3318:15177+17	142C  CD4B14  			CALL	TIMED_GETCHAR
3319:15194+7+5	142F  30F9    			JR NC,	PURGE
3320:15201+10	1431  C9      			RET
3321:				
3322:				;===============================================
3323:				;DOT_GETCHAR
3324:				;in:	B=Count of Dots
3325:				;out: 	C=1, No Char (Time Out)
3326:				;	C=0, A = Char
3327:				;-----------------------------------------------
3328:15211+7	1432  3E01    	DOT_GETCHAR	LD	A,1
3329:15218+17	1434  CD4B14  			CALL	TIMED_GETCHAR	;C=0, A=Byte from Buffer; C=1, no byte
3330:15235+7+5	1437  3807    			JR  C,	DGC_DOT
3331:15242+7	1439  FE09    			CP	9
3332:15249+7+5	143B  280A    			JR   Z,	DGC_RET
3333:15256+7	143D  E65F    			AND 	0x5F		;to upper case
3334:15263+10	143F  C9      			RET			;Return to check charcter
3335:15273+7	1440  3E2E    	DGC_DOT		LD	A,'.'		;Put out some thinking dots
3336:15280+17	1442  CDEC13  			CALL	PUT_CHAR
3337:15297+8+5	1445  10EB    			DJNZ	DOT_GETCHAR
3338:15305+4	1447  37      	DGC_RET		SCF
3339:15309+10	1448  C9      			RET
3340:				
3341:				;===============================================
3342:				;TIMED1_GETCHAR - Gets a character within 1 second
3343:				;-----------------------------------------------
3344:15319+7	1449  3E02    	TIMED1_GETCHAR	LD	A,2
3345:				
3346:				;===============================================
3347:				;TIMED_GETCHAR - Gets a character within a time limit
3348:				;in:	A contains # of 1/2 seconds to wait before returning
3349:				;out: 	C=1, No Char (Time Out)
3350:				;	C=0, A = Char
3351:				;-----------------------------------------------
3352:15326+11	144B  D5      	TIMED_GETCHAR	PUSH	DE
3353:15337+11	144C  C5      			PUSH	BC
3354:15348+4	144D  57      			LD	D,A
3355:15352+7	144E  0E0F    	TGC_LP1		LD	C,15		;B,C=Loop Count down until timeout
3356:									;TEST FOR RX DATA
3357:15359+17	1450  CD2114  	TGC_LP2		CALL	IN_CHAR	;ACE:141, BIT:181, BOTH:269	
3358:15376+10	1453  D25E14  			JP NC,	TGC_RET	;10
3359:15386+8+5	1456  10F8    			DJNZ	TGC_LP2	;13/8	;110 Cycles inner Loop time. 164*256/4 ~= 10 mSec
3360:15394+4	1458  0D      			DEC	C	;5
3361:15398+7+5	1459  20F5    			JR NZ,	TGC_LP2	;10
3362:15405+4	145B  15      			DEC	D
3363:15409+7+5	145C  20F0    			JR NZ,	TGC_LP1
3364:				;		SCF		;CARRY STILL SET TO INDICATE TIME OUT
3365:15416+10	145E  C1      	TGC_RET		POP	BC
3366:15426+10	145F  D1      			POP	DE
3367:15436+10	1460  C9      			RET
3368:				
3369:				
3370:				;-----------------------   B O T H  I/O   -----------------------
3371:				;----------------------------------------------------------------
3372:15446+17	1461  CD0915  	RXC_BOTH	CALL	RXC_BIT
3373:15463+4	1464  6F      			LD	L,A	
3374:15467+17	1465  CDC414  			CALL	RXC_ACE
3375:15484+4	1468  B5      			OR	L
3376:15488+10	1469  C9      			RET
3377:				
3378:15498+17	146A  CD1715  	IC_BOTH		CALL	IC_BIT		;17
3379:15515+5+6	146D  D0      			RET	NC		;11/5 RETURN IF CHAR
3380:15520+12	146E  185F    			JR	IC_ACE		;10
3381:				
3382:15532+17	1470  CDE014  	PC_BOTH		CALL	PC_ACE
3383:15549+17	1473  CD3815  			CALL	PC_BIT
3384:15566+10	1476  C9      			RET		
3385:				
3386:				
3387:				;-----------------------   L E D  I/O   -----------------------
3388:				;--------------------------------------------------------------
3389:				;
3390:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3391:				;Select Put_Char Output
3392:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3393:15576+11	1477  E5      	LED_HOME	PUSH	HL
3394:15587+10	1478  21E0FF  			LD	HL,LED_DISPLAY
3395:15597+16	147B  22C8FF  			LD	(LED_CURSOR),HL
3396:15613+10	147E  E1      			POP	HL
3397:15623+10	147F  C9      			RET
3398:						
3399:15633+11	1480  E5      	LED_CLEAR	PUSH	HL
3400:15644+11	1481  C5      			PUSH	BC
3401:15655+7	1482  3E0C    			LD	A,0x0C
3402:15662+17	1484  CD8A14  			CALL	PC_LED
3403:15679+10	1487  C1      			POP	BC
3404:15689+10	1488  E1      			POP	HL
3405:15699+10	1489  C9      			RET
3406:						
3407:				
3408:				;Put_Char to LED Display, Char in C
3409:15709+16	148A  2AC8FF  	PC_LED		LD	HL,(LED_CURSOR)	;Point to LED Display Buffer
3410:15725+4	148D  79      			LD	A,C
3411:15729+7	148E  FE20    			CP	0x20		;Test for Control/unprintable characters
3412:15736+7+5	1490  380B    			JR  C,	PCL_CTRL
3413:				
3414:15743+7	1492  0629    			LD	B,HIGH LED_FONT	;Set BC to point to LED FONT
3415:15750+8	1494  CBB9    			RES	7,C		;Ensure ASCII 0x20-0x7F only
3416:15758+7	1496  0A      			LD	A,(BC)
3417:15765+8	1497  CBFF    			SET	7,A		;Ensure TXbit is 1
3418:15773+7	1499  77      			LD	(HL),A		;Save Character in LED_DISPLAY BUFFER
3419:15780+4	149A  2C      			INC	L
3420:15784+12	149B  1817    			JR	PCL_RET2
3421:				
3422:15796+7	149D  FE0C    	PCL_CTRL	CP	0x0C		;<NP>
3423:15803+7+5	149F  200D    			JR NZ,	PCLC_1
3424:15810+7	14A1  0608    			LD	B,8		;<NP> Clears LED Line
3425:15817+7	14A3  3E80    			LD	A,0x80
3426:15824+10	14A5  21E0FF  			LD	HL,LED_DISPLAY
3427:15834+7	14A8  77      	PCLC_LP		LD	(HL),A
3428:15841+4	14A9  2C      			INC	L
3429:15845+8+5	14AA  10FC    			DJNZ	PCLC_LP
3430:15853+12	14AC  1803    			JR	PCL_RETC
3431:				
3432:15865+7	14AE  FE0D    	PCLC_1		CP	0x0D		;<CR>	Control characters:
3433:15872+5+6	14B0  C0      			RET	NZ
3434:15877+10	14B1  21E0FF  	PCL_RETC	LD	HL,LED_DISPLAY	;<CR> Returns cursor to start of LED Line
3435:15887+8	14B4  CB9D    	PCL_RET2	RES	3,L
3436:15895+16	14B6  22C8FF  			LD	(LED_CURSOR),HL
3437:15911+10	14B9  C9      			RET
3438:				
3439:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3440:				;Keyboard Get A byte
3441:				;All Keys are equal, but F works as a SHIFT on Press and F on release
3442:				;Output:	Z=1, No Key Pressed
3443:				;		Z=0, A=Key Pressed, bit 4 = Shift, ie, 0x97 = Shift-7
3444:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3445:15921+11	14BA  E5      	IC_KEY		PUSH	HL
3446:15932+10	14BB  21EFFF  			LD	HL,KEY_PRESSED
3447:15942+7	14BE  7E      			LD	A,(HL)
3448:15949+10	14BF  3600    			LD	(HL),0
3449:15959+10	14C1  E1      			POP	HL
3450:15969+4	14C2  B7      			OR	A
3451:15973+10	14C3  C9      			RET
3452:				
3453:				
3454:				;-----------------------   A C E  I/O   -----------------------
3455:				;--------------------------------------------------------------
3456:				;HW_LIST: 00 NO FP, 01 FP only, 02 SIO only, 03 BOTH SIO & FP
3457:				
3458:15983+13	14C4  3A94FF  	RXC_ACE		LD	A,(HW_SETIO)
3459:15996+7	14C7  E602    			AND	2
3460:16003+5+6	14C9  C8      			RET  Z
3461:16008+11	14CA  DBCD    			IN	A,(ACE_STATUS)
3462:16019+7	14CC  E601    			AND	1		
3463:16026+10	14CE  C9      			RET
3464:				
3465:16036+13	14CF  3A94FF  	IC_ACE		LD	A,(HW_SETIO)	;13
3466:16049+7	14D2  E602    			AND	2		;4
3467:16056+4	14D4  37      			SCF			;4  C=1, Assume byte NOT available
3468:16060+5+6	14D5  C8      			RET  Z			;11/5
3469:16065+11	14D6  DBCD    			IN	A,(ACE_STATUS)	;11
3470:16076+7	14D8  E601    			AND	1		;4
3471:16083+4	14DA  37      			SCF			;4  C=1, Assume byte NOT available
3472:16087+5+6	14DB  C8      			RET Z			;11/5 Exit if byte not available C=1
3473:16092+11	14DC  DBC8    			IN	A,(ACE_DATA)
3474:16103+4	14DE  B7      			OR	A		;Exit with C=0
3475:16107+10	14DF  C9      			RET
3476:				
3477:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3478:				;Put Char ACE,  C=Char to send
3479:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3480:16117+13	14E0  3A94FF  	PC_ACE		LD	A,(HW_SETIO)
3481:16130+7	14E3  E602    			AND	2
3482:16137+5+6	14E5  C8      			RET  Z
3483:16142+11	14E6  DBCD    	PCA_LP		IN	A,(ACE_STATUS)
3484:16153+7	14E8  E620    			AND	0x20
3485:16160+7+5	14EA  28FA    			JR Z,	PCA_LP
3486:16167+4	14EC  79      			LD	A,C
3487:16171+11	14ED  D3C8    			OUT	(ACE_DATA),A
3488:16182+10	14EF  21D7FF  			LD  	HL, POS_ACE
3489:16192+17	14F2  CDFC13  			CALL	PC_POS_UPDATE
3490:16209+10	14F5  C9      			RET
3491:				
3492:16219+7	14F6  3E80    	ACE_SET_BAUD	LD	A,0x80		;Set baud rate
3493:16226+11	14F8  D3CB    			OUT	(ACE_LCR),A
3494:16237+13	14FA  3A8FFF  			LD	A,(ACE_BAUD)	;12=9600 baud
3495:16250+11	14FD  D3C8    			OUT	(ACE_BAUD0),A
3496:16261+4	14FF  AF      			XOR	A
3497:16265+11	1500  D3C9    			OUT	(ACE_BAUD1),A
3498:16276+7	1502  3E03    			LD	A,3		;Set 8 data bits, no parity, 1 stop
3499:16283+11	1504  D3CB    			OUT	(ACE_LCR),A
3500:16294+11	1506  DBC8    			IN	A,(ACE_DATA)	;Clear any rxd flag
3501:16305+10	1508  C9      			RET
3502:				
3503:				
3504:				;-----------------------   B I T  I/O   -----------------------
3505:				;--------------------------------------------------------------
3506:16315+13	1509  3A94FF  	RXC_BIT		LD	A,(HW_SETIO)
3507:16328+7	150C  E601    			AND	1
3508:16335+5+6	150E  C8      			RET  Z		
3509:16340+13	150F  3ACAFF  			LD	A,(RXBHEAD)
3510:16353+10	1512  21CCFF  			LD	HL,RXBTAIL
3511:16363+7	1515  96      			SUB	(HL)		
3512:16370+10	1516  C9      			RET
3513:				
3514:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3515:				;RS-232 Get A byte
3516:				;	Exit:	C=0, A=Byte from Buffer
3517:				;		C=1, Buffer Empty, no byte
3518:				;		w/call, tcy=87 if no byte
3519:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
3520:16380+13	1517  3A94FF  	IC_BIT		LD	A,(HW_SETIO)	;13
3521:16393+7	151A  E601    			AND	1		;4
3522:16400+4	151C  37      			SCF			;4  C=1, Assume byte NOT available
3523:16404+5+6	151D  C8      			RET  Z			;11/5
3524:16409+11	151E  C5      			PUSH	BC		;11
3525:16420+13	151F  3ACAFF  			LD	A,(RXBHEAD)	;13 Test if TAIL=HEAD (=No bytes in buffer)
3526:16433+4	1522  47      			LD	B,A		;4
3527:16437+13	1523  3ACCFF  			LD	A,(RXBTAIL)	;13
3528:16450+4	1526  A8      			XOR	B		;4 Check if byte(s) in receive buffer
3529:16454+10	1527  C1      			POP	BC		;10
3530:16464+4	1528  37      			SCF			;4  C=1, Assume byte NOT available
3531:16468+5+6	1529  C8      			RET Z			;11 Exit if byte not available (ie TAIL=HEAD), C=1
3532:16473+11	152A  E5      			PUSH	HL
3533:16484+4	152B  F3      			DI
3534:16488+16	152C  2ACCFF  			LD	HL,(RXBTAIL)
3535:16504+4	152F  2C      			INC	L
3536:16508+16	1530  22CCFF  			LD	(RXBTAIL),HL	;Tail = Tail + 1
3537:16524+4	1533  FB      			EI
3538:16528+7	1534  7E      			LD	A,(HL)		;A = Byte from buffer (@ TAIL)
3539:16535+10	1535  E1      			POP	HL
3540:16545+4	1536  B7      			OR	A		;Exit with C=0
3541:16549+10	1537  C9      			RET
3542:				
3543:				
3544:				;Put_Char to RS232 BIT banger
3545:				;The bit banged byte to be sent is done through the msb of the LED Display Output byte.
3546:				;To simplify AND expedite the sending of those Display bytes (with the RS-232 BIT), the transmitted
3547:				;byte will be scattered in a secondary buffer that is 10 bytes (1 start, 8 data, 1 stop)
3548:				;This secondary buffer will have the transmitted bits mixed IN with the LED Display Bytes
3549:				;The Interrupt is disabled only at crucial moments, but otherwise left on to accept any characters
3550:				;received from the RS-232 line
3551:16559+10	1538  21D6FF  	PC_BIT		LD  	HL, POS_BIT
3552:16569+17	153B  CDFC13  			CALL	PC_POS_UPDATE
3553:16586+10	153E  21F6FF  			LD  	HL,LED_DISPLAY_SB
3554:								;Copy 10 bytes from the LED_DISPLAY buffer (MOD 8) to the secondary buffer
3555:16596+20	1541  ED5BD0FF	PC_REDO		LD  	DE,(SCAN_PTR)   ;SCAN_PTR holds the next LED BYTE @ OUTPUT.
3556:16616+4	1545  43      			LD  	B,E		;Save SCAN_PTR for test if an Interrupt occurs
3557:				
3558:16620+13	1546  3AF5FF  			LD	A,(SCAN_LED)
3559:16633+7	1549  77      			LD  	(HL),A
3560:16640+15	154A  CBBE    			RES 	7,(HL)	;Configure Start BIT (msb) to be 0
3561:				
3562:16655+4	154C  2C      			INC 	L
3563:								;Shift next 9 bits IN this loop,
3564:16659+13	154D  3A95FF  	PC_LP0		LD	A,(HW_LIST)	;Skip other buffer bytes if FP not present
3565:16672+4	1550  B7      			OR	A
3566:16676+13	1551  3AF5FF  			LD	A,(SCAN_LED)	;Save for next interrupt
3567:16689+7+5	1554  2804    			JR  Z,	PC_NOFP
3568:				
3569:16696+4	1556  1C      			INC 	E
3570:16700+8	1557  CB9B    			RES 	3,E		;Bound DE to the 8 bytes of LED_DISPLAY
3571:16708+7	1559  1A      			LD  	A,(DE)
3572:						
3573:16715+4	155A  17      	PC_NOFP		RLA		;Bump OUT msb
3574:16719+8	155B  CB09    			RRC 	C		;Fetch Data BIT (non destructive shifting incase of REDO)
3575:16727+8	155D  CB1F    			RR  	A		;Shift IN Data BIT
3576:16735+7	155F  77      			LD  	(HL),A
3577:16742+4	1560  2C      			INC 	L
3578:16746+7+5	1561  20EA    			JR  	NZ,PC_LP0
3579:				
3580:16753+4	1563  2D      			DEC 	L
3581:16757+15	1564  CBFE    			SET 	7,(HL)	;Stop Bit
3582:				
3583:16772+7	1566  2EF6    			LD  	L,LOW LED_DISPLAY_SB  ;Restart Pointer to Secondary Buffer
3584:				
3585:								;Test if SCAN_PTR Changed (due to ISR)
3586:16779+7	1568  1E05    			LD  E,5		;Preload RX delay counter (incase of RX byte during TX)
3587:16786+7	156A  1680    			LD  D,0x80	;Preload RxD Register with A marker BIT (to count 8 data bits)
3588:				
3589:16793+4	156C  F3      			DI		;STOP INTERRUPTS HERE to see if SCAN_PTR has changed (due to Timer Interrupt)
3590:16797+13	156D  3AD0FF  			LD  A,(SCAN_PTR) ;Adjust working scan pointer (counted to 10 mod 8, so subtract 2 to restore)
3591:16810+4	1570  A8      			XOR B
3592:16814+7+5	1571  2805    			JR  Z,PC_0
3593:								;If SCAN_PTR changed, Redo the Secondary Buffer
3594:16821+4	1573  FB      			EI		;Allow Interrupts again while preparing Secondary Buffer
3595:16825+8	1574  CB01    			RLC C		;ADJUST Transmitted bits due to 9 bits shifted (back up 1 BIT)
3596:16833+12	1576  18C9    			JR  PC_REDO
3597:				;- - - - - - - - - - - - - - - - - - - - - Transmit the BYTE here....(BYTE encoded in temp 10 byte LED buffer)
3598:				;1 Bit time at 9600 = 416.6666 cycles
3599:				
3600:16845+7	1578  0E40    	PC_0		LD  C,Port40
3601:				
3602:16852+7	157A  7E      	PC_1		LD  A,(HL)	;7	Send BIT
3603:16859+11	157B  D340    			OUT (Port40),A	;11
3604:16870+7	157D  0608    			LD  B,8		;7
3605:				
3606:16877+12	157F  ED78    	PC_2		IN  A,(C)	;12	;While waiting, Poll for RX DATA Start bit
3607:16889+10	1581  F29F15  			JP  P,PC_5	;10 tc (Note 1.JP)
3608:16899+13	1584  3A0000  			LD  A,(0)	;13 tc NOP
3609:16912+8+5	1587  10F6    	PC_3		DJNZ PC_2	;13/8  ;48 IN loop (-5 on last itteration).  48 * 8 + 39 - 5 = 418 tc per BIT
3610:				
3611:16920+4	1589  2C      			INC L		;4
3612:16924+10	158A  C27A15  			JP  NZ,PC_1	;10	;39 TC Overhead to send BIT
3613:16934+10	158D  C32216  			JP  PC_RET
3614:				
3615:16944+8	1590  CB38    	PC_4		SRL B		;4	If false start bit detected, Divide B by 2 and return to simple tx
3616:16952+10	1592  C28715  			JP  NZ,PC_3	;10
3617:16962+4	1595  2C      			INC L		;4
3618:16966+10	1596  CA2216  			JP  Z,PC_RET	;10
3619:16976+7	1599  7E      			LD  A,(HL)	;7	Send BIT
3620:16983+11	159A  D340    			OUT (Port40),A	;11
3621:16994+10	159C  C37F15  			JP  PC_2	;10
3622:				
3623:				
3624:								;Here an RX byte was detected while transmitting.
3625:								;Delay IN detection could be as much as 60tc, we will assume 1/2 (=30tc)
3626:								;We need to test Start Bit @ 208tc,
3627:								;We are juggling TX & RX. TX will occur earlier than BIT time due to shorter loop delay
3628:17004+4	159F  2C      	PC_5		INC  L		;4
3629:17008+4	15A0  05      			DEC  B		;4
3630:17012+10	15A1  CAAB15  			JP Z,PC_7	;10
3631:17022+8	15A4  CB20    			SLA  B		;8      Multiply B by 2 for 24 cycle loop
3632:17030+4	15A6  1D      	PC_6		DEC  E		;4	RxBit Timing
3633:17034+7+5	15A7  280F    			JR   Z,PC_9	;7/12   ;Either before OR after sending A BIT, we will branch OUT of loop here to check for RX Start Bit
3634:17041+8+5	15A9  10FB    			DJNZ PC_6	;13/8 tc TxBit Timing
3635:								;		24 tc Loop
3636:				;TxBit
3637:17049+7	15AB  060D    	PC_7	       	LD  B,13	;7
3638:17056+4	15AD  AF      			XOR A		;4
3639:17060+4	15AE  B5      			OR  L		;4
3640:17064+7+5	15AF  2804    			JR  Z,PC_8	;7/12	;Stop sending if L=0
3641:17071+7	15B1  7E      			LD  A,(HL)	;7	;39 to send next BIT
3642:17078+11	15B2  D340    			OUT (Port40),A	;11
3643:17089+4	15B4  2C      			INC L		;4
3644:17093+10	15B5  C3A615  	PC_8		JP  PC_6	;10 tc (Note 1.JP)
3645:				
3646:								;Test if Start Bit is good (at ~1/2 BIT time)
3647:17103+7	15B8  1E05    	PC_9		LD  E,5		;7   E=5 incase we have a bad start bit and have to return to simple TX
3648:17110+12	15BA  ED78    			IN  A,(C)	;12  Re-TEST Start Bit at 1/2 bit time
3649:17122+10	15BC  FA9015  			JP  M,PC_4	;10  If Start BIT not verified, then return to simple TXD (return at point where we are Decrementing B to minimize diff)
3650:17132+7	15BF  1E0F    			LD  E,15	;7   Adjust initial sampling delay (as per timing observed)
3651:				
3652:				
3653:								;At this point, we have good start BIT, 1 OR more TX bits left to go...  here's where timing is accurate again
3654:								;We will go through each TXbit AND RXBit once during the full BIT time.  So the time of these routines are added
3655:17139+4	15C1  1D      	PC_10		DEC E		;4
3656:17143+7+5	15C2  2814    			JR  Z,PC_14	;7/12
3657:17150+8+5	15C4  10FB    	PC_11		DJNZ PC_10	;13/8 tc    24Loop= 6uSec
3658:				
3659:								; TX= S 0 1 2 3 4 5 6 7 S
3660:								; RX=  S 0 1 2 3 4 5 6 7 S  <-It's possible to receive all 8 data bits before sending Stop Bit
3661:				;TxBit ;54tc to Send BIT
3662:17158+4	15C6  AF      			XOR A		;4
3663:17162+4	15C7  B5      			OR  L		;4
3664:17166+7+5	15C8  2809    			JR  Z,PC_13	;7/12	;Stop sending if L=0
3665:17173+7	15CA  7E      			LD  A,(HL)	;7
3666:17180+11	15CB  D340    			OUT (Port40),A	;11
3667:17191+4	15CD  2C      			INC L		;4
3668:17195+7	15CE  060D    	PC_12        	LD  B,13	;7     (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
3669:17202+10	15D0  C3C115  			JP  PC_10	;10 tc (Note 1.JP)
3670:				
3671:17212+7	15D3  060D    	PC_13		LD  B,13	;7     (7tc NOP)
3672:17219+10	15D5  C3CE15  			JP  PC_12	;10 tc (Note 1.JP)
3673:				
3674:				;RxBit ;51tc to Receive BIT
3675:17229+11	15D8  DB40    	PC_14		IN   A,(Port40)	;11	Fetch RXbit
3676:17240+4	15DA  00      			NOP		;4
3677:17244+4	15DB  07      			RLCA		;4	put IN CARRY
3678:17248+8	15DC  CB1A    			RR    D		;8	shift into RxD
3679:17256+7	15DE  1E0D    			LD    E,13	;7      (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
3680:17263+7+5	15E0  3803    			JR C, PC_15	;7/12	;Test for marker BIT shifting OUT of D
3681:17270+10	15E2  C3C415  			JP    PC_11	;10	RXBIT = 40tc
3682:				
3683:17280+4	15E5  00      	PC_15		NOP		;4
3684:17284+4	15E6  1D      	PC_16		DEC  E		;4
3685:17288+7+5	15E7  2814    			JR Z,PC_19	;7/12
3686:17295+8+5	15E9  10FB    			DJNZ PC_16	;13/8 tc    24Loop= 6uSec
3687:				
3688:								; TX= S 0 1 2 3 4 5 6 7 S
3689:								; RX=  S 0 1 2 3 4 5 6 7 S  <-It's possible to receive all 8 data bits before sending Stop Bit
3690:				;TxBit ;54tc to Send BIT
3691:17303+4	15EB  AF      			XOR  A		;4
3692:17307+4	15EC  B5      			OR   L		;4
3693:17311+7+5	15ED  2809    			JR Z,PC_18	;7/12	;Stop sending if L=0
3694:17318+7	15EF  7E      			LD   A,(HL)	;7
3695:17325+11	15F0  D340    			OUT (Port40),A	;11
3696:17336+4	15F2  2C      			INC  L		;4
3697:17340+7	15F3  060D    	PC_17        	LD   B,13	;7     (417 - 54 - 51)/24 = 13 counts required to pace 1 BIT
3698:17347+10	15F5  C3E615  			JP   PC_16	;10 tc (Note 1.JP)
3699:				
3700:17357+7	15F8  060D    	PC_18		LD   B,13	;7     (7tc NOP)
3701:17364+10	15FA  C3F315  			JP   PC_17	;10 tc (Note 1.JP)
3702:				
3703:				
3704:				
3705:				;RxBit ;51tc to Receive BIT
3706:17374+11	15FD  DB40    	PC_19		IN  A,(Port40)	;11	Fetch Stop BIT
3707:17385+4	15FF  07      			RLCA		;4	put IN CARRY
3708:17389+10	1600  DA0916  			JP C,PC_20
3709:17399+10	1603  218DFF  			LD   HL,RX_ERR_STOP
3710:17409+17	1606  CD260E  			CALL TINC
3711:				
3712:17426+4	1609  7A      	PC_20		LD  A,D		;Fetch received byte to RX Buffer
3713:17430+16	160A  2ACAFF  			LD  HL,(RXBHEAD)
3714:17446+4	160D  2C      			INC L
3715:17450+16	160E  22CAFF  			LD  (RXBHEAD),HL ;Head = Head + 1
3716:17466+7	1611  77      			LD  (HL),A	;Stuff into RX BUFFER
3717:17473+13	1612  3ACCFF  			LD  A,(RXBTAIL)
3718:17486+4	1615  BD      			CP  L
3719:17490+7+5	1616  200A    			JR  NZ,PC_RET	;Jump if NOT Zero = No Over run error (Head <> Tail)
3720:17497+4	1618  3C      			INC A		;Else
3721:17501+13	1619  32CCFF  			LD  (RXBTAIL),A	;Tail = Tail + 1
3722:17514+10	161C  218EFF  			LD   HL,RX_ERR_OVR ;Count Over Run Error
3723:17524+17	161F  CD260E  			CALL TINC
3724:				
3725:17541+13	1622  3A95FF  	PC_RET		LD	A,(HW_LIST)	;Skip Resync if FP not present
3726:17554+4	1625  B7      			OR	A
3727:17558+7+5	1626  2811    			JR  Z,	PC_RET1
3728:				
3729:17565+11	1628  DB40    			IN	A,(Port40)	;Resync the SCAN_PTR
3730:17576+4	162A  3C      			INC	A
3731:17580+7	162B  E607    			AND	7
3732:17587+7	162D  F6E0    			OR  LOW LED_DISPLAY
3733:17594+4	162F  6F      			LD	L,A
3734:17598+13	1630  32D0FF  			LD	(SCAN_PTR),A	;Save Scan Ptr @ Next Scan Output
3735:17611+7	1633  26FF    			LD	H,HIGH SCAN_PTR
3736:17618+7	1635  7E      			LD	A,(HL)
3737:17625+13	1636  32F5FF  			LD	(SCAN_LED),A	;Save for next interrupt		
3738:17638+4	1639  FB      	PC_RET1		EI
3739:17642+10	163A  C9      			RET
3740:				
3741:				
3742:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3743:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3744:				;	Chapter_11	ISR.  RS-232 Receive, LED & Keyboard scanning, Timer tic counting
3745:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
3746:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
3747:				
3748:				;                       *********   *******    ********
3749:				;                       *********  *********   *********
3750:				;                          ***     **     **   **     **
3751:				;                          ***     **          **     **
3752:				;---------------------     ***     *******     ********   ---------------------
3753:				;---------------------     ***       *******   ********   ---------------------
3754:				;                          ***            **   **  **
3755:				;                          ***     **     **   **   **
3756:				;                       *********  *********   **    **
3757:				;                       *********   *******    **     **
3758:				;
3759:				;
3760:				;
3761:				;The ISR will service either the Timer interrupt or Serial Data (bit banger) interrupt.
3762:				;
3763:				;The ISR will re-enable interrupts during Timer functions for re-entry to catch Serial Data.
3764:				;
3765:				;
3766:				;The INT calls RST 38.  RST38 is the same in ROM or RAM.
3767:				;
3768:				;**RST38--------Switch to the Alternate Register set, jump to ISR_VEC (typcially ISR_DISPATCH)
3769:				;**ISR_DISPATCH-Direct Select ROM, Check input port, jump to ISR_RXD (RS-232) or ISR_TIMER
3770:				;**ISR_RXD------Bit Bang a byte, store in RXBUFFER, jump to ISR_RET
3771:				;**ISR_TIMER----Output LED (Clears TIMER_INT), enter Extended Timer or jump to ISR_RET (If
3772:				;		already executing the extended Timer)
3773:				;ISR_EXTIMER----RAM/ROM state, set to ROM. Use ISR Stack, Undo Alternate Registers, EI, PUSH HL, AF
3774:				;		Resync LED to scan, Do Halt Test (jump BREAK_RET), Run TicCounter (1mSec),
3775:				;		Do extra extended timer to complete keypad scans every 32mSec or exit EXTIMER
3776:				;ISR_EXXTIMER---Scan Keypad for events, do Keyevents as they occur to control LED output,
3777:				;		update LED output, <Ctrl>-C Test (jump BREAK_RET), Call User Interrupt Vector
3778:				;		Keypad Event F-E causes jump to BREAK_RET
3779:				;		Single Step causes jump to BREAK_RET
3780:				;ISR_EXTIMER_RET POP AF, HL. Restore Stack, Restore RAM/ROM state, Switch to Alternate Registers for RET
3781:				;**ISR_RET------Select RAM/ROM state as tracked in Mainline code, Undo Alternate Registers, EI. RETI
3782:				;BREAK_RET------Leaves the ISR to return to 0000 and restart the monitor.
3783:				
3784:				;** = ISR RUNNING ON ALTERNATE REGSITERS (**IROAR**)
3785:				
3786:				;
3787:				;
3788:				;	Normal timer interrupt takes 463 cycles  (??? outdated counts)
3789:				;	42  ISR Vectoring & Redirection
3790:				;	50  Timer Int Detection
3791:				;	28  LED Refresh (Re-enable Interrupts)
3792:				;	78  Resync & Prepare next LED Refresh value
3793:				;	111 Halt Test
3794:				;	38  TIC Counter
3795:				;	21  Keyboard/Display maintenance required check
3796:				;	41  User Interrupt Check
3797:				;	34  ISR Exit
3798:				;
3799:				;	Occuring 8 out of 32 ISR's:
3800:				;	82  Scanning non pressed keys
3801:				;
3802:				;	Occuring 1 out of 32 ISR's
3803:				;	165 Processing non pressed keys
3804:				;	97  Ctrl-C Checking
3805:				;	67  Beeper Timer
3806:				;	31  Cmd Expiration Timer
3807:				;	262 Display Memory contents
3808:				;	649 Display Register contents
3809:				;
3810:				;	24/32 ISR's = 463 cycles	= 11,112
3811:				;	7/32  ISR's = 545 cycles    	=  3,815
3812:				;	1/32  ISR's = 1,554 cycles	=  1,554 (Displaying Register)
3813:				;	Total over 32 ISR's		= 16,481
3814:				;	Average per ISR = 515 cycles
3815:				;			= 128.75uS used every 1024uS interrupt cycle
3816:				;			= 13% ISR Overhead (When Displaying Register)
3817:				;
3818:				;
3819:				;
3820:				;
3821:				;
3822:				;Note: A start bit can still hijack the ISR at Dispatch.
3823:				;
3824:				;A start bit happening anywhere in mainline code will take ~???tc to reach ISR_RXD
3825:				;A start bit happening upon entry to ISR_DISPATCH (when doing timer int) will take ??tc to reach ISR_RXD
3826:				;A start bit happening just past the ISR_DISPATCH window of opportunity will take 
3827:				;
3828:				;ISR_DISPATCH Sort out what is causing the interrupt
3829:				;
3830:				
3831:				
3832:				;- - - - - - - - - - - - - - RS-232 Receive BYTE
3833:				;
3834:				;1 Bit time at 9600 = 416.6666 cycles	;We get here ~25 to 200 tc (range = 175tc = 1/2 bit time)
3835:				;**IROAR**
3836:17652+7	163B  2E02    	ISR_RXD		LD   L,2	;7
3837:17659+11	163D  DB40    	IRXD_VS		IN   A,(Port40)	;11	;Re-sample Start BIT @+7, +35tc
3838:17670+4	163F  07      			RLCA		;4	;(Actual sampling occurs 9 OR 10 tc later)
3839:17674+7+5	1640  383E    			JR   C,IRXD_INC	;7/12
3840:17681+4	1642  2D      			DEC  L		;4
3841:17685+7+5	1643  20F8    			JR  NZ,IRXD_VS	;7/12
3842:								;35tc per loop
3843:								;@+68 when we come OUT of loop
3844:								;
3845:								;=~93tc to ~268tc  Middle = 180
3846:								;
3847:								;Must have a total delay of 1.5 bits 625 to reach middle of 1st data BIT
3848:								;Total delay: 1.5 * 416 = 625tc
3849:								;Next bit is at 417tc to 834tc
3850:								;625-180 = Need another 445 Delay
3851:						
3852:				
3853:								;My cycle counting is off by at least 30uSec = 120tc
3854:								;Changed 26 to 20.  20*16-5=315 (411-315=96)
3855:				
3856:						
3857:17692+7	1645  3E16    			LD   A,22	;7	;Delay loop after START Bit
3858:17699+4	1647  3D      			DEC  A		;4
3859:17703+7+5	1648  20FD    			JR   NZ,$-1	;12/7	Delay loop = 26 * 16 - 5 = 411
3860:				
3861:				
3862:				;- - - - - - - - - - - - - - RS-232 Receive BYTE
3863:17710+7	164A  2E08    			LD   L,8	;7
3864:								;@624	;Loop through sampling 8 data bits
3865:     -	164C          	IRXD_NB		
3866:17717+11	164C  DB40    			IN   A,(Port40)	;11	;Sample BIT
3867:17728+4	164E  07      			RLCA		;4	;Get BIT
3868:17732+8	164F  CB1C    			RR   H		;8	;Shift IN
3869:17740+4	1651  2D      			DEC  L		;4	;Count down 8 bits
3870:					;	JR   Z,IRXD_STP	;7/12	;Use this jump to test for STOP bit
3871:				
3872:17744+7+5	1652  2814    			JR  Z,IRXD_SAVE	;7/12	Optional to finish receiving byte here AND ignore framing errors
3873:								;	(Replace the previous condital jump with IRXD_SAVE destination).
3874:				
3875:17751+7	1654  3E17    	IRXD_NI		LD  A,23	;7	;Delay loop between data bits
3876:17758+4	1656  3D      			DEC A		;4
3877:17762+7+5	1657  20FD    			JR  NZ,$-1	;12/7	;Delay loop = 16 * 23 + 53 - 5 = 416
3878:17769+12	1659  18F1    			JR  IRXD_NB	;12	;Total Overhead = 53
3879:								;Time to get all data bits = 416 * 7 + 39 = 2951 (last BIT does not get full delay)
3880:								
3881:								;@3576  (we wish to sample stop BIT @3958) (need to delay another 382)				
3882:17781+7	165B  3E17    	IRXD_STP	LD  A,23	;7	;Delay loop before STOP BIT
3883:17788+4	165D  3D      			DEC A		;4
3884:17792+7+5	165E  20FD    			JR  NZ,$-1	;12/7	;Delay loop =
3885:17799+11	1660  DB40    			IN  A,(Port40)	;11	;NOP for 11tc
3886:17810+11	1662  DB40    			IN  A,(Port40)	;11	;Sample Stop BIT @3957
3887:17821+4	1664  B7      			OR  A		;4	;(Actual sampling occurs 9 OR 10 tc later)
3888:17825+10	1665  F28516  			JP  P,IRXD_BAD
3889:				
3890:17835+4	1668  7C      	IRXD_SAVE	LD  A,H		;4	;Fetch received byte
3891:17839+16	1669  2ACAFF  			LD  HL,(RXBHEAD) ;16	;Advance Head Ptr of RX Buffer, Head = Head + 1
3892:17855+4	166C  2C      			INC L		;4
3893:17859+16	166D  22CAFF  			LD  (RXBHEAD),HL ;16
3894:17875+7	1670  77      			LD  (HL),A	;7	;Save Received byte into RX Buffer
3895:						
3896:						
3897:				
3898:						
3899:17882+13	1671  3ACCFF  			LD  A,(RXBTAIL)	;13	;Test if buffer has over ran
3900:17895+4	1674  BD      			CP  L		;4	;If Tail = Head Then Tail = Tail + 1 & Flag overrun
3901:17899+7+5	1675  2014    			JR NZ,IRXD_RESET ;Return if NO overrun error
3902:								
3903:17906+4	1677  3C      			INC A		;Lose A BYTE in buffer and count the overrun
3904:17910+13	1678  32CCFF  			LD  (RXBTAIL),A
3905:				
3906:17923+10	167B  218EFF  			LD   HL,RX_ERR_OVR
3907:17933+12	167E  1808    			JR 	IRXD_TINC
3908:17945+10	1680  218CFF  	IRXD_INC	LD   HL,RX_ERR_LDRT ;10
3909:17955+12	1683  1803    			JR 	IRXD_TINC
3910:17967+10	1685  218DFF  	IRXD_BAD	LD  HL,RX_ERR_STOP
3911:17977+17	1688  CD260E  	IRXD_TINC	CALL TINC
3912:				
3913:17994+13	168B  3A95FF  	IRXD_RESET	LD	A,(HW_LIST)	;Skip Resync if FP not present
3914:18007+4	168E  B7      			OR	A
3915:18011+7+5	168F  2813    			JR  Z,	IRXD_WS
3916:				
3917:18018+11	1691  DB40    			IN	A,(Port40)	;Resync the SCAN_PTR
3918:18029+4	1693  3C      			INC	A
3919:18033+7	1694  E607    			AND	7
3920:18040+7	1696  F6E0    			OR  LOW LED_DISPLAY	;LED_DISPLAY is at xxEO (it's ok to overlap in this order)
3921:18047+13	1698  32D0FF  			LD	(SCAN_PTR),A	;Save Scan Ptr @ Next Scan Output
3922:				
3923:18060+16	169B  2AD0FF  			LD	HL,(SCAN_PTR)	;Fetch next byte to output
3924:18076+7	169E  7E      			LD	A,(HL)
3925:18083+11	169F  D340    			OUT	(Port40),A	;Output ASAP to satisfy Interrupt Flag
3926:18094+13	16A1  32F5FF  			LD	(SCAN_LED),A	;Save for next interrupt
3927:				
3928:18107+11	16A4  DB40    	IRXD_WS		IN   	A,(Port40)	;11	;Sample BIT
3929:18118+4	16A6  07      			RLCA		;4	;Get BIT 
3930:18122+7+5	16A7  30FB    			JR  NC,	IRXD_WS		;Wait for STOP bit
3931:				
3932:18129+10	16A9  C33BFB  			JP	ISR_RET
3933:				
3934:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Timer Tics
3935:				;Refresh next LED Display
3936:				;**IROAR**
3937:18139+13	16AC  3AF5FF  	ISR_TIMER	LD	A,(SCAN_LED)	;13 ZMC-Display Refresh / Reset Int
3938:18152+11	16AF  D340    			OUT	(Port40),A	;11 Output ASAP to satisfy Interrupt Flag
3939:				
3940:18163+10	16B1  21D8FF  			LD	HL,ISR_FLAGS	;10
3941:18173+12	16B4  CB46    			BIT	0,(HL)		;12
3942:18185+10	16B6  C23BFB  			JP  NZ,	ISR_RET		;10
3943:				
3944:     -	16B9          	ISR_EXTIMER	;Extended Timer Int.
3945:									;If ISR NEST level = 0 then save the stack and run on ISR Stack
3946:				
3947:18195+15	16B9  CBC6    			SET	0,(HL)		;ISR_FLAGS (Prevent addition entries to this routine)
3948:				
3949:18210+20	16BB  ED7328FB			LD	(SP_ISR_SAVE),SP ;20 ;ALTERNATE TIMER STACK
3950:18230+10	16BF  3128FB  			LD	SP,STACK_ISR1	;10  ;ALTERNATE TIMER STACK
3951:				
3952:18240+4	16C2  2C      			INC	L		;RRSTATE
3953:18244+15	16C3  CB06    			RLC	(HL)		;RRSTATE.0=0 Additional interrupts shall return to ROM
3954:									;RRSTATE.1=RRSTATE.0 Save RAM/ROM selection for exit from this TIMER ISR
3955:					
3956:18259+4	16C5  08      			EX	AF,AF'		;Revert to regular registers in the event of another interrupt.
3957:18263+4	16C6  FB      			EI			;4  Allow RXD interrupts
3958:18267+4	16C7  D9      			EXX
3959:				
3960:				;Time critical functions are over.  		
3961:				;We've entered an interrupt and want to stay in for a while to update the front panel.
3962:				;But we want serial interrupts to be allowed to continue
3963:				;Alternate registers have been relinquished for other Interrupts.
3964:				;Must Push our own.
3965:				
3966:				;On First entry here, we have a new stack, old stack is saved at SP_ISR_SAVE and return address is on the old stack
3967:				
3968:18271+11	16C8  E5      			PUSH	HL
3969:18282+11	16C9  F5      			PUSH	AF
3970:				
3971:									;********************************* Tic counter - Advance
3972:18293+16	16CA  2AF0FF  			LD	HL,(TicCounter)	;16 Advance Timer Counter
3973:18309+6	16CD  23      			INC	HL		;6
3974:18315+16	16CE  22F0FF  			LD	(TicCounter),HL	;16
3975:									;st=38
3976:				
3977:18331+13	16D1  3A95FF  			LD	A,(HW_LIST)	;Exit ISR if FP not present
3978:18344+4	16D4  B7      			OR	A
3979:18348+7+5	16D5  2829    			JR  Z,	ISR_EXTIMER_RET
3980:				
3981:									;********************************* SCAN RESYNC
3982:18355+11	16D7  DB40    			IN	A,(Port40)	;11 Resync the SCAN_PTR
3983:18366+4	16D9  3C      			INC	A		;4  Advance to next column to match column after next OUT
3984:18370+7	16DA  E607    			AND	7		;7
3985:18377+7	16DC  F6E0    			OR  LOW LED_DISPLAY	;7  LED_DISPLAY is at xxEO (it's ok to overlap in this order)
3986:18384+13	16DE  32D0FF  			LD	(SCAN_PTR),A	;13 Save Scan Ptr @ Next Scan Output
3987:18397+16	16E1  2AD0FF  			LD	HL,(SCAN_PTR)	;16 Fetch next byte to output
3988:18413+7	16E4  7E      			LD	A,(HL)		;7
3989:18420+13	16E5  32F5FF  			LD	(SCAN_LED),A	;13 Save for next interrupt
3990:									;st=78
3991:				
3992:				
3993:									;********************************* HALT TEST
3994:18433+16	16E8  2AD2FF  			LD	HL,(HALT_TEST)	;Ignore HALT Test in SD Card Mode
3995:18449+4	16EB  E9      			JP	(HL)
3996:     -	16EC          	DO_HALT_TEST
3997:18453+16	16EC  2A28FB  			LD	HL,(SP_ISR_SAVE);10 Get PC
3998:18469+17	16EF  CD4A0E  			CALL	LD_HL_HL	;17+43
3999:18486+6	16F2  2B      			DEC	HL		;6
4000:18492+7	16F3  7E      			LD	A,(HL)		;7 Fetch Previous Instruction
4001:18499+7	16F4  FE76    			CP	0x76		;7 Is HALT?
4002:18506+10	16F6  CA0218  			JP  Z,	ICMD_BREAK_RET	;10
4003:									;st=111
4004:     -	16F9          	SKIP_HALT_TEST
4005:				
4006:				
4007:				;Keyboard / Display Update / Keyboard Commands or Entry
4008:									;********************************* KEYBOARD SCANNING
4009:18516+10	16F9  21DAFF  			LD	HL,XTIMER_TIC
4010:18526+11	16FC  35      			DEC	(HL)
4011:18537+10	16FD  FA1417  			JP  M,	ISR_EXXTIMER
4012:						
4013:				;*************************************************** EXIT THE EXTENDED (INTERRUPTABLE) ISR
4014:				
4015:18547+10	1700  F1      	ISR_EXTIMER_RET	POP	AF
4016:18557+10	1701  E1      			POP	HL
4017:				
4018:18567+4	1702  F3      			DI
4019:18571+20	1703  ED7B28FB			LD	SP,(SP_ISR_SAVE) ;RESUME SAVED STACK
4020:				
4021:18591+4	1707  08      			EX	AF,AF'		;Swap Registers for Jump Back
4022:18595+4	1708  D9      			EXX
4023:				
4024:18599+10	1709  21D8FF  			LD	HL,ISR_FLAGS
4025:18609+15	170C  CB86    			RES	0,(HL)		;Reset NEST level to 0
4026:				
4027:18624+4	170E  2C      			INC	L		;RRSTATE
4028:18628+15	170F  CB0E    			RRC	(HL)		;RRSTATE.0=RRSTATE.1 Restore RAM/ROM selection
4029:18643+10	1711  C33BFB  			JP	ISR_RET
4030:				
4031:				;Somewhere in High RAM...
4032:				;
4033:				;ISR_RET	LD	A,(RRSTATE)	;Restore RAM/ROM selection
4034:				;		OUT	(RAMROM),A
4035:				;		EX	AF,AF'		;Restore swapped Registers
4036:				;		EXX
4037:				;		EI
4038:				;		RETI			;Return to Mainline code
4039:				
4040:				
4041:     -	1714          	ISR_EXXTIMER				;Extra Extended Timer (8 times every 32mSec)
4042:				
4043:18653+11	1714  DB40    			IN	A,(Port40)	;11 Read KEY down & ScanPtr
4044:18664+10	1716  21E9FF  			LD	HL,KBPORTSAMPLE	;10
4045:18674+7	1719  77      			LD	(HL),A
4046:18681+7	171A  E607    			AND	7
4047:18688+4	171C  6F      			LD	L,A		;HL->BIT_TABLE
4048:18692+7	171D  7E      			LD	A,(HL)
4049:18699+7	171E  2EE8    			LD	L,LOW KBCOLSAMPLED ;HL->KBCOLSAMPLED
4050:18706+7	1720  B6      			OR	(HL)
4051:18713+7	1721  77      			LD	(HL),A		;Save bit map of columns sampled
4052:								
4053:18720+6	1722  23      			INC	HL		;HL->KBPORTSAMPLE
4054:18726+7	1723  7E      			LD	A,(HL)
4055:18733+7	1724  E607    			AND	7
4056:18740+12	1726  CB5E    			BIT 	3,(HL)		;8  Test ROW-0
4057:18752+7+5	1728  2005    			JR  NZ,	IKEY0_UP	;12 Jump if key UP
4058:18759+7	172A  F680    			OR	0x80		;Flag a Key is down
4059:18766+6	172C  23      			INC	HL		;HL->KBHEXSAMPLE
4060:18772+7	172D  77      			LD	(HL),A		;Save HEX key
4061:18779+6	172E  2B      			DEC	HL		;HL->KBPORTSAMPLE
4062:						
4063:									;Sample input again for Row-1 test
4064:     -	172F          	IKEY0_UP
4065:18785+12	172F  CB66    			BIT 	4,(HL)		;8 Test ROW-1
4066:18797+7+5	1731  2005    			JR  NZ,	IKEY1_UP	;12 Jump if key UP
4067:18804+7	1733  F688    			OR	0x88		;Flag a key is down AND set bit 3 so key is between 8 and E
4068:18811+6	1735  23      			INC	HL		;HL->KBHEXSAMPLE
4069:18817+7	1736  77      			LD	(HL),A		;Save HEX key
4070:18824+6	1737  2B      			DEC	HL		;HL->KBPORTSAMPLE
4071:						
4072:     -	1738          	IKEY1_UP		
4073:									;   Test for all columns Scanned
4074:18830+6	1738  2B      			DEC	HL		;HL->KBCOLSAMPLED 
4075:18836+7	1739  7E      			LD	A,(HL)		;   *ALL keys scanned when KBCOLSAMPLED = 0xFF
4076:18843+4	173A  3C      			INC	A		;4
4077:18847+10	173B  C2F617  			JP  NZ,	IKEY_SCAN_END	;10
4078:						
4079:18857+7	173E  77      			LD	(HL),A		;KBCOLSAMPLED = 0x00 for next Scan
4080:				
4081:				;- - - - - - - - - - - - - - - - - - - - - - - - 
4082:				;Keys and Display update on Column 7 Only
4083:						
4084:18864+6	173F  23      			INC	HL		;HL->KBPORTSAMPLE
4085:18870+12	1740  CB6E    			BIT 	5,(HL)		;8  Test F KEY
4086:18882+7+5	1742  2807    			JR  Z,	IKEYF_UP	;12 Jump if key UP
4087:									;When F key is down, it can serve as either F or Shift.
4088:									;
4089:18889+13	1744  3AC1FF  			LD	A,(KEYBFMODE)	;Check the F MODE (shift key or HEX key)
4090:18902+6	1747  23      			INC	HL		;HL->KBHEXSAMPLE
4091:18908+7	1748  B6      			OR	(HL)		;8F=HEX INPUT, 90=Shiftable
4092:									;so when F is pressed:
4093:									;  If 8F it overrides all the other keys and KBHEXSAMPLE=8F
4094:									;  If 90 it OR's with KBHEXSAMPLE to become 9X where X is previous key held down
4095:18915+7	1749  77      			LD	(HL),A		;Save HEX key
4096:18922+6	174A  2B      			DEC	HL		;HL->KBPORTSAMPLE
4097:						
4098:     -	174B          	IKEYF_UP
4099:				
4100:				
4101:				;-Keyboard Scanning, only after scanning Column 7 we are here with the following:
4102:				;	KeyPad	KBHEXSAMPLE
4103:				;	no-key	0000 0000
4104:				;	  0	1000 0000
4105:				;	  1	1000 0001
4106:				;	  2	1000 0010
4107:				;	  3	1000 0011
4108:				;	  4	1000 0100
4109:				;	  5	1000 0101
4110:				;	  6	1000 0110
4111:				;	  7	1000 0111
4112:				;	  8	1000 1000
4113:				;	  9	1000 1001
4114:				;	  A	1000 1010
4115:				;	  B	1000 1011
4116:				;	  C	1000 1100
4117:				;	  D	1000 1101
4118:				;	  E	1000 1110
4119:				;	  F	1000 1111
4120:				;	  ^F			1001 xxxx (xxxx=any key pressed during the scan from Column 0)
4121:				
4122:18928+6	174B  23      			INC	HL		;HL->KBHEXSAMPLE
4123:18934+7	174C  7E      			LD	A,(HL)		;7  Get new HEX sample		
4124:18941+10	174D  3600    			LD	(HL),0		;10 Zero KBHEXSAMPLE for next scan
4125:18951+10	174F  21DAFF  			LD	HL,XTIMER_TIC
4126:18961+10	1752  3614    			LD	(HL),20		;Start new Scan in 20 Tics
4127:				
4128:     -	1754          	IKEY_DEBOUNCE	;A=current key scan or 0x00 for no key.
4129:18971+16	1754  2AEBFF  			LD	HL,(KEYBSCANPV) ;16 Get previously saved scanned key and timer
4130:18987+4	1757  BD      			CP	L		;4
4131:18991+7+5	1758  2803    			JR  Z,	IKEYP_NCOS	;12 Jump if NO Change of State
4132:18998+7	175A  2603    			LD	H,3		;Timer = 3 (Controls how sensitive the keyboard is to Key Inputs)
4133:19005+4	175C  6F      			LD	L,A		;Previous scan=current scan
4134:				
4135:19009+4	175D  25      	IKEYP_NCOS	DEC	H		;4  Timer = Timer - 1
4136:19013+16	175E  22EBFF  			LD	(KEYBSCANPV),HL	;16 Save previous scan & timer
4137:19029+10	1761  CA7317  			JP  Z,	IKEYP_EVENT	;10 Jump when Timer = 0
4138:19039+10	1764  F2AE17  			JP  P,	IK_NOKEY_EVENT	;10 Jump when Timer = 1 to 7F
4139:									
4140:									;When Timer underflows to FF, we can use the range from FF to 80
4141:									;to perform time delayed auto repeat for the key.
4142:									
4143:19049+7	1767  3ED0    			LD	A,0xD0		;Sets when to repeat (closer to FF, faster)
4144:19056+4	1769  BC      			CP	H
4145:19060+10	176A  C2AE17  			JP  NZ, IK_NOKEY_EVENT
4146:									;Timer then "lives" between D4 and D0 causing auto repeat of
4147:									;present key pressed (even if it's no key).
4148:						
4149:19070+7	176D  3ED4    			LD	A,0xD4		;Sets how fast to repeat (closer to "when to repeat" faster)
4150:19077+13	176F  32ECFF  			LD	(KEYBSCANTIMER),A ;Save timer
4151:19090+4	1772  7D      			LD	A,L		;Fetch keyscan
4152:				
4153:				
4154:     -	1773          	IKEYP_EVENT	;A=current key scan or 0x00 for no key (either after debounce or as repeat)
4155:19094+10	1773  21EDFF  			LD	HL,KEY_PRES_EV	;Point HL to previously saved/processed Key
4156:19104+4	1776  B7      			OR	A
4157:19108+7+5	1777  280F    			JR  Z,	IK_KEYUP_EVENT
4158:						
4159:     -	1779          	IKEYP_EVENT_DN				;When A<>0, It's a KEY DOWN EVENT
4160:19115+7	1779  FE90    			CP	0x90		;Is it Shift key down?
4161:19122+10	177B  C29617  			JP  NZ,	IK_KEYDN_EVENT	;Jump to process key down if it's NOT a shift key
4162:									;Special consideration given here for Shift Key down.
4163:				
4164:19132+12	177E  CB66    			BIT	4,(HL)		;Test bit 4 of KEY_PRES_EV (previously saved/processed key)
4165:19144+7	1780  77      			LD	(HL),A		;Save the 0x90 to KEY_PRES_EV
4166:									;Exit with just the Shift Key pressed (wait for the next shifted key to come in)
4167:19151+10	1781  CADF17  			JP  Z,	IKEY_DONE	;If previously saved key was not a shifted key, keep the 0x90
4168:									;If shift key is held down long enough to repeat, it then becomes F key
4169:19161+4	1784  3D      			DEC	A		;Otherwise, reduce the shift key to a simple "F" key (0x90 - 1 = 0x8F)
4170:19165+10	1785  C39617  			JP	IK_KEYDN_EVENT
4171:				
4172:     -	1788          	IK_KEYUP_EVENT	;*************************************************** KEY UP EVENT
4173:									;When A=0, It's a KEY UP EVENT
4174:19175+6	1788  23      			INC	HL
4175:19181+10	1789  3600    			LD	(HL),0
4176:19191+6	178B  2B      			DEC	HL
4177:19197+7	178C  7E      			LD	A,(HL)		;Fetch the previous key down code
4178:19204+7	178D  FE90    			CP	0x90
4179:19211+10	178F  C2DF17  			JP  NZ,	IKEY_DONE	;Exit if not the shift key going up
4180:									;Otherwise, if it was the Shift key going up....
4181:19221+4	1792  3D      			DEC	A  ;90->8F	;replace it with a simple "F" key
4182:						;JP	IK_KEYDN_EVENT	;and execute the key down event.
4183:19225+6	1793  23      			INC	HL
4184:19231+7	1794  77      			LD	(HL),A
4185:19238+6	1795  2B      			DEC	HL
4186:				
4187:				
4188:     -	1796          	IK_KEYDN_EVENT	;*************************************************** KEY DOWN EVENT
4189:19244+7	1796  77      			LD	(HL),A		;Save Last Key Down (for Shift Testing)
4190:19251+6	1797  23      			INC	HL
4191:19257+7	1798  BE      			CP	(HL)
4192:19264+7+5	1799  2805    			JR   Z,	IK_RTN
4193:19271+11	179B  34      			INC	(HL)
4194:19282+11	179C  35      			DEC	(HL)
4195:19293+7+5	179D  200F    			JR  NZ,	IK_NOKEY_EVENT
4196:19300+7	179F  77      			LD	(HL),A
4197:				
4198:19307+10	17A0  21E7FF  	IK_RTN		LD	HL,LED_ANBAR
4199:19317+15	17A3  CBC6    			SET	0,(HL)		;ANBARLED 0 = BEEPER
4200:19332+10	17A5  21B2FF  			LD	HL,BEEP_TO
4201:19342+15	17A8  CBCE    			SET	1,(HL)		;Time out beep in 2 counts
4202:				
4203:19357+16	17AA  2ABEFF  			LD	HL,(KEY_EVENT)
4204:19373+4	17AD  E9      			JP	(HL)
4205:				;KEY_EVENT_DISPATCH
4206:				;Execute different routines based on Users actions.
4207:				;Possible choices within this firmware include:
4208:				;IMON_CMD	- Menu Command Input (default and initial setting).  Resets to this even upon IKC_RESET_CMD
4209:				;ICMD0_R	- HEX Input Mode to select a Register (valid input is 0-12 for the 13 registers). Value saved in RegPtr.
4210:				;ICMD_BYTE	- BYTE Input Mode. IK_HEXST tracks state machine of routine. IK_HEXH store the value.  Execute @HEX_READY when done.
4211:				;ICMD_WORD	- WORD Input Mode. IK_HEXST tracks state machine of routine. IK_HEXH & IK_HEXL store the value.  Execute @HEX_READY when done.
4212:				;ISET_PRESSED	- Saves Key Pressed for User, does not process any keys.
4213:				
4214:     -	17AE          	IK_NOKEY_EVENT	;*************************************************** NO KEY EVENT
4215:				
4216:				
4217:									;********************************* <Ctrl>-C Checking
4218:19377+16	17AE  2AB8FF  			LD	HL,(CTRL_C_CHK)	;16 <Ctrl>-C check +77
4219:19393+4	17B1  E9      			JP	(HL)		;4
4220:									;st=97
4221:     -	17B2          	CTRL_C_RET
4222:				
4223:19397+10	17B2  21C0FF  			LD	HL,IK_TIMER	;10
4224:19407+7	17B5  7E      			LD	A,(HL)		;7 Time out any pending Monitor Input
4225:19414+4	17B6  B7      			OR	A		;4
4226:19418+10	17B7  CADF17  			JP Z,	IKEY_DONE	;10 st=31
4227:19428+11	17BA  35      			DEC	(HL)
4228:19439+10	17BB  C2DF17  			JP NZ,	IKEY_DONE
4229:				
4230:									;IK Timer Expired Event
4231:     -	17BE          	IKC_RESET_CMD				;Upon time out, return monitor to CMD input
4232:19449+16	17BE  2ABAFF  			LD	HL,(LDISPMODE)
4233:19465+16	17C1  22BCFF  			LD	(DISPMODE),HL
4234:19481+10	17C4  214218  			LD	HL,IMON_CMD
4235:19491+16	17C7  22BEFF  			LD	(KEY_EVENT),HL
4236:19507+10	17CA  21C1FF  			LD	HL,KEYBFMODE	;Shiftable Keyboard
4237:19517+10	17CD  3690    			LD	(HL),0x90
4238:				
4239:19527+13	17CF  3AB3FF  	IKC_REFRESH	LD	A,(ANBAR_DEF)	;Refresh Display
4240:19540+13	17D2  32E7FF  			LD	(LED_ANBAR),A
4241:19553+7	17D5  3EFF    	IKR_QREFRESH	LD	A,-1
4242:19560+13	17D7  32C3FF  			LD	(IK_HEXST),A	;Zero HEX Input Sequencer
4243:19573+7	17DA  3E01    			LD	A,1		;Force Quick Refresh of Label
4244:19580+13	17DC  32C2FF  			LD	(DISPLABEL),A
4245:						;JP	IKEY_DONE
4246:     -	17DF          	IKEY_DONE
4247:				
4248:				
4249:						;*************************************************** UP DATE LED DISPLAY
4250:19593+16	17DF  2ABCFF  			LD	HL,(DISPMODE)	;16 +242 (for Display Memory)
4251:19609+4	17E2  E9      			JP	(HL)		;4
4252:     -	17E3          	IDISP_RET
4253:19613+10	17E3  21B2FF  			LD	HL,BEEP_TO	;10
4254:19623+11	17E6  35      			DEC	(HL)		;11
4255:19634+7+5	17E7  2807    			JR Z,	IKEY_NO_BEEP	;10
4256:19641+10	17E9  21E7FF  			LD	HL,LED_ANBAR	;10  ANBARLED 0 = BEEPER
4257:19651+15	17EC  CBC6    			SET	0,(HL)		;15	BEEP ON WHEN BEEP_TO > 1
4258:19666+12	17EE  1806    			JR	IKEY_SCAN_END
4259:						
4260:19678+11	17F0  34      	IKEY_NO_BEEP	INC	(HL)		;11
4261:19689+10	17F1  21E7FF  			LD	HL,LED_ANBAR	;10
4262:19699+15	17F4  CB86    			RES	0,(HL)		;15  ANBARLED 0 = BEEPER
4263:									;st=67
4264:									
4265:     -	17F6          	IKEY_SCAN_END	
4266:				
4267:19714+16	17F6  2AB0FF  			LD	HL,(UiVec)	;16  Do a User Interrupt Vector
4268:19730+17	17F9  CDA00C  			CALL	VCALL_HL
4269:19747+10	17FC  C30017  			JP	ISR_EXTIMER_RET
4270:				
4271:19757+10	17FF  C9      	UiVec_RET	RET			;Default Return for UiVec
4272:				
4273:19767+7	1800  3EFE    	ICMD_BREAK	LD	A,0xFE
4274:19774+13	1802  32DFFF  	ICMD_BREAK_RET	LD	(SOFT_RST_FLAG),A	;FE=RESTART, D1=SINGLE STEP, F6=HALT, CC=<Ctrl>-C
4275:19787+13	1805  3AB3FF  			LD	A,(ANBAR_DEF)	;Soft Restart only allowed while in Run Mode
4276:19800+7	1808  E602    			AND	2		;Run mode LED
4277:19807+10	180A  CADF17  			JP  Z,	IKEY_DONE
4278:				
4279:19817+4	180D  F3      			DI
4280:19821+10	180E  F1      			POP	AF
4281:19831+10	180F  E1      			POP	HL
4282:19841+20	1810  ED7B28FB			LD	SP,(SP_ISR_SAVE)
4283:19861+10	1814  C30000  			JP	0
4284:						
4285:19871+16	1817  2ACAFF  	CTRL_C_TEST	LD	HL,(RXBHEAD)	;16
4286:19887+7	181A  7E      			LD	A,(HL)		;7
4287:19894+10	181B  21DEFF  			LD	HL,CTRL_C_TIMER	;10
4288:19904+7	181E  FE03    			CP	3		;7  Compare <Ctrl>-C
4289:19911+10	1820  CA2518  			JP  Z,	CTRL_C_IN_Q	;10
4290:19921+10	1823  360A    			LD	(HL),10		;10
4291:19931+11	1825  35      	CTRL_C_IN_Q	DEC	(HL)		;7
4292:19942+10	1826  C2B217  			JP  NZ,	CTRL_C_RET	;10  st=77
4293:19952+7	1829  3ECC    			LD	A,0xCC
4294:19959+10	182B  C30218  			JP	ICMD_BREAK_RET
4295:				
4296:19969+10	182E  211718  	CTRL_C_CHK_ON	LD	HL,CTRL_C_TEST
4297:19979+16	1831  22B8FF  			LD	(CTRL_C_CHK),HL
4298:19995+10	1834  C9      			RET
4299:20005+10	1835  21B217  	CTRL_C_CHK_OFF	LD	HL,CTRL_C_RET
4300:20015+16	1838  22B8FF  			LD	(CTRL_C_CHK),HL
4301:20031+10	183B  C9      			RET
4302:				
4303:				
4304:				
4305:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
4306:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
4307:				;	Keyboard Monitor
4308:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
4309:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
4310:				
4311:				;============================================================================
4312:				; No Keyboard activity, Save Key for User.
4313:20041+13	183C  32EFFF  	ISET_PRESSED	LD	(KEY_PRESSED),A
4314:20054+10	183F  C3DF17  			JP	IKEY_DONE
4315:				
4316:				
4317:				;============================================================================
4318:				;	IMON - Monitor Loop
4319:				;
4320:				; This is the main executive loop for the Front Panel Emulator, Dispatch the Command
4321:				;============================================================================
4322:20064+10	1842  215718  	IMON_CMD	LD	HL,IMON_TBL
4323:20074+7	1845  E61F    			AND	0x1F
4324:20081+4	1847  07      			RLCA			;X2
4325:20085+17	1848  CD450E  			CALL	ADD_HL_A
4326:20102+17	184B  CD4A0E  			CALL	LD_HL_HL	; HL = (HL)
4327:20119+4	184E  E9      			JP	(HL)
4328:				
4329:20123+10	184F  21D8FF  	ICMD4_EXEC	LD	HL,ISR_FLAGS
4330:20133+15	1852  CB86    			RES	0,(HL)		;Reset NEST level to 0
4331:20148+10	1854  C3600B  			JP	GO_EXEC_T
4332:				
4333:     -	1857  9718    	IMON_TBL	DW	ICMD0		;0 = Display Register
4334:     -	1859  DF17    			DW	IKEY_DONE	;ICMD1
4335:     -	185B  DF17    			DW	IKEY_DONE	;ICMD2
4336:     -	185D  DF17    			DW	IKEY_DONE	;ICMD3
4337:     -	185F  4F18    			DW	ICMD4_EXEC	;4 = GO Execute
4338:     -	1861  9B19    			DW	ICMD5		;5 = Input Port
4339:     -	1863  B819    			DW	ICMD6		;6 = Output Port
4340:     -	1865  301A    			DW	ICMD7		;7 = Single Step
4341:     -	1867  DF17    			DW	IKEY_DONE	;ICMD8
4342:     -	1869  DD19    			DW	IRAMROMBANK	;ICMD9
4343:     -	186B  B51A    			DW	ICMDA		;A = Advance Element
4344:     -	186D  D61A    			DW	ICMDB		;B = Backup Element
4345:     -	186F  DF17    			DW	IKEY_DONE	;ICMDC
4346:     -	1871  011B    			DW	ICMDD		;D = Alter Element
4347:     -	1873  AD18    			DW	ICMDE		;E = Display Memory
4348:     -	1875  DF17    			DW	IKEY_DONE	;ICMDF
4349:     -	1877  DF17    			DW	IKEY_DONE	;ICMD10 (Shift-0 Can't happen, you get hard reset)
4350:     -	1879  DF17    			DW	IKEY_DONE	;ICMD11
4351:     -	187B  DF17    			DW	IKEY_DONE	;ICMD12
4352:     -	187D  DF17    			DW	IKEY_DONE	;ICMD13
4353:     -	187F  DF17    			DW	IKEY_DONE	;ICMD14
4354:     -	1881  DF17    			DW	IKEY_DONE	;ICMD15
4355:     -	1883  DF17    			DW	IKEY_DONE	;ICMD16
4356:     -	1885  DF17    			DW	IKEY_DONE	;ICMD17
4357:     -	1887  DF17    			DW	IKEY_DONE	;ICMD18
4358:     -	1889  DF17    			DW	IKEY_DONE	;ICMD19
4359:     -	188B  DD19    			DW	IRAMROMBANK	;ICMD1A
4360:     -	188D  DF17    			DW	IKEY_DONE	;ICMD1B
4361:     -	188F  DF17    			DW	IKEY_DONE	;ICMD1C
4362:     -	1891  DF17    			DW	IKEY_DONE	;ICMD1D
4363:     -	1893  0018    			DW	ICMD_BREAK	;ICMD1E
4364:     -	1895  DF17    			DW	IKEY_DONE	;ICMD1F (Shift-F Can't happen)
4365:				
4366:				
4367:20158+17	1897  CD1D0C  	ICMD0		CALL	WRITE_BLOCK	;0 = Display Register
4368:     -	189A  BAFF    			DW	LDISPMODE	;Where to write
4369:     -	189C  0700    			DW	7		;Bytes to write
4370:     -	189E  671B    			DW	IDISP_REG	;(LDISPMODE)
4371:     -	18A0  671B    			DW	IDISP_REG	;(DISPMODE)
4372:     -	18A2  EC1A    			DW	ICMD0_R		;(KEY_EVENT) Switch to HEX Input Mode
4373:     -	18A4  50      			DB	80		;(IK_TIMER)
4374:20175+10	18A5  21E7FF  			LD	HL,LED_ANBAR
4375:20185+15	18A8  CBF6    			SET	6,(HL)		;ANBARLED 6 = Enter Register
4376:20200+10	18AA  C3DF17  			JP	IKEY_DONE
4377:				
4378:20210+17	18AD  CD1D0C  	ICMDE		CALL	WRITE_BLOCK	;E = Display Memory
4379:     -	18B0  BAFF    			DW	LDISPMODE	;Where to write
4380:     -	18B2  0E00    			DW	14		;Bytes to write
4381:     -	18B4  9C1B    			DW	IDISP_MEM	;(LDISPMODE)
4382:     -	18B6  9C1B    			DW	IDISP_MEM	;(DISPMODE)
4383:     -	18B8  CA18    			DW	ICMD_WORD	;(KEY_EVENT) Switch to HEX Input Mode
4384:     -	18BA  50      			DB	80		;(IK_TIMER)
4385:     -	18BB  8F      			DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
4386:     -	18BC  00      			DB	0		;(DISPLABEL)
4387:     -	18BD  FF      			DB	-1		;(IK_HEXST)
4388:     -	18BE  E0FF    			DW	LED_DISPLAY	;(HEX_CURSOR) @d1
4389:     -	18C0  2019    			DW	HEX2ABUSS	;(HEX_READY)
4390:				
4391:20227+10	18C2  21E7FF  			LD	HL,LED_ANBAR
4392:20237+15	18C5  CBEE    			SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
4393:20252+10	18C7  C3DF17  			JP	IKEY_DONE
4394:				
4395:				
4396:20262+16	18CA  2AC4FF  	ICMD_WORD	LD	HL,(HEX_CURSOR)
4397:20278+17	18CD  CD531C  			CALL	LED_PUT_HEX_HL
4398:20295+16	18D0  22C4FF  			LD	(HEX_CURSOR),HL
4399:20311+10	18D3  21C3FF  			LD	HL,IK_HEXST
4400:20321+11	18D6  34      			INC	(HL)
4401:20332+7+5	18D7  201B    			JR NZ,	ICMD_WORDN1	;Do 1st digit
4402:				
4403:20339+16	18D9  2ABCFF  			LD	HL,(DISPMODE)
4404:20355+16	18DC  22BAFF  			LD	(LDISPMODE),HL
4405:20371+10	18DF  21E317  			LD	HL,IDISP_RET
4406:20381+16	18E2  22BCFF  			LD	(DISPMODE),HL	;No Display Update while HEX Input Mode
4407:				
4408:20397+16	18E5  2AC4FF  			LD	HL,(HEX_CURSOR)
4409:20413+7	18E8  3E81    			LD	A,0x81		;Underscore
4410:20420+7	18EA  77      			LD	(HL),A		;Display X _
4411:20427+4	18EB  2C      			INC	L
4412:20431+7	18EC  77      			LD	(HL),A		;Display X _ _
4413:20438+4	18ED  2C      			INC	L
4414:20442+7	18EE  77      			LD	(HL),A		;Display X _ _ _
4415:20449+10	18EF  215AFF  			LD	HL,IK_HEXH	;HL=DIGITS 1&2
4416:20459+12	18F2  180D    			JR	ICMD_WORD1
4417:				
4418:20471+7	18F4  7E      	ICMD_WORDN1	LD	A,(HL)
4419:20478+10	18F5  215AFF  			LD	HL,IK_HEXH	;HL=DIGITS 1&2
4420:20488+4	18F8  3D      			DEC	A
4421:20492+7+5	18F9  280D    			JR Z,	ICMD_WORD2	;Do 2nd digit
4422:20499+10	18FB  2159FF  			LD	HL,IK_HEXL	;HL=DIGITS 3&4
4423:20509+4	18FE  3D      			DEC	A
4424:20513+7+5	18FF  2007    			JR NZ,	ICMD_WORD2
4425:				
4426:20520+13	1901  3AEDFF  	ICMD_WORD1	LD	A,(KEY_PRES_EV)	;1st & 3rd DIGIT
4427:20533+18	1904  ED67    			RRD
4428:20551+12	1906  1807    			JR	ICMD_WORD_RET
4429:				
4430:20563+18	1908  ED67    	ICMD_WORD2	RRD			;2nd & 4th DIGIT
4431:20581+13	190A  3AEDFF  			LD	A,(KEY_PRES_EV)
4432:20594+18	190D  ED6F    			RLD
4433:				
4434:20612+7	190F  3EA0    	ICMD_WORD_RET	LD	A,160
4435:20619+13	1911  32C0FF  			LD	(IK_TIMER),A	;Set Time out on Register Selection
4436:20632+13	1914  3AC3FF  			LD	A,(IK_HEXST)	;Advance to next DspMod
4437:20645+7	1917  FE03    			CP	3
4438:20652+10	1919  C2DF17  			JP NZ,	IKEY_DONE
4439:20662+16	191C  2AC6FF  			LD	HL,(HEX_READY)
4440:20678+4	191F  E9      			JP	(HL)
4441:				
4442:20682+16	1920  2A59FF  	HEX2ABUSS	LD	HL,(IK_HEXL)
4443:20698+16	1923  2288FF  			LD	(ABUSS),HL
4444:20714+10	1926  C3BE17  			JP	IKC_RESET_CMD
4445:				
4446:20724+13	1929  3A8AFF  	HEX2REG		LD	A,(RegPtr)	;Select Register
4447:20737+11	192C  D5      			PUSH	DE
4448:20748+20	192D  ED5B59FF			LD	DE,(IK_HEXL)
4449:20768+17	1931  CD820C  			CALL	PUT_REGISTER
4450:20785+10	1934  D1      			POP	DE
4451:20795+10	1935  C3BE17  			JP	IKC_RESET_CMD
4452:				
4453:				
4454:20805+16	1938  2AC4FF  	ICMD_BYTE	LD	HL,(HEX_CURSOR)
4455:20821+17	193B  CD531C  			CALL	LED_PUT_HEX_HL
4456:20838+16	193E  22C4FF  			LD	(HEX_CURSOR),HL		
4457:20854+10	1941  21C3FF  			LD	HL,IK_HEXST
4458:20864+11	1944  34      			INC	(HL)
4459:20875+7+5	1945  2022    			JR NZ,	ICMD_BYTE2	;Do 1st digit
4460:				
4461:20882+16	1947  2ABCFF  			LD	HL,(DISPMODE)
4462:20898+16	194A  22BAFF  			LD	(LDISPMODE),HL
4463:20914+10	194D  21E317  			LD	HL,IDISP_RET
4464:20924+16	1950  22BCFF  			LD	(DISPMODE),HL	;No Display Update while HEX Input Mode
4465:				
4466:20940+16	1953  2AC4FF  			LD	HL,(HEX_CURSOR)
4467:20956+7	1956  3E81    			LD	A,0x81		;Underscore
4468:20963+7	1958  77      			LD	(HL),A		;Display X _
4469:				
4470:20970+10	1959  215AFF  			LD	HL,IK_HEXH	;HL=DIGITS 1&2
4471:20980+13	195C  3AEDFF  			LD	A,(KEY_PRES_EV)	;1st DIGIT
4472:20993+18	195F  ED67    			RRD
4473:21011+7	1961  3EA0    			LD	A,160
4474:21018+13	1963  32C0FF  			LD	(IK_TIMER),A	;Set Time out on Register Selection
4475:21031+10	1966  C3DF17  			JP 	IKEY_DONE
4476:				
4477:21041+10	1969  215AFF  	ICMD_BYTE2	LD	HL,IK_HEXH	;HL=DIGITS 1&2
4478:21051+18	196C  ED67    			RRD			;2nd DIGIT
4479:21069+13	196E  3AEDFF  			LD	A,(KEY_PRES_EV)
4480:21082+18	1971  ED6F    			RLD
4481:21100+7	1973  7E      			LD	A,(HL)
4482:21107+16	1974  2AC6FF  			LD	HL,(HEX_READY)
4483:21123+4	1977  E9      			JP	(HL)
4484:				
4485:21127+13	1978  328BFF  	HEX2IN_Ptr	LD	(IoPtr),A	;Save Byte input to IoPtr
4486:21140+10	197B  C3BE17  			JP	IKC_RESET_CMD
4487:				
4488:21150+13	197E  328BFF  	HEX2OUT_Ptr	LD	(IoPtr),A	;Save Byte input to IoPtr
4489:21163+10	1981  C34A1B  			JP	ICMD_IO_OUT
4490:				
4491:21173+16	1984  2A88FF  	HEX2MEM		LD	HL,(ABUSS)
4492:21189+7	1987  77      			LD	(HL),A
4493:21196+6	1988  23      			INC	HL
4494:21202+16	1989  2288FF  			LD	(ABUSS),HL
4495:21218+10	198C  C30A1B  			JP	ICMD_AMEM
4496:				
4497:21228+11	198F  C5      	HEX2OUT_PORT	PUSH	BC
4498:21239+4	1990  47      			LD	B,A
4499:21243+13	1991  3A8BFF  			LD	A,(IoPtr)
4500:21256+4	1994  4F      			LD	C,A
4501:21260+12	1995  ED41    			OUT	(C),B
4502:21272+10	1997  C1      			POP	BC
4503:21282+10	1998  C34A1B  			JP	ICMD_IO_OUT
4504:				
4505:     -	199B          	ICMD1
4506:     -	199B          	ICMD2
4507:     -	199B          	ICMD3
4508:     -	199B          	ICMD4
4509:				
4510:21292+17	199B  CD1D0C  	ICMD5		CALL	WRITE_BLOCK
4511:     -	199E  BAFF    			DW	LDISPMODE	;Where to write
4512:     -	19A0  0E00    			DW	14		;Bytes to write
4513:     -	19A2  D01B    			DW	IDISP_IN	;(LDISPMODE)
4514:     -	19A4  D01B    			DW	IDISP_IN	;(DISPMODE)
4515:     -	19A6  3819    			DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
4516:     -	19A8  50      			DB	80		;(IK_TIMER)
4517:     -	19A9  8F      			DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
4518:     -	19AA  00      			DB	0		;(DISPLABEL)
4519:     -	19AB  FF      			DB	-1		;(IK_HEXST)
4520:     -	19AC  E2FF    			DW	LED_DISPLAY+2	;(HEX_CURSOR) @d3
4521:     -	19AE  7819    			DW	HEX2IN_Ptr	;(HEX_READY)
4522:				
4523:21309+10	19B0  21E7FF  			LD	HL,LED_ANBAR
4524:21319+15	19B3  CBEE    			SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
4525:21334+10	19B5  C3DF17  			JP	IKEY_DONE
4526:				
4527:21344+17	19B8  CD1D0C  	ICMD6		CALL	WRITE_BLOCK
4528:     -	19BB  BAFF    			DW	LDISPMODE	;Where to write
4529:     -	19BD  0E00    			DW	14		;Bytes to write
4530:     -	19BF  051C    			DW	IDISP_OUT	;(LDISPMODE)
4531:     -	19C1  051C    			DW	IDISP_OUT	;(DISPMODE)
4532:     -	19C3  3819    			DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
4533:     -	19C5  50      			DB	80		;(IK_TIMER)
4534:     -	19C6  8F      			DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
4535:     -	19C7  00      			DB	0		;(DISPLABEL)
4536:     -	19C8  FF      			DB	-1		;(IK_HEXST)
4537:     -	19C9  E2FF    			DW	LED_DISPLAY+2	;(HEX_CURSOR) @d3
4538:     -	19CB  7E19    			DW	HEX2OUT_Ptr	;(HEX_READY)
4539:				
4540:21361+10	19CD  21E5FF  			LD	HL,LED_DISPLAY+5
4541:21371+10	19D0  3680    			LD	(HL),0x80	;Blank d6
4542:21381+4	19D2  2C      			INC	L
4543:21385+10	19D3  3680    			LD	(HL),0x80	;Blank d7
4544:21395+10	19D5  21E7FF  			LD	HL,LED_ANBAR
4545:21405+15	19D8  CBEE    			SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
4546:21420+10	19DA  C3DF17  			JP	IKEY_DONE
4547:				
4548:				
4549:				
4550:21430+17	19DD  CD1D0C  	IRAMROMBANK	CALL	WRITE_BLOCK
4551:     -	19E0  BCFF    			DW	DISPMODE	;Where to write
4552:     -	19E2  0500    			DW	5		;Bytes to write
4553:     -	19E4  E317    			DW	IDISP_RET	;(DISPMODE)
4554:     -	19E6  131A    			DW	IRAMROMBANK_CHG	;(KEY_EVENT) Switch to BYTE Input Mode
4555:     -	19E8  50      			DB	80		;(IK_TIMER)
4556:						
4557:21447+13	19E9  3ADBFF  			LD	A,(READ_RAMROM)
4558:21460+4	19EC  1F      	IDDR_DISP	RRA
4559:21464+11	19ED  D3CC    			OUT	(ACE_OUT),A	;SET Bank
4560:21475+7+5	19EF  3014    			JR  NC,	IDRR_ROM
4561:21482+17	19F1  CD8A1C  			CALL	LED_HOME_PRINTI
4562:     -	19F4  72616D20			DB	'ram    ',EOS
	              20202000
4563:21499+10	19FC  21E4FF  			LD	HL,LED_DISPLAY+4
4564:21509+17	19FF  CD531C  			CALL	LED_PUT_HEX_HL
4565:21526+10	1A02  C3DF17  			JP	IKEY_DONE
4566:						
4567:21536+17	1A05  CD8A1C  	IDRR_ROM	CALL	LED_HOME_PRINTI
4568:     -	1A08  726F6D20			DB	'rom    ',EOS
	              20202000
4569:21553+10	1A10  C3DF17  			JP	IKEY_DONE
4570:				
4571:				;SET_BANK	
4572:21563+7	1A13  3E50    	IRAMROMBANK_CHG	LD	A,80
4573:21570+13	1A15  32C0FF  			LD	(IK_TIMER),A
4574:21583+13	1A18  3ADBFF  			LD	A,(READ_RAMROM)
4575:21596+4	1A1B  1F      			RRA
4576:21600+7+5	1A1C  3008    			JR  NC,	IDRRC_ROM
4577:21607+4	1A1E  3C      			INC	A
4578:21611+8	1A1F  CB67    			BIT	4,A
4579:21619+7+5	1A21  2007    			JR  NZ,	IDRRC_2ROM
4580:21626+4	1A23  17      			RLA
4581:21630+12	1A24  1805    			JR	IDRRC_RET
4582:				
4583:21642+7	1A26  3E01    	IDRRC_ROM	LD	A,1		;Start at BANK 0 of RAM, bit0 set = RAM
4584:21649+12	1A28  1801    			JR	IDRRC_RET
4585:						
4586:21661+4	1A2A  AF      	IDRRC_2ROM	XOR	A		;Return to ROM after 15 Banks
4587:21665+13	1A2B  32DBFF  	IDRRC_RET	LD	(READ_RAMROM),A
4588:21678+12	1A2E  18BC    			JR	IDDR_DISP
4589:				
4590:				
4591:				
4592:				
4593:				;============================================================================
4594:				;	Single Step
4595:				;============================================================================
4596:21690+13	1A30  3AB3FF  	ICMD7		LD	A,(ANBAR_DEF)	;Single step only allowed while in Monitor Mode
4597:21703+7	1A33  E604    			AND	4
4598:21710+10	1A35  CADF17  			JP  Z,	IKEY_DONE
4599:						
4600:						;DEBUG SINGLE STEP ONLY ALLOWED WITH FP BOARD
4601:21720+13	1A38  3A95FF  			LD	A,(HW_LIST)
4602:21733+7	1A3B  E601    			AND	1
4603:21740+10	1A3D  CADF17  			JP  Z,	IKEY_DONE
4604:						
4605:				
4606:21750+13	1A40  3A95FF  	GO_SINGLE	LD	A,(HW_LIST)	;TEST HARDWARE LIST here for Return to Main Menu when
4607:21763+7	1A43  E601    			AND	1		;Single Step was an RS232 input command
4608:21770+7+5	1A45  2027    			JR  NZ,	GS_OK
4609:				
4610:21777+17	1A47  CDCA0D  			CALL	PRINTI
4611:     -	1A4A  0D0A5369			DB	CR,LF,"Single Step requires Front Panel",EOS		
	              6E676C65
	              20537465
	              70207265
	              71756972
	              65732046
	              726F6E74
	              2050616E
	              656C00
4612:21794+10	1A6D  C9      			RET	
4613:						
4614:21804+10	1A6E  21751A  	GS_OK		LD	HL,ISINGLE	;Redirect next Interrupt to Single Step
4615:21814+16	1A71  22CEFF  			LD	(INT_VEC),HL
4616:21830+4	1A74  76      			HALT			;Halt for next interrupt (Aligns TC with INT)
4617:				
4618:									;The following interrupt code happens		
4619:						;RST	0x38		;13  (11 + 2 wait cycles)
4620:						;EX	AF,AF'		;4
4621:						;EXX			;4
4622:						;LD	HL,(INT_VEC)	;16 Typical Calls are to ISR_DISPATCH
4623:						;JP	(HL)		;4
4624:									;st=41
4625:									
4626:									;On the next interrupt, handle it here
4627:21834+4	1A75  08      	ISINGLE		EX	AF,AF'		;4
4628:21838+4	1A76  D9      			EXX			;4
4629:21842+13	1A77  3AF5FF  			LD	A,(SCAN_LED)	;13 ZMC-Display Refresh / Reset Int
4630:21855+11	1A7A  D340    			OUT	(Port40),A	;11 Output ASAP to satisfy Interrupt Flag
4631:				
4632:21866+11	1A7C  DB40    			IN	A,(Port40)	;11 Resync the SCAN_PTR
4633:21877+4	1A7E  3C      			INC	A		;4  Advance to next column to match column after next OUT
4634:21881+7	1A7F  E607    			AND	7		;7
4635:21888+7	1A81  F6E0    			OR  LOW LED_DISPLAY	;7  LED_DISPLAY is at xxEO (it's ok to overlap in this order)
4636:21895+13	1A83  32D0FF  			LD	(SCAN_PTR),A	;13 Save Scan Ptr @ Next Scan Output
4637:21908+16	1A86  2AD0FF  			LD	HL,(SCAN_PTR)	;16 Fetch next byte to output
4638:21924+7	1A89  7E      			LD	A,(HL)		;7
4639:21931+13	1A8A  32F5FF  			LD	(SCAN_LED),A	;13 Save for next interrupt
4640:									;st=110
4641:				
4642:21944+10	1A8D  219C1A  			LD	HL,ISINGLE_DONE	;10 Redirect next Interrupt to Single Step
4643:21954+16	1A90  22CEFF  			LD	(INT_VEC),HL	;16
4644:				
4645:21970+7	1A93  3ED4    			LD	A,212		;7
4646:									;st=33
4647:									;-----
4648:									;184 (+completion), There are 4096 cycles between interrupts.
4649:									;	 4096 cycles to waste
4650:									;	 -184 cycles to get here
4651:									;	 -525 cycles to execute
4652:									;	=3387 cycles more to waste
4653:									;
4654:									;	Waste Loop = 16 * 212 -5 = 3387
4655:									;
4656:21977+4	1A95  3D      	ISINGLE_LP	DEC	A		;4  Count down the cycles to time the next ISR to occur
4657:21981+7+5	1A96  20FD    			JR NZ,	ISINGLE_LP	;12/7 cycle after execution commences
4658:21988+4	1A98  00      			NOP		
4659:21992+10	1A99  C3710B  			JP	GO_EXEC		;10 Go Execute the single instruction!
4660:									;(515 T states until executing next instruction)
4661:				
4662:22002+4	1A9C  08      	ISINGLE_DONE	EX	AF,AF'		;4
4663:22006+4	1A9D  D9      			EXX			;4
4664:22010+20	1A9E  ED7328FB			LD	(SP_ISR_SAVE),SP
4665:22030+11	1AA2  E5      			PUSH	HL
4666:22041+11	1AA3  F5      			PUSH	AF
4667:				
4668:22052+7	1AA4  3ED1    			LD	A,0xD1		;ISR being re-entered after the single step
4669:22059+10	1AA6  C30218  			JP 	ICMD_BREAK_RET	;
4670:				
4671:				;ICMD_BREAK_RET	....
4672:				;		DI
4673:				;		POP	AF
4674:				;		POP	HL
4675:				;		LD	SP,(SP_ISR_SAVE)
4676:				;		JP	0
4677:						
4678:				
4679:				
4680:				
4681:				
4682:				;============================================================================
4683:22069+13	1AA9  3ABCFF  	GET_DISPMODE	LD	A,(DISPMODE)
4684:22082+7	1AAC  FE79    			CP  LOW IDISP_REG_DATA
4685:22089+5+6	1AAE  C8      			RET Z				;Z=1 : DISPMODE = REGISTER
4686:22094+7	1AAF  FEB4    			CP  LOW IDISP_MEM_DATA
4687:22101+4	1AB1  37      			SCF
4688:22105+5+6	1AB2  C0      			RET NZ				;Z=0, C=1 : DISPMODE = I/O
4689:22110+4	1AB3  B7      			OR	A			;WARNING, If LOW IDISP_MEM_DATA=0 Then ERROR
4690:22114+10	1AB4  C9      			RET				;Z=0, C=0 : DISPMODE = MEM
4691:				
4692:				;	if 0x00 = LOW IDISP_MEM_DATA
4693:				;	   error "Error, LOW IDISP_MEM_DATA must not be 0x00"
4694:				;	endif
4695:				
4696:				;============================================================================
4697:				;	Increment Display Element
4698:				;============================================================================
4699:22124+17	1AB5  CDA91A  	ICMDA		CALL	GET_DISPMODE
4700:22141+10	1AB8  CAC81A  			JP  Z,	ICMA_REG
4701:22151+10	1ABB  DACF1A  			JP  C,	ICMA_IO
4702:				
4703:22161+16	1ABE  2A88FF  			LD	HL,(ABUSS)
4704:22177+6	1AC1  23      			INC     HL
4705:22183+16	1AC2  2288FF  			LD	(ABUSS),HL
4706:22199+10	1AC5  C3D517  			JP	IKR_QREFRESH
4707:				
4708:22209+13	1AC8  3A8AFF  	ICMA_REG	LD      A,(RegPtr)
4709:22222+4	1ACB  3C      			INC	A
4710:22226+10	1ACC  C3EF1A  			JP	ICMD_SET_REG
4711:				
4712:22236+10	1ACF  218BFF  	ICMA_IO		LD	HL,IoPtr
4713:22246+11	1AD2  34      			INC	(HL)
4714:22257+10	1AD3  C3D517  			JP	IKR_QREFRESH
4715:				
4716:				
4717:				;============================================================================
4718:				;	Decrement Display Element (Reg, I/O, Mem)
4719:				;============================================================================
4720:22267+17	1AD6  CDA91A  	ICMDB		CALL	GET_DISPMODE
4721:22284+10	1AD9  CAE91A  			JP  Z,	ICMB_REG
4722:22294+10	1ADC  DAFA1A  			JP  C,	ICMB_IO
4723:				
4724:22304+16	1ADF  2A88FF  			LD	HL,(ABUSS)
4725:22320+6	1AE2  2B      			DEC     HL
4726:22326+16	1AE3  2288FF  			LD	(ABUSS),HL
4727:22342+10	1AE6  C3D517  			JP	IKR_QREFRESH
4728:				
4729:22352+13	1AE9  3A8AFF  	ICMB_REG	LD      A,(RegPtr)
4730:22365+4	1AEC  3D      	ICMD0_R		DEC	A		;Adjust so Key 1 = 0 = SP
4731:22369+7	1AED  E60F    			AND	0xF
4732:22376+7	1AEF  FE0D    	ICMD_SET_REG	CP	13
4733:22383+7+5	1AF1  3801    			JR  C,	ICMD_SR_OK
4734:22390+4	1AF3  AF      			XOR	A
4735:22394+13	1AF4  328AFF  	ICMD_SR_OK	LD	(RegPtr),A
4736:22407+10	1AF7  C3BE17  			JP	IKC_RESET_CMD
4737:				
4738:				
4739:22417+10	1AFA  218BFF  	ICMB_IO		LD	HL,IoPtr
4740:22427+11	1AFD  35      			DEC	(HL)
4741:22438+10	1AFE  C3D517  			JP	IKR_QREFRESH
4742:				
4743:				;============================================================================
4744:				;	Alter Display Element (Reg, I/O, Mem)
4745:				;============================================================================
4746:22448+17	1B01  CDA91A  	ICMDD		CALL	GET_DISPMODE
4747:22465+10	1B04  CA291B  			JP  Z,	ICMD_REG
4748:22475+10	1B07  DA451B  			JP  C,	ICMD_IO
4749:				
4750:22485+17	1B0A  CD1D0C  	ICMD_AMEM	CALL	WRITE_BLOCK
4751:     -	1B0D  BAFF    			DW	LDISPMODE	;Where to write
4752:     -	1B0F  0E00    			DW	14		;Bytes to write
4753:     -	1B11  9C1B    			DW	IDISP_MEM	;(LDISPMODE)
4754:     -	1B13  9C1B    			DW	IDISP_MEM	;(DISPMODE)
4755:     -	1B15  3819    			DW	ICMD_BYTE	;(KEY_EVENT) Switch to BYTE Input Mode
4756:     -	1B17  50      			DB	80		;(IK_TIMER)
4757:     -	1B18  8F      			DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
4758:     -	1B19  01      			DB	1		;(DISPLABEL)
4759:     -	1B1A  FF      			DB	-1		;(IK_HEXST)
4760:     -	1B1B  E5FF    			DW	LED_DISPLAY+5	;(HEX_CURSOR) @d6
4761:     -	1B1D  8419    			DW	HEX2MEM		;(HEX_READY)
4762:				
4763:22502+10	1B1F  21E7FF  			LD	HL,LED_ANBAR
4764:22512+15	1B22  CBEE    			SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
4765:22527+15	1B24  CBE6    			SET	4,(HL)		;ANBARLED 4 = Alter
4766:22542+10	1B26  C3DF17  			JP	IKEY_DONE
4767:				
4768:				
4769:				
4770:22552+10	1B29  21CA18  	ICMD_REG	LD	HL,ICMD_WORD	;Switch to WORD Input Mode
4771:22562+16	1B2C  22BEFF  			LD	(KEY_EVENT),HL
4772:22578+10	1B2F  212919  			LD	HL,HEX2REG
4773:22588+16	1B32  22C6FF  			LD	(HEX_READY),HL
4774:22604+10	1B35  21E3FF  			LD	HL,LED_DISPLAY+3 ;@d4
4775:22614+16	1B38  22C4FF  			LD	(HEX_CURSOR),HL
4776:						;LD	A,0x8F
4777:						;LD	(KEYBFMODE),A	;HEX Keyboard
4778:22630+10	1B3B  21E7FF  			LD	HL,LED_ANBAR
4779:22640+15	1B3E  CBEE    			SET	5,(HL)		;ANBARLED 5 = Enter Mem Loc
4780:22655+15	1B40  CBE6    			SET	4,(HL)		;ANBARLED 4 = Alter
4781:22670+10	1B42  C3DF17  			JP	IKEY_DONE
4782:				
4783:22680+7	1B45  FEE7    	ICMD_IO		CP  LOW IDISP_IN_DATA
4784:22687+10	1B47  CA9B19  			JP  Z,	ICMD5
4785:				
4786:22697+17	1B4A  CD1D0C  	ICMD_IO_OUT	CALL	WRITE_BLOCK
4787:     -	1B4D  BAFF    			DW	LDISPMODE	;Where to write
4788:     -	1B4F  0E00    			DW	14		;Bytes to write
4789:     -	1B51  051C    			DW	IDISP_OUT	;(LDISPMODE)
4790:     -	1B53  051C    			DW	IDISP_OUT	;(DISPMODE)
4791:     -	1B55  3819    			DW	ICMD_BYTE	;(KEY_EVENT) Switch to HEX Input Mode
4792:     -	1B57  50      			DB	80		;(IK_TIMER)
4793:     -	1B58  8F      			DB	0x8F		;(KEYBFMODE) HEX Keyboard Mode (F on press)
4794:     -	1B59  00      			DB	0		;(DISPLABEL)
4795:     -	1B5A  FF      			DB	-1		;(IK_HEXST)
4796:     -	1B5B  E5FF    			DW	LED_DISPLAY+5	;(HEX_CURSOR) @d6
4797:     -	1B5D  8F19    			DW	HEX2OUT_PORT	;(HEX_READY)
4798:22714+10	1B5F  21E7FF  			LD	HL,LED_ANBAR
4799:22724+15	1B62  CBDE    			SET	3,(HL)		;ANBARLED 3 = Send Data to Output Port
4800:22739+10	1B64  C3DF17  			JP	IKEY_DONE
4801:				
4802:				
4803:				;============================================================================
4804:				;	LED Display Register
4805:				;============================================================================
4806:22749+17	1B67  CD7714  	IDISP_REG	CALL	LED_HOME
4807:22766+13	1B6A  3A8AFF  			LD	A,(RegPtr)
4808:22779+17	1B6D  CD2E0C  			CALL	GET_REGNAME
4809:22796+17	1B70  CD781C  			CALL	LED_PRINT
4810:22813+10	1B73  21791B  			LD	HL,IDISP_REG_DATA
4811:22823+16	1B76  22BCFF  			LD	(DISPMODE),HL
4812:				
4813:22839+13	1B79  3A8AFF  	IDISP_REG_DATA	LD	A,(RegPtr)	;13 Then Display Data
4814:22852+17	1B7C  CD6D0C  			CALL	GET_REGISTER	;17+169
4815:22869+4	1B7F  7D      			LD	A,L		;4
4816:22873+11	1B80  F5      			PUSH	AF		;11
4817:22884+4	1B81  7C      			LD	A,H		;4
4818:22888+10	1B82  21E3FF  			LD	HL,LED_DISPLAY+3 ;10
4819:22898+17	1B85  CD4A1C  			CALL	LED_PUT_BYTE_HL	;17+165
4820:22915+10	1B88  F1      			POP	AF		;10
4821:22925+17	1B89  CD4A1C  			CALL	LED_PUT_BYTE_HL	;17+165
4822:22942+10	1B8C  21C2FF  			LD	HL,DISPLABEL	;10
4823:22952+11	1B8F  35      			DEC	(HL)		;7
4824:22963+10	1B90  C2E317  			JP NZ,	IDISP_RET	;10   sp=629
4825:22973+10	1B93  21671B  			LD	HL,IDISP_REG
4826:22983+16	1B96  22BCFF  			LD	(DISPMODE),HL
4827:22999+10	1B99  C3E317  			JP 	IDISP_RET
4828:				
4829:				;============================================================================
4830:				;	LED Display Memory Location
4831:				;============================================================================
4832:23009+10	1B9C  21E0FF  	IDISP_MEM	LD	HL,LED_DISPLAY	;First, Display location
4833:23019+13	1B9F  3A89FF  			LD	A,(ABUSS+1)
4834:23032+17	1BA2  CD4A1C  			CALL	LED_PUT_BYTE_HL
4835:23049+13	1BA5  3A88FF  			LD	A,(ABUSS)
4836:23062+17	1BA8  CD4A1C  			CALL	LED_PUT_BYTE_HL
4837:23079+7	1BAB  3E80    			LD	A,0x80		;Blank next char
4838:23086+7	1BAD  77      			LD	(HL),A
4839:23093+10	1BAE  21B41B  			LD	HL,IDISP_MEM_DATA
4840:23103+16	1BB1  22BCFF  			LD	(DISPMODE),HL
4841:									;Then Display DATA
4842:23119+16	1BB4  2A88FF  	IDISP_MEM_DATA	LD	HL,(ABUSS)	;16
4843:23135+17	1BB7  CD45FB  			CALL	GET_MEM
4844:23152+10	1BBA  21E5FF  			LD	HL,LED_DISPLAY+5 ;10
4845:23162+17	1BBD  CD4A1C  			CALL	LED_PUT_BYTE_HL	;17+165
4846:23179+10	1BC0  21C2FF  			LD	HL,DISPLABEL	;10 Repeat Display of Data several times before redisplaying Location
4847:23189+11	1BC3  35      			DEC	(HL)		;7
4848:23200+10	1BC4  C2E317  			JP NZ,	IDISP_RET	;10  st=242
4849:23210+10	1BC7  219C1B  			LD	HL,IDISP_MEM
4850:23220+16	1BCA  22BCFF  			LD	(DISPMODE),HL
4851:23236+10	1BCD  C3E317  			JP 	IDISP_RET
4852:				
4853:				
4854:				;============================================================================
4855:				;	LED Display Input Port
4856:				;============================================================================
4857:23246+17	1BD0  CD8A1C  	IDISP_IN	CALL	LED_HOME_PRINTI
4858:     -	1BD3  696E00  			DB	'in',EOS
4859:23263+13	1BD6  3A8BFF  			LD	A,(IoPtr)
4860:23276+10	1BD9  21E2FF  			LD	HL,LED_DISPLAY+2
4861:23286+17	1BDC  CD4A1C  			CALL	LED_PUT_BYTE_HL
4862:23303+10	1BDF  3680    			LD	(HL),0x80	;Blank d5
4863:23313+10	1BE1  21E71B  			LD	HL,IDISP_IN_DATA
4864:23323+16	1BE4  22BCFF  			LD	(DISPMODE),HL
4865:				
4866:23339+11	1BE7  C5      	IDISP_IN_DATA	PUSH	BC
4867:23350+13	1BE8  3A8BFF  			LD	A,(IoPtr)
4868:23363+4	1BEB  4F      			LD	C,A
4869:23367+12	1BEC  ED78    			IN	A,(C)
4870:23379+10	1BEE  C1      			POP	BC
4871:23389+10	1BEF  21E5FF  			LD	HL,LED_DISPLAY+5
4872:23399+17	1BF2  CD4A1C  			CALL	LED_PUT_BYTE_HL
4873:23416+10	1BF5  21C2FF  			LD	HL,DISPLABEL
4874:23426+11	1BF8  35      			DEC	(HL)
4875:23437+10	1BF9  C2E317  			JP NZ,	IDISP_RET
4876:23447+10	1BFC  21D01B  			LD	HL,IDISP_IN
4877:23457+16	1BFF  22BCFF  			LD	(DISPMODE),HL
4878:23473+10	1C02  C3E317  			JP 	IDISP_RET
4879:				
4880:				
4881:				;============================================================================
4882:				;	LED Display Output Port		cmd 6
4883:				;============================================================================
4884:23483+17	1C05  CD8A1C  	IDISP_OUT	CALL	LED_HOME_PRINTI
4885:     -	1C08  6F7500  			DB	'ou',EOS
4886:23500+13	1C0B  3A8BFF  			LD	A,(IoPtr)
4887:23513+10	1C0E  21E2FF  			LD	HL,LED_DISPLAY+2
4888:23523+17	1C11  CD4A1C  			CALL	LED_PUT_BYTE_HL
4889:23540+10	1C14  3680    			LD	(HL),0x80	;Blank d5
4890:23550+10	1C16  211C1C  			LD	HL,IDISP_OUT_DATA
4891:23560+16	1C19  22BCFF  			LD	(DISPMODE),HL
4892:				
4893:23576+10	1C1C  21C2FF  	IDISP_OUT_DATA	LD	HL,DISPLABEL
4894:23586+11	1C1F  35      			DEC	(HL)
4895:23597+10	1C20  C2E317  			JP NZ,	IDISP_RET
4896:23607+10	1C23  21051C  			LD	HL,IDISP_OUT
4897:23617+16	1C26  22BCFF  			LD	(DISPMODE),HL
4898:23633+10	1C29  C3E317  			JP 	IDISP_RET
4899:				
4900:				;============================================================================
4901:				;	LED Display OFF
4902:				;============================================================================
4903:23643+10	1C2C  21E0FF  	IDISP_OFF	LD	HL,LED_DISPLAY
4904:23653+7	1C2F  3E80    			LD	A,0x80
4905:23660+11	1C31  C5      			PUSH	BC
4906:23671+7	1C32  0608    			LD	B,8
4907:23678+7	1C34  77      	IDO_LP		LD	(HL),A
4908:23685+4	1C35  2C      			INC	L
4909:23689+8+5	1C36  10FC    			DJNZ	IDO_LP
4910:23697+10	1C38  C1      			POP	BC
4911:23707+10	1C39  21E317  			LD	HL,IDISP_RET
4912:23717+16	1C3C  22BCFF  			LD	(DISPMODE),HL
4913:23733+4	1C3F  E9      			JP 	(HL)
4914:				
4915:				;============================================================================
4916:				;	LED Delay	- After a delay for spash screen, display Registers
4917:				;============================================================================
4918:23737+10	1C40  21C2FF  	IDISP_DELAY	LD	HL,DISPLABEL
4919:23747+11	1C43  35      			DEC	(HL)
4920:23758+10	1C44  C2E317  			JP NZ,	IDISP_RET
4921:23768+10	1C47  C3BE17  			JP 	IKC_RESET_CMD
4922:				
4923:				;============================================================================
4924:				;PUTS 2 HEX digits to LED Display
4925:				;Input:	A=BYTE to display
4926:				;	HL=Where to display
4927:				;Output: HL=Next LED Display location
4928:23778+11	1C4A  F5      	LED_PUT_BYTE_HL	PUSH	AF		;11 Save Byte to display (for 2nd HEX digit)
4929:23789+4	1C4B  0F      			RRCA			;4
4930:23793+4	1C4C  0F      			RRCA			;4
4931:23797+4	1C4D  0F      			RRCA			;4
4932:23801+4	1C4E  0F      			RRCA			;4
4933:23805+17	1C4F  CD531C  			CALL	LED_PUT_HEX_HL
4934:23822+10	1C52  F1      			POP	AF		;10
4935:						;CALL	LED_PUT_HEX_HL
4936:						;RET			;10  st=165
4937:				
4938:23832+11	1C53  E5      	LED_PUT_HEX_HL	PUSH	HL
4939:23843+7	1C54  E60F    			AND	0xF
4940:23850+7	1C56  2629    			LD	H,HIGH LED_HEX
4941:23857+4	1C58  6F      			LD	L,A
4942:23861+7	1C59  7E      			LD	A,(HL)		;Fetch LED Font for HEX digit
4943:23868+10	1C5A  E1      			POP	HL
4944:23878+7	1C5B  77      			LD	(HL),A		;Display HEX digit
4945:23885+4	1C5C  2C      			INC	L
4946:23889+8	1C5D  CB9D    			RES	3,L
4947:23897+10	1C5F  C9      			RET
4948:						
4949:23907+11	1C60  E5      	LED_PUT_BYTE	PUSH	HL
4950:23918+16	1C61  2AC8FF  			LD	HL,(LED_CURSOR)
4951:23934+17	1C64  CD4A1C  			CALL	LED_PUT_BYTE_HL
4952:23951+16	1C67  22C8FF  			LD	(LED_CURSOR),HL
4953:23967+10	1C6A  E1      			POP	HL
4954:23977+10	1C6B  C9      			RET
4955:						
4956:23987+11	1C6C  E5      	LED_PUT_HEX	PUSH	HL
4957:23998+16	1C6D  2AC8FF  			LD	HL,(LED_CURSOR)
4958:24014+17	1C70  CD531C  			CALL	LED_PUT_HEX_HL
4959:24031+16	1C73  22C8FF  			LD	(LED_CURSOR),HL
4960:24047+10	1C76  E1      			POP	HL
4961:24057+10	1C77  C9      			RET
4962:						
4963:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4964:				;LED_PRINT -- Print A null-terminated string @(HL)
4965:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4966:24067+11	1C78  F5      	LED_PRINT:	PUSH	AF
4967:24078+11	1C79  C5      			PUSH	BC
4968:24089+7	1C7A  7E      	LED_PRINT_LP	LD	A, (HL)
4969:24096+6	1C7B  23      			INC	HL
4970:24102+4	1C7C  B7      			OR	A
4971:24106+7+5	1C7D  2808    			JR Z,	LED_PRINT_RET
4972:24113+4	1C7F  4F      			LD	C,A
4973:24117+11	1C80  E5      			PUSH	HL
4974:24128+17	1C81  CD8A14  			CALL	PC_LED
4975:24145+10	1C84  E1      			POP	HL
4976:24155+12	1C85  18F3    			JR	LED_PRINT_LP
4977:24167+10	1C87  C1      	LED_PRINT_RET	POP	BC
4978:24177+10	1C88  F1      			POP	AF
4979:24187+10	1C89  C9      			RET
4980:				
4981:				
4982:				
4983:24197+17	1C8A  CD7714  	LED_HOME_PRINTI	CALL	LED_HOME
4984:						
4985:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4986:				;PRINT IMMEDIATE
4987:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
4988:24214+19	1C8D  E3      	LED_PRINTI:	EX	(SP),HL	;HL = Top of Stack
4989:24233+17	1C8E  CD781C  			CALL	LED_PRINT
4990:24250+19	1C91  E3      			EX	(SP),HL	;Move updated return address back to stack
4991:24269+10	1C92  C9      			RET
4992:				
4993:				
4994:				
4995:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
4996:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
4997:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
4998:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
4999:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5000:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5001:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5002:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5003:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5004:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5005:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5006:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5007:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5008:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5009:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5010:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5011:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5012:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5013:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5014:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5015:				;
5016:				;	Chapter_12	S D - C A R D
5017:				;
5018:				;   *******   *******                *******      ***     ********   *******  
5019:				;  *********  ********              *********    *****    *********  ******** 
5020:				;  **         **    ***             **     **   *** ***   **     **  **    ***
5021:				;  **         **     **             **         ***   ***  **     **  **     **
5022:				;   ******    **     **   ******    **         *********  ********   **     **
5023:				;    ******   **     **   ******    **         *********  ********   **     **
5024:				;         **  **     **             **         **     **  **  **     **     **
5025:				;         **  **    ***             **     **  **     **  **   **    **    ***
5026:				;  *********  ********              *********  **     **  **    **   ******** 
5027:				;   *******   *******                *******   **     **  **     **  *******  
5028:				;
5029:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5030:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5031:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5032:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5033:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5034:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5035:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5036:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5037:				
5038:				;String equates
5039:				
5040:24279+4	1C93  F3      	GO_SD_CARD	DI			; Disable Interrupts
5041:				
5042:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5043:				;Init all System RAM, enable interrupts
5044:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
5045:24283+10	1C94  213800  	GSC_INIT	LD	HL,0x0038
5046:24293+10	1C97  113800  			LD	DE,0x0038
5047:24303+10	1C9A  010600  			LD	BC,RST38_LEN
5048:24313+16+5	1C9D  EDB0    			LDIR
5049:				
5050:24329+10	1C9F  2180FB  			LD	HL,SDISKA	;Initialize New Variables for SD-CARD operation & full 64K RAM
5051:24339+16	1CA2  2208FF  			LD	(FCB_PTR),HL
5052:24355+10	1CA5  21F916  			LD	HL,SKIP_HALT_TEST
5053:24365+16	1CA8  22D2FF  			LD	(HALT_TEST),HL
5054:					
5055:24381+17	1CAB  CD1D0C  			CALL	WRITE_BLOCK
5056:     -	1CAE  B3FF    			DW	ANBAR_DEF	;Where to write
5057:     -	1CB0  1000    			DW	16		;Bytes to write
5058:     -	1CB2  82      			DB	0x82		;(ANBAR_DEF) = RUN MODE
5059:     -	1CB3  7C0C    			DW	GET_REG_RUN	;(GET_REG)
5060:     -	1CB5  910C    			DW	PUT_REG_RUN	;(PUT_REG)
5061:     -	1CB7  B217    			DW	CTRL_C_RET	;(CTRL_C_CHK)
5062:     -	1CB9  E317    			DW	IDISP_RET	;(LDISPMODE)
5063:     -	1CBB  E317    			DW	IDISP_RET	;(DISPMODE)
5064:     -	1CBD  4218    			DW	IMON_CMD	;(KEY_EVENT) Initialize to Command Mode
5065:     -	1CBF  01      			DB	1		;(IK_TIMER)
5066:     -	1CC0  90      			DB	0x90		;(KEYBFMODE) HEX Keyboard Mode (F on release)
5067:     -	1CC1  FF      			DB	0xFF		;(DISPLABEL)
5068:				
5069:24398+4	1CC2  FB      			EI			;************** Interrupts ON!!!!
5070:				
5071:24402+17	1CC3  CD8A1C  			CALL	LED_HOME_PRINTI
5072:     -	1CC6  53642D43			DB	"Sd-CARD",EOS
	              41524400
5073:						
5074:24419+17	1CCE  CDDC22  			CALL	INIT_FAT
5075:24436+5+6	1CD1  C0      			RET	NZ		;RETURN IF FAILED
5076:				
5077:24441+17	1CD2  CD1F0E  			CALL	PUT_NEW_LINE
5078:						
5079:24458+7	1CD5  3EC0    			LD	A,0xC0
5080:24465+13	1CD7  320CFF  			LD	(VIEW_FLAGS),A	;View File open/not status & Size
5081:				
5082:									;Filename will be preloaded on auto run
5083:24478+13	1CDA  3A43FF  			LD	A,(FILENAME)	;Check for any Auto Run
5084:24491+4	1CDD  B7      			OR	A
5085:24495+7+5	1CDE  2808    			JR   Z,	SDC_MENU
5086:						
5087:24502+17	1CE0  CDA91D  			CALL	SD_OPEN_FILENAME
5088:24519+7+5	1CE3  2803    			JR Z,	SDC_MENU	;Jump if file not found
5089:24526+17	1CE5  CDC31E  			CALL	READ_HEX_EXEC	;Read & Execute HEX file, Return if Error
5090:				
5091:				;----------------------------------------------------------------------------------------------------; SD MENU
5092:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5093:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5094:				;----------------------------------------------------------------------------------------------------; SD MENU
5095:				
5096:24543+17	1CE8  CDCA0D  	SDC_MENU:	CALL	PRINTI		;Monitor Start, Display Welcome Message
5097:     -	1CEB  0D0A    			DB	CR,LF
5098:     -	1CED  4C202020			DB	"L              LIST FILES",CR,LF
	              20202020
	              20202020
	              2020204C
	              49535420
	              46494C45
	              530D0A
5099:     -	1D08  57202020			DB	"W              WITNESS LOAD",CR,LF
	              20202020
	              20202020
	              20202057
	              49544E45
	              5353204C
	              4F41440D
	              0A
5100:     -	1D25  3F203E00			DB	"? >",EOS
5101:				
5102:24560+17	1D29  CDE013  			CALL 	GET_CHAR	;get char
5103:24577+7	1D2C  FE1B    			CP	27
5104:24584+5+6	1D2E  C8      			RET	Z		;MAIN MENU
5105:24589+7	1D2F  E65F    			AND 	0x5F		;to upper case
5106:24596+7	1D31  FE4C    			CP	'L'
5107:24603+7+5	1D33  2815    			JR Z,	DO_DIR		; L = List Files
5108:24610+7	1D35  FE57    			CP	'W'
5109:24617+7+5	1D37  2802    			JR Z,	BOOT_SDVIEW	; W = Witness Load
5110:24624+12	1D39  18AD    			JR	SDC_MENU	
5111:				
5112:				;=============================================================================
5113:24636+10	1D3B  210CFF  	BOOT_SDVIEW	LD	HL,VIEW_FLAGS	;BIT .0=View HEX Load
5114:24646+15	1D3E  CBC6    			SET	0,(HL)
5115:24661+17	1D40  CDCA0D  			CALL 	PRINTI
5116:     -	1D43  202D4F4E			DB	" -ON",EOS
	              00
5117:24678+12	1D48  189E    			JR	SDC_MENU	
5118:							
5119:				;=============================================================================
5120:24690+17	1D4A  CD5E1D  	DO_DIR		CALL	PRINT_DIR
5121:24707+17	1D4D  CD2A21  			CALL	INPUT_FILENAME
5122:24724+5+6	1D50  D8      			RET	C		;Return to Menu if <Esc>
5123:24729+17	1D51  CD1F0E  			CALL	PUT_NEW_LINE
5124:24746+17	1D54  CDA91D  			CALL	SD_OPEN_FILENAME
5125:24763+7+5	1D57  28F1    			JR Z,	DO_DIR		;Jump if file not found
5126:24770+17	1D59  CDC31E  			CALL	READ_HEX_EXEC	;Read & Execute HEX file, Return if Error
5127:24787+12	1D5C  18EC    			JR	DO_DIR
5128:				
5129:				
5130:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5131:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5132:				;	Chapter_13	FILE operations
5133:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5134:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5135:				
5136:				;=============================================================================
5137:				;		Destroys A,B,C,IX
5138:				;-----------------------------------------------------------------------------
5139:24799+17	1D5E  CDCA0D  	PRINT_DIR	CALL	PRINTI
5140:     -	1D61  0D0A5C44			DB CR,LF,"\DIRECTORY:",CR,LF,EOS
	              49524543
	              544F5259
	              3A0D0A00
5141:24816+17	1D71  CDCB20  			CALL	SD_LDIR1
5142:24833+5+6	1D74  C8      	SDLF_LP 	RET	Z			;End of list
5143:24838+7	1D75  7E      			LD	A,(HL)
5144:24845+7	1D76  FE21    			CP	33
5145:24852+10	1D78  FAA41D  			JP M,	DD_NEXT
5146:24862+7	1D7B  FE7F    			CP	127
5147:24869+10	1D7D  F2A41D  			JP P,	DD_NEXT
5148:24879+11	1D80  E5      			PUSH	HL			;Test if starting cluster is 0, skip file
5149:24890+14	1D81  DDE1    			POP	IX
5150:24904+19	1D83  DD7E1A  			LD	A,(IX+1Ah)
5151:24923+19	1D86  DDB61B  			OR	(IX+1Bh)
5152:24942+10	1D89  CAA41D  			JP Z,	DD_NEXT
5153:				
5154:24952+17	1D8C  CD0521  			CALL	PRINT_FILENAME
5155:						
5156:24969+17	1D8F  CDCD13  			CALL	GET_POS		;Get output position (counted characters after CR)
5157:24986+7	1D92  FE40    			CP	64
5158:24993+10+7	1D94  F41F0E  			CALL P,	PUT_NEW_LINE
5159:25003+17	1D97  CDCD13  	DD_TAB_LP	CALL	GET_POS		;TAB OUT 16 CHARS
5160:25020+7	1D9A  E60F    			AND	0Fh
5161:25027+10	1D9C  CAA41D  			JP Z,	DD_NEXT
5162:25037+17	1D9F  CD190E  			CALL	PUT_SPACE
5163:25054+12	1DA2  18F3    			JR	DD_TAB_LP
5164:				
5165:25066+17	1DA4  CDE020  	DD_NEXT		CALL	SD_LDIRN
5166:25083+12	1DA7  18CB    			JR	SDLF_LP
5167:				
5168:				
5169:				;=============================================================================
5170:				;Open File	Enter with FILENAME set and FCB_PTR set to desired FCB
5171:				;		EXIT Z=1 If File Not Found
5172:				;-----------------------------------------------------------------------------
5173:25095+16	1DA9  2A08FF  	SD_OPEN_FILENAME LD	HL,(FCB_PTR)
5174:25111+6	1DAC  23      			INC	HL		;+1 = FNAME
5175:25117+4	1DAD  EB      			EX	DE,HL		
5176:25121+10	1DAE  2143FF  			LD	HL,FILENAME	;Write FILENAME to FCB
5177:25131+10	1DB1  010B00  			LD	BC,11
5178:25141+16+5	1DB4  EDB0    			LDIR
5179:				
5180:				;=============================================================================
5181:				;Open File	Enter with FCB_PTR set to desired FCB
5182:				;		EXIT Z=1 If File Not Found
5183:				;-----------------------------------------------------------------------------
5184:25157+16	1DB6  2A08FF  	SD_OPEN		LD	HL,(FCB_PTR)
5185:25173+10	1DB9  3600    			LD	(HL),0		;FSTAT=0, Clear Open Status
5186:25183+6	1DBB  23      			INC	HL		;+1 = FNAME
5187:25189+10	1DBC  1143FF  			LD	DE,FILENAME	;Write FCB Name to FILENAME
5188:25199+10	1DBF  010B00  			LD	BC,11
5189:25209+16+5	1DC2  EDB0    			LDIR		
5190:25225+17	1DC4  CD8B20  			CALL	SDV_FIND_FILE	;HL = Directory Entry  ;PRINT FILE NAME, FOUND OR NOT
5191:25242+5+6	1DC7  C8      			RET	Z		;Exit if file not found
5192:				
5193:				;FAT-16 Directory Entry
5194:				; 46 44 49 53 4b 20 20 20 45 58 45 20 00 00 00 00  FDISK   .EXE
5195:				; 00 00 00 00 00 00 36 59 62 1b 02 00 17 73 00 00
5196:				;
5197:				;Bytes   Content
5198:				;0-10    File name (8 bytes) with extension (3 bytes)
5199:				;11      Attribute - a bitvector. Bit 0: read only. Bit 1: hidden.
5200:				;        Bit 2: system file. Bit 3: volume label. Bit 4: subdirectory.
5201:				;        Bit 5: archive. Bits 6-7: unused.
5202:				;12-21   Reserved (see below)
5203:				;22-23   Time (5/6/5 bits, for hour/minutes/doubleseconds)
5204:				;24-25   Date (7/4/5 bits, for year-since-1980/month/day)
5205:				;26-27   Starting cluster (0 for an empty file)
5206:				;28-31   Filesize in bytes
5207:				;
5208:				;Z80MC FCB
5209:				;
5210:				;SDFCB:
5211:				;FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
5212:				;FNAME		EQU	1	;DS 11	;+1  File name
5213:				;AFClus0	EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
5214:				;CRFClus (FFFF)	EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
5215:				;CAFClus (FFFF)	EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
5216:				;RFSec	 (FFFF)	EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
5217:				;SSOC	 (FF's)	EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
5218:				;ABS_SEC (FF's)	EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
5219:				;FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)
5220:				
5221:				
5222:25247+11	1DC8  E5      	SDO_DO		PUSH	HL		;HL Points to FAT Directory Entry
5223:25258+10	1DC9  011C00  			LD	BC,1Ch		;File Size Offset (into Directory Entry)
5224:25268+11	1DCC  09      			ADD	HL,BC
5225:25279+4	1DCD  EB      			EX	DE,HL
5226:25283+16	1DCE  2A08FF  			LD	HL,(FCB_PTR)	;HL=FCB
5227:25299+11	1DD1  09      			ADD	HL,BC		;1C is also the offset for FSIZE
5228:25310+11	1DD2  E5      			PUSH	HL
5229:25321+4	1DD3  EB      			EX	DE,HL
5230:25325+17	1DD4  CD3E27  			CALL	MOV_32_HL	;Move (HL) to 32 bit register BCDE, Fetch File Size
5231:25342+10	1DD7  214EFF  			LD	HL,FILESIZE
5232:25352+17	1DDA  CD4927  			CALL	MOV_HL_32	;Save 32 bits to RAM at HL (FILESIZE)
5233:25369+10	1DDD  E1      			POP	HL		;HL = FCB.FSIZE
5234:25379+17	1DDE  CD4927  			CALL	MOV_HL_32	;Save 32 bits to RAM at HL (FCB)
5235:25396+10	1DE1  E1      			POP	HL
5236:				
5237:25406+10	1DE2  011A00  			LD	BC,1Ah		;H=(START CLUSTER)
5238:25416+11	1DE5  09      			ADD	HL,BC
5239:25427+17	1DE6  CD4A0E  			CALL	LD_HL_HL	;Fetch Starting Custer
5240:25444+4	1DE9  EB      			EX	DE, HL		;DE=Starting Cluster
5241:25448+16	1DEA  2A08FF  			LD	HL,(FCB_PTR)	;HL=FCB
5242:25464+10	1DED  3601    			LD	(HL),1		;FSTAT=1
5243:25474+10	1DEF  010C00  			LD	BC,AFClus0 	;offset to AFClus0
5244:25484+11	1DF2  09      			ADD	HL,BC
5245:25495+7	1DF3  73      			LD	(HL),E		;Save Starting Cluster
5246:25502+6	1DF4  23      			INC	HL
5247:25508+7	1DF5  72      			LD	(HL),D
5248:25515+6	1DF6  23      			INC	HL
5249:25521+7	1DF7  060E    			LD	B,14
5250:25528+7	1DF9  3EFF    			LD	A,0FFH
5251:25535+17	1DFB  CD160C  			CALL	FILL_BLOCK	;Fill 14 bytes of FF (Nuke pointers to force new calculations)
5252:						
5253:25552+13	1DFE  3A0CFF  			LD	A,(VIEW_FLAGS)	;BIT .0=View HEX Load, .6=FILE SIZE
5254:25565+8	1E01  CB77    			BIT	6,A
5255:25573+7+5	1E03  281D    			JR  Z,	SDO_RET
5256:						
5257:25580+17	1E05  CDCA0D  			CALL	PRINTI
5258:     -	1E08  2046494C			DB 	" FILE SIZE=0x",EOS
	              45205349
	              5A453D30
	              7800
5259:25597+16	1E16  2A50FF  			LD	HL, (FILESIZE+2)
5260:25613+17	1E19  CDEA0D  			CALL	PUT_HL
5261:25630+16	1E1C  2A4EFF  			LD	HL, (FILESIZE)
5262:25646+17	1E1F  CDEA0D  			CALL	PUT_HL
5263:									
5264:25663+16	1E22  2A08FF  	SDO_RET		LD	HL,(FCB_PTR)	;HL=FCB
5265:25679+7	1E25  F6FF    			OR	0FFh		;Clear Z
5266:25686+10	1E27  C9      			RET
5267:						
5268:				
5269:				;=============================================================================
5270:				;LINE INPUT	Enter with FCB_PTR set to desired FCB
5271:				;		(Recently opened so pointers will be initialized)
5272:				;		if Relative Cluster = 0xFFFF (new open), pointer will init to start of file.
5273:				;		Output Z=1 if EOF, HL=FCB_PTR
5274:				;		Z=0, HL=Pointer to Line Buffer
5275:				;		BC, DE nuked
5276:				;		LOGICAL_SEC is used/nuked
5277:				;-----------------------------------------------------------------------------
5278:25696+16	1E28  2A08FF  	LINE_INPUT	LD	HL,(FCB_PTR)	;Test FSTAT for EOF, marked in FCB Status
5279:25712+12	1E2B  CB7E    			BIT	7,(HL)
5280:25724+5+6	1E2D  C0      			RET	NZ		;Exit if EOF
5281:									;Test for newly opened file
5282:25729+10	1E2E  010E00  			LD	BC,14		; check Current Relative Cluster <> FFFF
5283:25739+11	1E31  09      			ADD	HL,BC
5284:25750+7	1E32  3EFF    			LD	A,0xFF
5285:25757+7	1E34  BE      			CP	(HL)
5286:25764+7+5	1E35  201F    			JR NZ,	LI_TP		;Jump if file was read from
5287:25771+6	1E37  23      			INC	HL
5288:25777+7	1E38  BE      			CP	(HL)
5289:25784+7+5	1E39  201B    			JR NZ,	LI_TP		;Jump if file was read from
5290:									;File has not yet been read...
5291:25791+10	1E3B  010D00  			LD	BC, 28-15	;Advance to File Size
5292:25801+11	1E3E  09      			ADD	HL,BC
5293:25812+10	1E3F  1182FA  			LD	DE,LI_FILESIZE	;Init LI_FILESIZE with max count of bytes to read
5294:25822+10	1E42  010400  			LD	BC,4
5295:25832+16+5	1E45  EDB0    			LDIR			;Copy File Size to Byte counter
5296:				
5297:25848+10	1E47  210000  			LD	HL,0		;Start at first Logical Sector
5298:25858+16	1E4A  2288FA  			LD	(LI_SDLOG_SEC),HL
5299:25874+16	1E4D  220DFF  			LD	(LOGICAL_SEC),HL
5300:									;FCB_PTR = FILE TO READ
5301:25890+17	1E50  CD8821  			CALL	DISK_READ	;HL=BUFF
5302:25907+16	1E53  2286FA  			LD	(LI_SDBUFF_PTR),HL	;Save Disk Buffer pointer
5303:						
5304:25923+17	1E56  CDBA1E  	LI_TP		CALL	CLEAR_LINE_BUFF
5305:				
5306:25940+20	1E59  ED4B82FA			LD	BC,(LI_FILESIZE) ;Low 16bits of Filesize counter (32bit)
5307:25960+10	1E5D  1100FA  			LD	DE, LINE_BUFF	;Data desination @DE
5308:25970+16	1E60  2A86FA  			LD	HL,(LI_SDBUFF_PTR) ;Data source (SD BUFFER)
5309:				
5310:25986+17	1E63  CDA21E  	LI_LP		CALL	LI_GETDATA	;Fetch byte from SD_RAMBUFFER @HL
5311:									;Advances to read next logical sector if HL>BUFF_SIZE
5312:						
5313:26003+16	1E66  EDA0    	LI_1		LDI			;COPY A BYTE.  (DE)=(HL), INC HL, INC DE, DEC BC
5314:26019+10	1E68  EA811E  			JP PE,	LI_2		;Jump if BC>0, Not at End of File possible
5315:						
5316:									;BC=0
5317:26029+11	1E6B  E5      			PUSH	HL		
5318:26040+16	1E6C  2A84FA  			LD	HL,(LI_FILESIZE+2) ;Check upper 32 bits for 0 or decrement size.
5319:26056+4	1E6F  37      			SCF
5320:26060+15	1E70  ED42    			SBC	HL,BC		;HL=HL-0000-1 (HL=HL-1 with *Borrow*)
5321:26075+7+5	1E72  3009    			JR NC,	LI_1B
5322:26082+4	1E74  EB      			EX	DE,HL
5323:26086+16	1E75  2A08FF  			LD	HL,(FCB_PTR)
5324:26102+15	1E78  CBFE    			SET	7,(HL)		;SET FSTAT EOF FLAG
5325:26117+10	1E7A  E1      			POP	HL
5326:26127+12	1E7B  1819    			JR	LI_EOL
5327:						
5328:						
5329:26139+16	1E7D  2284FA  	LI_1B		LD	(LI_FILESIZE+2),HL
5330:26155+10	1E80  E1      			POP	HL
5331:					
5332:26165+7	1E81  FE0D    	LI_2		CP	CR		;Test for CR
5333:26172+7+5	1E83  2008    			JR NZ,	LI_3
5334:									;If CR, check if next char is LF
5335:26179+17	1E85  CDA21E  			CALL	LI_GETDATA	;Look ahead to next char
5336:26196+7	1E88  FE0A    			CP	LF
5337:26203+7+5	1E8A  200A    			JR NZ,	LI_EOL		;NO LF? Consider the CR as EOL
5338:26210+4	1E8C  3C      			INC	A		;Nuke the LF
5339:							
5340:26214+7	1E8D  FE0A    	LI_3		CP	LF		;Test if LF
5341:26221+7+5	1E8F  2805    			JR Z,	LI_EOL		;Jump if LF char copied
5342:26228+7	1E91  3E80    	LI_4		LD	A,LOW LINE_BUFFEND
5343:26235+4	1E93  BB      			CP	E
5344:26239+7+5	1E94  20CD    			JR NZ,	LI_LP
5345:				
5346:26246+16	1E96  2286FA  	LI_EOL		LD	(LI_SDBUFF_PTR),HL	;Save SD_READ_BUFFER POINTER for next line
5347:26262+20	1E99  ED4382FA			LD	(LI_FILESIZE),BC ;Save count down for next line
5348:26282+10	1E9D  2100FA  			LD	HL, LINE_BUFF	;Return with HL=LINE_BUFF
5349:26292+4	1EA0  AF      			XOR	A		;Z=1
5350:26296+10	1EA1  C9      			RET
5351:				
5352:26306+4	1EA2  7C      	LI_GETDATA	LD	A,H		;Check for SD buffer over bounds
5353:26310+7	1EA3  FEFE    			CP	HIGH (SD_RAM_BUFFER + 0x200)
5354:26317+7	1EA5  7E      			LD	A,(HL)
5355:26324+5+6	1EA6  C0      			RET	NZ
5356:26329+16	1EA7  2A88FA  			LD	HL,(LI_SDLOG_SEC) ;Read next 512 sector from file
5357:26345+6	1EAA  23      			INC	HL
5358:26351+16	1EAB  2288FA  			LD	(LI_SDLOG_SEC),HL
5359:26367+16	1EAE  220DFF  			LD	(LOGICAL_SEC),HL
5360:26383+11	1EB1  C5      			PUSH	BC
5361:26394+11	1EB2  D5      			PUSH	DE
5362:26405+17	1EB3  CD8821  			CALL	DISK_READ	;HL=BUFF
5363:26422+10	1EB6  D1      			POP	DE
5364:26432+10	1EB7  C1      			POP	BC
5365:26442+7	1EB8  7E      			LD	A,(HL)
5366:26449+10	1EB9  C9      			RET
5367:				
5368:26459+10	1EBA  2100FA  	CLEAR_LINE_BUFF	LD	HL,LINE_BUFF	;Clear LINE_BUFF
5369:26469+7	1EBD  0682    			LD	B, LOW (LINE_BUFFEND - LINE_BUFF) +2
5370:26476+17	1EBF  CD100C  			CALL	CLEAR_BLOCK	;LINE FULL OF EOS
5371:26493+10	1EC2  C9      			RET
5372:				
5373:				;=============================================================================
5374:				;	Read a HEX file and execute it
5375:				;-----------------------------------------------------------------------------
5376:26503+10	1EC3  21281E  	READ_HEX_EXEC	LD	HL,LINE_INPUT
5377:26513+16	1EC6  225BFF  			LD	(HEX_SOURCE),HL
5378:				
5379:26529+17	1EC9  CDF41E  			CALL	READ_HEX_FILE
5380:26546+5+6	1ECC  D8      			RET	C		;CY=1 ERROR encountered
5381:				
5382:26551+13	1ECD  3A0CFF  			LD	A, (VIEW_FLAGS)	;When veiwing load, prompt EXECUTE
5383:26564+4	1ED0  0F      			RRCA
5384:26568+10	1ED1  D23220  			JP  NC,	GH_EXEC
5385:				
5386:26578+17	1ED4  CDCA0D  			CALL	PRINTI		;End of File Reached
5387:     -	1ED7  0D0A2D45			DB CR,LF,"-EOF-"
	              4F462D
5388:     -	1EDE  0D0A4578			DB CR,LF,"Execute?",EOS
	              65637574
	              653F00
5389:						
5390:26595+17	1EE9  CDE013  			CALL	GET_CHAR
5391:26612+7	1EEC  E65F    			AND 	0x5F		;to upper case
5392:26619+7	1EEE  FE59    			CP	'Y'
5393:26626+10	1EF0  CA3220  			JP Z,	GH_EXEC
5394:26636+10	1EF3  C9      			RET	
5395:				
5396:				
5397:				
5398:				;=============================================================================
5399:				;	Read a HEX file
5400:				;Input:	HEX_SOURCE must point to the routine that will fill LINE_BUFF with the next line
5401:				;Output	CY=1 ERROR encountered,  Z=0 Time Out
5402:				;-----------------------------------------------------------------------------
5403:26646+17	1EF4  CD8A1C  	READ_HEX_FILE	CALL	LED_HOME_PRINTI
5404:     -	1EF7  464C2000			DB	'FL ',EOS
5405:26663+10	1EFB  210000  			LD	HL, 0		;Zero Line Counter
5406:26673+16	1EFE  228AFA  			LD	(RHF_LINES),HL
5407:						
5408:				
5409:26689+16	1F01  2A5BFF  	RHF_LOOP	LD	HL,(HEX_SOURCE)
5410:26705+17	1F04  CDA00C  			CALL	VCALL_HL	;JP	(HL)
5411:26722+4	1F07  37      			SCF
5412:26726+4	1F08  3F      			CCF			;CY=0
5413:26730+5+6	1F09  C0      			RET	NZ		;Exit if Z=1 (End of File or Serial Time Out)
5414:								
5415:26735+16	1F0A  2A8AFA  			LD	HL, (RHF_LINES)	;Increment Line Counter
5416:26751+6	1F0D  23      			INC	HL
5417:26757+16	1F0E  228AFA  			LD	(RHF_LINES),HL
5418:						
5419:26773+4	1F11  7C      			LD	A,H		;Display line on LED
5420:26777+4	1F12  45      			LD	B,L
5421:26781+10	1F13  21E3FF  			LD	HL,LED_DISPLAY+3
5422:26791+17	1F16  CD4A1C  			CALL	LED_PUT_BYTE_HL
5423:26808+4	1F19  78      			LD	A,B
5424:26812+17	1F1A  CD4A1C  			CALL	LED_PUT_BYTE_HL
5425:						
5426:26829+13	1F1D  3A0CFF  			LD	A, (VIEW_FLAGS)	;BIT .0=View HEX Load, .6=FILE SIZE
5427:26842+4	1F20  0F      			RRCA
5428:26846+7+5	1F21  3006    			JR  NC,	RHF_DO
5429:						
5430:26853+10	1F23  2100FA  			LD	HL, LINE_BUFF	;Reload HL
5431:26863+17	1F26  CDBD0D  			CALL	PRINT		
5432:								
5433:26880+17	1F29  CD301F  	RHF_DO		CALL	RHF_LINE	;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
5434:26897+5+6	1F2C  D8      			RET	C		;CY=1 ERROR encountered
5435:26902+7+5	1F2D  20D2    			JR  NZ,	RHF_LOOP	;Z=1 when End Of File record encountered
5436:26909+10	1F2F  C9      			RET
5437:						
5438:				;-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
5439:26919+10	1F30  2100FA  	RHF_LINE	LD	HL, LINE_BUFF	;Reload HL
5440:26929+7	1F33  7E      			LD	A,(HL)
5441:26936+7	1F34  FE3A    			CP	':'		;Step 0, look for colon
5442:26943+7+5	1F36  280F    			JR Z,	RHF_OK1
5443:				
5444:26950+4	1F38  B7      			OR	A		;If LINE BLANK then EOF
5445:26954+5+6	1F39  C8      			RET	Z		;Z=1,CY=0 EOF
5446:				
5447:26959+17	1F3A  CDCA0D  			CALL	PRINTI
5448:     -	1F3D  0D0A434F			DB CR,LF,"COLON",EOS
	              4C4F4E00
5449:26976+12	1F45  1847    			JR	RHF_ERR_ON_LINE
5450:				
5451:26988+11	1F47  E5      	RHF_OK1		PUSH	HL
5452:26999+10	1F48  D1      			POP	DE		;DE=HL=LINE_BUFF
5453:27009+7	1F49  0E00    			LD	C,0		;Convert remaining HEX characters to Binary values
5454:27016+7	1F4B  0602    	RHF_BYTE_LP2	LD	B,2
5455:27023+6	1F4D  23      	RHF_BYTE_LP	INC	HL		;
5456:27029+7	1F4E  7E      			LD	A,(HL)
5457:27036+17	1F4F  CD980D  			CALL	ASC2HEX		;Process LSD char
5458:27053+7+5	1F52  380C    			JR C,	RHF_NOT_HEX
5459:27060+4	1F54  EB      			EX	DE,HL
5460:27064+18	1F55  ED6F    			RLD			;Shift digit to LINE_BUFF @ DE
5461:27082+4	1F57  EB      			EX	DE,HL
5462:27086+8+5	1F58  10F3    			DJNZ	RHF_BYTE_LP	;Repeat for 2 HEX digits
5463:27094+7	1F5A  1A      			LD	A,(DE)		;Update Checksum
5464:27101+4	1F5B  81      			ADD	A,C
5465:27105+4	1F5C  4F      			LD	C,A
5466:27109+6	1F5D  13      			INC	DE
5467:27115+12	1F5E  18EB    			JR	RHF_BYTE_LP2	;Repeat for all HEX pairs
5468:						
5469:27127+17	1F60  CD2C20  	RHF_NOT_HEX	CALL	IS_CRLF		;Test if final char is CR or LF
5470:27144+7+5	1F63  2814    			JR Z,	RHF_OK2
5471:					
5472:27151+17	1F65  CDCA0D  			CALL	PRINTI
5473:     -	1F68  0D0A494E			DB CR,LF,"INVALID CHAR",EOS
	              56414C49
	              44204348
	              415200
5474:27168+12	1F77  1815    			JR	RHF_ERR_ON_LINE
5475:				
5476:27180+4	1F79  05      	RHF_OK2		DEC	B
5477:27184+4	1F7A  05      			DEC	B
5478:27188+7+5	1F7B  282F    			JR Z,	RHF_OK3
5479:27195+17	1F7D  CDCA0D  			CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
5480:     -	1F80  0D0A4845			DB CR,LF,"HEX PAIRING",EOS
	              58205041
	              4952494E
	              4700
5481:						;JR	RHF_ERR_ON_LINE
5482:						
5483:27212+17	1F8E  CDCA0D  	RHF_ERR_ON_LINE	CALL	PRINTI
5484:     -	1F91  20455252			DB " ERROR ON LINE# 0x",EOS
	              4F52204F
	              4E204C49
	              4E452320
	              307800
5485:27229+16	1FA4  2A8AFA  			LD	HL, (RHF_LINES)
5486:27245+17	1FA7  CDEA0D  			CALL	PUT_HL
5487:27262+4	1FAA  37      			SCF			;Return with ERROR
5488:27266+10	1FAB  C9      			RET			;Z=?,CY=1 ERROR
5489:				
5490:				
5491:27276+13	1FAC  3A00FA  	RHF_OK3		LD	A,(LINE_BUFF)	;Get Size of HEX line
5492:27289+4	1FAF  7B      			LD	A,E		;Get number of bytes processed from hex line
5493:27293+7	1FB0  D600    			SUB	LOW LINE_BUFF
5494:27300+10	1FB2  2100FA  			LD	HL,LINE_BUFF
5495:27310+7	1FB5  96      			SUB	(HL)		;Subtract the number of bytes indicated in the HEX Line
5496:27317+7	1FB6  FE05    			CP	5
5497:27324+7+5	1FB8  280E    			JR Z,	RHF_OK4
5498:27331+17	1FBA  CDCA0D  			CALL	PRINTI		;
5499:     -	1FBD  0D0A4C45			DB CR,LF,"LENGTH",EOS
	              4E475448
	              00
5500:27348+12	1FC6  18C6    			JR	RHF_ERR_ON_LINE
5501:						
5502:				; LLAAAAFF000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1FXX
5503:				;:200000000000000000000000000000000000000000000000000000000000000000000000E0
5504:				;
5505:				;Length is 0x20 bytes, total line length is then 0x25 (len+add+field+data+chksum)  1+2+1+20+1
5506:				
5507:27360+4	1FC8  79      	RHF_OK4		LD	A,C
5508:27364+4	1FC9  B7      			OR	A
5509:27368+7+5	1FCA  2810    			JR Z,	RHF_OK5
5510:27375+17	1FCC  CDCA0D  			CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
5511:     -	1FCF  0D0A4348			DB CR,LF,"CHECKSUM",EOS
	              45434B53
	              554D00
5512:27392+12	1FDA  18B2    			JR	RHF_ERR_ON_LINE
5513:				
5514:27404+10	1FDC  2103FA  	RHF_OK5		LD	HL,LINE_BUFF+3	;FIELD TYPE
5515:27414+7	1FDF  7E      			LD	A,(HL)
5516:27421+4	1FE0  B7      			OR	A
5517:27425+7+5	1FE1  2829    			JR Z,	RHF_OK6
5518:27432+4	1FE3  3D      			DEC	A
5519:27436+5+6	1FE4  C8      			RET	Z		;Z=1,CY=0 EOF
5520:27441+17	1FE5  CDCA0D  			CALL	PRINTI		;If B<>2 then there was a PAIRING error of HEX Digits
5521:     -	1FE8  0D0A554E			DB CR,LF,"UNKNOWN RECORD TYPE, IGNORED",EOS
	              4B4E4F57
	              4E205245
	              434F5244
	              20545950
	              452C2049
	              474E4F52
	              454400
5522:27458+17	2007  CD8E1F  			CALL	RHF_ERR_ON_LINE
5523:27475+12	200A  181D    			JR	RHF_DO_NEXTL
5524:						
5525:27487+6	200C  2B      	RHF_OK6		DEC	HL		;ADDRESS (BIG ENDIAN)
5526:27493+7	200D  5E      			LD	E,(HL)
5527:27500+6	200E  2B      			DEC	HL
5528:27506+7	200F  56      			LD	D,(HL)
5529:						
5530:27513+6	2010  2B      			DEC	HL		;Length
5531:27519+7	2011  7E      			LD	A,(HL)
5532:27526+4	2012  4F      			LD	C,A
5533:27530+7	2013  0600    			LD	B,0
5534:				
5535:27537+10	2015  210CFF  			LD	HL, VIEW_FLAGS
5536:27547+12	2018  CB4E    			BIT	1,(HL)
5537:27559+10	201A  C22420  			JP  NZ,	RHF_OK7
5538:27569+15	201D  CBCE    			SET	1,(HL)
5539:27584+4	201F  EB      			EX	DE,HL
5540:27588+16	2020  220AFF  			LD	(GH_START), HL
5541:27604+4	2023  EB      			EX	DE,HL
5542:				
5543:27608+10	2024  2104FA  	RHF_OK7		LD	HL,LINE_BUFF+4	;DATA
5544:27618+16+5	2027  EDB0    			LDIR
5545:27634+4	2029  AF      	RHF_DO_NEXTL	XOR	A
5546:27638+4	202A  3D      			DEC	A
5547:27642+10	202B  C9      			RET			;Z=0,CY=0 IGNORE
5548:				
5549:				
5550:27652+7	202C  FE0D    	IS_CRLF		CP	CR
5551:27659+5+6	202E  C8      			RET 	Z
5552:27664+7	202F  FE0A    			CP	LF
5553:27671+10	2031  C9      			RET
5554:				
5555:27681+13	2032  3A0CFF  	GH_EXEC		LD	A, (VIEW_FLAGS)
5556:27694+8	2035  CB4F    			BIT	1,A
5557:27702+7+5	2037  2020    			JR NZ,	GH_EXEC_GO
5558:27709+17	2039  CDCA0D  			CALL	PRINTI
5559:     -	203C  0D0A2121			DB CR,LF,"!!! START ADDRESS NOT SET",EOS
	              21205354
	              41525420
	              41444452
	              45535320
	              4E4F5420
	              53455400
5560:27726+10	2058  C9      			RET
5561:				
5562:27736+16	2059  2A0AFF  	GH_EXEC_GO	LD	HL, (GH_START)	;HL = JUMP ADDRESS
5563:27752+17	205C  CDCA0D  	GH_EXEC_GO2	CALL	PRINTI
5564:     -	205F  0D0A4578			DB CR,LF,"Execute at:",EOS
	              65637574
	              65206174
	              3A00
5565:						
5566:27769+17	206D  CDEA0D  			CALL	PUT_HL
5567:27786+17	2070  CD1F0E  			CALL	PUT_NEW_LINE
5568:				
5569:27803+11	2073  E5      			PUSH	HL
5570:27814+10	2074  218320  			LD	HL,HR_EXEC_GO_SUB	;Copy from
5571:27824+10	2077  1153FB  			LD	DE,HR_EXE_GO		;Copy to
5572:27834+10	207A  010800  			LD	BC,HR_EXEC_GS_LEN	;Length=11 bytes
5573:27844+16+5	207D  EDB0    			LDIR
5574:27860+10	207F  E1      			POP	HL
5575:27870+10	2080  C353FB  			JP	HR_EXE_GO
5576:				
5577:27880+7	2083  3E01    	HR_EXEC_GO_SUB	LD	A,1
5578:27887+13	2085  32D9FF  			LD	(RRSTATE),A
5579:27900+11	2088  D3C1    			OUT	(RAMROM),A
5580:27911+4	208A  E9      			JP	(HL)	;Execute the Get HEX
5581:				
5582:     -	0008          	HR_EXEC_GS_LEN	EQU	$-HR_EXEC_GO_SUB
5583:				
5584:				
5585:				
5586:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5587:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5588:				;	Chapter_14	FILE Support Routines
5589:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
5590:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
5591:				
5592:				;=============================================================================
5593:						;Find File w/ Verbose Output
5594:						;Call with File Name set in FILENAME.EXT
5595:						;Return Z=1 File Not Found
5596:						;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
5597:						;Destroys A,B,C
5598:27915+13	208B  3A0CFF  	SDV_FIND_FILE	LD	A,(VIEW_FLAGS)	;BIT .0=View HEX Load, .6=Display FILE SIZE, .7=Display File name & Found or Not
5599:27928+4	208E  07      			RLCA
5600:27932+7+5	208F  302C    			JR NC,	SD_FIND_FILE	;Call the Find File routine
5601:27939+10	2091  2143FF  			LD	HL,FILENAME
5602:27949+17	2094  CD0521  			CALL	PRINT_FILENAME
5603:27966+17	2097  CDBD20  			CALL	SD_FIND_FILE	;Call the Find File routine
5604:27983+11	209A  F5      			PUSH	AF
5605:27994+10	209B  C2AF20  			JP NZ,	SDV_FOUND	;Print Yah or Nah
5606:28004+17	209E  CDCA0D  			CALL 	PRINTI
5607:     -	20A1  202D4E4F			DB " -NOT FOUND",EOS
	              5420464F
	              554E4400
5608:28021+10	20AD  F1      			POP	AF
5609:28031+10	20AE  C9      			RET
5610:28041+17	20AF  CDCA0D  	SDV_FOUND	CALL 	PRINTI
5611:     -	20B2  202D4558			DB " -EXISTS",EOS
	              49535453
	              00
5612:28058+10	20BB  F1      			POP	AF
5613:28068+10	20BC  C9      			RET
5614:				
5615:				;=============================================================================
5616:						;Find File
5617:						;Call with File Name set in RAM variable: FILENAME.EXT
5618:						;Return Z=1 File Not Found
5619:						;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
5620:28078+17	20BD  CDCB20  	SD_FIND_FILE	CALL	SD_LDIR1
5621:28095+5+6	20C0  C8      	SDFF_LP 	RET Z			;End of list
5622:28100+17	20C1  CD6321  			CALL	CMP_FILENAME	;Compares file name at (HL) with FILENAME.EXT in RAM
5623:28117+5+6	20C4  C0      			RET NZ			;FILE FOUND
5624:28122+17	20C5  CDE020  			CALL	SD_LDIRN
5625:28139+10	20C8  C3C020  			JP	SDFF_LP
5626:				
5627:				
5628:				;=============================================================================
5629:				;Directory Routines.  1st Routine to start/init the search, 2nd routine to continue the search
5630:				;-----------------------------------------------------------------------------
5631:				;Call this routine to initialize and start the HL Pointer to the first Directory Entry
5632:28149+10	20CB  2135FF  	SD_LDIR1	LD	HL,DIR_SECTOR	;SEC_PTR = DIR_SECTOR
5633:28159+17	20CE  CD3E27  			CALL	MOV_32_HL
5634:28176+16	20D1  2A25FF  			LD	HL, (ROOTDIR_SIZE)	;ENT_COUNT = ROOTDIR_SIZE (to count down directory entries searched)
5635:28192+16	20D4  2241FF  			LD	(ENT_COUNT), HL
5636:						
5637:				
5638:28208+17	20D7  CD9624  	SD_FETCH	CALL	SD_READ_SEC		;Fetch a ROOT DIRECTORY sector
5639:28225+10	20DA  2100FC  			LD	HL,SD_RAM_BUFFER	;(Re)start H at start of Sector
5640:28235+4	20DD  AF      	SD_TEST		XOR	A			;EXIT Z=0 if there is a File at this entry
5641:28239+7	20DE  BE      			CP	(HL)
5642:28246+10	20DF  C9      			RET
5643:				
5644:				;=============================================================================
5645:				;Call this routine to advance to the next Directory Entry (loads next sector and restarts HL as needed)
5646:				;-----------------------------------------------------------------------------
5647:28256+10	20E0  012000  	SD_LDIRN	LD	BC,20h		;Advance to next file entry
5648:28266+11	20E3  09      			ADD	HL,BC
5649:28277+4	20E4  7C      			LD	A,H
5650:28281+7	20E5  FEFE    			CP	HIGH (SD_RAM_BUFFER+200h)
5651:28288+10	20E7  C2DD20  			JP NZ,	SD_TEST		;Check if extended beyond this sector
5652:				
5653:28298+4	20EA  AF      			XOR	A		;Return Z=1 if no more files
5654:28302+16	20EB  2A41FF  			LD	HL, (ENT_COUNT)
5655:28318+10	20EE  01F0FF  			LD	BC,-16
5656:28328+11	20F1  09      			ADD	HL,BC
5657:28339+16	20F2  2241FF  			LD	(ENT_COUNT), HL
5658:28355+5+6	20F5  D0      			RET NC			;Out of Directory entries
5659:28360+4	20F6  7C      			LD	A,H
5660:28364+4	20F7  B5      			OR	L
5661:28368+5+6	20F8  C8      			RET Z			;Out of Directory entries
5662:				
5663:28373+10	20F9  213DFF  			LD	HL,SEC_PTR	;Advance to next SECTOR
5664:28383+17	20FC  CD3E27  			CALL	MOV_32_HL
5665:28400+17	20FF  CD6527  			CALL	INC_32
5666:28417+10	2102  C3D720  			JP	SD_FETCH
5667:				
5668:				
5669:				;=============================================================================
5670:				;	Prints Filename at HL (DESTROYS A)
5671:				;-----------------------------------------------------------------------------
5672:28427+11	2105  E5      	PRINT_FILENAME	PUSH	HL
5673:28438+11	2106  C5      			PUSH	BC
5674:28449+7	2107  0608    			LD	B,8
5675:28456+17	2109  CD1D21  			CALL	PRINT_BS	;Print up to 8 characters or until an encouter with Space or NULL
5676:28473+7	210C  3E2E    			LD	A,'.'
5677:28480+17	210E  CDEC13  			CALL	PUT_CHAR
5678:28497+4	2111  48      			LD	C,B		;Adjust HL to +8
5679:28501+7	2112  0600    			LD	B,0	
5680:28508+11	2114  09      			ADD	HL,BC
5681:28519+7	2115  0603    			LD	B,3
5682:28526+17	2117  CD1D21  			CALL	PRINT_BS	;Print up to 3 characters or until an encouter with Space or NULL
5683:28543+10	211A  C1      			POP	BC
5684:28553+10	211B  E1      			POP	HL
5685:28563+10	211C  C9      			RET
5686:				
5687:28573+7	211D  7E      	PRINT_BS	LD	A,(HL)		;PRINT B CHARS OR UP TO EITHER A NULL OR SPACE.
5688:28580+4	211E  B7      			OR	A
5689:28584+5+6	211F  C8      			RET Z
5690:28589+7	2120  FE20    			CP	' '
5691:28596+5+6	2122  C8      			RET Z
5692:28601+17	2123  CDEC13  			CALL	PUT_CHAR
5693:28618+6	2126  23      			INC	HL
5694:28624+8+5	2127  10F4    			DJNZ	PRINT_BS
5695:28632+10	2129  C9      			RET
5696:				
5697:				
5698:				;=============================================================================
5699:				;	OUTPUT: FILENAME ENTERED, C=0
5700:				;		<ESC> PRESSED C=1
5701:28642+17	212A  CDCA0D  	INPUT_FILENAME	CALL 	PRINTI		;Display Menu Prompt
5702:     -	212D  0D0A454E			DB CR,LF,"ENTER 8.3 FILE NAME> ",EOS
	              54455220
	              382E3320
	              46494C45
	              204E414D
	              453E2000
5703:28659+10	2145  2143FF  			LD	HL,FILENAME
5704:28669+7	2148  060B    			LD	B,11
5705:28676+7	214A  3E20    			LD	A,' '
5706:28683+17	214C  CD160C  			CALL	FILL_BLOCK
5707:28700+7	214F  0E2E    			LD	C,'.'
5708:28707+7	2151  0608    			LD	B,8
5709:28714+17	2153  CD9727  			CALL	GET_STRING
5710:28731+5+6	2156  D8      			RET C
5711:28736+7	2157  FE0D    			CP	13
5712:28743+5+6	2159  C8      			RET	Z
5713:28748+10	215A  214BFF  			LD	HL,FILEEXT
5714:28758+7	215D  0603    			LD	B,3
5715:28765+17	215F  CD9727  			CALL	GET_STRING
5716:28782+10	2162  C9      			RET
5717:				
5718:				;=============================================================================
5719:28792+11	2163  E5      	CMP_FILENAME	PUSH	HL		;Save H pointer into  Directory
5720:28803+10	2164  010800  			LD	BC,8		;Compare 8 characters
5721:28813+10	2167  1143FF  			LD	DE,FILENAME
5722:28823+17	216A  CD8021  			CALL	CMP_STRING
5723:28840+7+5	216D  200E    			JR NZ,	CMPF_RETFAIL	;Exit if not equal
5724:						;ADD	HL,BC		;Adjust HL to +8, HL should be +8
5725:28847+10	216F  010300  			LD	BC,3
5726:28857+10	2172  114BFF  			LD	DE,FILEEXT
5727:28867+17	2175  CD8021  			CALL	CMP_STRING
5728:28884+7+5	2178  2003    			JR NZ,	CMPF_RETFAIL	;Exit if not equal
5729:28891+4	217A  0C      			INC	C		;Z=0
5730:28895+10	217B  E1      			POP	HL
5731:28905+10	217C  C9      			RET
5732:						
5733:28915+4	217D  AF      	CMPF_RETFAIL	XOR	A		;Z=1
5734:28919+10	217E  E1      			POP	HL
5735:28929+10	217F  C9      			RET
5736:				
5737:28939+7	2180  1A      	CMP_STRING	LD	A, (DE)
5738:28946+16	2181  EDA1    			CPI			;CP (HL):INC HL:DEC BC
5739:28962+5+6	2183  C0      			RET NZ			;Exit if not equal
5740:28967+5+6	2184  E0      			RET PO			;Exit if end of string
5741:28972+6	2185  13      			INC	DE
5742:28978+12	2186  18F8    			JR	CMP_STRING
5743:				
5744:				
5745:				;=====================================================================================================
5746:				;Read of Logical Disk Sector.
5747:				;=====================================================================================================
5748:					;Start-of-Directory = Size-of-Fat * Number-of-fats + 1 (boot sector)
5749:					;Start-of-Data-Area = Start-of-Directory + #Entries/32/bytes_per_sector
5750:				
5751:					;Input:	LOGICAL_SEC Disk Sector required (0 to 2001) based on 26 sectors per track by 77 tracks, counting from 0
5752:					;Disk FCB in HL
5753:				
5754:					;if AFClus0 = 0x0000 then attempt to open the file report Disk not loaded if fail
5755:					;Relative file sector:
5756:					;DISK_SEC is the input to this routine, it holds Virtual Disk Sector 0 to 2001
5757:					;because every SD sector has 512 bytes, each SD sector holds 4 CP/M Virtual Disk sectors (that's 128 bytes)
5758:					;RFSec is the Relative File Sector, it spans from 0 to 500 (this accomodates 501 SD Sectors or 256,512 bytes)
5759:					;If RFSec = DISK_SEC / 4 Then...
5760:					;If RFSec has not changed, then read that sector into RAM and be done.
5761:					;That Relative File sector is located on the SD card at address set in the absolute sector (ABS_SEC)
5762:					;
5763:					;If RFSec has changed... then determine is the new RFSec is within the same cluster or not.
5764:					;On a 1Gig SD card, the system uses 32 sectors per cluster.  This means, 32 sequential SD Memory Card sectors form 1 cluster.
5765:					;If a sector within the same cluster is being accessed, then the cluster does not have to be found again.
5766:					;If it's NOT in the same cluster, then find new cluster by looking through the FAT
5767:					;If it is in the same cluster, then skip to the part were we can just offset the RFSec into the current cluster
5768:					;
5769:					;...else
5770:					;RFSec = DISK_SEC / 4  'Set the new sector as the current one.
5771:					;
5772:					;Find the Relative File Cluster (RFClus).  This number will be from 0 to 15 on a 1Gig SD Card = 262,144 bytes (to hold a 256,256 file)
5773:					;
5774:					;Relative file cluster:
5775:					;RFClus = RFSec / SEC_PER_CLUS
5776:					;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
5777:					;  if RFClus < CRFClus then CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
5778:					;  RFClus = RFClus - CRFClus
5779:					;  do while RFClus>0
5780:					;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
5781:					;      CAFClus = FAT(CAFClus)
5782:					;      CRFClus = CRFClus + 1
5783:					;      RFClus = RFClus - 1
5784:					;  loop
5785:					;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
5786:					;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
5787:				;Destroys: A, BC, DE, HL, IX
5788:				;=====================================================================================================
5789:				;Read of Logical Disk Sector.
5790:				;Input:	LOGICAL_SEC = 0=First Sector
5791:     -	2188          	DISK_READ	
5792:						;CALL	PRINTI		;debug
5793:						;DB  " R-",EOS		;debug
5794:						;LD	HL,(LOGICAL_SEC);debug
5795:						;CALL	PUT_HL		;debug
5796:				
5797:28990+20	2188  DD2A08FF			LD	IX,(FCB_PTR)	;Get Current Disk FCB
5798:29010+19	218C  DD7E00  			LD	A,(IX)		;Is file open?
5799:29029+4	218F  B7      			OR	A		;Test FSTAT
5800:29033+10	2190  C2B321  			JP NZ,	DR_1		;Jump YES
5801:						
5802:						;PUSH	IX		;debug
5803:						;POP	HL		;debug
5804:						;CALL	PRINTI		;debug
5805:						;DB  " HL:",EOS		;debug
5806:						;CALL	PUT_HL		;debug
5807:						
5808:29043+17	2193  CDB61D  			CALL	SD_OPEN		;ELSE, Attempt to open file
5809:29060+19	2196  DD7E00  			LD	A, (IX)		;Is file open?
5810:29079+4	2199  B7      			OR	A		;Test FSTAT
5811:29083+10	219A  C2B321  			JP NZ,	DR_1		;Jump YES
5812:29093+17	219D  CDCA0D  			CALL	PRINTI
5813:     -	21A0  202D4469			DB " -Disk Not Loaded",EOS
	              736B204E
	              6F74204C
	              6F616465
	              6400
5814:29110+10	21B2  C9      			RET			;Exit if file could not open
5815:				
5816:29120+19	21B3  DD6E12  	DR_1		LD	L,(IX+RFSec)	;If file open, Check if Read is from same Data Sector
5817:29139+19	21B6  DD6613  			LD	H,(IX+RFSec+1)	;D=RFSec
5818:				
5819:						;CALL	PRINTI		;debug
5820:						;DB  " LS:",EOS		;debug
5821:						;CALL	PUT_DE		;debug
5822:				
5823:29158+20	21B9  ED5B0DFF			LD	DE, (LOGICAL_SEC) ;Fetch sector to be read
5824:29178+17	21BD  CD9127  			CALL	CMP_DE_HL
5825:29195+10	21C0  C2D021  			JP NZ,	DR_NEW_SEC	;Jump if Read is from a different Data Sector
5826:				
5827:									;LOGICAL SECTOR = LAST READ SECTOR, Fetch Absolute Sector and read it to RAM (if wasn't last read)
5828:29205+16	21C3  2A08FF  			LD	HL,(FCB_PTR)	;Get Current Disk FCB
5829:29221+7	21C6  3E18    			LD	A,ABS_SEC	;H=FCB(ABS_SEC)
5830:29228+4	21C8  85      			ADD	A,L
5831:29232+4	21C9  6F      			LD	L,A
5832:				
5833:29236+17	21CA  CD3E27  			CALL	MOV_32_HL
5834:29253+10	21CD  C3D522  			JP	DR_READ_IT
5835:				
5836:				
5837:					;RFClus = RFSec / SEC_PER_CLUS
5838:					;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
5839:					;  if RFClus < CRFClus then
5840:					;     CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
5841:					;  eles
5842:					;     RFClus = RFClus - CRFClus	   'else, continue FAT search from point of
5843:					;  endif
5844:					;  do while RFClus>0
5845:					;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
5846:					;      CAFClus = FAT(CAFClus)
5847:					;      CRFClus = CRFClus + 1
5848:					;      RFClus = RFClus - 1
5849:					;  loop
5850:					;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
5851:					;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
5852:					
5853:     -	21D0          	DR_NEW_SEC				;We are to read a sector of the file that is different from the last READ.
5854:									;This branch would also take place on the first time we read a file, since
5855:									;the "Last Sector Read" was set to a dummy value of 0xFFFF
5856:									;
5857:									;Save the sector we are now reading as "Last Sector Read" = RFSec
5858:				
5859:29263+19	21D0  DD7312  			LD	(IX+RFSec  ),E	;D=LOGICAL_SEC = Relative File Sector (Update FCB with this new Rel-File-Sec
5860:29282+19	21D3  DD7213  			LD	(IX+RFSec+1),D	;
5861:				
5862:									;Find in which relative or sequential Cluster this sector is in
5863:									;by dividing by the "Sectors per Cluster"
5864:									;eg. If there are 4 sectors per cluster, then Sectors 0 to 3 will be in Cluster 0
5865:									;Cluster 0 is the first cluster of the file and the location of this cluster
5866:									;(the Absolute Cluster) is given by the directory entry for this file.
5867:				
5868:29301+16	21D6  2A52FF  			LD	HL, (DIVIDE_FUNC)	;DE = DE / Sectors-Per-Cluster (Divide Func hard coded with Sec/Clus)
5869:29317+17	21D9  CDA00C  			CALL	VCALL_HL
5870:				
5871:						;CALL	PRINTI		;debug
5872:						;DB  " RC:",EOS		;debug
5873:						;CALL	PUT_DE		;debug
5874:						
5875:29334+16	21DC  2A08FF  			LD	HL,(FCB_PTR)
5876:29350+7	21DF  3E0E    			LD	A,CRFClus	;H=FCB(CRFClus)
5877:29357+4	21E1  85      			ADD	A,L
5878:29361+4	21E2  6F      			LD	L,A
5879:				
5880:29365+7	21E3  4E      			LD	C,(HL)
5881:29372+6	21E4  23      			INC	HL
5882:29378+7	21E5  46      			LD	B,(HL)		;BC = CRFClus
5883:29385+6	21E6  2B      			DEC	HL
5884:				
5885:						;CALL	PRINTI		;debug
5886:						;DB  " LRC:", EOS	;debug
5887:						;CALL	PUT_BC		;debug
5888:				
5889:				
5890:									;H->FCB(CRFClus)
5891:									;TEST DE - BC  aka NewRFClus vs FCB-RFClus
5892:									;Speed Optimize the above code
5893:29391+4	21E7  7A      			LD	A,D
5894:29395+4	21E8  B8      			CP	B
5895:29399+7+5	21E9  2005    			JR NZ,	DR_DIFF_CLUS
5896:29406+4	21EB  7B      			LD	A,E
5897:29410+4	21EC  B9      			CP	C
5898:29414+10	21ED  CAB222  			JP Z,	DR_SAME_CLUS	;IF they are the same, then the new sector is in the same cluster
5899:29424+7+5	21F0  3007    	DR_DIFF_CLUS	JR NC,	DR_BIGGER_CLUS
5900:				
5901:									;If going to a smaller cluster, restart the FAT search from the begining
5902:29431+10	21F2  010000  			LD	BC,0		;CRFClus = 0
5903:29441+6	21F5  2B      			DEC	HL
5904:29447+6	21F6  2B      			DEC	HL
5905:29453+12	21F7  1808    			JR	DR_SEEK_FAT	;HL will load with AFClus0
5906:				
5907:29465+4	21F9  7B      	DR_BIGGER_CLUS	LD	A,E		;NewRFClus = NewRFClus - FCB-RFClus,  ie Set counter for number of new FAT hops.
5908:29469+4	21FA  91      			SUB	C
5909:29473+4	21FB  5F      			LD	E,A
5910:29477+4	21FC  7A      			LD	A,D
5911:29481+4	21FD  98      			SBC	A,B
5912:29485+4	21FE  57      			LD	D,A
5913:				
5914:29489+6	21FF  23      			INC	HL
5915:29495+6	2200  23      			INC	HL		;HL will load with CAFClus
5916:				
5917:					;  do while RFClus>0
5918:					;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
5919:					;      CAFClus = FAT(CAFClus)
5920:					;      CRFClus = CRFClus + 1
5921:					;      RFClus = RFClus - 1
5922:					;  loop
5923:				
5924:     -	2201          	DR_SEEK_FAT
5925:29501+17	2201  CD4A0E  			CALL	LD_HL_HL	;HL = CAFClus or AFClus0
5926:				
5927:				;		CALL	PRINTI		;debug
5928:				;		DB  CR,LF,"CAFClus=",EOS ;debug
5929:				;		CALL	PUT_HL		;debug
5930:				;		CALL	PRINTI		;debug
5931:				;		DB  CR,LF,"CRFClus=",EOS ;debug
5932:				;		CALL	PUT_BC		;debug
5933:				;		CALL	PRINTI		;debug
5934:				;		DB  CR,LF,"RFClus=",EOS	;debug
5935:				;		CALL	PUT_DE		;debug
5936:				
5937:									;BC = CRFClus
5938:29518+4	2204  7A      	DR_SEEK_LP	LD	A,D		;DE = RFClus
5939:29522+4	2205  B3      			OR	E
5940:29526+7+5	2206  2861    			JR Z,	DR_SEEK_DONE
5941:				
5942:				;		CALL	PRINTI		;debug
5943:				;		DB  CR,LF,"seek=",EOS	;debug
5944:				;		CALL	PUT_HL		;debug
5945:								
5946:29533+4	2208  7C      			LD	A,H		;IF CAFClus = 0xFFFF... (No more clusters to fetch)
5947:29537+4	2209  A5      			AND	L
5948:29541+4	220A  2F      			CPL
5949:29545+4	220B  B7      			OR	A		
5950:29549+10	220C  C23B22  			JP NZ,	DR_SEEK_1
5951:									;Error, File too small
5952:29559+17	220F  CDCA0D  			CALL	PRINTI
5953:     -	2212  202D4552			DB " -ERROR, NO MORE ALLOCATED CLUSTERS!",EOS
	              524F522C
	              204E4F20
	              4D4F5245
	              20414C4C
	              4F434154
	              45442043
	              4C555354
	              45525321
	              00
5954:29576+4	2237  76      			HALT
5955:29580+10	2238  C33722  			JP	$-1
5956:						
5957:     -	223B          	DR_SEEK_1	
5958:				
5959:					;Here comes the FAT Hopping FUN...
5960:					;      CAFClus = FAT(CAFClus)
5961:					;it's convenient that 1 Sector is 512 bytes, that's 256 words = 256 FAT Entries, therefore...
5962:					;H = Sector of FAT
5963:					;L = Word within that Sector of FAT
5964:				
5965:29590+11	223B  C5      			PUSH	BC
5966:29601+11	223C  D5      			PUSH	DE
5967:29612+11	223D  E5      			PUSH	HL
5968:29623+4	223E  5C      			LD	E,H		;E=Sector of FAT
5969:29627+16	223F  2A31FF  			LD	HL, (FAT1START)	;DE = E + FAT1START
5970:29643+4	2242  7D      			LD	A,L
5971:29647+4	2243  83      			ADD	A,E
5972:29651+4	2244  5F      			LD	E,A
5973:29655+4	2245  7C      			LD	A,H
5974:29659+7	2246  CE00    			ADC	A,0		;Carry it forward
5975:29666+4	2248  57      			LD	D,A
5976:29670+16	2249  2A33FF  			LD	HL, (FAT1START+2)
5977:29686+7+5	224C  3001    			JR NC,	DRS_0		;Test for Carry
5978:29693+6	224E  23      			INC	HL		;Carry it forward
5979:29699+4	224F  44      	DRS_0		LD	B,H
5980:29703+4	2250  4D      			LD	C,L		;BCDE now have Sector of FAT desired
5981:29707+17	2251  CD9624  			CALL	SD_READ_SEC
5982:29724+10	2254  D1      			POP	DE		;Fetch DE, E=Word within that FAT sector
5983:29734+10	2255  2100FC  			LD	HL,SD_RAM_BUFFER
5984:29744+4	2258  B7      			OR	A		;Clear Carry
5985:29748+4	2259  7B      			LD	A,E		;Fetch offset into FAT sector read
5986:29752+4	225A  17      			RLA
5987:29756+4	225B  6F      			LD	L,A		;
5988:29760+4	225C  7C      			LD	A,H
5989:29764+7	225D  CE00    			ADC	A,0
5990:29771+4	225F  67      			LD	H,A		;HL -> FAT Entry
5991:29775+17	2260  CD4A0E  			CALL	LD_HL_HL	;HL = FAT Entry
5992:29792+10	2263  D1      			POP	DE
5993:29802+10	2264  C1      			POP	BC
5994:				
5995:29812+6	2265  03      			INC	BC
5996:29818+6	2266  1B      			DEC	DE
5997:29824+12	2267  189B    			JR	DR_SEEK_LP
5998:				
5999:     -	2269          	DR_SEEK_DONE	;Write Registers to FCB
6000:						;BC = CRFClus  = The Relative Cluster (ie, the 5th cluster into the file)
6001:						;DE = RFClus - Not required (it's a counter down to zero to find the correct cluster)
6002:						;HL = CAFClus  = The Absolute or Actual Cluster (ie, Cluster 149 on the disk)
6003:				
6004:29836+20	2269  DD2A08FF			LD	IX,(FCB_PTR)
6005:29856+19	226D  DD710E  			LD	(IX+CRFClus  ),C	;Save CRFClust to FCB
6006:29875+19	2270  DD700F  			LD	(IX+CRFClus+1),B
6007:29894+19	2273  DD7510  			LD	(IX+CAFClus  ),L	;Save CAFClus to FCB
6008:29913+19	2276  DD7411  			LD	(IX+CAFClus+1),H
6009:				
6010:					;Now, let's find the Data Sector to be loaded....
6011:					;First, calculate the Starting Sector of Cluster (SSOC)
6012:					;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
6013:				
6014:29932+6	2279  2B      			DEC	HL		;HL = CAFClus - 2
6015:29938+6	227A  2B      			DEC	HL
6016:						
6017:29944+4	227B  EB      			EX	DE,HL
6018:				
6019:				;-------------------------------------	Multiply Routine.  16bit by 8 bit -> 24bit
6020:29948+7	227C  0E00    			LD	C,0		;CDE = 16bit input (need 24 bits to shift)
6021:29955+7	227E  0608    			LD	B,8		;Go through 8 bits
6022:29962+14	2280  DD2121FF			LD	IX, SEC_PER_CLUS	;Fetch Multiplier
6023:29976+4	2284  AF      			XOR	A
6024:29980+10	2285  210000  			LD	HL,0		;AHL = 24bit output
6025:						
6026:29990+23	2288  DDCB000E	DRSS_LP		RRC	(IX)
6027:30013+7+5	228C  3002    			JR NC,	DRSS_SHIFT
6028:30020+11	228E  19      			ADD	HL,DE		;DE=DE+HL
6029:30031+4	228F  89      			ADC	A,C
6030:				
6031:30035+8	2290  CB23    	DRSS_SHIFT	SLA	E
6032:30043+8	2292  CB12    			RL	D
6033:30051+8	2294  CB11    			RL	C
6034:30059+8+5	2296  10F0    			DJNZ	DRSS_LP
6035:					
6036:30067+4	2298  4F      			LD	C,A
6037:30071+7	2299  0600    			LD	B,0		;BCHL = 32bit Absolute sector
6038:									;Add to BCHL, the DATASTART sector
6039:30078+20	229B  ED5B39FF			LD	DE, (DATASTART)	;32 Bit ADD DATASTART
6040:30098+11	229F  19      			ADD	HL, DE
6041:30109+4	22A0  EB      			EX	DE, HL		;DE=DE+START (LSB)
6042:30113+16	22A1  2A3BFF  			LD	HL, (DATASTART+2)
6043:30129+15	22A4  ED4A    			ADC	HL,BC
6044:30144+4	22A6  4D      			LD	C,L
6045:30148+4	22A7  44      			LD	B,H		;BC=BC+START (MSB)
6046:				;-------
6047:									;Save the result to RAM variable SSOC
6048:30152+16	22A8  2A08FF  			LD	HL,(FCB_PTR)
6049:30168+7	22AB  3E14    			LD	A,SSOC		;Set FCB(SSOC)
6050:30175+4	22AD  85      			ADD	A,L
6051:30179+4	22AE  6F      			LD	L,A		
6052:30183+17	22AF  CD4927  			CALL	MOV_HL_32	;Save the 32 bit register BCDE to (HL)
6053:				;-------
6054:				
6055:					;ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
6056:     -	22B2          	DR_SAME_CLUS				;Fetch the RFSec
6057:30200+20	22B2  DD2A08FF			LD	IX,(FCB_PTR)	;Set FCB(RFSec)
6058:30220+19	22B6  DD5E12  			LD	E,(IX+RFSec)	;DE=RFSec
6059:30239+19	22B9  DD5613  			LD	D,(IX+RFSec+1)
6060:				
6061:30258+16	22BC  2A56FF  			LD	HL,(MOD_FUNC)	;DE = DE % Sectors-Per-Cluster
6062:30274+17	22BF  CDA00C  			CALL	VCALL_HL	;A = RFSec MOD SEC_PER_CLUS
6063:				
6064:30291+10	22C2  010000  			LD	BC,0		;BCDE = (RFSec MOD SEC_PER_CLUS)
6065:30301+7	22C5  1600    			LD	D,0
6066:30308+4	22C7  5F      			LD	E,A
6067:				
6068:30312+16	22C8  2A08FF  			LD	HL,(FCB_PTR)
6069:30328+7	22CB  3E14    			LD	A,SSOC		;Set FCB(SSOC)
6070:30335+4	22CD  85      			ADD	A,L
6071:30339+4	22CE  6F      			LD	L,A		
6072:30343+17	22CF  CD5427  			CALL	ADD_32_HL	;BCDE = SSOC + (RFSec MOD SEC_PER_CLUS)
6073:									;(HL returns +4) to ABS_SEC
6074:				
6075:30360+17	22D2  CD4927  			CALL	MOV_HL_32	;Save the ABS_SEC
6076:				
6077:30377+17	22D5  CD9624  	DR_READ_IT	CALL	SD_READ_SEC	;Fetch the Sector
6078:				
6079:30394+10	22D8  2100FC  			LD	HL,SD_RAM_BUFFER
6080:30404+10	22DB  C9      			RET
6081:				
6082:				
6083:				
6084:				;=====================================================================================================
6085:				;=====================================================================================================
6086:				;SD_CARD_TYPE	.BLOCK	1	;SD CARD TYPE
6087:				;SDC_STATUS	.BLOCK	1	;SD Status Code returned
6088:				;SD_PARAM	.BLOCK	4	;32 bit address parameter for SD Commands
6089:				;SD_PART_TYPE	.BLOCK	1	;SD PARTITION TYPE
6090:				;SD_PART_BASE	.BLOCK	4	;SD PARTITION STARTING RECORD
6091:				;SD_PART_SIZE	.BLOCK	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
6092:				;SEC_PER_CLUS	.BLOCK	1	;0x0D
6093:				;RESERVED_SEC	.BLOCK	2	;0x0E - 0x0F
6094:				;FAT_COPIES	.BLOCK	1	;0x10
6095:				;RT_DIR_ENTRIES	.BLOCK	2	;0x11 - 0x12
6096:				;TOT_FILESYS_SEC.BLOCK	4	;0x13 - 0x14 or 0x20 - 0x23
6097:				;HIDDEN_SECTORS	.BLOCK	4	;0x1C - 0x1F
6098:				;SEC_PER_FAT	.BLOCK	2	;0x16 - 0x17
6099:				;FAT1START	.BLOCK	4	;Calculated
6100:				;DIR_SECTOR	.BLOCK	4	;Calculated
6101:				;DATASTART	.BLOCK	4	;Calculated
6102:				;-----------------------------------------------------------------------------
6103:30414+10	22DC  210AFF  	INIT_FAT	LD	HL,FAT_CLEAR	;Clear RAM
6104:30424+7	22DF  0639    			LD	B,FAT_CLR_LEN
6105:30431+17	22E1  CD100C  			CALL	CLEAR_BLOCK
6106:				
6107:30448+17	22E4  CD9B25  			CALL	INIT_SDCARD
6108:30465+5+6	22E7  C0      			RET NZ			;RET NZ IF FAILED
6109:				
6110:30470+17	22E8  CDCA0D  			CALL 	PRINTI		;
6111:     -	22EB  4D425200			DB "MBR",EOS
6112:				
6113:30487+10	22EF  010000  			LD	BC,0		;BCDE = 0x00000000
6114:30497+10	22F2  110000  			LD	DE,0
6115:30507+17	22F5  CDB424  			CALL	SD_RS_FORCED	;READ MBR (FORCED READ)
6116:30524+17	22F8  CD8324  			CALL	TEST_SIGNATURE
6117:30541+5+6	22FB  C0      			RET NZ			;RET NZ IF FAILED
6118:				
6119:30546+17	22FC  CDCA0D  			CALL 	PRINTI		;
6120:     -	22FF  20547970			DB " Type",EOS
	              6500
6121:30563+13	2305  3AC2FD  			LD	A, (SD_RAM_BUFFER+01C2h)
6122:30576+17	2308  CDF60D  			CALL	PUT_BYTE
6123:30593+13	230B  3216FF  			LD	(SD_PART_TYPE), A
6124:30606+7	230E  FE04    			CP	4
6125:30613+7+5	2310  2809    			JR   Z,	INITFAT_PGOOD
6126:30620+7	2312  FE06    			CP	6
6127:30627+7+5	2314  2805    			JR   Z,	INITFAT_PGOOD
6128:30634+7	2316  FE86    			CP	86h
6129:30641+10	2318  C26B24  			JP  NZ,	INITFAT_FAIL
6130:				
6131:30651+10	231B  21C6FD  	INITFAT_PGOOD	LD	HL,SD_RAM_BUFFER+1C6h
6132:30661+10	231E  1117FF  			LD	DE,SD_PART_BASE
6133:30671+10	2321  010800  			LD	BC,8
6134:30681+16+5	2324  EDB0    			LDIR		;Copy BASE & SIZE from BUFFER to RAM Variables
6135:30697+17	2326  CDCA0D  			CALL 	PRINTI		;
6136:     -	2329  20504252			DB " PBR",EOS
	              00
6137:				
6138:30714+10	232E  2117FF  			LD	HL,SD_PART_BASE
6139:30724+17	2331  CD3E27  			CALL	MOV_32_HL	;Copy BASE to SEC_PTR
6140:30741+17	2334  CD9624  			CALL	SD_READ_SEC	;READ BOOT RECORD OF PARTITION
6141:30758+17	2337  CD8324  			CALL	TEST_SIGNATURE
6142:30775+5+6	233A  C0      			RET NZ
6143:				
6144:30780+10	233B  210BFC  			LD	HL,SD_RAM_BUFFER+0Bh
6145:30790+10	233E  111FFF  			LD	DE,BYTE_P_SEC
6146:30800+10	2341  010A00  			LD	BC,10
6147:30810+16+5	2344  EDB0    			LDIR	;Copy Description Table to RAM Variables (Up to Total Filesys Sectors)
6148:30826+4	2346  EB      			EX	DE, HL	;Test TOTAL_FILESYS_SECTORS = 0
6149:30830+6	2347  2B      			DEC	HL
6150:30836+6	2348  2B      			DEC	HL
6151:30842+7	2349  7E      			LD	A,(HL)
6152:30849+6	234A  23      			INC	HL
6153:30855+7	234B  B6      			OR	(HL)
6154:30862+7+5	234C  200C    			JR  NZ,	INITFAT_TFS_OK
6155:30869+6	234E  2B      			DEC	HL
6156:30875+4	234F  EB      			EX	DE, HL	
6157:30879+10	2350  2120FC  			LD	HL,SD_RAM_BUFFER+020h
6158:30889+10	2353  010400  			LD	BC,4
6159:30899+16+5	2356  EDB0    			LDIR
6160:30915+12	2358  1807    			JR	INITFAT_TFS_DONE
6161:				
6162:30927+4	235A  AF      	INITFAT_TFS_OK	XOR	A
6163:30931+6	235B  23      			INC	HL
6164:30937+7	235C  77      			LD	(HL),A
6165:30944+6	235D  23      			INC	HL
6166:30950+7	235E  77      			LD	(HL),A
6167:30957+6	235F  23      			INC	HL
6168:30963+4	2360  EB      			EX	DE, HL	
6169:     -	2361          	INITFAT_TFS_DONE
6170:				
6171:30967+10	2361  211CFC  			LD	HL,SD_RAM_BUFFER+01Ch
6172:30977+10	2364  010400  			LD	BC,4
6173:30987+16+5	2367  EDB0    			LDIR			;Copy HIDDEN_SECTORS to RAM Variables
6174:31003+10	2369  2116FC  			LD	HL,SD_RAM_BUFFER+016h
6175:31013+10	236C  010200  			LD	BC,2
6176:31023+16+5	236F  EDB0    			LDIR			;Copy SECTORS_PER_FAT to RAM Variables
6177:				
6178:				;BS.fat1Start = MBR.part1Start + BS.reservedSectors;
6179:31039+16	2371  2A22FF  			LD	HL, (RESERVED_SEC)	;H=Reserved Sectors
6180:31055+4	2374  EB      			EX	DE, HL	
6181:31059+16	2375  2A17FF  			LD	HL, (SD_PART_BASE)	;FAT1START = SD_PART_BASE + RESERVED_SEC
6182:31075+11	2378  19      			ADD	HL,DE
6183:31086+16	2379  2231FF  			LD	(FAT1START), HL
6184:31102+16	237C  2A19FF  			LD	HL, (SD_PART_BASE+2)
6185:31118+7+5	237F  3001    			JR  NC,	INITFAT_C1_DONE
6186:31125+6	2381  23      			INC	HL
6187:31131+16	2382  2233FF  	INITFAT_C1_DONE	LD	(FAT1START+2), HL
6188:				
6189:				;firstDirSector = BS.fat1Start + (BS.fatCopies * BS.sectorsPerFAT);
6190:31147+13	2385  3A24FF  			LD	A, (FAT_COPIES)
6191:31160+4	2388  47      			LD	B,A
6192:31164+16	2389  2A2FFF  			LD	HL, (SEC_PER_FAT)
6193:31180+4	238C  EB      			EX	DE, HL	
6194:31184+10	238D  210000  			LD	HL,0
6195:31194+11	2390  19      	INITFAT_C2_LP	ADD	HL,DE
6196:31205+8+5	2391  10FD    			DJNZ	INITFAT_C2_LP	;H = FAT_COPIES * SEC_PER_FAT
6197:31213+4	2393  EB      			EX	DE, HL		;DE = FATS * SECperFAT
6198:31217+16	2394  2A31FF  			LD	HL, (FAT1START)
6199:31233+11	2397  19      			ADD	HL,DE		;DIR_SECTOR = FAT1START + FAT_COPIES * SEC_PER_FAT
6200:31244+16	2398  2235FF  			LD	(DIR_SECTOR), HL
6201:31260+16	239B  2A33FF  			LD	HL, (FAT1START+2)
6202:31276+7+5	239E  3001    			JR  NC,	INITFAT_C2_DONE
6203:31283+6	23A0  23      			INC	HL
6204:31289+16	23A1  2237FF  	INITFAT_C2_DONE	LD	(DIR_SECTOR+2), HL
6205:				
6206:				;DATASTART = DIR_SECTOR + LEN(Directory)
6207:				;          = DIR_SECTOR + ROOTDIR_SIZE * 32 / BYTE_P_SEC
6208:31305+7	23A4  0610    			LD	B,16		;Maximum # of Reductions
6209:31312+16	23A6  2A1FFF  			LD	HL, (BYTE_P_SEC)	;To fit math into 16 bits, let's reduce "ROOTDIR_SIZE / BYTE_P_SEC"
6210:31328+4	23A9  EB      			EX	DE, HL	;Divide each by 2 while dividable
6211:31332+16	23AA  2A25FF  			LD	HL, (ROOTDIR_SIZE)	;H=ROOTDIR_SIZE, D=BYTE_P_SEC
6212:31348+4	23AD  7B      	INITFAT_C3_LP	LD	A,E
6213:31352+4	23AE  1F      			RRA
6214:31356+7+5	23AF  3829    			JR  C,	INITFAT_C3_0	;If lsb of D is 1, no more Reduction possible
6215:31363+4	23B1  7D      			LD	A,L
6216:31367+4	23B2  1F      			RRA
6217:31371+7+5	23B3  3825    			JR  C,	INITFAT_C3_0	;If lsb of H is 1, no more Reduction possible
6218:31378+4	23B5  7A      			LD	A,D
6219:31382+4	23B6  1F      			RRA
6220:31386+4	23B7  57      			LD	D,A
6221:31390+4	23B8  7B      			LD	A,E
6222:31394+4	23B9  1F      			RRA
6223:31398+4	23BA  5F      			LD	E,A
6224:31402+4	23BB  7C      			LD	A,H
6225:31406+4	23BC  1F      			RRA
6226:31410+4	23BD  67      			LD	H,A
6227:31414+4	23BE  7D      			LD	A,L
6228:31418+4	23BF  1F      			RRA
6229:31422+4	23C0  6F      			LD	L,A
6230:31426+8+5	23C1  10EA    			DJNZ	INITFAT_C3_LP
6231:				
6232:31434+17	23C3  CDCA0D  	INITFAT_C3_ERR	CALL 	PRINTI		;
6233:     -	23C6  20457272			DB " Error DATASTART",EOS
	              6F722044
	              41544153
	              54415254
	              00
6234:31451+4	23D7  AF      			XOR	A
6235:31455+4	23D8  3D      			DEC	A
6236:31459+10	23D9  C9      			RET
6237:						
6238:31469+7	23DA  0605    	INITFAT_C3_0	LD	B,5		;5 shifts = Multiply 32
6239:31476+11	23DC  29      	INITFAT_C3_LP2	ADD	HL,HL		;Double H
6240:31487+10	23DD  DAC323  			JP C,	INITFAT_C3_ERR
6241:31497+8+5	23E0  10FA    			DJNZ	INITFAT_C3_LP2
6242:				
6243:31505+4	23E2  7B      			LD	A,E		;2'S Complement BYTE_P_SEC
6244:31509+4	23E3  2F      			CPL
6245:31513+4	23E4  4F      			LD	C,A
6246:31517+4	23E5  7A      			LD	A,D
6247:31521+4	23E6  2F      			CPL
6248:31525+4	23E7  47      			LD	B,A
6249:31529+6	23E8  03      			INC	BC
6250:31535+10	23E9  11FFFF  			LD	DE,0FFFFh	;Start with -1
6251:31545+11	23EC  09      	INITFAT_C3_LP3	ADD	HL,BC		;Divide by counting Subtractions
6252:31556+6	23ED  13      			INC	DE
6253:31562+7+5	23EE  38FC    			JR   C,	INITFAT_C3_LP3
6254:31569+16	23F0  2A35FF  			LD	HL, (DIR_SECTOR)	;Add the Dword at DIR_SECTOR
6255:31585+11	23F3  19      			ADD	HL,DE
6256:31596+16	23F4  2239FF  			LD	(DATASTART), HL
6257:31612+16	23F7  2A37FF  			LD	HL, (DIR_SECTOR+2)
6258:31628+7+5	23FA  3001    			JR  NC,	INITFAT_C3_1
6259:31635+6	23FC  23      			INC	HL
6260:31641+16	23FD  223BFF  	INITFAT_C3_1	LD	(DATASTART+2), HL
6261:				
6262:31657+13	2400  3A21FF  			LD	A, (SEC_PER_CLUS)	;Determine the best way to divide Sectors into cluster#
6263:31670+4	2403  3D      			DEC	A
6264:31674+13	2404  3258FF  			LD	(MODMASK), A
6265:31687+4	2407  3C      			INC	A
6266:31691+7+5	2408  284B    			JR   Z,	INITFAT_FAIL1
6267:31698+10	240A  010008  			LD	BC,0800h
6268:31708+4	240D  1F      	INITFAT_C4_LP	RRA
6269:31712+7+5	240E  3002    			JR  NC,	INITFAT_C4_1
6270:31719+4	2410  50      			LD	D,B		;Save location of "1" bit
6271:31723+4	2411  0C      			INC	C		;Count of 1 bits.
6272:31727+8+5	2412  10F9    	INITFAT_C4_1	DJNZ	INITFAT_C4_LP
6273:31735+7	2414  3E01    			LD	A,1
6274:31742+4	2416  B9      			CP	C
6275:31746+7+5	2417  200F    			JR  NZ,	INITFAT_C4_2	;More than 1 "1" bit, cannot do divide by simple shift.
6276:31753+4	2419  7A      			LD	A,D		;Fetch position of the 1 bit.  8=lsb, 1=msb
6277:31757+4	241A  2F      			CPL
6278:31761+7	241B  C60A    			ADD	A,10		;Re-adjust to make 1=lsb AND 8=msb  A=9-A
6279:31768+13	241D  3254FF  			LD	(DF_SHIFTCNT), A
6280:31781+10	2420  212C27  			LD	HL,DIVBYSHIFT	;Use fast shift divider
6281:31791+10	2423  113927  			LD	DE,MODBYMASK
6282:31801+12	2426  1805    			JR	INITFAT_C4_3
6283:				
6284:31813+10	2428  211427  	INITFAT_C4_2	LD	HL,DIV16BY8SPC	;Use Full Divide function for Sectors Per Cluster
6285:31823+11	242B  E5      			PUSH	HL
6286:31834+10	242C  D1      			POP	DE
6287:31844+16	242D  2252FF  	INITFAT_C4_3	LD	(DIVIDE_FUNC), HL
6288:31860+4	2430  EB      			EX	DE, HL	
6289:31864+16	2431  2256FF  			LD	(MOD_FUNC), HL
6290:				
6291:31880+17	2434  CDCA0D  			CALL 	PRINTI		;
6292:     -	2437  20564F4C			DB " VOL=",EOS
	              3D00
6293:31897+10	243D  212BFC  			LD	HL,SD_RAM_BUFFER+002Bh
6294:31907+7	2440  060B    			LD	B,11
6295:31914+17	2442  CDD00D  			CALL	PRINTB
6296:31931+17	2445  CDCA0D  			CALL 	PRINTI		;
6297:     -	2448  20535953			DB " SYS=",EOS
	              3D00
6298:31948+7	244E  0608    			LD	B,8
6299:31955+17	2450  CDD00D  			CALL	PRINTB
6300:31972+4	2453  AF      			XOR	A
6301:31976+10	2454  C9      			RET
6302:				
6303:31986+17	2455  CDCA0D  	INITFAT_FAIL1	CALL 	PRINTI		;
6304:     -	2458  0D0A4572			DB CR,LF,"Error=0 Sec/Clus",EOS
	              726F723D
	              30205365
	              632F436C
	              757300
6305:32003+17	246B  CDCA0D  	INITFAT_FAIL	CALL 	PRINTI		;
6306:     -	246E  0D0A4641			DB CR,LF,"FAT Init FAILED",EOS
	              5420496E
	              69742046
	              41494C45
	              4400
6307:32020+4	2480  AF      			XOR	A
6308:32024+4	2481  3D      			DEC	A
6309:32028+10	2482  C9      			RET
6310:				
6311:				;-------------------------------------------------
6312:32038+17	2483  CDCA0D  	TEST_SIGNATURE	CALL 	PRINTI		;
6313:     -	2486  205300  			DB " S",EOS
6314:32055+6	2489  2B      			DEC	HL
6315:32061+7	248A  3EAA    			LD	A,0AAh
6316:32068+7	248C  BE      			CP	(HL)
6317:32075+7+5	248D  20DC    			JR  NZ,	INITFAT_FAIL
6318:32082+6	248F  2B      			DEC	HL
6319:32088+7	2490  3E55    			LD	A,055h
6320:32095+7	2492  BE      			CP	(HL)
6321:32102+7+5	2493  20D6    			JR  NZ,	INITFAT_FAIL
6322:32109+10	2495  C9      			RET
6323:				
6324:				
6325:				
6326:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
6327:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
6328:				;	Chapter_15	SD Memory Card Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
6329:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
6330:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
6331:				
6332:				;-----------------------------------------------------------------------------------------------------
6333:				;Read the SD Card at Sector BCDE TO the SD_RAM_BUFFER
6334:				;-----------------------------------------------------------------------------------------------------
6335:						;Sector in SEC_PTR
6336:32119+10	2496  213DFF  	SD_READ_SEC	LD	HL,SEC_PTR	;READ SECTOR
6337:32129+17	2499  CD7827  			CALL	CMP_HL_32
6338:32146+5+6	249C  C8      			RET Z			;Return if no change to sector being read
6339:				
6340:32151+13	249D  3A0FFF  			LD	A, (DIRTY_DATA)	;Test if flush required
6341:32164+4	24A0  B7      			OR	A
6342:32168+10	24A1  CAB424  			JP Z,	SD_RS_FORCED	;Jump if no change in SD RAM BUFFER
6343:32178+4	24A4  AF      			XOR	A
6344:32182+13	24A5  320FFF  			LD	(DIRTY_DATA), A	;Clear Write Flag
6345:				
6346:32195+11	24A8  C5      			PUSH	BC		;Save BCDE (Sector to Read)
6347:32206+11	24A9  D5      			PUSH	DE
6348:32217+11	24AA  E5      			PUSH	HL
6349:32228+17	24AB  CD3E27  			CALL	MOV_32_HL	;Fetch the last SEC_PTR
6350:				
6351:				;		CALL	PRINTI		;debug
6352:				;		DB  " Write:",EOS	;debug
6353:				;		CALL	PUT_BC		;debug
6354:				;		CALL	PUT_DE		;debug
6355:				
6356:32245+17	24AE  CDF424  			CALL	SD_WRITE_SEC
6357:32262+10	24B1  E1      			POP	HL
6358:32272+10	24B2  D1      			POP	DE
6359:32282+10	24B3  C1      			POP	BC
6360:						
6361:     -	24B4          	SD_RS_FORCED
6362:					;CALL	PRINTI		;debug
6363:					;DB  " Read:",EOS	;debug
6364:					;CALL	PUT_BC		;debug
6365:					;CALL	PUT_DE		;debug
6366:				
6367:32292+10	24B4  213DFF  			LD	HL,SEC_PTR
6368:32302+17	24B7  CD4927  			CALL	MOV_HL_32	;Save Sector in SEC_PTR
6369:32319+17	24BA  CD7225  			CALL	SET_PARAM	;READ SECTOR, HL=SD_RAM_BUFFER
6370:32336+7	24BD  0605    			LD	B,5		;5 Retries to read
6371:32343+7	24BF  3E11    	SD_RS_LP0	LD	A,17 		;Read Sector Command
6372:32350+17	24C1  CD9526  			CALL	SD_CMD
6373:32367+7+5	24C4  2807    			JR Z,	SD_RS_0
6374:32374+8+5	24C6  10F7    			DJNZ	SD_RS_LP0
6375:									;Read failed
6376:32382+4	24C8  05      			DEC	B		;Clear Zero flag
6377:32386+17	24C9  CD7D26  			CALL	SD_DESELECT	;Deselect card
6378:					;CALL	PRINTI	;debug
6379:					;DB  " #1",EOS	;debug
6380:32403+10	24CC  C9      			RET
6381:				
6382:32413+7	24CD  0600    	SD_RS_0		LD	B,0		;256 Attempts to recieve the DATASTART
6383:32420+17	24CF  CDDE26  	SD_RS_LP1	CALL	SPI_RX
6384:32437+7	24D2  FEFE    			CP	0FEh		;IS DATASTART?
6385:32444+7+5	24D4  2806    			JR Z,	SD_RS_1
6386:32451+8+5	24D6  10F7    			DJNZ	SD_RS_LP1
6387:32459+17	24D8  CD7D26  			CALL	SD_DESELECT	;Deselect card
6388:					;CALL	PRINTI	;debug
6389:					;DB  " #2",EOS	;debug
6390:32476+10	24DB  C9      			RET
6391:				
6392:32486+10	24DC  010002  	SD_RS_1		LD	BC,0200h
6393:32496+17	24DF  CDDE26  	SD_RS_LP2	CALL	SPI_RX		;Fetch 512 Bytes to M(HL)
6394:32513+7	24E2  77      			LD	(HL),A
6395:32520+6	24E3  23      			INC	HL
6396:32526+4	24E4  0D      			DEC	C
6397:32530+7+5	24E5  20F8    			JR NZ,	SD_RS_LP2
6398:32537+8+5	24E7  10F6    			DJNZ	SD_RS_LP2
6399:				
6400:32545+17	24E9  CDDE26  			CALL	SPI_RX		;BURN 2 BYTES (CRC)
6401:32562+17	24EC  CDDE26  			CALL	SPI_RX		;
6402:32579+17	24EF  CD7D26  			CALL	SD_DESELECT	;Deselect card
6403:					;CALL	PRINTI	;debug
6404:					;DB  " #3",EOS	;debug
6405:32596+4	24F2  AF      			XOR	A
6406:32600+10	24F3  C9      			RET
6407:				
6408:				
6409:				
6410:				;-----------------------------------------------------------------------------------------------------
6411:				;Write the SD_RAM_BUFFER to the SD Card at Sector 'SEC_PTR'
6412:				;-----------------------------------------------------------------------------------------------------
6413:						;Sector in SEC_PTR, H=SD_RAM_BUFFER
6414:32610+4	24F4  AF      	SD_WRITE_SEC	XOR	A
6415:32614+11	24F5  D3C6    			OUT	(GREEN_LED),A
6416:32625+17	24F7  CD7225  			CALL	SET_PARAM
6417:32642+7	24FA  3E18    			LD	A,24 	;Write Sector Command
6418:32649+17	24FC  CD9526  			CALL	SD_CMD
6419:32666+7	24FF  3E01    			LD	A,1 	;Error Code
6420:32673+10	2501  C25725  			JP NZ,	SD_WR_FAIL
6421:				
6422:32683+7	2504  3EFE    			LD	A,0FEh	;DATA START BLOCK
6423:32690+17	2506  CDE026  			CALL	SPI_TX
6424:32707+10	2509  010002  			LD	BC,0200h
6425:32717+7	250C  7E      	SD_WR_LP	LD	A,(HL)
6426:32724+6	250D  23      			INC	HL
6427:32730+17	250E  CDE026  			CALL	SPI_TX
6428:32747+4	2511  0D      			DEC	C
6429:32751+10	2512  C20C25  			JP NZ,	SD_WR_LP
6430:32761+8+5	2515  10F5    			DJNZ	SD_WR_LP
6431:				
6432:32769+7	2517  3EFF    			LD	A,0FFh
6433:32776+17	2519  CDE026  			CALL	SPI_TX
6434:32793+4	251C  00      			NOP
6435:32797+7	251D  3EFF    			LD	A,0FFh
6436:32804+17	251F  CDE026  			CALL	SPI_TX
6437:				
6438:32821+17	2522  CDDE26  			CALL	SPI_RX
6439:32838+7	2525  E61F    			AND	1Fh
6440:32845+7	2527  FE05    			CP	5
6441:32852+7	2529  3E02    			LD	A,2 	;Error Code
6442:32859+10	252B  C25725  			JP NZ,	SD_WR_FAIL
6443:32869+17	252E  CDF426  			CALL	WAIT_NOT_BUSY
6444:32886+7	2531  3E03    			LD	A,3 	;Error Code
6445:32893+10	2533  DA5725  			JP C,	SD_WR_FAIL
6446:32903+17	2536  CD8D25  			CALL	SD_CLEAR_ARG
6447:32920+7	2539  3E0D    			LD	A,13		;SEND_STATUS
6448:32927+17	253B  CD9526  			CALL	SD_CMD
6449:32944+7	253E  3E04    			LD	A,4 	;Error Code
6450:32951+10	2540  C25725  			JP NZ,	SD_WR_FAIL
6451:32961+17	2543  CDDE26  			CALL	SPI_RX
6452:32978+4	2546  B7      			OR	A
6453:32982+7	2547  3E05    			LD	A,5 	;Error Code
6454:32989+10	2549  C25725  			JP NZ,	SD_WR_FAIL
6455:				
6456:32999+4	254C  AF      			XOR	A		;A should be zero
6457:33003+13	254D  320FFF  			LD	(DIRTY_DATA), A
6458:				
6459:33016+17	2550  CD9026  			CALL	SD_DELAY
6460:				
6461:33033+17	2553  CD7D26  			CALL	SD_DESELECT	;Deselect card
6462:33050+10	2556  C9      			RET
6463:				
6464:33060+17	2557  CD7D26  	SD_WR_FAIL	CALL	SD_DESELECT	;Deselect card
6465:33077+17	255A  CDCA0D  			CALL	PRINTI
6466:     -	255D  0D0A2D57			DB CR,LF,"-Write Failed:",EOS
	              72697465
	              20466169
	              6C65643A
	              00
6467:33094+17	256E  CDF60D  			CALL	PUT_BYTE
6468:33111+10	2571  C9      			RET
6469:				
6470:				;-----------------------------------------------------------------------------------------------------
6471:				;Input:	Sector in 32 bit register BCDE
6472:33121+13	2572  3A10FF  	SET_PARAM	LD	A, (SD_CARD_TYPE)	;IF CARD_TYPE <> 3 THEN SHIFT SECTOR << 9 Bits
6473:33134+7	2575  FE03    			CP	3
6474:33141+10	2577  CA8325  			JP Z,	SP_RET
6475:				
6476:33151+4	257A  79      			LD	A,C
6477:33155+4	257B  EB      			EX	DE, HL	
6478:33159+11	257C  29      			ADD	HL,HL
6479:33170+4	257D  17      			RLA
6480:33174+4	257E  47      			LD	B,A
6481:33178+4	257F  4C      			LD	C,H
6482:33182+4	2580  55      			LD	D,L
6483:33186+7	2581  1E00    			LD	E,0
6484:				
6485:33193+10	2583  2112FF  	SP_RET		LD	HL,SD_PARAM
6486:33203+17	2586  CD4927  			CALL	MOV_HL_32		;Save Parameter
6487:33220+10	2589  2100FC  			LD	HL,SD_RAM_BUFFER	;Set buffer space
6488:33230+10	258C  C9      			RET
6489:				
6490:				;-----------------------------------------------------------------------------------------------------
6491:33240+4	258D  AF      	SD_CLEAR_ARG	XOR	A
6492:33244+13	258E  3212FF  			LD	(SD_PARAM),A
6493:33257+13	2591  3213FF  			LD	(SD_PARAM+1),A
6494:33270+13	2594  3214FF  			LD	(SD_PARAM+2),A
6495:33283+13	2597  3215FF  			LD	(SD_PARAM+3),A
6496:33296+10	259A  C9      			RET
6497:				
6498:				
6499:				;=====================================================================================================
6500:				;SD Memory Car Routines, Low Level, INIT CARD, Send/Recieve Data, Send Commands
6501:				;=====================================================================================================
6502:				;-------------------------------- INIT SDCARD --------------------------------
6503:33306+17	259B  CD7D26  	INIT_SDCARD	CALL	SD_DESELECT	;Deselect and clock the card many cycles
6504:33323+7	259E  0680    			LD	B,080H
6505:33330+7	25A0  3EFF    	ISD_0		LD	A,0FFH
6506:33337+13	25A2  3210FF  			LD	(SD_CARD_TYPE),A
6507:33350+17	25A5  CDE026  			CALL	SPI_TX		;CLOCK many cycles
6508:33367+8+5	25A8  10F6    			DJNZ	ISD_0		;256 Clocks
6509:33375+17	25AA  CD8826  			CALL	SD_SELECT
6510:				
6511:33392+17	25AD  CDCA0D  			CALL 	PRINTI		;
6512:     -	25B0  0D0A496E			DB	CR,LF,"Init SD",EOS
	              69742053
	              4400
6513:				
6514:33409+17	25BA  CD8D25  			CALL	SD_CLEAR_ARG	;Fetch the 01 response
6515:33426+7	25BD  0600    			LD	B,0		;256 retries
6516:33433+7	25BF  3E00    	ISD_LP1		LD	A,0		;CMD 0
6517:33440+17	25C1  CD9526  			CALL	SD_CMD
6518:						;CALL	PUT_BYTE
6519:33457+7	25C4  FE01    			CP	1		;Test 01 response
6520:33464+7+5	25C6  2813    			JR  Z,	ISD_1
6521:33471+8+5	25C8  10F5    			DJNZ	ISD_LP1
6522:						
6523:33479+17	25CA  CDCA0D  	INIT_FAIL	CALL 	PRINTI		;
6524:     -	25CD  2D464149			DB	"-FAILED",EOS
	              4C454400
6525:33496+17	25D5  CD7D26  			CALL	SD_DESELECT
6526:33513+4	25D8  AF      			XOR	A		;Return Zero Flag cleared = Failure
6527:33517+4	25D9  3D      			DEC	A
6528:33521+10	25DA  C9      			RET
6529:				
6530:33531+17	25DB  CDCA0D  	ISD_1		CALL 	PRINTI		;
6531:     -	25DE  20547970			DB	" Type#",EOS
	              652300
6532:33548+10	25E5  21AA01  			LD	HL,01AAh	;Deterimine Card Type
6533:33558+16	25E8  2212FF  			LD	(SD_PARAM),HL
6534:33574+7	25EB  3E08    			LD	A,8		;CMD 8
6535:33581+17	25ED  CD9526  			CALL	SD_CMD
6536:33598+7	25F0  E604    			AND	4
6537:33605+7+5	25F2  2808    			JR   Z,	ISD_2
6538:33612+7	25F4  3E01    			LD	A,1		;If CMD8 is Illegal Cmd, CARD_TYPE=1
6539:33619+13	25F6  3210FF  			LD	(SD_CARD_TYPE),A
6540:33632+10	25F9  C31626  			JP	ISD_3
6541:				
6542:33642+17	25FC  CDDE26  	ISD_2		CALL	SPI_RX
6543:33659+17	25FF  CDDE26  			CALL	SPI_RX
6544:33676+17	2602  CDDE26  			CALL	SPI_RX
6545:33693+17	2605  CDDE26  			CALL	SPI_RX
6546:33710+13	2608  3211FF  			LD	(SDC_STATUS),A
6547:33723+7	260B  FEAA    			CP	0AAh
6548:33730+7	260D  3EAA    			LD	A,0AAh		;Error code
6549:33737+7+5	260F  20B9    			JR  NZ,	INIT_FAIL
6550:33744+7	2611  3E02    			LD	A,2
6551:33751+13	2613  3210FF  			LD	(SD_CARD_TYPE),A
6552:				
6553:33764+17	2616  CD090E  	ISD_3		CALL	PUT_HEX
6554:33781+17	2619  CDCA0D  			CALL 	PRINTI		;
6555:     -	261C  2041434D			DB	" ACMD41",EOS
	              44343100
6556:33798+17	2624  CD8D25  			CALL	SD_CLEAR_ARG
6557:				
6558:33815+7	2627  0600    			LD	B,0
6559:33822+7	2629  3E37    	ISD_LP2		LD	A,55		;CMD 55 (ACMD)
6560:33829+17	262B  CD9526  			CALL	SD_CMD
6561:33846+7	262E  3E29    			LD	A,41		;CMD 41
6562:33853+17	2630  CD9526  			CALL	SD_CMD
6563:33870+7	2633  FE00    			CP	0
6564:33877+7+5	2635  2808    			JR Z,	ISD_4
6565:33884+4	2637  AF      			XOR	A		;256 ~= 2mSec Delay
6566:33888+17	2638  CD9026  			CALL	SD_DELAY
6567:33905+8+5	263B  10EC    			DJNZ	ISD_LP2
6568:33913+12	263D  188B    			JR	INIT_FAIL
6569:				
6570:33925+17	263F  CDCA0D  	ISD_4		CALL 	PRINTI		;
6571:     -	2642  2B00    			DB	"+",EOS
6572:33942+13	2644  3A10FF  			LD	A,(SD_CARD_TYPE)
6573:33955+7	2647  FE02    			CP	2
6574:33962+7+5	2649  202D    			JR  NZ,	ISD_6
6575:33969+7	264B  3E3A    			LD	A,58		;CMD 58
6576:33976+17	264D  CD9526  			CALL	SD_CMD
6577:33993+7	2650  FE00    			CP	0
6578:34000+10	2652  C2CA25  			JP  NZ,	INIT_FAIL
6579:34010+17	2655  CDDE26  			CALL	SPI_RX
6580:34027+7	2658  E6C0    			AND	0C0h
6581:34034+7	265A  FEC0    			CP	0C0h
6582:34041+10	265C  C26F26  			JP NZ,	ISD_5
6583:34051+7	265F  3E03    			LD	A,3
6584:34058+13	2661  3210FF  			LD	(SD_CARD_TYPE),A
6585:34071+17	2664  CDCA0D  			CALL 	PRINTI		;
6586:     -	2667  20547970			DB	" Type#3",EOS
	              65233300
6587:34088+17	266F  CDDE26  	ISD_5		CALL	SPI_RX
6588:34105+17	2672  CDDE26  			CALL	SPI_RX
6589:34122+17	2675  CDDE26  			CALL	SPI_RX
6590:				
6591:34139+17	2678  CD7D26  	ISD_6		CALL	SD_DESELECT
6592:34156+4	267B  AF      			XOR	A		;Set Zero Flag = Success
6593:34160+10	267C  C9      			RET
6594:				
6595:				;-----------------------------------------------------------------------------------------------------
6596:34170+11	267D  F5      	SD_DESELECT	PUSH	AF
6597:34181+7	267E  3E01    			LD	A,1
6598:34188+11	2680  D3C4    			OUT	(SDCS),A
6599:34199+11	2682  D3C0    			OUT	(SDCLK),A
6600:34210+11	2684  D3C6    			OUT	(GREEN_LED),A
6601:34221+10	2686  F1      			POP	AF
6602:34231+10	2687  C9      			RET
6603:						
6604:				;-----------------------------------------------------------------------------------------------------
6605:34241+11	2688  F5      	SD_SELECT	PUSH	AF
6606:34252+4	2689  AF      			XOR	A
6607:34256+11	268A  D3C4    			OUT	(SDCS),A
6608:34267+10	268C  F1      			POP	AF
6609:34277+10	268D  C9      			RET
6610:				
6611:				;-----------------------------------------------------------------------------------------------------
6612:34287+7	268E  3E0D    	SD_DELAY100	LD	A,13	 ;Small delay after selecting card
6613:34294+4	2690  3D      	SD_DELAY	DEC	A	 ;5
6614:34298+10	2691  C29026  			JP NZ,	SD_DELAY ;10    15*13 ~= 200 ~= 100uSec
6615:34308+10	2694  C9      			RET
6616:				
6617:				;-----------------------------------------------------------------------------------------------------
6618:				;Send command to SD card
6619:34318+11	2695  C5      	SD_CMD		PUSH	BC
6620:34329+17	2696  CD8826  			CALL	SD_SELECT
6621:34346+17	2699  CDF426  			CALL	WAIT_NOT_BUSY
6622:				
6623:34363+7	269C  06FF    			LD	B,0FFh	;Default CRC
6624:34370+7	269E  FE00    			CP	0
6625:34377+10	26A0  C2A526  			JP NZ,	SDC_1
6626:34387+7	26A3  0695    			LD	B,095h	;If CMD=0 THEN CRC=95
6627:34394+7	26A5  FE08    	SDC_1		CP	8
6628:34401+10	26A7  C2AC26  			JP NZ,	SDC_2
6629:34411+7	26AA  0687    			LD	B,087h
6630:     -	26AC          	SDC_2
6631:				
6632:34418+7	26AC  F640    			OR	040H	;All Commands start with 40h
6633:34425+17	26AE  CDE026  			CALL	SPI_TX
6634:34442+13	26B1  3A15FF  			LD	A,(SD_PARAM+3)
6635:34455+17	26B4  CDE026  			CALL	SPI_TX
6636:34472+13	26B7  3A14FF  			LD	A,(SD_PARAM+2)
6637:34485+17	26BA  CDE026  			CALL	SPI_TX
6638:34502+13	26BD  3A13FF  			LD	A,(SD_PARAM+1)
6639:34515+17	26C0  CDE026  			CALL	SPI_TX
6640:34532+13	26C3  3A12FF  			LD	A,(SD_PARAM)
6641:34545+17	26C6  CDE026  			CALL	SPI_TX
6642:34562+4	26C9  78      			LD	A,B
6643:34566+17	26CA  CDE026  			CALL	SPI_TX
6644:				
6645:34583+7	26CD  0600    			LD	B,0
6646:34590+17	26CF  CDDE26  	SDC_LP		CALL	SPI_RX	;Read Respsonse?
6647:34607+13	26D2  3211FF  			LD	(SDC_STATUS),A
6648:34620+4	26D5  B7      			OR	A
6649:34624+10	26D6  F2DC26  			JP P,	SDC_RET	;If Positive Response, EXIT
6650:34634+8+5	26D9  10F4    			DJNZ	SDC_LP	;Else Read next Response
6651:34642+4	26DB  B7      			OR	A
6652:34646+10	26DC  C1      	SDC_RET		POP	BC
6653:34656+10	26DD  C9      			RET
6654:				
6655:				;-----------------------------------------------------------------------------------------------------
6656:				;------------------------------- Receive a byte from SPI
6657:34666+7	26DE  3EFF    	SPI_RX		LD	A,0FFH	;Read Respsonse, send a byte to get a byte...
6658:				
6659:34673+11	26E0  C5      	SPI_TX		PUSH	BC
6660:34684+4	26E1  4F      			LD	C,A	;Save Byte to send in C
6661:34688+7	26E2  0608    			LD	B,8	;8 BITS
6662:						
6663:34695+11	26E4  DBCE    	SPI_TX_LP	IN	A,(ACE_MSR)	;Fetch RX bit
6664:34706+4	26E6  17      			RLA			;Save bit in CY
6665:34710+8	26E7  CB11    			RL	C		;Move bit into C (and bump next tx bit up)
6666:34718+4	26E9  17      			RLA			;Get bit to send in lsb
6667:34722+11	26EA  D3C5    			OUT	(SDTX),A	;Send bit
6668:34733+11	26EC  DBC0    			IN	A,(SDCLK)	;Clock the bit
6669:34744+8+5	26EE  10F4    			DJNZ	SPI_TX_LP		
6670:34752+4	26F0  79      			LD	A,C
6671:34756+4	26F1  2F      			CPL			;Correct Inversion by ACE
6672:34760+10	26F2  C1      			POP	BC
6673:34770+10	26F3  C9      			RET
6674:				
6675:				;-----------------------------------------------------------------------------------------------------
6676:				;------------------------------- Wait until FF's come back from Card (ie NOT BUSY)
6677:34780+11	26F4  F5      	WAIT_NOT_BUSY	PUSH	AF	;Do not destroy Acc
6678:34791+11	26F5  C5      			PUSH	BC	;Fetch 1 consecutive FF's to be sure SD card NOT BUSY
6679:34802+7	26F6  0600    			LD	B,0
6680:34809+7	26F8  0E01    	WNB_LP		LD	C,1	;Set count for 1 trys
6681:34816+17	26FA  CDDE26  	WNB_LP2		CALL	SPI_RX
6682:34833+4	26FD  3C      			INC	A
6683:34837+10	26FE  C20A27  			JP NZ,	WNB_0	;NOT FF RETURNED, JUMP TO COUNT DOWN TRYS
6684:34847+4	2701  0D      			DEC	C	;Count Down Consecutive FF's
6685:34851+10	2702  C2FA26  			JP NZ,	WNB_LP2
6686:34861+10	2705  C1      			POP	BC
6687:34871+10	2706  F1      			POP	AF
6688:34881+4	2707  37      			SCF		;Return NOT BUSY (Clear Carry)
6689:34885+4	2708  3F      			CCF
6690:34889+10	2709  C9      			RET
6691:				
6692:34899+4	270A  AF      	WNB_0		XOR	A
6693:34903+17	270B  CD9026  			CALL	SD_DELAY
6694:34920+8+5	270E  10E8    			DJNZ	WNB_LP	;Count Down Trys
6695:34928+10	2710  C1      			POP	BC
6696:34938+10	2711  F1      			POP	AF
6697:34948+4	2712  37      			SCF		;Return STILL BUSY (Set Carry)
6698:34952+10	2713  C9      			RET
6699:				
6700:				
6701:				
6702:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
6703:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
6704:				;	Chapter_16	General Support Routines, 32 Bit stuff and other math
6705:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
6706:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
6707:				
6708:				;-----------------------------------------------------------------------------------------------------
6709:				;Maximum number to divide is Logical Sector 2001/4 = 500
6710:				;If dividing by powers of 2, then we can shift the number for fast divide
6711:34962+13	2714  3A21FF  	DIV16BY8SPC	LD	A, (SEC_PER_CLUS)
6712:				;Input:	DE=Dividend, A=Divisor
6713:				;Out:	DE=Result, A=Remainder
6714:34975+4	2717  EB      	DIV16BY8	EX	DE, HL	; HL = Dividend
6715:34979+7	2718  1E00    			LD	E,00	; Quotient = 0
6716:34986+4	271A  4F      			LD	C, A	; Store        Divisor
6717:34990+7	271B  0608    			LD	B, 08	; Count = 8
6718:34997+11	271D  29      	DIV16BY8_LP	ADD	HL,HL	; Dividend = Dividend x 2
6719:35008+8	271E  CB03    			RLC	E	; Quotient = Quotient x 2
6720:35016+4	2720  7C      			LD	A, H
6721:35020+4	2721  91      			SUB	C	; Is most significant byte of Dividend > divisor
6722:35024+7+5	2722  3802    			JR C,	DIV16BY8_SK	; No, go to Next step
6723:35031+4	2724  67      			LD	H, A	; Yes, subtract divisor
6724:35035+4	2725  1C      			INC	E	; and Quotient = Quotient + 1
6725:35039+8+5	2726  10F5    	DIV16BY8_SK	DJNZ 	DIV16BY8_LP ; Count = Count - 1
6726:35047+4	2728  7C      			LD	A, H
6727:35051+7	2729  1600    			LD	D,0	; Quotient in DE
6728:35058+10	272B  C9      			RET
6729:				
6730:				;-----------------------------------------------------------------------------------------------------
6731:35068+13	272C  3A54FF  	DIVBYSHIFT	LD	A, (DF_SHIFTCNT)	; DE = Dividend
6732:35081+4	272F  47      			LD	B,A
6733:35085+4	2730  05      	DBS_LP		DEC	B
6734:35089+5+6	2731  C8      			RET Z
6735:35094+8	2732  CB3A    			SRL	D
6736:35102+8	2734  CB1B    			RR	E
6737:35110+10	2736  C33027  			JP	DBS_LP
6738:				
6739:				;-----------------------------------------------------------------------------------------------------
6740:35120+13	2739  3A58FF  	MODBYMASK	LD	A, (MODMASK)
6741:35133+4	273C  A3      			AND	E
6742:35137+10	273D  C9      			RET
6743:				
6744:				;------------------------- Move (HL) to 32 bit register BCDE
6745:35147+7	273E  5E      	MOV_32_HL	LD	E,(HL)
6746:35154+6	273F  23      			INC	HL
6747:35160+7	2740  56      			LD	D,(HL)
6748:35167+6	2741  23      			INC	HL
6749:35173+7	2742  4E      			LD	C,(HL)
6750:35180+6	2743  23      			INC	HL
6751:35186+7	2744  46      			LD	B,(HL)
6752:35193+6	2745  2B      			DEC	HL
6753:35199+6	2746  2B      			DEC	HL
6754:35205+6	2747  2B      			DEC	HL
6755:35211+10	2748  C9      			RET
6756:				
6757:				;------------------------- Move 32 bit register BCDE to (HL)
6758:35221+7	2749  73      	MOV_HL_32	LD	(HL),E
6759:35228+6	274A  23      			INC	HL
6760:35234+7	274B  72      			LD	(HL),D
6761:35241+6	274C  23      			INC	HL
6762:35247+7	274D  71      			LD	(HL),C
6763:35254+6	274E  23      			INC	HL
6764:35260+7	274F  70      			LD	(HL),B
6765:35267+6	2750  2B      			DEC	HL
6766:35273+6	2751  2B      			DEC	HL
6767:35279+6	2752  2B      			DEC	HL
6768:35285+10	2753  C9      			RET
6769:				
6770:				;------------------------- ADD (HL) to 32 bit register BCDE - (Must return with HL changed to last byte)
6771:35295+4	2754  7B      	ADD_32_HL	LD	A,E
6772:35299+7	2755  86      			ADD	A,(HL)
6773:35306+4	2756  5F      			LD	E,A
6774:35310+6	2757  23      			INC	HL
6775:35316+4	2758  7A      			LD	A,D
6776:35320+7	2759  8E      			ADC	A,(HL)
6777:35327+4	275A  57      			LD	D,A
6778:35331+6	275B  23      			INC	HL
6779:35337+4	275C  79      			LD	A,C
6780:35341+7	275D  8E      			ADC	A,(HL)
6781:35348+4	275E  4F      			LD	C,A
6782:35352+6	275F  23      			INC	HL		
6783:35358+4	2760  78      			LD	A,B
6784:35362+7	2761  8E      			ADC	A,(HL)
6785:35369+4	2762  47      			LD	B,A
6786:35373+6	2763  23      			INC	HL		;(Must return with HL advanced past 32 bits)
6787:35379+10	2764  C9      			RET
6788:				
6789:				;-----------------------------------------------------------------------------------------------------
6790:35389+6	2765  13      	INC_32		INC	DE
6791:35395+4	2766  7A      			LD	A,D
6792:35399+4	2767  B3      			OR	E
6793:35403+5+6	2768  C0      			RET NZ
6794:35408+6	2769  03      			INC	BC
6795:35414+10	276A  C9      			RET
6796:				
6797:				;-----------------------------------------------------------------------------------------------------
6798:35424+4	276B  7A      	DEC_32		LD	A,D
6799:35428+4	276C  B3      			OR	E
6800:35432+10	276D  C27127  			JP NZ,	DEC_32NB
6801:35442+6	2770  0B      			DEC	BC
6802:35448+6	2771  1B      	DEC_32NB	DEC	DE
6803:35454+10	2772  C9      			RET
6804:				
6805:				;-----------------------------------------------------------------------------------------------------
6806:35464+4	2773  7A      	TSTZ_32		LD	A,D
6807:35468+4	2774  B3      			OR	E
6808:35472+4	2775  B1      			OR	C
6809:35476+4	2776  B0      			OR	B
6810:35480+10	2777  C9      			RET
6811:				
6812:				;-----------------------------------------------------------------------------------------------------
6813:				;Compare BCDE with 32bit word at HL
6814:35490+6	2778  23      	CMP_HL_32	INC	HL		;Point to MSB
6815:35496+6	2779  23      			INC	HL
6816:35502+6	277A  23      			INC	HL
6817:35508+4	277B  78      			LD	A,B		;Compare with B
6818:35512+7	277C  BE      			CP	(HL)
6819:35519+7+5	277D  200E    			JR NZ,	CH3_R1
6820:35526+6	277F  2B      			DEC	HL
6821:35532+4	2780  79      			LD	A,C
6822:35536+7	2781  BE      			CP	(HL)
6823:35543+7+5	2782  200A    			JR NZ,	CH3_R2
6824:35550+6	2784  2B      			DEC	HL
6825:35556+4	2785  7A      			LD	A,D
6826:35560+7	2786  BE      			CP	(HL)
6827:35567+7+5	2787  2006    			JR NZ,	CH3_R3
6828:35574+6	2789  2B      			DEC	HL
6829:35580+4	278A  7B      			LD	A,E
6830:35584+7	278B  BE      			CP	(HL)
6831:35591+10	278C  C9      			RET
6832:35601+6	278D  2B      	CH3_R1		DEC	HL
6833:35607+6	278E  2B      	CH3_R2		DEC	HL
6834:35613+6	278F  2B      	CH3_R3		DEC	HL
6835:35619+10	2790  C9      			RET
6836:				
6837:				;------------------------- COMPARE DE WITH HL
6838:35629+4	2791  7A      	CMP_DE_HL	LD	A,D		;Compare the MSB first
6839:35633+4	2792  BC      			CP	H
6840:35637+5+6	2793  C0      			RET NZ
6841:35642+4	2794  7B      			LD	A,E
6842:35646+4	2795  BD      			CP	L
6843:35650+10	2796  C9      			RET
6844:				
6845:				
6846:				
6847:				;=====================================================================================================
6848:				;General Support Routines, Strings
6849:				;=====================================================================================================
6850:				;	OUTPUT: STRING ENTERED @M(HL), C=0
6851:				;		<ESC> PRESSED C=1
6852:				;-----------------------------------------------------------------------------------------------------
6853:35660+17	2797  CDE013  	GET_STRING:	CALL	GET_CHAR
6854:35677+7	279A  FE1B    			CP	27
6855:35684+4	279C  37      			SCF			;Set Carry to indicate Abort
6856:35688+5+6	279D  C8      			RET Z
6857:35693+7	279E  FE0D    			CP	13		;Exit on <CR>
6858:35700+5+6	27A0  C8      			RET Z
6859:35705+4	27A1  B9      			CP	C		;Exit on Selectable Char (dot for file input)
6860:35709+5+6	27A2  C8      			RET Z
6861:35714+17	27A3  CDB227  			CALL	TO_UPPER
6862:35731+7	27A6  FE21    			CP	' '+1		;Test if ACC is Control or Space
6863:35738+7+5	27A8  38ED    			JR C,	GET_STRING	;Skip such characters
6864:35745+4	27AA  05      			DEC	B
6865:35749+4	27AB  04      			INC	B		;Exit if B characters are already inputed
6866:35753+5+6	27AC  C8      			RET Z			;Exit if no more characters allowed
6867:35758+7	27AD  77      			LD	(HL),A
6868:35765+6	27AE  23      			INC	HL
6869:35771+4	27AF  05      			DEC	B
6870:35775+12	27B0  18E5    			JR	GET_STRING
6871:				
6872:				;-----------------------------------------------------------------------------------------------------
6873:35787+7	27B2  FE61    	TO_UPPER	CP	'a'
6874:35794+5+6	27B4  D8      			RET C		;Return if ACC < 'a'
6875:35799+7	27B5  FE7B    			CP	'z'+1
6876:35806+5+6	27B7  D0      			RET NC		;Return if ACC > 'z'
6877:35811+7	27B8  E65F    			AND	5Fh	;Convert to upper case
6878:35818+10	27BA  C9      			RET
6879:				
6880:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
6881:35828+7	27BB  FE41    	IS_LETTER	CP	'A'
6882:35835+5+6	27BD  D8      			RET C
6883:35840+7	27BE  FE5B    			CP	'Z'+1
6884:35847+4	27C0  3F      			CCF
6885:35851+10	27C1  C9      			RET
6886:				
6887:				;-----------------------------------------------------------------------------------------------------
6888:				;ASCII TO BINARY
6889:				;INPUT:	HL Points to a 2 character String of ASCII
6890:				;	DE Points to a memory location to receive the Binary value
6891:				;OUTPUT: CY=0 if successful (both ASCII characters were a valid HEX digit (0-9,A-F,a-f)
6892:				;	 (DE) = Binary value of (HL) and (HL+1)
6893:				;	eg:
6894:				;	Before Call: HL=1000, DE=2000, M(1000)='A', M(1001)='B', M(2000)=xx, CY=?
6895:				;	After  Call: HL=1002, DE=2000, M(1000)='A', M(1001)='B', M(2000)=AB, CY=0
6896:				;	
6897:				;	CY=1 if invalid hex char encountered, a partial output may appear at (DE)
6898:				;	eg:
6899:				;	Before Call: HL=1000, DE=2000, M(1000)='J', M(1001)='B', M(2000)=12, CY=?
6900:				;	After  Call: HL=1000, DE=2000, M(1000)='J', M(1001)='B', M(2000)=12, CY=1
6901:				;	eg:
6902:				;	Before Call: HL=1000, DE=2000, M(1000)='A', M(1001)='J', M(2000)=12, CY=?
6903:				;	After  Call: HL=1001, DE=2000, M(1000)='A', M(1001)='J', M(2000)=2A, CY=1
6904:				;
6905:				;DESTROYS: AF
6906:				;
6907:35861+17	27C2  CDC627  	ASC2BIN		CALL	ABF1		;Convert 2 chars to HEX @(DE)
6908:35878+5+6	27C5  D8      			RET	C		;Exit on error CY=1
6909:35883+7	27C6  7E      	ABF1		LD	A,(HL)
6910:35890+17	27C7  CD980D  			CALL	ASC2HEX	;(non-hex) char when CY=1
6911:35907+5+6	27CA  D8      			RET	C
6912:35912+4	27CB  EB      	ABF_GOODHEX	EX	DE,HL
6913:35916+18	27CC  ED6F    			RLD
6914:35934+4	27CE  EB      			EX	DE,HL
6915:35938+6	27CF  23      			INC	HL
6916:35944+10	27D0  C9      			RET		
6917:				
6918:35954+13	27D1  32B2FF  	BEEP		LD	(BEEP_TO),A
6919:35967+10	27D4  C9      			RET
6920:				
6921:35977+13	27D5  32F2FF  	SET_ECHO	LD	(ECHO_STATE),A	;TURN ON/OFF ECHO
6922:35990+10	27D8  C9      			RET
6923:				
6924:36000+13	27D9  32C0FF  	LED_UPDATE	LD	(IK_TIMER),A	;0 = Cancel any monitor time outs
6925:36013+10	27DC  213C18  			LD	HL,ISET_PRESSED
6926:36023+16	27DF  22BEFF  			LD	(KEY_EVENT),HL
6927:36039+10	27E2  21E317  			LD	HL,IDISP_RET
6928:36049+16	27E5  22BCFF  			LD	(DISPMODE),HL
6929:36065+10	27E8  C9      			RET
6930:				
6931:36075+13	27E9  3AC8FF  	LED_GET_POS	LD	A,(LED_CURSOR)
6932:36088+7	27EC  E607    			AND	7
6933:36095+10	27EE  C9      			RET
6934:						
6935:36105+7	27EF  E607    	LED_SET_POS	AND	7
6936:36112+7	27F1  F6E0    			OR	LOW LED_DISPLAY
6937:36119+13	27F3  32C8FF  			LD	(LED_CURSOR),A
6938:36132+10	27F6  C9      			RET
6939:						
6940:36142+11	27F7  E5      	LED_RIGHT	PUSH	HL
6941:36153+11	27F8  C5      			PUSH	BC
6942:36164+10	27F9  21E0FF  			LD	HL,LED_DISPLAY
6943:36174+16	27FC  22C8FF  			LD	(LED_CURSOR),HL
6944:36190+7	27FF  0607    			LD	B,7
6945:36197+7	2801  3E80    			LD	A,0x80				
6946:36204+7	2803  4E      	LEDR_LP		LD	C,(HL)
6947:36211+7	2804  77      			LD	(HL),A
6948:36218+4	2805  79      			LD	A,C
6949:36222+6	2806  23      			INC	HL
6950:36228+8+5	2807  10FA    			DJNZ	LEDR_LP
6951:36236+10	2809  C1      			POP	BC
6952:36246+10	280A  E1      			POP	HL				
6953:36256+10	280B  C9      			RET
6954:				
6955:36266+11	280C  E5      	LED_LEFT	PUSH	HL
6956:36277+11	280D  C5      			PUSH	BC
6957:36288+10	280E  21E6FF  			LD	HL,LED_DISPLAY+6
6958:36298+16	2811  22C8FF  			LD	(LED_CURSOR),HL
6959:36314+7	2814  0607    			LD	B,7
6960:36321+7	2816  3E80    			LD	A,0x80				
6961:36328+7	2818  4E      	LEDL_LP		LD	C,(HL)
6962:36335+7	2819  77      			LD	(HL),A
6963:36342+4	281A  79      			LD	A,C
6964:36346+6	281B  2B      			DEC	HL
6965:36352+8+5	281C  10E5    			DJNZ	LEDR_LP
6966:36360+10	281E  C1      			POP	BC
6967:36370+10	281F  E1      			POP	HL
6968:36380+10	2820  C9      			RET
6969:				
6970:				
6971:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
6972:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
6973:				;	Chapter_17	High RAM routines
6974:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
6975:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
6976:				;These routines cause bank memory switches between RAM/ROM and must be in HIGH RAM to execute.
6977:				;They will be loaded into HIGH RAM
6978:				
6979:36390+10	2821  212D28  	LOAD_HIGH_RAM	LD	HL,ROM_CODE	;Copy ISR Dispatch & Return to Upper RAM
6980:36400+10	2824  112AFB  			LD	DE,HRAM_CODE
6981:36410+10	2827  012900  			LD	BC,ROM_CODE_LEN
6982:36420+16+5	282A  EDB0    			LDIR
6983:36436+10	282C  C9      			RET
6984:				
6985:				;FOLLOWING IS THE ISR DISPATCH ROUTINE  ISR_DISPATCH (IN HIGH RAM)
6986:				;
6987:				;ISR_DISPATCH:
6988:36446+4	282D  AF      	ROM_CODE	XOR	A		;4  
6989:36450+11	282E  D3C1    			OUT	(RAMROM),A	;11 SELECT ROM
6990:36461+11	2830  DB40    			IN	A,(Port40)	;11	
6991:36472+4	2832  07      			RLCA			;4
6992:36476+10	2833  D23B16  			JP NC,	ISR_RXD		;10	Jump ASAP if RS-232 start bit coming in (2 Stack Words)
6993:36486+4	2836  07      			RLCA			;4
6994:36490+10	2837  DAAC16  			JP C,	ISR_TIMER	;10 (st=50) Jump if Timer interrupt   		(7 Stack Words)
6995:36500+7	283A  3E80    			LD	A,0x80		;	Otherwise, unknown interrupt (RS-232 noise?)
6996:36507+11	283C  D340    			OUT	(Port40),A	;11	Just reset Timer interrupt, just incase?
6997:						;JP	ISR_RET
6998:				
6999:     -	0011          	ISR_RET_OFF	EQU	$-ROM_CODE
7000:36518+13	283E  3AD9FF  			LD	A,(RRSTATE)	;Restore RAM/ROM selection
7001:36531+11	2841  D3C1    			OUT	(RAMROM),A
7002:36542+4	2843  08      			EX	AF,AF'		;Restore swapped Registers
7003:36546+4	2844  D9      			EXX
7004:36550+4	2845  FB      			EI
7005:36554+14	2846  ED4D    			RETI			;Return to Mainline code
7006:						
7007:     -	001B          	GET_MEM_OFF	EQU	$-ROM_CODE
7008:36568+13	2848  3ADBFF  			LD	A,(READ_RAMROM)	;Bit 0 is RAM/ROM
7009:36581+4	284B  F3      			DI
7010:36585+11	284C  D3C1    			OUT	(RAMROM),A	;Select RAM/ROM
7011:36596+7	284E  7E      			LD	A,(HL)		;Fetch from RAM/ROM
7012:36603+4	284F  08      			EX	AF,AF'
7013:36607+4	2850  AF      			XOR	A		;Return to ROM
7014:36611+11	2851  D3C1    			OUT	(RAMROM),A
7015:36622+4	2853  08      			EX	AF,AF'
7016:36626+4	2854  FB      			EI		
7017:36630+10	2855  C9      			RET
7018:						
7019:				;Alternative way to Get Mem and minimize the Interrupt mask black out
7020:				;HR_GET_MEM	PUSH	BC
7021:				;		LD	B,0
7022:				;		LD	C,RAMROM
7023:				;		LD	A,(READ_RAMROM)
7024:				;		DI
7025:				;		OUT	(C),A
7026:				;		LD	A,(HL)		;Fetch from RAM/ROM
7027:				;		OUT	(C),B
7028:				;		EI
7029:				;		POP	BC
7030:				;		RET
7031:						
7032:						
7033:     -	0029          	ROM_CODE_LEN	equ	$-ROM_CODE
7034:				
7035:				
7036:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7037:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7038:				;	Appendix_A	LED FONT
7039:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7040:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7041:				
7042:				
7043:				; **         *********  *******        *********    *****    **     **  *********
7044:				; **         *********  ********       *********   *******   ***    **  *********
7045:				; **         **         **    ***      **         ***   ***  ****   **     ***
7046:				; **         **         **     **      **         **     **  *****  **     ***
7047:				; **         *********  **     **      *********  **     **  ** *** **     ***
7048:				; **         *********  **     **      *********  **     **  **  *****     ***
7049:				; **         **         **     **      **         **     **  **   ****     ***
7050:				; **         **         **    ***      **         ***   ***  **    ***     ***
7051:				; *********  *********  ********       **          *******   **     **     ***
7052:				; *********  *********  *******        **           *****    **     **     ***
7053:				
7054:				;	0 = Segment D OR LED7       --4--
7055:				;	1 = Segment E OR LED6      2|   |3
7056:				;	2 = Segment F OR LED5       |   |
7057:				;	3 = Segment B OR LED4       --5--
7058:				;	4 = Segment A OR LED3      1|   |6
7059:				;	5 = Segment G OR LED2       |   |
7060:				;	6 = Segment C OR LED1       --0--
7061:				
7062:				
7063:     -	2900          			ORG  ($ & 0xFF00) + 0x100
7064:     -	2900  DFC8BBF9	LED_HEX	DB	11011111b, 11001000b, 10111011b, 11111001b, 11101100b, 11110101b, 11110111b, 11011000b	;00-07 01234567
	              ECF5F7D8
7065:     -	2908  FFFCFEE7		DB	11111111b, 11111100b, 11111110b, 11100111b, 10010111b, 11101011b, 10110111b, 10110110b	;08-0F 89ABCDEF
	              97EBB7B6
7066:				
7067:				
7068:     -	2920          			ORG  ($ & 0xFF00) + 0x20
7069:				;	**** 	; CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED,   CGABFED	;HEX	Character
7070:     -	2920  80868CBC	LED_FONT DB	10000000b, 10000110b, 10001100b, 10111100b, 11010101b, 10101000b, 10101001b, 10000100b 	;20-27  !"#$%&'
	              D5A8A984
7071:     -	2928  97D994A6		DB	10010111b, 11011001b, 10010100b, 10100110b, 11000001b, 10100000b, 10000001b, 10101010b	;28-2F ()*+,-./
	              C1A081AA
7072:     -	2930  DFC8BBF9		DB	11011111b, 11001000b, 10111011b, 11111001b, 11101100b, 11110101b, 11110111b, 11011000b	;30-37 01234567
	              ECF5F7D8
7073:     -	2938  FFFC91D1		DB	11111111b, 11111100b, 10010001b, 11010001b, 10000011b, 10100001b, 11000001b, 10111010b	;38-3F 89:;<=>?
	              83A1C1BA
7074:     -	2940  FBFEE797		DB	11111011b, 11111110b, 11100111b, 10010111b, 11101011b, 10110111b, 10110110b, 11010111b	;40-47 @ABCDEFG
	              EBB7B6D7
7075:     -	2948  EEC8CBAE		DB	11101110b, 11001000b, 11001011b, 10101110b, 10000111b, 11101010b, 11011110b, 11011111b	;48-4F HIJKLMNO
	              87EADEDF
7076:     -	2950  BEFCA2F5		DB	10111110b, 11111100b, 10100010b, 11110101b, 10010110b, 11001111b, 11001111b, 11001111b	;50-57 PQRSTUVW
	              96CFCFCF
7077:     -	2958  E0ED9B97		DB	11100000b, 11101101b, 10011011b, 10010111b, 11100100b, 11011001b, 10011100b, 10000001b	;58-5F XYZ[\]^_
	              E4D99C81
7078:     -	2960  88FBE7A3		DB	10001000b, 11111011b, 11100111b, 10100011b, 11101011b, 10111111b, 10110110b, 11111101b	;60-67 `abcdefg
	              EBBFB6FD
7079:     -	2968  E6C0CBAE		DB	11100110b, 11000000b, 11001011b, 10101110b, 10000110b, 11101010b, 11100010b, 11100011b	;68-6F hijklmno
	              86EAE2E3
7080:     -	2970  BEFCA2F5		DB	10111110b, 11111100b, 10100010b, 11110101b, 10100111b, 11000011b, 11000011b, 11000011b	;70-77 pqrstuvw
	              A7C3C3C3
7081:     -	2978  E0ED9B97		DB	11100000b, 11101101b, 10011011b, 10010111b, 10000110b, 11011001b, 10010000b, 11101011b	;78-7F xyz{|}~
	              86D990EB
7082:				
7083:     -	2A00          			ORG  ($ & 0xFF00) + 0x100
7084:     -	2A00          	GO_BASIC
7085:					INCLUDE	BASICZ80.ASM
**** BASICZ80.ASM ****
   1:						;*************************************************************
   2:						;                       MICRO-BASIC                          *
   3:						;------------------------------------------------------------*
   4:						;   A SMALL INTEGER BASIC INTERPRETER FOR THE 8080/8085/Z80  *
   5:						;                                D.F. DUNFIELD  JAN 25/1983  *
   6:						;------------------------------------------------------------*
   7:						;Translated to Z80 code for use with Lee Hart's Z80
   8:						;Membership Card.  April 1, 2017 by Josh Bensadon.
   9:						;
  10:						;------------------------------------------------------------*
  11:						;                      BASIC COMMANDS                        *
  12:						;                                                            *
  13:						;  CLEAR,    DATA,     DIM,      END,      BEXIT,     FOR,    *
  14:						;  GOSUB,    GOSUB(N), GOTO,     GOTO(N),  IF/THEN,  INPUT,  *
  15:						;  LET,      LIF/THEN, LIST,     LOAD,     NEW,      NEXT,   *
  16:						;  ORDER,    PLOT,     PRINT,    READ,     REM,      RETURN, *
  17:						;  RUN,      SAVE,     SIZE,     STOP,     USR,      <EDIT>  *
  18:						;------------------------------------------------------------*
  19:						;                     BASIC OPERATORS                        *
  20:						;                                                            *
  21:						; NUMERIC:     + - * % / \ & | ; ( ) < = > == -= <= >=       *
  22:						; CHARACTER:   + = == -=                                     *
  23:						; OTHER:       : # $ @ ? [ ] ( )                             *
  24:						;------------------------------------------------------------*
  25:						;                      BASIC VARIABLES                       *
  26:						;                                                            *
  27:						;     A - Z ......... 16 BIT SIMPLE INTEGER VARIABLES.       *
  28:						;     A$ - Z$ ....... SIMPLE CHARACTER VARIABLES. < 36 CHARS *
  29:						;     A[N] - Z[N] ... 16 BIT INTEGER ARRAYS.                 *
  30:						;     @[N] .......... PSEUDO MEMORY REFERENCE ARRAY.         *
  31:						;     @[N]$ ......... NUMERIC TO CHARACTER CONVERSION.(CHR$) *
  32:						;     ? ............. PSEUDO RANDOM NUMBER GENERATOR.        *
  33:						;------------------------------------------------------------*
  34:						;                        MEMORY MAP                          *
  35:						;                                                            *
  36:						;    0000-03FF     1K SYSTEM MONITOR (IN ROM).               *
  37:						;    0400-0FFF     3K BASIC INTERPRETER (IN ROM).            *
  38:						;    1000-13FF     1K MEMORY MAPPED 64*16 VIDEO DISPLAY      *
  39:						;    1400-15FF     0.5K POINTERS, STACKS, BUFFERS.           *
  40:						;    1600-19FF     1K VARIABLES AND POINTERS.                *
  41:						;    1A00-FFFF     PROGRAM AND ARRAY STORAGE.                *
  42:						;*************************************************************
  43:						;	PAGE
  44:						;
  45:						;*************************************************************
  46:						;                   CONSTANTS AND EQUATES
  47:						;*************************************************************
  48:						;
  49:						; MONITOR ROUTINES
  50:						;
  51:     -	0051          			BINCHR	EQU	0x51		;INPUT ROUTINE ADDRESS
  52:     -	0045          			BPUTCHR EQU	0x45		;OUTPUT ROUTINE ADDRESS
  53:						;CTRLC	EQU	0x27E		;CONTROL-C TEST ROUTINE ADDRESS
  54:     -	0042          			BEXIT	EQU	0x42		;TERMINATION RETURN ADDRESS
  55:						;GETR	EQU	0x2EB		;ROUTINE TO LOAD INTEL HEX FORMAT
  56:						;TDUMP	EQU	0xD6		;ROUTINE TO DUMP IN INTEL HEX FORMAT
  57:						;TON	EQU	0x396		;ROUTINE TO START TAPE
  58:						;TOFF	EQU	0x3A6		;ROUTINE TO STOP TAPE
  59:						;CURPOS	EQU	0x37E		;ROUTINE TO POSITION CURSOR
  60:     -	007D          			BPUTSP	EQU	0x7D		;DISPLAY SPACE ON CONSOLE
  61:     -	0080          			BPUTNL	EQU	0x80		;ROUTINE TO PRINT A <LF>, <CR> ON TERMINAL
  62:     -	0057          			PRINTM	EQU	0x57		;DISPLAY'S MSGM UP TO ZERO OR <CR>
  63:						;CR	EQU	0x0D
  64:						;LF	EQU	0x0A
  65:						; MEMORY ALLOCATION
  66:     -	8000          			BUFF	EQU	0x8000		;START OF RAM, INPUT BUFFER
  67:     -	80FF          			IOCON	EQU	BUFF+0xFF	;INPUT/OUTPUT CONFIGURATION
  68:     -	80FD          			USROUT	EQU	IOCON-2		;USER SUPPLIED OUTPUT DEVICE VECTOR
  69:     -	80FB          			CURSOR	EQU	USROUT-2	;CURSOR POSITION
  70:     -	80F9          			LSTCHR	EQU	CURSOR-2	;CHARACTER UNDER CURSOR
  71:     -	80F7          			STACK	EQU	LSTCHR-2	;MACHINE STACK
  72:     -	8032          			TB	EQU	BUFF+50		;TEMPORARY TEXT BUFFER
  73:     -	8064          			XBF	EQU	TB+50		;EXTRA TEXT BUFFER
  74:     -	8100          			EDBUF	EQU	BUFF+256	;EDIT BUFFER
  75:     -	81FA          			CS	EQU	EDBUF+0xFA	;CONTROL STACK SPACE
  76:     -	81FB          			CSP	EQU	CS+1		;CONTROL STACK POINTER
  77:     -	81FD          			ARYLOC	EQU	CSP+2		;LOCATION OF ARRAYS
  78:     -	81FE          			SEED	EQU	ARYLOC+1	;RANDOM NUMBER SEED
  79:     -	8200          			VARS	EQU	SEED+2		;VARIABLE SPACE
  80:     -	8234          			RFLAG	EQU	VARS+52		;PROGRAM RUNNING FLAG
  81:     -	8235          			IFLAG	EQU	RFLAG+1		;INPUTTING FLAG
  82:     -	8236          			PP	EQU	IFLAG+1		;POINTER TO END OF EXPRESSION
  83:     -	8237          			EFLAG	EQU	PP+1		;ASSIGNMENT FLAG
  84:     -	8238          			DATA	EQU	EFLAG+1		;READ/DATA POINTER
  85:     -	823A          			LAST	EQU	DATA+2		;LAST FREE ARRAY SPACE
  86:     -	823C          			SIGT	EQU	LAST+2		;SIGNATURE TO PREVENT CLEARING OF PROGRAM
  87:     -	823E          			TEMP	EQU	SIGT+2		;TEMPORARY STORAGE
  88:     -	8600          			TEXT	EQU	VARS+1024	;PROGRAM AND ARRAY STORAGE
  89:     -	007A          			NEGTEXT EQU     0x007a
  90:     -	007F          			DELETE	EQU	0x7F		;DELETE CHARACTER
  91:						;	PAGE
  92:						;
  93:						;*******************************************************************
  94:						; START OF MAIN PROGRAM, FIRST INITIALIZE, INSURING WE DON'T THINK *
  95:						; WE HAVE A VALID PROGRAM, ALSO CLEAR OUT HIS VARIABLES AND ARRAYS *
  96:						;*******************************************************************
  97:						;
  98:						;	ORG	0x8000		;FOLLOW MONITOR
  99:36640+10	2A00  210036  			BASIC	LD	HL,INTRO	;ADDRESS OF 'INTRO' MESSAGE
 100:36650+17	2A03  CD5700  				CALL	PRINTM		;TELL HIM WHO WROTE THIS!
 101:36667+16	2A06  2A3C82  				LD	HL,(SIGT)	;CHECK IF RAM IS SIGNED
 102:36683+10	2A09  116913  				LD	DE,0x1369
 103:36693+4	2A0C  AF      				XOR	A
 104:36697+15	2A0D  ED52    				SBC	HL,DE
 105:36712+7+5	2A0F  280C    				JR Z,	INIT		;JUMP IF SIGNATURE, IE DON'T INIT TEXT SPACE
 106:							
 107:36719+20	2A11  ED533C82				LD	(SIGT),DE	;SIGN RAM FOR NEXT TIME
 108:36739+7	2A15  3EFF    			NEW	LD	A,0xFF		;INDICATES END OF PROGRAM
 109:36746+13	2A17  320086  				LD	(TEXT), A	;INITIALIZE TO NO PROGRAM
 110:36759+17	2A1A  CDAF2C  			RESV	CALL	CLEAR		;CLEAR OUT HIS VARIABLES
 111:						; RESET FLAGS, AND PROMPT WITH 'READY', SO HE WILL KNOW WE ARE LISTENING
 112:36776+10	2A1D  210000  			INIT	LD	HL,0		;GET DOUBLE BYTE ZERO
 113:36786+16	2A20  223482  				LD	(RFLAG), HL	;INDICATE NOT RUNNING, AND NOT INPUT
 114:36802+16	2A23  223682  				LD	(PP), HL		;INDICATE NO ASSIGNMENT DONE
 115:36818+10	2A26  213036  				LD	HL,RDY		;ADDRESS OF 'READY' MESSAGE
 116:36828+17	2A29  CD5700  				CALL	PRINTM		;TELL HIM WE ARE READY
 117:						; GET A LINE FROM CONSOLE, AND SEE WHAT HE WANTS
 118:36845+10	2A2C  31F780  			TOP	LD	SP,STACK	;FIX UP STACK IN CASE WE ABORTED SOMETHING
 119:							
 120:36855+10	2A2F  2180FF  				LD	HL,RC_TYPE	;Check Auto Boot
 121:36865+12	2A32  CB7E    				BIT	7,(HL)
 122:36877+15	2A34  CBBE    				RES	7,(HL)
 123:36892+10	2A36  C2EC2C  				JP  NZ,	RUN
 124:							
 125:36902+17	2A39  CDD02A  				CALL	GLINE		;LET HIM GIVE US A LINE
 126:36919+7	2A3C  FE0D    				CP	CR		;DID HE ONLY PRESS RETURN
 127:36926+10	2A3E  CA2C2A  				JP Z,	TOP		;NOT GOOD ENOUGH, MAKE HIM TRY AGAIN
 128:36936+17	2A41  CDC62A  				CALL	NUM		;DID HIS LINE START WITH A NUMBER
 129:36953+10	2A44  D2AF2B  				JP NC,	EDIT		;IF SO, HE IS WRITING A PROGRAM!!!
 130:						; LOOK UP COMMAND AND EXECUTE
 131:36963+10	2A47  011D2A  				LD	BC,INIT		;ADDRESS TO RETURN TO
 132:36973+11	2A4A  C5      				PUSH	BC		;SAVE SO WE CAN RETURN
 133:36984+10	2A4B  212135  				LD	HL,KTAB-1	;POINT TO COMMAND TABLE
 134:						;
 135:						; LOCATES COMMAND POINTED TO BY D-E IN THE COMMAND TABLE POINTED TO BY H-L
 136:						; AND CHAINS TO THE COMMAND PROCESSING CODE FOR THAT COMMAND
 137:						;
 138:36994+17	2A4E  CD0431  			CMD	CALL	PARSE1		;ADVANCE TO NEXT CHARACTER
 139:37011+11	2A51  D5      			TLP0	PUSH	DE		;SAVE POINTER TO START OF COMMAND
 140:37022+6	2A52  23      			CMDL	INC	HL		;ADVANCE IN TABLE
 141:37028+7	2A53  1A      				LD	A, (DE)		;GET DATA FROM COMMAND
 142:37035+7	2A54  BE      				CP	(HL)		;COMPARE WITH TABLE CONTENTS
 143:37042+6	2A55  13      				INC	DE		;ADVANCE IN COMMAND
 144:37048+10	2A56  CA522A  				JP Z,	CMDL		;IF SAME, KEEP TESTING
 145:						; DIDN'T MATCH, SEE IF IT'S END OF WORD (HIGH BIT SET)
 146:37058+7	2A59  F680    				OR	0x80		;ARE WE AT END?
 147:37065+7	2A5B  BE      				CP	(HL)		;AND IS IT THIS ONE?
 148:37072+10	2A5C  CA6F2A  				JP Z,	GOTCMD		;IF SO, WE HAVE IT
 149:						; WASN'T THAT ENTRY, KEEP LOOKING
 150:37082+4	2A5F  97      				SUB	A		;SEE IT THIS IS END OF TABLE
 151:37086+7	2A60  BE      				CP	(HL)		;ARE WE AT END?
 152:37093+10	2A61  CA6E2A  				JP Z,	GOTDEF		;IF SO, WE WILL SAY WE FOUND
 153:37103+10	2A64  D1      				POP	DE		;RESTORE POINTER TO COMMAND
 154:37113+7	2A65  B6      			CMD1	OR	(HL)		;TEST FOR AT END OF TABLE ENTRY
 155:37120+6	2A66  23      				INC	HL		;POINT TO NEXT
 156:37126+10	2A67  F2652A  				JP P,	CMD1		;IF NO, KEEP LOOKING
 157:37136+6	2A6A  23      				INC	HL		;SKIP FIRST ADDRESS BYTE
 158:37142+10	2A6B  C3512A  				JP	TLP0		;TEST THIS ENTRY
 159:						; WE HIT THE END OF THE TABLE, ASSUME THE DEFAULT ADDRESS (LET)
 160:37152+6	2A6E  1B      			GOTDEF	DEC	DE		;BACKUP TO START OF WORD
 161:						; WE MATCHED ALL THE WAY TO THE END OF A COMMAND WORD, GET IT'S ADDRESS
 162:37158+6	2A6F  23      			GOTCMD	INC	HL		;POINT TO ADDRESS BYTE
 163:37164+7	2A70  4E      				LD	C,(HL)		;SAVE TEMPORARY
 164:37171+6	2A71  23      				INC	HL		;POINT TO NEXT ADDRESS BYTE
 165:37177+7	2A72  66      				LD	H,(HL)		;GET LOW ADDRESS
 166:37184+4	2A73  69      				LD	L,C		;GET HIGH ADDRESS
 167:37188+19	2A74  E3      				EX	(SP), HL	
 168:37207+10	2A75  C30431  				JP	PARSE1		;SKIP TO NEXT NON-BLANK, AND CHAIN TO CODE
 169:						;
 170:						;***************************************************************
 171:						;              ERROR CHECKING AND HANDLING CODE
 172:						;***************************************************************
 173:						;
 174:						; VCHAR... TESTS FOR A VALID VARIABLE, SYNTAX ERROR IF NOT
 175:						;
 176:37217+17	2A78  CDFC30  			VCHAR	CALL	CHAR		;TEST VARIABLE
 177:37234+5+6	2A7B  D0      				RET NC			;IF OK, GO BACK
 178:						;
 179:						; SYNTAX ERROR... HE'S NOT MAKEING ANY SENSE AT ALL
 180:						; ISSUE NASTY MESSAGE TO STRAIGHTEN HIM OUT
 181:						;
 182:37239+10	2A7C  21EA35  			SYNT	LD	HL,SYN		;GET NASTY 'SYNTAX' MESSAGE
 183:37249+6	2A7F  1B      				DEC	DE		;BACK UP IN SOURCE SO WE DONT SAY WRONG LINE
 184:						;
 185:						; ERROR STUFF... SOMETHING HAS GONE WRONG... TELL HIM THE BAD NEWS AND
 186:						; QUIT ANYTHING THAT WE MAY HAVE STARTED, SO THAT THINGS CAN'T GET WORSE
 187:						; ALSO, IF WE WERE RUNNING, GIVE HIM THE LINE NUMBER AS A CLUE
 188:						;
 189:37255+7	2A80  3E3F    			ERR	LD	A,'?'		;PRECEDE ERROR MESSAGE BY '?'
 190:37262+17	2A82  CD4500  				CALL	BPUTCHR	;DISPLAY ON TERMINAL
 191:37279+13	2A85  3A3582  				LD	A, (IFLAG)	;WERE WE TRYING TO 'INPUT' SOMETHING)
 192:37292+4	2A88  A7      				AND	A		;IF WE WERE, THEN ..
 193:37296+10	2A89  C2312F  				JP NZ,	INERR		;SPECIAL MESSAGE + HANDLEING
 194:						; NOW THAT WE HAVE FIGURED OUT WHAT'S GOING ON, LET HIM IN ON IT
 195:37306+17	2A8C  CD5700  				CALL	PRINTM		;PRINT ERROR MESSAGE
 196:37323+10	2A8F  213D36  				LD	HL,EM		;FOLLOWED BY..
 197:						; PRINT MESSAGE FOLLOWED BY LINE NUMBER (ALSO USED BY 'STOP IN LINE XXXX')
 198:37333+17	2A92  CD5700  			PERR	CALL	PRINTM		;THE ' ERROR ' PART
 199:37350+13	2A95  3A3482  				LD	A, (RFLAG)	;WERE WE RUNNING..
 200:37363+4	2A98  A7      				AND	A		;IF NOT,
 201:37367+10	2A99  CABD2A  				JP Z,	INLF		;THEN THATS ALL WE HAVE TO DO
 202:						; DISPLAY LINE NUMBER OF RUNNING PROGRAM
 203:37377+10	2A9C  21E035  				LD	HL,INL		;ADDRESS OF 'IN LINE ' MESSAGE
 204:37387+17	2A9F  CD5700  				CALL	PRINTM		;DISPLAY FOR HIM
 205:						; FIND START OF OUR LINE, AND DISPLAY LINE NUMBER
 206:37404+6	2AA2  1B      			FSOL	DEC	DE		;BACK UP IN SOURCE
 207:37410+4	2AA3  7A      				LD	A,D		;GET HIGH BYTE OF ADDRESS
 208:37414+7	2AA4  FE86    				CP	HIGH TEXT	;TEST FOR BEYOND BEGINNING
 209:37421+10	2AA6  DAAF2A  				JP C,	STLIN		;AT START OF LINE
 210:37431+7	2AA9  1A      				LD	A, (DE)		;GET CHARACTER FROM BUFER
 211:37438+7	2AAA  FE0D    				CP	CR		;TEST FOR CARRIAGE RETURN
 212:37445+10	2AAC  C2A22A  				JP NZ,	FSOL		;IF NOT, KEEP LOOKING
 213:37455+6	2AAF  13      			STLIN	INC	DE		;ADVANCE IN SOURCE
 214:37461+4	2AB0  EB      				EX	DE, HL	
 215:37465+17	2AB1  CD512C  				CALL	PNUM		;PRINT AND BUFFER LINE NUMBER
 216:						; COPY LINE WITH ERROR INTO OLD LINE EDIT BUFFER, INCASE HE WANTS TO FIX IT
 217:37482+6	2AB4  23      			FIXIT	INC	HL		;SKIP LENGTH BYTE, ADVANCE TO NEXT IN SOURCE
 218:37488+7	2AB5  7E      				LD	A,(HL)		;GET CHARACTER FROM LINE
 219:37495+7	2AB6  12      				LD	(DE), A		;SAVE IN BUFFER
 220:37502+6	2AB7  13      				INC	DE		;ADVANCE TO NEXT IN BUFFER
 221:37508+7	2AB8  FE0D    				CP	CR		;TEST FOR END-OF-LINE
 222:37515+10	2ABA  C2B42A  				JP NZ,	FIXIT		;IF NOT, KEEP COPYING
 223:						; WAIT FOR CONSOLE INPUT, ON A NEW LINE
 224:37525+17	2ABD  CD8000  			INLF	CALL	BPUTNL		;ADVANCE A LINE ON HIS TERMINAL
 225:37542+17	2AC0  CDDF2C  				CALL	RESET		;RESET DATA POINTER AND CONTROL-STACK
 226:37559+10	2AC3  C31D2A  				JP	INIT		;GET NEXT COMMAND
 227:						;
 228:						; SUBROUTINE TEST FOR VALID ASCII DIGIT (0-9), RETURNS WITH C=1 IF NOT
 229:						;
 230:37569+7	2AC6  FE30    			NUM	CP	'0'		;TEST FOR < '0'
 231:37576+5+6	2AC8  D8      				RET C			;IF SO, BAD DIGIT
 232:37581+7	2AC9  FE3A    				CP	'9'+1		;TEST FOR >'9'
 233:37588+4	2ACB  3F      				CCF			;INVERT LOGIC, C=1 IF BAD
 234:37592+10	2ACC  C9      				RET
 235:						;
 236:						;***************************************************************
 237:						;                    TEXT EDITING ROUTINES
 238:						;***************************************************************
 239:						;
 240:						; SUBROUTINE TO GET AND EDIT COMMAND LINE FROM TERMINAL
 241:						;
 242:37602+17	2ACD  CD8000  			BADLN	CALL	BPUTNL		;ADVANCE TO NEW LINE
 243:37619+10	2AD0  110080  			GLINE	LD	DE,BUFF		;POINT TO INPUT BUFFER
 244:37629+10	2AD3  210081  				LD	HL,EDBUF	;POINT TO EDIT BUFFER
 245:37639+4	2AD6  43      				LD	B,E		;CLEAR INSERT FLAG (LOW ADR OF BUFFER IS ZERO)
 246:37643+4	2AD7  7B      			LOOP1	LD	A,E		;GET LOW ADDRESS OF OUR POSITION
 247:37647+4	2AD8  A7      				AND	A		;TEST FOR NEGATIVE
 248:37651+10	2AD9  FACD2A  				JP M,	BADLN		;IF SO, HE'S DELETED BEYOND START OF BUFFER
 249:37661+17	2ADC  CDED34  				CALL	BGETCHR		;GET A CHARACTER
 250:37678+7	2ADF  FE03    				CP	3		;TEST FOR CONTROL-C (CANCEL)
 251:37685+10	2AE1  CABD2A  				JP Z,	INLF		;IF SO, ABORT BACK TO COMMAND HANDLER
 252:37695+7	2AE4  FE06    				CP	6		;TEST FOR CONTROL-F (FIND COMMAND)
 253:37702+10	2AE6  CA672B  				JP Z,	GFIND		;EXECUTE FIND
 254:37712+7	2AE9  FE01    				CP	1		;TEST FOR CONTROL-A (ADVANCE COMMAND)
 255:37719+10	2AEB  CA492B  				JP Z,	GADV		;EXECUTE ADVANCE
 256:37729+7	2AEE  FE09    				CP	9		;TEST FOR CONTROL-I (TOGGLE INSERT MODE)
 257:37736+10	2AF0  CA8A2B  				JP Z,	GINST		;TOGGLE INSERT MODE
 258:37746+7	2AF3  FE04    				CP	4		;TEST FOR CONTROL-D (DELETE CHARACTER.)
 259:37753+10	2AF5  CA582B  				JP Z,	GRUB		;ERASE CHARACTER
 260:37763+7	2AF8  FE20    				CP	' '		;TEST FOR CONTROL-CHARACTER
 261:37770+10	2AFA  D2072B  				JP NC,	OKPRT		;IF NOT, OK TO PROCESS
 262:37780+7	2AFD  FE0D    				CP	CR		;CARRIAGE RETURN IS OK,
 263:37787+10	2AFF  CA072B  				JP Z,	OKPRT		;SO PROCESS IT
 264:37797+7	2B02  FE08    				CP	8		;SO IS A BACKSPACE
 265:37804+10	2B04  C2D72A  				JP NZ,	LOOP1		;ANYTHING ELSE SHOULD BE IGNORED
 266:						; WE HAVE GOTTEN A VALID CHARACTER
 267:37814+7	2B07  FE7F    			OKPRT	CP	DELETE		;TEST FOR DELETE CHARACTER
 268:37821+10	2B09  C20E2B  				JP NZ,	RECT		;IF IT IS A DELETE,
 269:37831+7	2B0C  3E08    				LD	A,8		;MAKE IT INTO A BACKSPACE
 270:37838+4	2B0E  4F      			RECT	LD	C,A		;COPY INTO C
 271:37842+17	2B0F  CD4500  				CALL	BPUTCHR		;DISPLAY ON TERMINAL
 272:37859+6	2B12  1B      				DEC	DE		;ASSUME DELETE (BACKSPACE)
 273:						; DON'T DELETE CHARS FROM OLD LINE BUFFER IF WE ARE INSERTING
 274:37865+4	2B13  B0      				OR	B		;TEST INSERT FLAG
 275:37869+10	2B14  FA182B  				JP M,	IND		;IF NOT, WE ARE INSERTING
 276:37879+6	2B17  2B      				DEC	HL		;REDUCE OLD BUFFER POSITION
 277:37885+4	2B18  79      			IND	LD	A,C		;GET CHARACTER BACK
 278:37889+7	2B19  FE08    				CP	8		;TEST FOR DELETE (BACKSPACE)
 279:37896+10	2B1B  CAD72A  				JP Z,	LOOP1		;IF SO, WE WERE RIGHT, GET NEXT CHARACTER
 280:37906+6	2B1E  13      				INC	DE		;FIX OUR MISTAKE (NOT DELETE)
 281:37912+7	2B1F  12      				LD	(DE), A		;SAVE CHARACTER IN BUFFER)
 282:						; DON'T MOVE OLD LINE POINTER IF WE ARE INSERTING
 283:37919+4	2B20  B0      				OR	B		;TEST INSERT FLAG
 284:37923+10	2B21  FA2C2B  				JP M,	INOK		;IF SO, DON'T INCREMENT
 285:37933+6	2B24  23      				INC	HL		;ADVANCE IN OLD LINE BUFFER
 286:37939+7	2B25  7E      				LD	A,(HL)		;GET CHARACTER FROM OLD LINE
 287:37946+7	2B26  FE0D    				CP	CR		;TEST FOR END OF OLD LINE
 288:37953+10	2B28  CA2C2B  				JP Z,	INOK		;IF SO, DON'T GO PAST IT
 289:37963+6	2B2B  23      				INC	HL		;ADVANCE TO NEXT CHARACTER OF OLD LINE
 290:37969+4	2B2C  79      			INOK	LD	A,C		;GET CHARACTER BACK
 291:37973+6	2B2D  13      				INC	DE		;ADVANCE POINTER IN NEW LINE
 292:37979+7	2B2E  FE0D    				CP	CR		;TEST FOR CARRAIGE RETURN (END OF LINE)
 293:37986+10	2B30  C2D72A  				JP NZ,	LOOP1		;IF NOT, KEEP GETTING CHARACTERS
 294:37996+17	2B33  CD8000  				CALL	BPUTNL		;PRINT LINE-FEED CARRIAGE RETURN
 295:						; COPY NEW LINE INTO OLD LINE BUFFER (MAKEING IT THE 'NEW' OLD LINE)
 296:38013+10	2B36  110080  				LD	DE,BUFF		;POINT BACK TO NEW LINE BUFFER
 297:38023+11	2B39  D5      				PUSH	DE		;SAVE BUFFER ADDRESS
 298:38034+10	2B3A  210081  				LD	HL,EDBUF	;POINT TO OLD LINE BUFFER
 299:38044+7	2B3D  1A      			MOVL	LD	A, (DE)		;GET CHARACTER FROM NEW LINE
 300:38051+7	2B3E  77      				LD	(HL),A		;SAVE IN OLD LINE BUFFER
 301:38058+6	2B3F  23      				INC	HL		;POINT TO NEXT
 302:38064+6	2B40  13      				INC	DE		;POINT TO NEXT
 303:38070+7	2B41  FE0D    				CP	CR		;TEST FOR END OF LINE
 304:38077+10	2B43  C23D2B  				JP NZ,	MOVL		;IF NOT, KEEP MOVEING
 305:38087+10	2B46  D1      				POP	DE		;RESTORE BUFFER ADDRESS
 306:38097+7	2B47  1A      				LD	A, (DE)		;AND FIRST CHARACTER FROM IT
 307:38104+10	2B48  C9      				RET
 308:						; COPY ONE CHARACTER FROM OLD LINE TO NEW LINE
 309:38114+7	2B49  7E      			GADV	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
 310:38121+7	2B4A  FE0D    				CP	CR		;INSURE ITS NOT THE END
 311:38128+10	2B4C  CAD72A  				JP Z,	LOOP1		;IF SO, IGNORE COMMAND
 312:38138+4	2B4F  B0      				OR	B		;TEST INSERT FLAG
 313:38142+7	2B50  7E      				LD	A,(HL)		;GET CHARACTER BACK
 314:38149+10	2B51  F20E2B  				JP P,	RECT		;IF NO INSERT, OK
 315:38159+6	2B54  23      				INC	HL		;ADVANCE TO NEXT
 316:38165+10	2B55  C30E2B  				JP	RECT		;PASS CHARACTER TO INPUT ROUTINE
 317:						; RUB OUT ONE CHARACTER FROM THE OLD LINE
 318:38175+7	2B58  7E      			GRUB	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
 319:38182+7	2B59  FE0D    				CP	CR		;TEST FOR END OF LINE
 320:38189+10	2B5B  CAD72A  				JP Z,	LOOP1		;IF SO, IGNORE COMMAND
 321:38199+7	2B5E  3E2A    				LD	A,'*'		;INDICATE RUBBED OUT CHARACTER WITH '*'
 322:38206+17	2B60  CD4500  				CALL	BPUTCHR	;PRINT  IT TO SHOW WHAT WE ARE DOING
 323:38223+6	2B63  23      				INC	HL		;ADVANCE PASSED CHARACTER (RUBBING IT OUT)
 324:38229+10	2B64  C3D72A  				JP	LOOP1		;RETURN FOR NEXT CHARACTER
 325:						; FIND NEXT CHARACTER IN NEW LINE
 326:38239+17	2B67  CDED34  			GFIND	CALL	BGETCHR		;GET A CHARACTER
 327:38256+4	2B6A  4F      				LD	C,A		;SAVE IN C (TO COMPARE AGAINST.)
 328:38260+11	2B6B  E5      				PUSH	HL		;SAVE POSITION IN OLD LINE
 329:						; FIND OUT IF IT IS THERE..
 330:38271+7	2B6C  7E      			GF1	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
 331:38278+7	2B6D  FE0D    			GF0	CP	CR		;TEST FOR END OF LINE
 332:38285+10	2B6F  CA862B  				JP Z,	ABFND		;IF SO, WE DIDN'T FIND IT
 333:38295+6	2B72  23      				INC	HL		;ADVANCE TO NEXT CHARACTER
 334:38301+7	2B73  7E      				LD	A,(HL)		;GET CHARACTER
 335:38308+4	2B74  B9      				CP	C		;TEST FOR CHARACTER WE DESIRE
 336:38312+10	2B75  C26D2B  				JP NZ,	GF0		;IF NOT, KEEP LOOKING
 337:38322+10	2B78  E1      				POP	HL		;RESTORE POSITION ON OLD LINE
 338:						; NOW COPY OLD LINE OVER..
 339:38332+7	2B79  7E      			GF2	LD	A,(HL)		;GET CHARACTER FROM OLD LINE
 340:38339+7	2B7A  12      			GF3	LD	(DE), A		;SAVE IN NEW LINE
 341:38346+17	2B7B  CD4500  				CALL	BPUTCHR	;DISPLAY ON TERMINAL
 342:38363+6	2B7E  23      				INC	HL		;POINT TO NEXT CHAR. IN OLD LINE
 343:38369+6	2B7F  13      				INC	DE		;POINT TO NEXT CHAR IN NEW LINE
 344:38375+7	2B80  7E      				LD	A,(HL)		;GET NEXT CHAR FROM NEW LINE
 345:38382+4	2B81  B9      				CP	C		;TEST FOR CHARACTER WE WANT
 346:38386+10	2B82  C27A2B  				JP NZ,	GF3		;IF NOT, KEEP COPYING
 347:38396+11	2B85  E5      				PUSH	HL		;FIX UP STACK
 348:38407+10	2B86  E1      			ABFND	POP	HL		;RESTORE POSITION IN OLD LINE
 349:38417+10	2B87  C3D72A  				JP	LOOP1		;GET NEXT CHARACTER
 350:						; TOGGLE INSERT MODE
 351:38427+4	2B8A  78      			GINST	LD	A,B		;GET INSERT MODE FLAG
 352:38431+7	2B8B  EEFF    				XOR	0xFF		;COMPLEMENT, SETTING FLAGS
 353:38438+4	2B8D  47      				LD	B,A		;REAVE IN FLAG REGISTER
 354:38442+7	2B8E  3E3C    				LD	A,'<'		;INDICATE ENTERING INSERT MODE
 355:38449+10	2B90  FA952B  				JP M,	GIN1		;IF SO, INDICATE SO
 356:38459+7	2B93  3E3E    				LD	A,'>'		;INDICATE LEAVING INSERT
 357:38466+17	2B95  CD4500  			GIN1	CALL	BPUTCHR	;DISPLAY INDICATOR ON TERMINAL
 358:38483+10	2B98  C3D72A  				JP	LOOP1		;GET NEXT CHARACTER FROM TERMINAL
 359:						;
 360:						; GET A PACKED-DECIMAL LINE NUMBER FROM THE COMMAND BUFFER
 361:						;
 362:38493+10	2B9B  210000  			GETLN	LD	HL,0		;START WITH ZERO
 363:38503+7	2B9E  1A      			ELOOP	LD	A, (DE)		;GET DIGIT FROM COMMAND BUFFER
 364:38510+17	2B9F  CDC62A  				CALL	NUM		;TEST FOR ASCII DIGIT
 365:38527+5+6	2BA2  D8      				RET C			;IF NOT, STOP (WE HAVE IT)
 366:38532+6	2BA3  13      				INC	DE		;ADVANCE TO NEXT BUFFER POSITION
 367:38538+11	2BA4  29      				ADD	HL,HL		;MAKE ROOM FOR DIGIT IN BOTTOM..
 368:38549+11	2BA5  29      				ADD	HL,HL		;OF THE RESULT, BY ..
 369:38560+11	2BA6  29      				ADD	HL,HL		;ROTATING IT..
 370:38571+11	2BA7  29      				ADD	HL,HL		;LEFT BY FOUR BITS
 371:38582+7	2BA8  E60F    				AND	0x0F		;CONVERT DIGIT TO BINARY
 372:38589+4	2BAA  B5      				OR	L		;INSERT INTO LOWER DIGITS OF RESULT
 373:38593+4	2BAB  6F      				LD	L,A		;AND REPLACE BYTE IN RESULT WITH NEW VALUE
 374:38597+10	2BAC  C39E2B  				JP	ELOOP		;GET NEXT DIGIT
 375:						;
 376:						; LINE EDITOR, EDITS PROGRAM SOURCE BY LINE NUMBER IN COMMAND BUFFER
 377:						;
 378:38607+17	2BAF  CD1F2C  			EDIT	CALL	LINEF		;LOCATE LINE NUMBER IN SOURCE
 379:38624+11	2BB2  E5      				PUSH	HL		;SAVE POINTER INTO TEXT
 380:38635+10	2BB3  C2C72B  				JP NZ,	INS		;IF NEW LINE, DON'T TRY TO DELETE
 381:						; DELETE LINE POINTED TO BY H-L
 382:38645+4	2BB6  54      			DEL	LD	D,H		;COPY POINTER INTO
 383:38649+4	2BB7  5D      				LD	E,L		;THE D-E PAIR FOR BACKWARDS COPY
 384:38653+7	2BB8  3E0D    				LD	A,CR		;WE ARE LOOKING FOR A CARRIAGE RETURN
 385:						; FIND START OF NEXT LINE
 386:38660+7	2BBA  BE      			DELNX	CP	(HL)		;TEST FOR END OF LINE TO DELETE
 387:38667+6	2BBB  23      				INC	HL		;POINT TO NEXT CHARACTER IN SOURCE
 388:38673+10	2BBC  C2BA2B  				JP NZ,	DELNX		;IF NOT END OF LINE, KEEP LOOKING
 389:						; COPY REST OF PROGRAM BACK OVER DELETED LINE
 390:38683+7	2BBF  7E      			DELLP	LD	A,(HL)		;GET CHARACTER FROM NEXT LINE
 391:38690+7	2BC0  12      				LD	(DE), A		;SAVE OVER DELETED LINE
 392:38697+6	2BC1  13      				INC	DE		;POINT TO NEXT IN NEW LINE
 393:38703+6	2BC2  23      				INC	HL		;POINT TO NEXT IN OLD LINE
 394:38709+4	2BC3  3C      				INC	A		;TEST FOR END OF FILE
 395:38713+10	2BC4  C2BF2B  				JP NZ,	DELLP		;IF NOT, KEEP DELETEING
 396:						; INSERT LINE INTO TEXT
 397:38723+10	2BC7  010200  			INS	LD	BC,2		;SET LENGTH TO 2 (PACKED DECIMAL NUMBERS ARE 2)
 398:38733+10	2BCA  110080  				LD	DE,BUFF		;POINT TO BUFFER (CONTAINING NEW LINE)
 399:						; CALCULATE LENGTH OF LINE
 400:38743+17	2BCD  CD9B2B  				CALL	GETLN		;REMOVE NUMBERS AS THEY ARE NOT STORED AS TEXT
 401:38760+4	2BD0  0C      			ILP	INC	C		;INCREMENT LENGTH
 402:38764+7	2BD1  1A      				LD	A, (DE)		;GET CHARACTER FROM NEW LINE (IN BUFFER)
 403:38771+6	2BD2  13      				INC	DE		;POINT TO NEXT CHARACTER FROM NEW LINE
 404:38777+7	2BD3  FE0D    				CP	CR		;TEST FOR END OF LINE
 405:38784+10	2BD5  C2D02B  				JP NZ,	ILP		;IF NOT, KEEP COUNTING
 406:38794+4	2BD8  79      				LD	A,C		;GET LENGTH
 407:38798+10	2BD9  E1      				POP	HL		;RESTORE POSITION IN TEXT
 408:38808+7	2BDA  FE03    				CP	3		;TEST FOR NULL LINE
 409:38815+10	2BDC  CA2C2A  				JP Z,	TOP		;IS SO, DON'T INSERT
 410:						; INSERT NEW LINE INTO TEXT
 411:38825+4	2BDF  54      			INLN	LD	D,H		;SET D-E TO POINT TO
 412:38829+4	2BE0  5D      				LD	E,L		;THE LINE POSITION
 413:38833+17	2BE1  CDBB30  				CALL	GETEOF		;GET END OF FILE ADDRESS
 414:38850+6	2BE4  23      				INC	HL		;ADVANCE TO FREE BYTE
 415:38856+11	2BE5  C5      				PUSH	BC		;SAVE LENGTH
 416:38867+11	2BE6  E5      				PUSH	HL		;STACK END OF FILE ADDRESS
 417:38878+11	2BE7  09      				ADD	HL,BC		;ADD LENGTH
 418:38889+10	2BE8  C1      				POP	BC		;GET END OF FILE ADDRESS
 419:38899+6	2BE9  23      				INC	HL		;ADVANCE BECAUSE WE DECREMENT
 420:38905+6	2BEA  2B      			IL01	DEC	HL		;REDUCE POINTER INTO NEW POSITION
 421:38911+6	2BEB  0B      				DEC	BC		;REDUCE POINTER TO OLD POSITION
 422:38917+7	2BEC  0A      				LD	A, (BC)		;GET BYTE OF OLD DATA
 423:38924+7	2BED  77      				LD	(HL),A		;SAVE IN NEW POSITION
 424:38931+4	2BEE  79      				LD	A,C		;GET LOW ADDRESS
 425:38935+4	2BEF  BB      				CP	E		;TEST AGAINST WHERE WE ARE GOING
 426:38939+10	2BF0  C2EA2B  				JP NZ,	IL01		;IF NOT, KEEP COPYING
 427:38949+4	2BF3  78      				LD	A,B		;GET HIGH ADDRESS
 428:38953+4	2BF4  BA      				CP	D		;TEST AGAINST DESTINATION
 429:38957+10	2BF5  C2EA2B  				JP NZ,	IL01		;IF NOT SAME, KEEP COPYING
 430:38967+10	2BF8  110080  				LD	DE,BUFF		;GET ADDRESS OF NEW LINE
 431:38977+17	2BFB  CD9B2B  				CALL	GETLN		;OBTAIN NUMBERS
 432:38994+4	2BFE  7C      				LD	A,H		;GET HIGH 2 DIGITS
 433:38998+7	2BFF  02      				LD	(BC), A		;SAVE IN NEW LINE
 434:39005+6	2C00  03      				INC	BC		;POINT TO NEXT CHARACTER OF NEW LINE
 435:39011+4	2C01  7D      				LD	A,L		;GET LOW DIGITS
 436:39015+7	2C02  02      				LD	(BC), A		;SAVE IN NEW LINE
 437:39022+6	2C03  03      				INC	BC		;ADVANCE TO NEXT CHARACTER IN NEW LINE
 438:39028+10	2C04  E1      				POP	HL		;RESTORE LENGTH
 439:39038+4	2C05  7D      				LD	A,L		;GET LENGTH
 440:39042+7	2C06  C610    				ADD	A,0x10		;ADD OFFSET TO MAKE UNIQUE
 441:39049+7	2C08  02      				LD	(BC), A		;SAVE IN NEW LINE
 442:39056+6	2C09  03      				INC	BC		;POINT TO NEXT CHARACTER
 443:39062+7	2C0A  1A      			IL02	LD	A, (DE)		;GET CHARACTER FROM NEW LINE IN BUFFER
 444:39069+7	2C0B  02      				LD	(BC), A		;SAVE IN TEXT
 445:39076+6	2C0C  03      				INC	BC		;POINT TO NEXT POSITION IN TEXT
 446:39082+6	2C0D  13      				INC	DE		;ADVANCE IN BUFFER
 447:39088+7	2C0E  FE0D    				CP	CR		;TEST FOR END OF LINE
 448:39095+10	2C10  C20A2C  				JP NZ,	IL02		;IF NOT, KEEP LOOKING
 449:						; WE ARE INSERTING OR REPLACEING A LINE, SINCE WE DON'T KNOW HOW MUCH
 450:						; MEMORY IT WILL REQUIRE, WE MUST CLEAR THE ARRAYS, AS THEY FOLLOW THE
 451:						; PROGRAM. WE DO NOT HAVE TO DO THIS WHEN DELETING LINES
 452:39105+17	2C13  CDCD2C  				CALL	CLRARY		;CLEAR ARRAYS AND RETURN
 453:39122+10	2C16  C32C2A  				JP	TOP		;GO BACK FOR NEXT COMMAND
 454:						;
 455:						; LOCATE LINE IN TEXT, SYNTAX ERROR IF NOT LINE NUMBER
 456:						;
 457:39132+17	2C19  CDC62A  			FNDLIN	CALL	NUM		;IS IT A VALID NUMBER
 458:39149+10	2C1C  DA7C2A  				JP C,	SYNT		;IF NOT, IT'S A INVALID
 459:						;
 460:						; FINDS LINE IN PROGRAM TEXT. RETURNS WITH Z FLAG SET IF LINE EXISTS
 461:						; H-L POINTS TO START OF LINE. B-C CONTAINS LINE NUMBER OF ACTUAL
 462:						; LINE FOUND. (IF LINE NOT FOUND, POINTS TO FIRST GREATER LINE NUMBER)
 463:						;
 464:39159+17	2C1F  CD9B2B  			LINEF	CALL	GETLN		;GET LINE NUMBER FROM COMMAND BUFFER
 465:39176+4	2C22  EB      				EX	DE, HL	
 466:39180+10	2C23  210086  				LD	HL,TEXT		;START AT TOP OF PROGRAM
 467:39190+7	2C26  7E      			TRY	LD	A,(HL)		;GET FIRST CHARACTER FROM PROGRAM LINE
 468:39197+7	2C27  FEFF    				CP	0xFF		;TEST FOR END OF FILE
 469:39204+10	2C29  CA4E2C  				JP Z,	EOF		;IF SO, WE DIDN'T FIND
 470:39214+6	2C2C  23      				INC	HL		;ADVANCE POINTER TO LOW DIGITS
 471:39220+4	2C2D  BA      				CP	D		;TEST FOR HIGH DIGITS CORRECT
 472:39224+10	2C2E  DA392C  				JP C,	NEXTL		;IF LESS, FIND NEXT LINE
 473:39234+10	2C31  C2462C  				JP NZ,	NOTFND		;IF GREATER, LINE WASN'T FOUND
 474:39244+7	2C34  7E      				LD	A,(HL)		;GET LOW DIGITS
 475:39251+4	2C35  BB      				CP	E		;TEST LOW DIGITS
 476:39255+10	2C36  D2462C  				JP NC,	NOTFND		;IF LESS, LINE IS HERE OR DOSN'T EXIST
 477:						; ADVANCE TO NEXT LINE IN SOURCE
 478:39265+6	2C39  23      			NEXTL	INC	HL		;POINT TO LINE LENGTH
 479:39271+7	2C3A  7E      				LD	A,(HL)		;GET LENGTH
 480:39278+7	2C3B  D611    				SUB	0x11		;SUBTRACT OFFSET USED TO MAKE IT UNIQUE
 481:39285+4	2C3D  85      				ADD	A,L		;ADD TO POINTER
 482:39289+4	2C3E  6F      				LD	L,A		;AND REPLACE IN POINTER
 483:39293+10	2C3F  D2262C  				JP NC,	TRY		;IF NO CARRY, THATS IT
 484:39303+6	2C42  23      				INC	HL		;BUMP HIGH ADDRESS
 485:39309+10	2C43  C3262C  				JP	TRY		;AND TEST THIS LINE
 486:						; LINE IS HERE OR BEFORE
 487:39319+6	2C46  2B      			NOTFND	DEC	HL		;BACK UP TO DIGIT
 488:39325+4	2C47  4F      				LD	C,A		;PLACE LOW ORDER DIGIT IN C
 489:39329+7	2C48  46      				LD	B,(HL)		;PLACE HIGH ORDER DIGIT IN B
 490:39336+4	2C49  BB      				CP	E		;TEST FOR LINE FOUND
 491:39340+5+6	2C4A  C0      				RET NZ			;IF NOT SAME, RETURN INDICATING SO
 492:39345+4	2C4B  78      				LD	A,B		;GET HIGH DIGIT
 493:39349+4	2C4C  BA      				CP	D		;INDICATE IF NUMBERS SAME
 494:39353+10	2C4D  C9      				RET
 495:						; LINE WAS GREATER THAN ALL LINES IN PROGRAM, INDICATE EOF REACHED
 496:39363+4	2C4E  47      			EOF	LD	B,A		;RETURN HIGH LINE NUMBER
 497:39367+4	2C4F  A7      				AND	A		;INDICATE LINE DOSN'T EXIST
 498:39371+10	2C50  C9      				RET
 499:						;
 500:						; PRINTS PACKED-DECIMAL LINE NUMBER ON TERMINAL, AS WELL AS PLACEING
 501:						; IT AT THE START OF THE EDIT BUFFER
 502:						;
 503:39381+10	2C51  110081  			PNUM	LD	DE,EDBUF	;SET UP POINTER TO EDIT BUFFER
 504:39391+17	2C54  CD572C  				CALL	HPOUT		;PRINT FIRST TWO DIGITS
 505:39408+7	2C57  7E      			HPOUT	LD	A,(HL)		;GET CONTENTS OF MEMORY
 506:39415+6	2C58  23      				INC	HL		;AND POINT TO NEXT
 507:39421+11	2C59  F5      				PUSH	AF
 508:39432+4	2C5A  0F      				RRCA			;ROTATE
 509:39436+4	2C5B  0F      				RRCA			;UPPER DIGIT
 510:39440+4	2C5C  0F      				RRCA			;INTO
 511:39444+4	2C5D  0F      				RRCA			;LOWER DIGIT
 512:39448+17	2C5E  CD622C  				CALL	POUT		;DISPLAY UPPER DIGIT
 513:39465+10	2C61  F1      				POP	AF
 514:						; DISPLAYS ONE DIGIT
 515:39475+7	2C62  E60F    			POUT	AND	0x0F		;REMOVE UPPER GARBAGE
 516:39482+7	2C64  F630    				OR	0x30		;CONVERT TO ASCII DIGIT
 517:39489+7	2C66  12      				LD	(DE), A		;SAVE IN EDIT BUFFER
 518:39496+6	2C67  13      				INC	DE		;ADVANCE POINTER IN EDIT BUFFER
 519:39502+10	2C68  C34500  				JP	BPUTCHR	;DISPLAY DIGIT ON TERMINAL AND RETURN
 520:						;
 521:						;*****************************************************************
 522:						;                   BASIC COMMAND HANDLERS
 523:						;*****************************************************************
 524:						;
 525:						; IT'S A 'LIST' COMMAND, LETS GIVE HIM A PEEK AT THE SOURCE
 526:						; ALSO PLACE LAST LINE LISTED IN BUFFER, INCASE HE WANTS TO EDIT IT
 527:						;
 528:39512+11	2C6B  D5      			LIST:	PUSH	DE		;SAVE PROGRAM POINTER
 529:39523+10	2C6C  210086  				LD	HL,TEXT		;START AT THE BEGINNING OF THE PROGRAM
 530:39533+7	2C6F  06FF    				LD	B,255		;SET ENDING LINE BEYOND END OF TEXT
 531:39540+7	2C71  1A      				LD	A, (DE)		;GET CHARACTER OF OPERAND
 532:39547+17	2C72  CDC62A  				CALL	NUM		;TEST FOR A NUMBER
 533:39564+10	2C75  DA892C  				JP C,	GO		;IF NOT, LIST WHOLE THING
 534:39574+17	2C78  CD9B2B  				CALL	GETLN		;GET LINE NUMBER
 535:39591+11	2C7B  E5      				PUSH	HL		;SAVE ON STACK
 536:39602+6	2C7C  13      				INC	DE		;POINT TO NEXT CHARACTER
 537:39608+7	2C7D  FE2C    				CP	','		;TEST FOR ENDING NUMBER
 538:39615+10+7	2C7F  CC1F2C  				CALL Z,	LINEF		;IF SO, GET ENDING NUMBER
 539:39625+6	2C82  23      				INC	HL		;ADVANCE PAST BEGINNING OF LINE
 540:39631+10	2C83  D1      				POP	DE		;GET STARTING LINE NUMBER BACK
 541:39641+11	2C84  E5      				PUSH	HL		;SAVE ENDING LINE
 542:39652+17	2C85  CD232C  				CALL	LINEF+4		;FIND STARTING LINE ADDRESS
 543:39669+10	2C88  C1      				POP	BC		;GET ENDING ADDRESS BACK
 544:						; LIST TEXT FROM STARTING LINE IN H-L TO ENDING LINE IN B-C
 545:39679+7	2C89  7E      			GO	LD	A,(HL)		;GET CHARACTER FROM START OF LINE
 546:39686+4	2C8A  3C      				INC	A		;TEST FOR END OF FILE
 547:39690+10	2C8B  CAAD2C  				JP Z,	LIRET		;IF SO, STOP LISTING
 548:39700+17	2C8E  CD512C  				CALL	PNUM		;DISPLAY LINE NUMBER AND BUFFER IT
 549:39717+6	2C91  23      				INC	HL		;SKIP LENGTH BYTE, AS IT DOSN'T LOOK PRETTY
 550:39723+7	2C92  7E      			PRINS	LD	A,(HL)		;GET CHARACTER FROM LINE
 551:39730+7	2C93  12      				LD	(DE), A		;PLACE INTO BUFFER
 552:39737+6	2C94  13      				INC	DE		;ADVANCE IN BUFFER
 553:39743+17	2C95  CD4500  				CALL	BPUTCHR	;DISPLAY ON TERMINAL
 554:39760+6	2C98  23      				INC	HL		;ADVANCE POINTER IN PROGRAM
 555:39766+7	2C99  FE0D    				CP	CR		;TEST FOR END OF LINE
 556:39773+10	2C9B  C2922C  				JP NZ,	PRINS		;IF NOT, KEEP PRINTING
 557:39783+17	2C9E  CD8000  				CALL	BPUTNL		;NEW LINE ON TERMINAL
 558:39800+17	2CA1  CD6532  				CALL	COMP		;TEST FOR LAST LINE LISTED
 559:39817+10	2CA4  D2AD2C  				JP NC,	LIRET		;IF SO, STOP LISTING
 560:39827+17	2CA7  CDE734  				CALL	CTRLC		;TEST FOR ABORT FROM TERMINAL
 561:39844+10	2CAA  C2892C  				JP NZ,	GO		;KEEP LISTING IF NOT
 562:39854+10	2CAD  D1      			LIRET	POP	DE		;RESTORE PROGRAM POINTER
 563:39864+10	2CAE  C9      				RET
 564:						;
 565:						; CLEARS VARIABLES AND ARRAYS. (INITIALIZES THEM) AND INITIALIZES EDIT BUFFER
 566:						;
 567:39874+10	2CAF  210082  			CLEAR	LD	HL,VARS		;POINT TO VARIABLE SPACE
 568:39884+7	2CB2  3E0D    				LD	A,CR		;GET A CARRIAGE RETURN (END OF LINE CHARACTER)
 569:39891+13	2CB4  320081  				LD	(EDBUF), A	;INITIALIZE EDIT BUFFER TO A NULL LINE
 570:39904+7	2CB7  0E34    				LD	C,52		;26 VARIABLE TIMES 2 BYTES/VARIABLE
 571:39911+10	2CB9  3600    			CVLP	LD	(HL),0		;CLEAR INTEGER VARAIBLES TO ZERO
 572:39921+6	2CBB  23      				INC	HL		;ADVANCE TO NEXT BYTE OF VARIABLE SPACE
 573:39927+4	2CBC  0D      				DEC	C		;REDUCE COUNT OF VARAIABLES LEFT
 574:39931+10	2CBD  C2B92C  				JP NZ,	CVLP		;KEEP GOING TILL ALL INTEGERS ARE ZERO'ED
 575:39941+7	2CC0  3E86    				LD	A,HIGH (VARS + 0x400) ;ADDRESS OF END OF VARIABLE TABLE
 576:39948+10	2CC2  010A00  				LD	BC,10		;SKIP AHEAD 10 BYTES
 577:39958+11	2CC5  09      				ADD	HL,BC		;SO THAT WE DON'T CLOBBER OUR FLAGS
 578:39969+10	2CC6  36FF    			CVL1	LD	(HL),255	;0xFF IS NULL CHARACTER FOR CHAR. VARS
 579:39979+6	2CC8  23      				INC	HL		;POINT TO NEXT BYTE IN CHAR. VAR. SPACE
 580:39985+4	2CC9  BC      				CP	H		;TEST FOR COMPLETE (ALL SET TO NULL STRINGS)
 581:39989+10	2CCA  C2C62C  				JP NZ,	CVL1		;KEEP GOING TILL WE DO THEM ALL
 582:						; INITIALIZE ARRAYS, RESET ARRAY SPACE TO FIRST PAGE FOLLOWING PROGRAM
 583:39999+17	2CCD  CDBB30  			CLRARY	CALL	GETEOF		;GET ADDRESS OF FIRST FREE PAGE+SET POINTER
 584:40016+13	2CD0  32FD81  				LD	(ARYLOC), A	;STASH IN ARRAY TABLE POINTER
 585:40029+4	2CD3  67      				LD	H,A		;PLACE IN H, SO WE CAN REFERENCE INDERECT
 586:40033+7	2CD4  2E34    				LD	L,52		;START AT END OF TABLE
 587:40040+16	2CD6  223A82  				LD	(LAST), HL	;INDICATE FREE SPACE FOR NEXT ARRAY
 588:40056+4	2CD9  97      				SUB	A		;GET A ZERO
 589:40060+4	2CDA  2D      			CALS	DEC	L		;BACK UP IN TABLE
 590:40064+7	2CDB  77      				LD	(HL),A		;INITIALIZE TO INDICATE NO ARRAY
 591:40071+10	2CDC  C2DA2C  				JP NZ,	CALS		;KEEP GOING TILL TABLE IS CLEARED
 592:						; RESET CONTROL STACK AND DATA POINTER
 593:40081+10	2CDF  21FA81  			RESET	LD	HL,CS		;GET USER STACK POINTER
 594:40091+16	2CE2  22FB81  				LD	(CSP), HL	;INITIALZE USER STACK POINTER
 595:40107+10	2CE5  210000  				LD	HL,0		;GET A ZERO (NO DATA POINTER)
 596:40117+16	2CE8  223882  				LD	(DATA), HL	;INSURE NO DATA PRESENT
 597:40133+10	2CEB  C9      				RET
 598:						;
 599:						; ** WE'VE GOTTEN A 'RUN' COMMAND, LETS START THE PROGRAM ROLLING **
 600:						;
 601:40143+13	2CEC  3A0086  			RUN	LD	A, (TEXT)	;GET FIRST CHARACTER OF PROGRAM
 602:40156+10	2CEF  21D535  				LD	HL,NP		;AND ADDRESS OF 'NO PROGRAM' MESSAGE
 603:40166+4	2CF2  3C      				INC	A		;TEST FOR EXISTANCE OF PROGRAM
 604:40170+10	2CF3  CA802A  				JP Z,	ERR		;IF NOT, POINT OUT HIS MISTAKE
 605:40180+17	2CF6  CDAF2C  				CALL	CLEAR		;CLEAR VARIABLES AND ARRAYS
 606:40197+10	2CF9  110086  				LD	DE,TEXT		;START INTERPRETING AT THE BEGINNING
 607:40207+7	2CFC  3EFF    			RGON	LD	A,255		;INDICATE THAT WE ARE RUNNING
 608:40214+13	2CFE  323482  				LD	(RFLAG), A	;BY SETTING THIS FLAG
 609:40227+6	2D01  13      			RNEWL	INC	DE		;SKIP PACKED DECIMAL LINE
 610:40233+6	2D02  13      				INC	DE		;NUMBERS, AND THE LENGTH BYTE,
 611:40239+6	2D03  13      				INC	DE		;AS THE COMMAND FINDER WON'T LIKE IT
 612:						; MAIN 'RUN' INTERPRETING LOOP
 613:40245+10	2D04  31F780  			RLOOP	LD	SP,STACK	;REPAIR ANY DAMAGE
 614:40255+17	2D07  CDE734  				CALL	CTRLC		;TEST FOR 'MAGIC' CONTROL-C CHARACTER
 615:40272+10	2D0A  CA2C2D  				JP Z,	STOP		;IF SO, FAKE A 'STOP' COMMAND
 616:40282+10	2D0D  21F234  				LD	HL,PTAB-1	;POINT TO PROGRAM COMMAND TABLE
 617:40292+17	2D10  CD4E2A  				CALL	CMD		;RUN PROGRAM CODE
 618:						; ADVANCE TO NEXT STATEMENT
 619:40309+7	2D13  1A      			RNEXT	LD	A, (DE)		;GET CHARACTER FROM SOURCE
 620:40316+7	2D14  FE22    				CP	'"'		;TEST FOR A QUOTE
 621:40323+10+7	2D16  CC2931  				CALL Z,	SKPQUO		;IF SO, SEARCH FOR NEXT ONE
 622:40333+6	2D19  13      				INC	DE		;ADVANCE TO NEXT CHARACTER
 623:40339+7	2D1A  FE3A    				CP	':'		;TEST FOR COLON (NEW STATEMENT)
 624:40346+10	2D1C  CA042D  				JP Z,	RLOOP		;IF SO, EXECUTE NEXT COMMAND
 625:40356+7	2D1F  FE0D    				CP	CR		;TEST FOR CARRIAGE RETURN
 626:40363+10	2D21  C2132D  				JP NZ,	RNEXT		;IF NOT, KEEP LOOKING
 627:40373+7	2D24  1A      				LD	A, (DE)		;GET FIRST CHAR OF NEW LINE
 628:40380+4	2D25  3C      				INC	A		;TEST FOR 0xFF (END OF FILE)
 629:40384+10	2D26  CA1D2A  				JP Z,	INIT		;IF SO, GO BACK TO COMMAND MODE
 630:40394+10	2D29  C3012D  				JP	RNEWL		;EXECUTE THIS LINE
 631:							
 632:						;
 633:						; EITHER WE HAVE GOTTEN A 'STOP' COMMAND, OR THE OPERATOR PRESSED
 634:						; CONTROL-C, EITHER WAY, PRINT THE MESSAGE AND BEXIT
 635:						;
 636:40404+10	2D2C  213836  			STOP	LD	HL,STMSG	;ADDRESS OF 'STOP' MESSAGE
 637:40414+10	2D2F  C3922A  				JP	PERR		;TREAT IT LIKE AN ERROR
 638:						; IT'S A 'THEN', FOLLOWING AN 'IF', LOOK FOR LINE NUMBER OR A STATEMENT
 639:40424+17	2D32  CDC62A  			THEN	CALL	NUM		;IS IT A NUMBER?
 640:40441+10	2D35  D2432D  				JP NC,	GOTO		;IF SO, ITS A NUMBER TO 'GOTO'
 641:40451+10	2D38  C3042D  				JP	RLOOP		;IF NOT, ITS A STATEMENT TO EXECUTE
 642:						;
 643:						; IT'S A 'GOSUB' SAVE RETURN ADDRESS, AND PRETEND IT'S 'GOTO'
 644:						;
 645:40461+17	2D3B  CDBD2D  			GOSUB	CALL	PUSHD		;SAVE SOURCE POSITION
 646:40478+4	2D3E  97      				SUB	A		;INDICATE GOSUB ENTRY
 647:40482+17	2D3F  CDA92D  				CALL	PUSHS		;SAVE ON USER STACK
 648:40499+7	2D42  1A      				LD	A, (DE)		;RESTORE OPERAND CHARACTER
 649:						;
 650:						; IT'S A 'GOTO' MAKE THE BIG JUMP
 651:						;
 652:40506+7	2D43  FE28    			GOTO	CP	'('		;TEST FOR COMPUTED GOTO
 653:40513+10	2D45  C25E2D  				JP NZ,	NOON		;IF NO, NOT AN 'ON' STATEMENT
 654:40523+17	2D48  CD3531  				CALL	EXPR		;GET VALUE OF INTERNAL EXPRESSION
 655:40540+17	2D4B  CD0F31  			GLPO	CALL	SKIP		;SKIP TO NEXT EXPRESSION
 656:40557+7	2D4E  FE2C    				CP	','		;IF THERE IS NO MORE COMMA'S
 657:40564+10	2D50  C27C2A  				JP NZ,	SYNT		;THEN WE RAN OUT OF OPERANDS
 658:40574+6	2D53  13      			GLPD	INC	DE		;SKIP THE COMMA
 659:40580+4	2D54  2D      				DEC	L		;REDUCE OUR COUNT
 660:40584+10	2D55  F24B2D  				JP P,	GLPO		;IF IT'S STILL POSITIVE, KEEP SKIPPING
 661:40594+7	2D58  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
 662:40601+7	2D59  FE20    				CP	' '		;TEST FOR BLANKS
 663:40608+10	2D5B  CA532D  				JP Z,	GLPD		;AND KEEP GOING TILL WE SKIP THEM
 664:40618+11	2D5E  D5      			NOON	PUSH	DE		;SAVE POSITION (IN CASE WE FAIL)
 665:40629+17	2D5F  CD192C  				CALL	FNDLIN		;FIND THE LINE HE WANTS
 666:40646+10	2D62  D1      				POP	DE		;RESTORE OUR POSITION
 667:40656+4	2D63  EB      				EX	DE, HL	
 668:40660+10	2D64  CAFC2C  				JP Z,	RGON		;IF SUCESS, GOTO NEW LINE
 669:40670+4	2D67  EB      				EX	DE, HL	
 670:						;
 671:						; OH OH, LOOKS LIKE HE'S TRIED TO GOTO, GOSUB OR ORDER TO A LINE HE FORGOT
 672:						; TO TYPE IN, TELL HIM ABOUT IT AND LET HIM TRY TO FIGURE IT OUT
 673:						;
 674:40674+10	2D68  21C935  			BADLIN	LD	HL,LIN		;ADDRESS OF 'LINE NUMBER' MESSAGE
 675:40684+10	2D6B  C3802A  				JP	ERR		;HANDLE LIKE ANY ERROR
 676:						;
 677:						; IT'S A 'RETURN', HOPE SOMEBODY DID A 'GOSUB' SOMEWHERE
 678:						;
 679:40694+17	2D6E  CDB42D  			RETURN	CALL	POPS		;GET TYPE OF STACK ENTRY
 680:40711+4	2D71  A7      				AND	A		;TEST FOR 'GOSUB' ENTRY
 681:40715+10	2D72  CAC72D  				JP Z,	POPD		;IF SO, GET ADDRESS BACK AND RETURN
 682:						;
 683:						; HE SCREWED UP THE FOR/NEXT, GOSUB/RETURN NESTING
 684:						; LET HIM IN ON IT AND DIE WHILE WE CAN
 685:						;
 686:40725+10	2D75  21C135  			NSTERR	LD	HL,CSTK		;ADDRESS OF 'NESTING' MESSAGE
 687:40735+10	2D78  C3802A  				JP	ERR		;HANDLE LIKE ANY ERROR
 688:						;
 689:						; IT'S A 'FOR' COMMAND, LETS THROW THIS THING FOR A LOOP
 690:						;
 691:40745+17	2D7B  CD782A  			FOR	CALL	VCHAR		;INSURE IT'S A VARIABLE
 692:40762+11	2D7E  F5      				PUSH	AF
 693:40773+6	2D7F  1B      				DEC	DE		;BACK UP POINT JUST BEFORE EXPRESSION
 694:40779+4	2D80  7B      				LD	A,E		;GET LOW ADDRESS
 695:40783+13	2D81  323682  				LD	(PP), A		;AND PLACE IN POSITION FLAG
 696:40796+7	2D84  1A      			FINTO	LD	A, (DE)		;GET CHARACTER FROM SOURCE
 697:40803+7	2D85  FE0D    				CP	CR		;TEST FOR END OF LINE
 698:40810+10	2D87  CA7C2A  				JP Z,	SYNT		;IF SO, HE'S GOOFED
 699:40820+6	2D8A  13      				INC	DE		;SKIP TO NEXT
 700:40826+7	2D8B  FE54    				CP	'T'		;TEST FOR A 'T'
 701:40833+10	2D8D  C2842D  				JP NZ,	FINTO		;IF NOT, WE ARN'T THERE YET
 702:40843+7	2D90  1A      				LD	A, (DE)		;GET NEXT CHARACTER
 703:40850+7	2D91  FE4F    				CP	'O'		;IS IT 'TO'
 704:40857+10	2D93  C2842D  				JP NZ,	FINTO		;NO, MUST BE VARIABLE 'T'
 705:40867+11	2D96  D5      				PUSH	DE		;SAVE OUR POSITION
 706:40878+6	2D97  1B      				DEC	DE		;BACKUP TO THE 'T'
 707:40884+17	2D98  CD3E31  				CALL	DOEXP		;EVALUATE EXPRESSION
 708:40901+10	2D9B  D1      				POP	DE		;RESTORE OUT POSITION
 709:40911+6	2D9C  13      				INC	DE		;SKIP 'O'
 710:40917+17	2D9D  CD3531  				CALL	EXPR		;GET LIMIT EXPRESSION
 711:40934+17	2DA0  CDBD2D  				CALL	PUSHD		;SAVE OUR POSITION ON STACK
 712:40951+4	2DA3  EB      				EX	DE, HL	
 713:40955+17	2DA4  CDBD2D  				CALL	PUSHD		;SAVE ON STACK
 714:40972+4	2DA7  EB      				EX	DE, HL	
 715:40976+10	2DA8  F1      				POP	AF
 716:						;
 717:						; SAVES A SINGLE BYTE ENTRY ON THE USER (CONTROL) STACK
 718:						;
 719:40986+11	2DA9  E5      			PUSHS	PUSH	HL		;SAVE H-L
 720:40997+16	2DAA  2AFB81  				LD	HL, (CSP)	;GET STACK POINTER
 721:41013+7	2DAD  77      				LD	(HL),A		;SAVE BYTE ON STACK
 722:41020+6	2DAE  2B      			PSH1	DEC	HL		;REDUCE POINTER
 723:41026+16	2DAF  22FB81  			PSH2	LD	(CSP), HL	;RESAVE STACK POINTER
 724:41042+10	2DB2  E1      				POP	HL		;RESTORE H-L
 725:41052+10	2DB3  C9      				RET
 726:						;
 727:						; POP A SINGLE BYTE ENTRY FROM THE USER (CONTROL) STACK
 728:						;
 729:41062+11	2DB4  E5      			POPS	PUSH	HL		;SAVE H-L
 730:41073+16	2DB5  2AFB81  				LD	HL, (CSP)	;GET STACK POINTER
 731:41089+6	2DB8  23      				INC	HL		;ADVANCE TO NEXT ENTRY
 732:41095+7	2DB9  7E      				LD	A,(HL)		;GET BYTE BACK
 733:41102+10	2DBA  C3AF2D  				JP	PSH2		;SAVE POINTER AND CONTINUE
 734:						;
 735:						; PUSHES A DOUBLE BYTE ENTRY ON THE USER (CONTROL) STACK
 736:						;
 737:41112+11	2DBD  E5      			PUSHD	PUSH	HL		;SAVE H-L
 738:41123+16	2DBE  2AFB81  				LD	HL, (CSP)	;GET STACK POINTER
 739:41139+7	2DC1  72      				LD	(HL),D		;SAVE HIGH BYTE
 740:41146+6	2DC2  2B      				DEC	HL		;BACK UP
 741:41152+7	2DC3  73      				LD	(HL),E		;SAVE LOW BYTE
 742:41159+10	2DC4  C3AE2D  				JP	PSH1		;SAVE POINTER AND CONTINUE
 743:						;
 744:						; POPS A DOUBLE BYTE ENTRY FROM THE USER STACK
 745:						;
 746:41169+11	2DC7  E5      			POPD	PUSH	HL		;SAVE H-L
 747:41180+16	2DC8  2AFB81  				LD	HL, (CSP)	;GET STACK POINTER
 748:41196+6	2DCB  23      				INC	HL		;ADVANCE TO LAST ENTRY
 749:41202+7	2DCC  5E      				LD	E,(HL)		;GET LOW BYTE
 750:41209+6	2DCD  23      				INC	HL		;ADVANCE TO HIGH BYTE
 751:41215+7	2DCE  56      				LD	D,(HL)		;GET HIGH BYTE
 752:41222+10	2DCF  C3AF2D  				JP	PSH2		;SAVE AND CONTINUE
 753:						;
 754:						; LET COMMAND, EVALUATE EXPRESSION
 755:						;
 756:41232+17	2DD2  CD3531  			LET	CALL	EXPR		;EVALUATE EXPRESSION
 757:41249+13	2DD5  3A3782  				LD	A, (EFLAG)	;DID HE MAKE AN ASSIGNMENT?
 758:41262+4	2DD8  A7      				AND	A		;IF NOT..
 759:41266+10	2DD9  CA7C2A  				JP Z,	SYNT		;HE'S MADE ANOTHER MISTAKE
 760:41276+4	2DDC  97      				SUB	A		;RESET THE FLAG
 761:41280+13	2DDD  323782  				LD	(EFLAG), A	;SO WE KNOW WHEN HE SCREW'S UP AGAIN
 762:41293+10	2DE0  C9      				RET
 763:						;
 764:						; IT'S A NEXT COMMAND, TEST INDEX AGAINST LIMIT, AND LOOP IF NEEDED
 765:						;
 766:41303+17	2DE1  CD782A  			NEXT	CALL	VCHAR		;TEST FOR VALID VARIABLE
 767:41320+4	2DE4  47      				LD	B,A		;STASH IN B FOR SAFEKEEPING
 768:41324+16	2DE5  2AFB81  				LD	HL, (CSP)	;SAVE CONTROL STACK POINTER..
 769:41340+16	2DE8  223E82  				LD	(TEMP), HL	;IN CASE WE NEED TO LOOP AGAIN
 770:41356+17	2DEB  CDB42D  				CALL	POPS		;GET VARIABLE NAME FROM STACK
 771:41373+4	2DEE  B8      				CP	B		;TEST FOR WHAT HE GAVE US
 772:41377+10	2DEF  C2752D  				JP NZ,	NSTERR		;IF NOT, HE'S SCREWED UP THE NESTING
 773:41387+17	2DF2  CDF82F  				CALL	LOOK		;GET VARIABLE VALUE
 774:41404+11	2DF5  D5      				PUSH	DE		;SAVE POSITION
 775:41415+17	2DF6  CDC72D  				CALL	POPD		;GET LIMIT FROM STACK
 776:41432+4	2DF9  42      				LD	B,D		;GET LIMIT
 777:41436+4	2DFA  4B      				LD	C,E		;INTO B-C SO WE CAN 'COMP'
 778:41440+17	2DFB  CD6532  				CALL	COMP		;TEST IF INDEX >= LIMIT
 779:41457+10	2DFE  D2112E  				JP NC,	NOMORE		;IF SO, DON'T LOOP ANYMORE
 780:41467+10	2E01  D1      				POP	DE		;GET POSITION BACK
 781:41477+6	2E02  23      				INC	HL		;INCREMENT LOOP INDEX
 782:41483+7	2E03  1A      				LD	A, (DE)		;GET VARIABLE NAME BACK
 783:41490+17	2E04  CDE72F  				CALL	STOR		;SAVE IT AWAY
 784:41507+17	2E07  CDC72D  				CALL	POPD		;GET NEW POSITION
 785:41524+16	2E0A  2A3E82  				LD	HL, (TEMP)	;GET CONTROL-STACK POINTER
 786:41540+16	2E0D  22FB81  				LD	(CSP), HL	;AND REPLACE IT (LEAVING STACK UNCHANGED)
 787:41556+10	2E10  C9      				RET
 788:						; WE HAVE HIT THE END OF A FOR NEXT LOOP
 789:41566+17	2E11  CDC72D  			NOMORE	CALL	POPD		;CLEAN UP CONTROL STACK
 790:41583+10	2E14  D1      				POP	DE		;GET PROGRAM COUNTER BACK
 791:						;
 792:						; REMARK, DO NOTHING, BUT RETURN, ALLOWING 'RNEXT' TO SKIP THE COMMAND
 793:						;
 794:41593+10	2E15  C9      			REM:	RET
 795:						;
 796:						; IT'S AN 'IF' STATEMENT. FIND OUT 'IF' WE DO IT OR NOT
 797:						;
 798:41603+6	2E16  1B      			IF:	DEC	DE		;BACK UP IN SOURCE
 799:41609+4	2E17  7B      				LD	A,E		;GET LOW ADDRESS
 800:41613+13	2E18  323682  				LD	(PP), A		;SAVE IN POSITION POINTER
 801:41626+7	2E1B  1A      			FTHEN	LD	A, (DE)		;GET CHARACTER FROM SOURCE
 802:41633+7	2E1C  FE0D    				CP	CR		;IF IT'S A CARRIAGE RETURN..
 803:41640+10	2E1E  CA7C2A  				JP Z,	SYNT		;THEN HE DIDN'T TYPE IN A 'THEN'
 804:41650+6	2E21  13      				INC	DE		;ADVANCE TO NEXT CHARACTER
 805:41656+7	2E22  FE54    				CP	'T'		;IS IT A 'T'?
 806:41663+10	2E24  C21B2E  				JP NZ,	FTHEN		;IF NOT, IT AINT THE START OF 'THEN'
 807:41673+7	2E27  1A      				LD	A, (DE)		;GET NEXT CHARACTER
 808:41680+7	2E28  FE48    				CP	'H'		;TEST FOR NEXT CHARACTER OF 'THEN'
 809:41687+10	2E2A  C21B2E  				JP NZ,	FTHEN		;NO, MUST BE VARIABLE 'T' (OR HE CAN'T SPELL)
 810:41697+6	2E2D  1B      				DEC	DE		;BACK UP TO 'T'
 811:41703+11	2E2E  D5      				PUSH	DE		;SAVE POSITION IN SOURCE
 812:41714+17	2E2F  CD3E31  				CALL	DOEXP		;EVALUATE CONDITION EXPRESSION
 813:41731+10	2E32  D1      				POP	DE		;GET POSITION BACK
 814:41741+4	2E33  7C      				LD	A,H		;GET RESULT AND TEST.
 815:41745+4	2E34  B5      				OR	L		;IT FOR ZERO (FALSE)
 816:41749+5+6	2E35  C8      				RET Z			;IF SO, SKIP THIS STATEMENT
 817:41754+10	2E36  C3042D  				JP	RLOOP		;EXECUTE THE 'THEN'
 818:						;
 819:						; LONG IF, CONTROLS REMAINDER OF ENTIRE LINE
 820:						;
 821:41764+17	2E39  CD162E  			LIF	CALL	IF		;CALCULATE AND PROCESS IF TRUE
 822:41781+6	2E3C  13      			LNXT	INC	DE		;ADVANCE IN SOURCE
 823:41787+7	2E3D  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
 824:41794+7	2E3E  FE0D    				CP	CR		;TEST FOR END OF LINE
 825:41801+10	2E40  C23C2E  				JP NZ,	LNXT		;KEEP LOOKING
 826:41811+10	2E43  C9      				RET
 827:						;
 828:						; IT A 'PLOT' COMMAND, (HE'S PLOTTING AGAINST US)
 829:						;
 830:41821+17	2E44  CD3531  			PLOT	CALL	EXPR		;GET X COORDINATE
 831:41838+10	2E47  DA7C2A  				JP C,	SYNT		;IF CHARACTER, IT'S NO GOOD
 832:41848+11	2E4A  E5      				PUSH	HL		;SAVE X COORDINATE
 833:41859+6	2E4B  13      				INC	DE		;ADVANCE PAST ','
 834:41865+17	2E4C  CD3531  				CALL	EXPR		;GET Y COORDINATE
 835:41882+10	2E4F  C1      				POP	BC		;GET X POSITION IN B-C
 836:41892+11	2E50  29      				ADD	HL,HL		;MULTIPLY.
 837:41903+11	2E51  29      				ADD	HL,HL		;Y POSITION.
 838:41914+11	2E52  29      				ADD	HL,HL		;BY 64.
 839:41925+11	2E53  29      				ADD	HL,HL		;TO PLACE ADDRESS.
 840:41936+11	2E54  29      				ADD	HL,HL		;ON PROPER LINE.
 841:41947+11	2E55  29      				ADD	HL,HL		;OF THE DISPLAY
 842:41958+11	2E56  09      				ADD	HL,BC		;ADD IN X POSITION
 843:41969+10	2E57  010004  				LD	BC,1024		;TEST AGAINST END OF SCREEN
 844:41979+17	2E5A  CD6532  				CALL	COMP		;TO SEE IF WE ARE OVER
 845:41996+10	2E5D  D2AF2F  				JP NC,	DIMERR		;IF SO, 'DIMENSION ERROR'
 846:							;CALL	CURPOS		;POSITION THE CURSOR
 847:						; LOOK FOR END OF LINE, OR OTHER OPERANDS
 848:42006+17	2E60  CD0F31  				CALL	SKIP		;GET NEXT SEPERATOR
 849:42023+7	2E63  FE2C    				CP	','		;TEST FOR COMMA
 850:42030+5+6	2E65  C0      				RET NZ			;IF NOT, WE ARE DONE
 851:42035+6	2E66  13      				INC	DE		;SKIP ','
 852:						; OUT STATEMENT, LET'S OUTPUT SOMETHING TO A PORT
 853:42041+17	2E67  CD3531  			OUTP	CALL	EXPR		;GET EXPRESSION FOR PORT#
 854:42058+10	2E6A  DA7C2A  				JP  C,	SYNT
 855:42068+11	2E6D  C5      				PUSH	BC
 856:42079+4	2E6E  4D      				LD	C,L		;SET PORT
 857:42083+7	2E6F  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
 858:42090+7	2E70  FE2C    				CP	','		;TEST FOR COMMA
 859:42097+10	2E72  C27C2A  				JP NZ,	SYNT
 860:42107+17	2E75  CD0331  				CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
 861:42124+17	2E78  CD3531  				CALL	EXPR		;GET EXPRESSION FOR PORT#
 862:42141+10	2E7B  DA7C2A  				JP  C,	SYNT
 863:42151+12	2E7E  ED69    				OUT	(C),L
 864:42163+4	2E80  79      				LD	A,C		;IF OUTPUT TO 0x40, THEN WRITE TO SCAN LED
 865:42167+7	2E81  E6E0    				AND	0xE0
 866:42174+7	2E83  FE40    				CP	0x40
 867:42181+7+5	2E85  2004    				JR  NZ,	OUTPR
 868:42188+4	2E87  7D      				LD	A,L
 869:42192+13	2E88  32F5FF  				LD	(0xFFF5),A	;SCAN_LED ON Z80MC
 870:42205+10	2E8B  C1      			OUTPR	POP	BC
 871:42215+10	2E8C  C9      				RET
 872:						;
 873:						; PRINT STATEMENT, LET'S OUTPUT SOMETHING SO HE WON'T GET UPSET
 874:						; WHILE STARING AT THE TUBE WONDERING IF WE DIED
 875:						;
 876:42225+17	2E8D  CD3531  			BPRINT	CALL	EXPR		;GET EXPRESSION TO PRINT
 877:42242+11	2E90  D5      				PUSH	DE		;SAVE BASIC'S PROGRAM COUNTER
 878:42253+10+7	2E91  D4B22E  				CALL NC, DECPRT		;IF NUMERIC, OUTPUT DECIMAL NUMBER
 879:42263+10	2E94  D1      				POP	DE		;RESTORE BASIC'S PROGRAM COUNTER
 880:42273+10+7	2E95  DCA52E  				CALL C,	PV1		;IF CHARACTER, DISPLAY CHARACTER VALUE
 881:42283+7	2E98  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
 882:42290+7	2E99  FE2C    				CP	','		;TEST FOR COMMA
 883:42297+10	2E9B  C28000  				JP NZ,	BPUTNL		;IF NOT, IT'S THE END
 884:42307+17	2E9E  CD0331  				CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
 885:42324+10	2EA1  C28D2E  				JP NZ,	BPRINT		;PRINT NEXT EXPRESSION
 886:42334+10	2EA4  C9      				RET
 887:						; PRINT CHARACTER EXPRESSIONS
 888:42344+10	2EA5  216480  			PV1	LD	HL,XBF		;EXPRESSION IS IN EXTRA BUFFER
 889:42354+7	2EA8  7E      			PZ	LD	A,(HL)		;GET CHARACTER FROM EXPRESSION
 890:42361+6	2EA9  23      				INC	HL		;POINT TO NEXT
 891:42367+4	2EAA  A7      				AND	A		;TEST FOR END OF EXPRESSION
 892:42371+5+6	2EAB  F8      				RET M			;IF SO, END IT NOW
 893:42376+17	2EAC  CD4500  				CALL	BPUTCHR	;PRINT CHARACTER
 894:42393+10	2EAF  C3A82E  				JP	PZ		;KEEP GOING TILL END
 895:							
 896:						; RECURSIVE ROUTINE OUTPUTS NUMBER IN DECIMAL
 897:42403+7	2EB2  FE28    			DECPRT	CP	'('		;TEST FOR SPECIAL CASE
 898:42410+10+7	2EB4  C47D00  				CALL NZ, BPUTSP	;IF NOT, PRECEDE WITH SPACE
 899:42420+10	2EB7  010A00  			DECP1	LD	BC,10		;DIVIDE BY 10
 900:42430+17	2EBA  CD2932  				CALL	DODIV		;PERFORM DIVISION
 901:42447+7	2EBD  3E30    				LD	A,0x30		;TO CONVERT TO ASCII
 902:42454+4	2EBF  85      				ADD	A,L		;GET DIGIT
 903:42458+11	2EC0  F5      				PUSH	AF
 904:42469+4	2EC1  EB      				EX	DE, HL	
 905:42473+4	2EC2  7C      				LD	A,H		;GET HIGH BYTE
 906:42477+4	2EC3  B5      				OR	L		;TEST FOR ZERO, (FINISHED)
 907:42481+10+7	2EC4  C4B72E  				CALL NZ, DECP1		;IF NOT, GET NEXT VALUE
 908:42491+10	2EC7  F1      				POP	AF
 909:42501+10	2EC8  C34500  				JP	BPUTCHR	;DISPLAY AND RETURN
 910:						;
 911:						; IT'S AN 'INPUT', LETS GIVE HIM A CHANCE TO DO SOME TYPING.. BUT
 912:						; KEEP AN EYE ON HIM, IN CASE HE TRY'S TO PUT SOMETHING OVER ON US
 913:						;
 914:42511+17	2ECB  CDA334  			INPUT	CALL	CLBF		;CLEAR EXTRA TEXT BUFFER
 915:42528+7	2ECE  3E3F    				LD	A,'?'		;GET A QUESTION MARK.
 916:42535+13	2ED0  326480  				LD	(XBF), A	;TO USE AS THE DEFAULT PROMPT
 917:42548+7	2ED3  1A      				LD	A, (DE)		;GET FIRST CHAR OF OPERAND
 918:42555+7	2ED4  FE22    				CP	'"'		;TEST FOR USER SUPPLIED PROMPT
 919:42562+10	2ED6  C2DF2E  				JP NZ,	INP1		;IF NOT, DON'T CHANGE EXISTING ONE
 920:42572+17	2ED9  CD3531  				CALL	EXPR		;EVALUATE USER SUPPLIED PROMPT
 921:42589+17	2EDC  CD0331  				CALL	PARSE		;SKIP TO NEXT NON-BLANK
 922:42606+17	2EDF  CD782A  			INP1	CALL	VCHAR		;TEST FOR VALID VARIABLE NAME
 923:42623+11	2EE2  D5      				PUSH	DE		;SAVE SOURCE POSITION
 924:42634+6	2EE3  13      				INC	DE		;ADVANCE TO NEXT CHARACTER
 925:42640+11	2EE4  F5      				PUSH	AF
 926:42651+7	2EE5  1A      				LD	A, (DE)		;GET NEXT CHARACTER
 927:42658+7	2EE6  FE24    				CP	'$'		;TEST FOR CHARACTER INPUT
 928:42665+10	2EE8  CA0C2F  				JP Z,	GCHR		;IF SO, GET CHARACTER DATA
 929:42675+10	2EEB  210000  				LD	HL,0		;START WITH A ZERO
 930:42685+11	2EEE  39      				ADD	HL,SP		;AND GET STACK POINTER. IN CASE WE BLOW UP
 931:42696+16	2EEF  223E82  				LD	(TEMP), HL	;SAVE SO WE CAN GET IT BACK LATER
 932:42712+17	2EF2  CDA52E  			RETRY	CALL	PV1		;DISPLAY USER PROMPT
 933:42729+4	2EF5  97      				SUB	A		;GET A ZERO
 934:42733+13	2EF6  323582  				LD	(IFLAG), A	;AND CLEAR THE INPUT FLAG (IN CASE HE CTRL-C'S)
 935:42746+17	2EF9  CDD02A  				CALL	GLINE		;GET A LINE FROM THE TERMINAL
 936:42763+13	2EFC  323582  				LD	(IFLAG), A	;SET IFLAG. (SO GET ERROR, WE CAN COME BACK)
 937:42776+17	2EFF  CD3531  				CALL	EXPR		;EVALUATE EXPRESSION
 938:42793+10	2F02  F1      				POP	AF
 939:42803+17	2F03  CDE72F  				CALL	STOR		;STASH VALUE IN VARIABLE
 940:42820+10	2F06  D1      				POP	DE		;RESTORE SOURCE POSITION
 941:42830+4	2F07  97      				SUB	A		;GET A ZERO
 942:42834+13	2F08  323582  				LD	(IFLAG), A	;AND CLEAR IFLAG
 943:42847+10	2F0B  C9      				RET
 944:						; CHARACTER INPUT
 945:42857+17	2F0C  CDA52E  			GCHR	CALL	PV1		;DISPLAY USER PROMPT
 946:42874+17	2F0F  CDD02A  				CALL	GLINE		;GET A LINE OF INPUT
 947:42891+10	2F12  F1      				POP	AF
 948:42901+17	2F13  CDB52F  				CALL	LTA		;GET THE TEXT VARIABLE'S ADDRESS
 949:42918+7	2F16  0623    				LD	B,35		;LENGTH IS 35
 950:42925+7	2F18  1A      			Z1	LD	A, (DE)		;GET CHARACTER FROM INPUT BUFFER
 951:42932+7	2F19  FE0D    				CP	CR		;TEST FOR END OF BUFFER
 952:42939+10	2F1B  CA282F  				JP Z,	Z2		;IF SO, END THE LINE
 953:42949+6	2F1E  0B      				DEC	BC		;TEST FOR END OF VARIABLE SPACE
 954:42955+10	2F1F  CA282F  				JP Z,	Z2		;IF SO, END THE LINE
 955:42965+7	2F22  77      				LD	(HL),A		;SAVE IN VARIABLE SPACE
 956:42972+6	2F23  23      				INC	HL		;NEXT CHARACTER IN VARIABLE
 957:42978+6	2F24  13      				INC	DE		;NEXT CHARACTER IN INPUT BUFFER
 958:42984+10	2F25  C3182F  				JP	Z1		;COPY NEXT CHARACTER
 959:42994+10	2F28  D1      			Z2	POP	DE		;RESTORE SOURCE POSITION
 960:43004+10	2F29  36FF    			Z3	LD	(HL),0xFF	;PAD BUFFER WITH NULL CHARACTERS
 961:43014+6	2F2B  23      				INC	HL		;NEXT POSITION IN VARIABLE
 962:43020+6	2F2C  0B      				DEC	BC		;REDUCE COUNT TILL END
 963:43026+10	2F2D  F2292F  				JP P,	Z3		;KEEP GOING TILL VARIABLE IS FILLED
 964:43036+10	2F30  C9      				RET
 965:						;
 966:						; LOOK'S LIKE HE CAN'T EVEN ENTER A SIMPLE NUMBER, CLEAN UP ANY STACK
 967:						; HE MAY HAVE USED, AND LET HIM TAKE ANOTHER BLIND STAB AT THE KEYBOARD
 968:						;
 969:43046+10	2F31  21AE35  			INERR	LD	HL,IERMS	;GET NASTY MESSAGE
 970:43056+17	2F34  CD5700  				CALL	PRINTM		;GIVE HIM THE BAD NEWS
 971:43073+16	2F37  2A3E82  				LD	HL, (TEMP)	;GET HIS OLD STACK BACK
 972:43089+6	2F3A  F9      				LD	SP, HL	
 973:43095+10	2F3B  C3F22E  				JP	RETRY		;LET HIM TRY AGAIN
 974:						;
 975:						; DIMENSION, HE WANTS SOME ARRAY SPACE.. I SUPPOSE WE SHOULD GIVE IT TO HIM
 976:						;
 977:43105+4	2F3E  7B      			DIM	LD	A,E		;GET ADDRESS OF OUR POSITION
 978:43109+13	2F3F  323682  				LD	(PP), A		;SAVE IN POSITION POINTER
 979:43122+7	2F42  1A      			DIM0	LD	A, (DE)		;GET CHARACTER FROM SOURCE
 980:43129+6	2F43  13      				INC	DE		;ADVANCE TO NEXT
 981:43135+7	2F44  FE0D    				CP	CR		;TEST FOR END OF LINE
 982:43142+10	2F46  CA7C2A  				JP Z,	SYNT		;IF SO, TELL HIM TO STRAIGHTEN UP
 983:43152+7	2F49  FE29    				CP	')'		;TEST FOR START OF ARRAY DIMENSION
 984:43159+10	2F4B  C2422F  				JP NZ,	DIM0		;IF NOT, KEEP LOOKING
 985:43169+6	2F4E  1B      				DEC	DE		;BACK UP FOR EXPRESSION
 986:43175+11	2F4F  D5      				PUSH	DE		;SAVE BASIC PROGRAM COUNTER
 987:43186+17	2F50  CD3E31  				CALL	DOEXP		;EVALUATE ARRAY SIZE
 988:43203+6	2F53  23      				INC	HL		;ADD ONE ENTRY (ZERO ENTRY DOES EXIST)
 989:43209+11	2F54  29      				ADD	HL,HL		;DOUBLE BECAUSE THEY ARE 16 BIT'S
 990:43220+6	2F55  1B      				DEC	DE		;BACK UP TO NAME
 991:43226+4	2F56  44      				LD	B,H		;COPY SIZE NEEDED
 992:43230+4	2F57  4D      				LD	C,L		;INTO B AND C
 993:43234+16	2F58  2A3A82  				LD	HL, (LAST)	;GET FREE ADDRESS
 994:43250+11	2F5B  E5      				PUSH	HL		;SAVE FOR TABLE
 995:43261+10	2F5C  3600    			DLOOP	LD	(HL),0		;ZERO ARRAY BYTE
 996:43271+6	2F5E  23      				INC	HL		;ADVANCE TO NEXT
 997:43277+6	2F5F  0B      				DEC	BC		;REDUCE COUNT
 998:43283+4	2F60  78      				LD	A,B		;GET HIGH BYTE OF REMAINING TO DO
 999:43287+4	2F61  B1      				OR	C		;TEST FOR NONE LEFT
1000:43291+10	2F62  C25C2F  				JP NZ,	DLOOP		;IF NOT, KEEP ZEROING
1001:43301+16	2F65  223A82  				LD	(LAST), HL	;SAVE NEXT FREE SPACE INDICATOR
1002:43317+10	2F68  E1      				POP	HL		;GET ADDRESS OF ARRAY BACK
1003:43327+7	2F69  1A      				LD	A, (DE)		;GET ARRAY NAME
1004:43334+17	2F6A  CD7D2F  				CALL	TABENT		;GET TABLE ENTRY
1005:43351+4	2F6D  7C      				LD	A,H		;GET HIGH ADDRESS
1006:43355+7	2F6E  02      				LD	(BC), A		;PLACE IN TABLE
1007:43362+6	2F6F  03      				INC	BC		;ADVANCE IN TABLE
1008:43368+4	2F70  7D      				LD	A,L		;GET LOW ADDRESS
1009:43372+7	2F71  02      				LD	(BC), A		;PLACE IN TABLE
1010:43379+10	2F72  D1      				POP	DE		;GET SOURCE POSITION BACK
1011:43389+17	2F73  CD0331  				CALL	PARSE		;ADVANCE TO NEXT NON-BLANK
1012:43406+5+6	2F76  C8      				RET Z
1013:43411+7	2F77  FE2C    				CP	','		;TEST FOR ANOTHER OPERAND
1014:43418+10	2F79  CA3E2F  				JP Z,	DIM		;IF SO, KEEP GOING
1015:43428+4	2F7C  97      				SUB	A		;CAUSE A SYNTAX ERROR BECAUSE WE ARE BAD
1016:						;
1017:						; LOCATES TABLE POSITION OF AN ARRAY
1018:						;
1019:43432+17	2F7D  CD782A  			TABENT	CALL	VCHAR		;INSURE IT'S OK
1020:43449+7	2F80  D641    				SUB	'A'		;CONVERT TO BINARY
1021:43456+4	2F82  87      				ADD	A,A		;X 2 FOR TWO BYTE ENTRIES
1022:43460+4	2F83  4F      				LD	C,A		;SAVE IN C
1023:43464+13	2F84  3AFD81  				LD	A, (ARYLOC)	;GET ARRAY PAGE
1024:43477+4	2F87  47      				LD	B,A		;SAVE IN HIGH ZBYTE
1025:43481+10	2F88  C9      				RET
1026:						; LOOKS UP AN ARRAY VALUE
1027:43491+17	2F89  CD3E31  			ALOOK	CALL	DOEXP		;CALCULATE INDEX VALUE
1028:43508+6	2F8C  1B      				DEC	DE		;BACK UP PAST '['
1029:43514+7	2F8D  1A      				LD	A, (DE)		;GET VARIABLE NAME
1030:43521+17	2F8E  CD9E2F  				CALL	LOOKT		;FIND ADDRESS OF ENTRY
1031:43538+7	2F91  46      				LD	B,(HL)		;GET HIGH BYTE OF ENTRY
1032:43545+6	2F92  23      				INC	HL		;ADVANCE TO LOW BYTE
1033:43551+7	2F93  4E      				LD	C,(HL)		;GET LOW BYTE OF ARRAY ENTRY
1034:43558+4	2F94  60      				LD	H,B		;TRANSFER RESULT TO .
1035:43562+4	2F95  69      				LD	L,C		;H AND L WHERE THEY ARE EXPECTED
1036:43566+7	2F96  1A      				LD	A, (DE)		;GET VARIABLE NAME BACK
1037:43573+7	2F97  FE40    				CP	'@'		;TEST FOR MAGIC 'PEEK' ARRAY
1038:43580+5+6	2F99  C0      				RET NZ			;IF NOT, WE ARE OK
1039:43585+4	2F9A  6C      				LD	L,H		;SET VALUE TO THAT OF FIRST BYTE
1040:43589+7	2F9B  2600    				LD	H,0		;AND ELIMINATE HIGH BYTE
1041:43596+10	2F9D  C9      				RET
1042:						;
1043:						; LOCATES ADDRESS OF AN ARRAY ENTRY IN THE ARRAY TABLE. INDEX IN HL
1044:						;
1045:43606+7	2F9E  FE40    			LOOKT	CP	'@'		;TEST FOR SPECIAL CASE
1046:43613+5+6	2FA0  C8      				RET Z			;IF SO, PEEK AT ADDRESS
1047:43618+17	2FA1  CD7D2F  				CALL	TABENT		;LOCATE TABLE ENTRY
1048:43635+11	2FA4  D5      				PUSH	DE		;SAVE BASIC PROGRAM COUNTER
1049:43646+7	2FA5  0A      				LD	A, (BC)		;GET FIRST BYTE
1050:43653+4	2FA6  57      				LD	D,A		;COPY TO HIGH BYTE
1051:43657+6	2FA7  03      				INC	BC		;ADVANCE TO NEXT
1052:43663+7	2FA8  0A      				LD	A, (BC)		;GET LOW BYTE
1053:43670+4	2FA9  5F      				LD	E,A		;COPY TO D
1054:43674+11	2FAA  29      				ADD	HL,HL		;X TWO FOR TWO BYTE ENTRIES
1055:43685+11	2FAB  19      				ADD	HL,DE		;ADD IN OFFSET FOR START OF ARRAY
1056:43696+4	2FAC  B2      				OR	D		;TEST FOR ADDRESS OF ZERO, = NOT DIMENSIONED
1057:43700+10	2FAD  D1      				POP	DE		;RESTORE PROGRAM COUNTER
1058:43710+5+6	2FAE  C0      				RET NZ			;NOT A DIMENSION ERROR, GO BACK
1059:						;
1060:						; EITHER HE'S TRIED TO INDEX A NON-ARRAY VARIABLE, TRIED TO INDEX A CHARACTER
1061:						; VARIABLE WITH A VALUE GREATER THEN 34, OR HE'S PLOTTED OUTSIDE OF THE SCREEN
1062:						; NO MATTER WHAT HE'S DONE, GIVE HIM A NASTY MESSAGE SO HE WON'T DO IT AGAIN
1063:						;
1064:43715+10	2FAF  21F635  			DIMERR	LD	HL,OVM		;ADDRESS OF NASTY MESSAGE
1065:43725+10	2FB2  C3802A  				JP	ERR		;GIVE IT TO HIM
1066:						; LOCATES THE ADDRESS OF A CHARACTER (TEXT) VARIABLE
1067:43735+7	2FB5  D641    			LTA	SUB	0x41		;REDUCE TO SIMPLE BINARY
1068:43742+7	2FB7  FE1A    				CP	26		;TEST FOR VALID VARIABLE
1069:43749+10	2FB9  D27C2A  				JP NC,	SYNT		;IF NOT, GET MAD
1070:43759+10	2FBC  211982  				LD	HL,VARS+25	;START OF CHARACTER VARIABLES (-37)
1071:43769+10	2FBF  012500  				LD	BC,37		;LENGTH OF CHARACTER VARIABLES
1072:43779+11	2FC2  09      			V1	ADD	HL,BC		;OFFSET INTO TABLE
1073:43790+4	2FC3  3D      				DEC	A		;REDUCE VARIABLES WE HAVE TO GO
1074:43794+10	2FC4  F2C22F  				JP P,	V1		;IF NOT FINISHED, KEEP OFFSETING
1075:43804+10	2FC7  C9      				RET
1076:						;
1077:						; IT'S A 'USR' COMMAND, FIND OUT WHAT HE WANT'S, PASS CONTROL  TO
1078:						; HIS MACHINE LANGUAGE ROUTINE, AND GOD HELP HIM IF HE SCREW'S UP
1079:						; BECAUSE WE CAN'T DO ANYTHING FOR HIM UNTIL HE RETURNS
1080:						;
1081:43814+10	2FC8  21DD2F  			USR	LD	HL,URET		;GET ON STACK (SO HE CAN 'RET' TO IT)
1082:43824+11	2FCB  E5      				PUSH	HL		;SAVE IN MACHINE STACK
1083:43835+17	2FCC  CD3531  				CALL	EXPR		;EVALUATE ADDRESS
1084:43852+11	2FCF  E5      				PUSH	HL		;SAVE ON STACK (SO WE CAN 'RET' TO IT)
1085:43863+7	2FD0  1A      				LD	A, (DE)		;GET NEXT CHARACTER
1086:43870+7	2FD1  FE2C    				CP	','		;TEST FOR MORE PARAMETERS
1087:43877+10	2FD3  C2DA2F  				JP NZ,	CSAV		;IF NOT, DONT EVALUATE
1088:43887+6	2FD6  13      				INC	DE		;SKIP THE ','
1089:43893+17	2FD7  CD3531  				CALL	EXPR		;EVALUATE PARAMETER TO PASS
1090:						; WHEN 'PUSHD' RETURNS, IT WILL EFFECT A JUMP TO HIS CODE
1091:43910+10	2FDA  C3BD2D  			CSAV	JP	PUSHD		;SAVE PROGRAM POSITION
1092:						; IF WE GET HERE, HE MADE IT BACK IN ONE PIECE
1093:43920+17	2FDD  CDC72D  			URET	CALL	POPD		;GET PROGRAM COUNTER BACK
1094:43937+7	2FE0  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
1095:43944+7	2FE1  FE2C    				CP	','		;TEST FOR VARIABLE TO RECEIVE H-L
1096:43951+5+6	2FE3  C0      				RET NZ			;IF NOT, WE ARE DONE
1097:43956+17	2FE4  CD0331  				CALL	PARSE		;KEEP LOOKING
1098:						;
1099:						; STORES H-L INTO A INTEGER VARIABLE PASSED IN A
1100:						;
1101:43973+7	2FE7  0682    			STOR	LD	B,HIGH VARS	;GET ADDRESS OF VARIABLE TABLE
1102:43980+7	2FE9  D641    				SUB	0x41		;CONVERT TO BINARY
1103:43987+7	2FEB  FE1A    				CP	26		;TEST FOR VALID VARIABLE NAME
1104:43994+10	2FED  D27C2A  				JP NC,	SYNT		;IF NOT, IT'S INVALID
1105:44004+4	2FF0  87      				ADD	A,A		;DOUBLE BECAUSE THEY ARE 16 BIT ENTRIES
1106:44008+4	2FF1  4F      				LD	C,A		;PLACE IN C, MAKING COMPLETE ADDRESS
1107:44012+4	2FF2  7D      				LD	A,L		;GET LOW VALUE TO SAVE
1108:44016+7	2FF3  02      				LD	(BC), A		;SAVE IN VARIABLE
1109:44023+6	2FF4  03      				INC	BC		;NEXT BYTE OF VARIABLE
1110:44029+4	2FF5  7C      				LD	A,H		;GET HIGH BYTE
1111:44033+7	2FF6  02      				LD	(BC), A		;SAVE IN VARIABLE
1112:44040+10	2FF7  C9      				RET
1113:						;
1114:						; RETERIVES CONTENTS OF A VARIABLE
1115:						;
1116:44050+7	2FF8  0682    			LOOK	LD	B,HIGH VARS	;ADDRESS OF VARIABLES
1117:44057+7	2FFA  D641    				SUB	'A'		;CONVERT NAME TO BINARY
1118:44064+4	2FFC  87      				ADD	A,A		;DOUBLE FOR 16 BIT ENTRIES
1119:44068+4	2FFD  4F      				LD	C,A		;MAKE COMPLETE ADDRESS
1120:44072+7	2FFE  0A      				LD	A, (BC)		;GET LOW BYTE
1121:44079+4	2FFF  6F      				LD	L,A		;PLACE IN L
1122:44083+6	3000  03      				INC	BC		;NEXT BYTE OF VARIABLE
1123:44089+7	3001  0A      				LD	A, (BC)		;GET HIGH BYTE
1124:44096+4	3002  67      				LD	H,A		;PLACE IN H
1125:44100+10	3003  C9      				RET
1126:						;
1127:						; IT'S AN 'ORDER', (HE THINKS HE KNOWS WHERE THERE IS SOME DATA)
1128:						;
1129:44110+11	3004  D5      			ORDER	PUSH	DE		;SAVE OUR SOURCE POSITION
1130:44121+17	3005  CD192C  				CALL	FNDLIN		;GET ADDRESS OF THE LINE HE WANTS
1131:44138+10	3008  D1      				POP	DE		;RESTORE OUR POSITION
1132:44148+11	3009  D5      				PUSH	DE		;AND RESAVE OUR POSITION
1133:44159+10	300A  C2682D  				JP NZ,	BADLIN		;IF IT DOSN'T EXIST, THEN FORGET IT
1134:44169+6	300D  23      				INC	HL		;SKIP FIRST TWO DIGITS OF LINE NUMBER
1135:44175+6	300E  23      				INC	HL		;SKIP LAST TWO DIGITS OF LINE NUMBER
1136:44181+6	300F  23      				INC	HL		;SKIP LENGTH BYTE
1137:44187+4	3010  EB      				EX	DE, HL	
1138:44191+17	3011  CD9430  				CALL	VERDAT		;GET STATEMENT FROM LINE
1139:44208+16	3014  223882  				LD	(DATA), HL	;SAVE DATA POINTER
1140:44224+10	3017  D1      				POP	DE		;RESTORE OUR LINE, (SO WE CAN TELL HIM)
1141:44234+5+6	3018  C8      				RET Z
1142:						;
1143:						; DATA ERROR... ATTEMPT TO READ FROM A LINE WITHOUT 'DATA' OR
1144:						; ATTEMPT TO READ THE WRONG DATA TYPE. LET HIM IN ON IT
1145:						;
1146:44239+10	3019  21F135  			DERR	LD	HL,DTXT		;ADDRESS OF 'DATA' MESSAGE
1147:44249+10	301C  C37F2A  				JP	SYNT+3		;DISPLAY IT
1148:						;
1149:						; IT'S A READ. (HE WANTS TO KNOW WHATS IN THAT DATA WE FOUND)
1150:						;
1151:44259+17	301F  CD782A  			READ	CALL	VCHAR		;IS IT A VALID VARIABLE
1152:44276+11	3022  F5      				PUSH	AF
1153:44287+6	3023  13      				INC	DE		;ADVANCE TO NEXT CHARACTER
1154:44293+7	3024  1A      				LD	A, (DE)		;GET NEXT CHARACTER
1155:44300+7	3025  FE24    				CP	'$'		;IS IT A CHARACTER VARIABLE?
1156:44307+10	3027  CA3730  				JP Z,	CDAT		;IF SO, LOOK FOR CHARACTER DATA
1157:						; NUMERIC DATA, FOR NUMERIC VARIABLE
1158:44317+17	302A  CD5D30  				CALL	GETDAT		;GET NUMERIC DATA
1159:44334+10	302D  DA1930  				JP C,	DERR		;IF CHARACTER, IT A DATA TYPE ERROR
1160:44344+10	3030  F1      				POP	AF
1161:44354+17	3031  CDE72F  				CALL	STOR		;STASH VALUE IN IT
1162:44371+10	3034  C35130  				JP	MORDAT		;SEE IF HE WANT'S MORE DATA
1163:						; CHARACTER DATA, FOR CHARACTER VARIABLE
1164:44381+6	3037  13      			CDAT	INC	DE		;SKIP DOLLAR SIGN
1165:44387+17	3038  CD5D30  				CALL	GETDAT		;GET DATA
1166:44404+10	303B  D21930  				JP NC,	DERR		;IF NUMERIC, IT'S BAD
1167:44414+10	303E  F1      				POP	AF
1168:44424+17	303F  CDB52F  				CALL	LTA		;FIND IT'S ADDRESS
1169:44441+10	3042  016480  				LD	BC,XBF		;DATA IS IN EXTRA BUFFER
1170:44451+11	3045  D5      				PUSH	DE		;SAVE SOURCE POSITION
1171:44462+7	3046  1E23    				LD	E,35		;MOVE 35 CHARACTERS
1172:44469+7	3048  0A      			SL1	LD	A, (BC)		;GET CHARACTER FROM BUFFER. (DATA)
1173:44476+7	3049  77      				LD	(HL),A		;STASH IT IN THE VARIABLE
1174:44483+6	304A  03      				INC	BC		;SKIP TO THE NEXT CHARACTER IN THE BUFFER
1175:44489+6	304B  23      				INC	HL		;SKIP TO THE NEXT POSITION IN VARIABLE
1176:44495+4	304C  1D      				DEC	E		;REDUCE COUNT OF HOW MANY TO MOVE
1177:44499+10	304D  C24830  				JP NZ,	SL1		;IF NOT FINISHED, KEEP COPYING
1178:44509+10	3050  D1      				POP	DE		;RESTORE SOURCE POSITION
1179:						; LOOK FOR MORE VARIABLES (OPERANDS) IN THE 'READ' STATEMENT
1180:44519+17	3051  CD0431  			MORDAT	CALL	PARSE1		;FIND NEXT NON-BLANK
1181:44536+7	3054  FE2C    				CP	','		;IF COMMA..
1182:44543+5+6	3056  C0      				RET NZ			;IF NOT, WE HAVE ALL THERE IS
1183:44548+17	3057  CD0331  				CALL	PARSE		;SKIP COMMA AND FIND VARIABLE NAME
1184:44565+10	305A  C31F30  				JP	READ		;GET MORE DATA FOR FOLLOWING VARIABLE
1185:						; GETS DATA FROM THE DATA STATEMENTS, POINTED TO BY THE CURRENT READ POINTER
1186:44575+16	305D  2A3882  			GETDAT	LD	HL, (DATA)	;GET DATA POINTER
1187:44591+4	3060  7C      				LD	A,H		;SEE IF IT IS ZERO.
1188:44595+4	3061  B5      				OR	L		;WHICH INDICATES THAT IT WASN'T INITIALIZED
1189:44599+10	3062  CA1930  				JP Z,	DERR		;IF SO, IT'S A DATA ERROR
1190:44609+11	3065  D5      				PUSH	DE		;SAVE SOURCE POSIITION
1191:44620+4	3066  EB      				EX	DE, HL	
1192:44624+17	3067  CD3531  				CALL	EXPR		;EVALUATE THE DATA EXPRESSION
1193:44641+11	306A  F5      				PUSH	AF
1194:44652+7	306B  1A      			ENDAT	LD	A, (DE)		;GET NEXT CHARACTER FROM THE SOURCE
1195:44659+7	306C  FE2C    				CP	','		;TEST FOR MORE DATA
1196:44666+10	306E  CA8B30  				JP Z,	COMA		;IF SO, WE ARE OK
1197:44676+7	3071  FE3A    				CP	':'		;TEST FOR END OF STATEMENT
1198:44683+10	3073  CA7E30  				JP Z,	DAT1		;GO TO NEXT DATA STATEMENT
1199:44693+6	3076  13      				INC	DE		;ADVANCE ONE CHARACTER
1200:44699+7	3077  FE0D    				CP	CR		;CARRIAGE RETURN?
1201:44706+10	3079  C26B30  				JP NZ,	ENDAT		;KEEP LOOKING IF NOT
1202:						; HIT THE END OF A LINE, SKIP TO NEXT DATA STATEMENT
1203:44716+6	307C  13      				INC	DE		;SKIP FIRST TWO DIGITS
1204:44722+6	307D  13      				INC	DE		;SKIP SECOND TWO DIGITS
1205:44728+6	307E  13      			DAT1	INC	DE		;SKIP LENGTH (OR ':' IF STMT)
1206:44734+11	307F  E5      				PUSH	HL		;SAVE H-L REG
1207:44745+17	3080  CD9430  				CALL	VERDAT		;CHECK FOR DATA STATEMENT
1208:44762+4	3083  EB      				EX	DE, HL	
1209:44766+10	3084  E1      				POP	HL		;RESTORE REGISTERS
1210:44776+10	3085  CA8C30  				JP Z,	GDEND		;RETURN, WITH NEW DATA POINTER
1211:44786+10	3088  11FFFF  				LD	DE,0xFFFF	;INDICATE NO MORE DATA STATEMENTS
1212:44796+6	308B  13      			COMA	INC	DE		;SKIP THE COMMA
1213:44802+4	308C  EB      			GDEND	EX	DE, HL	
1214:44806+16	308D  223882  				LD	(DATA), HL	;SAVE IN POINTER
1215:44822+4	3090  EB      				EX	DE, HL	
1216:44826+10	3091  F1      				POP	AF
1217:44836+10	3092  D1      				POP	DE		;GET SOURCE POSITION BACK
1218:44846+10	3093  C9      				RET
1219:						;
1220:						; VERIFY THAT COMMAND WAS 'DATA'
1221:						;
1222:44856+17	3094  CD0431  			VERDAT	CALL	PARSE1		;SKIP TO COMMAND
1223:44873+4	3097  EB      				EX	DE, HL	
1224:44877+10	3098  111735  				LD	DE,DATCMD	;POINT TO DATA COMMAND
1225:44887+4	309B  7B      			VER1	LD	A,E		;GET LOW ADDRESS
1226:44891+7	309C  FE1B    				CP	LOW (DATCMD+4)	;ARE WE AT END
1227:44898+5+6	309E  C8      				RET Z
1228:44903+7	309F  1A      				LD	A, (DE)		;GET CHR FROM TABLE
1229:44910+6	30A0  13      				INC	DE		;ADVANCE TO NEXT
1230:44916+7	30A1  E67F    				AND	0x7F		;INSURE IT'S CORRECT
1231:44923+7	30A3  BE      				CP	(HL)		;DUZ IT MATCH?
1232:44930+6	30A4  23      				INC	HL		;NEXT IN DATA COMMAND
1233:44936+10	30A5  CA9B30  				JP Z,	VER1		;OK, TEST NEXT
1234:44946+10	30A8  C9      				RET
1235:						;
1236:						; HE WANT'S TO KNOW HOW BIG IT IS... LETS FIGURE IT OUT AND LET HIM IN ON IT
1237:						;
1238:44956+11	30A9  D5      			SIZE	PUSH	DE		;SAVE PROGRAM POINTER
1239:44967+17	30AA  CDBB30  				CALL	GETEOF		;FIND THE END OF THE FILE
1240:44984+10	30AD  017A00  				LD	BC,NEGTEXT	;GET THE (NEGATIVE) FILE START ADDRESS
1241:44994+11	30B0  09      				ADD	HL,BC		;SUBTRACT FILE START FROM FILE END
1242:45005+17	30B1  CDB22E  				CALL	DECPRT		;DISPLAY VALUE IN DECIMAL
1243:45022+10	30B4  214436  				LD	HL,SIMSG	;GET ' BYTES' MESSAGE
1244:45032+10	30B7  D1      				POP	DE		;RESTORE PROGRAM POINTER
1245:45042+10	30B8  C35700  				JP	PRINTM		;TELL HIM WHAT IT IS
1246:						; FINDS THE END OF THE FILE, HL=LAST BYTE OF PGM., A=FIRST FREE PAGE
1247:45052+10	30BB  210086  			GETEOF	LD	HL,TEXT		;START AT THE BEGINING
1248:45062+7	30BE  3EFF    				LD	A,255		;LOOKING FOR AN FF
1249:45069+7	30C0  BE      			GLPX	CP	(HL)		;IS THIS IT?
1250:45076+6	30C1  23      				INC	HL		;ADVANCE TO NEXT
1251:45082+10	30C2  C2C030  				JP NZ,	GLPX		;IF NOT IT, KEEP LOOKING
1252:45092+6	30C5  2B      				DEC	HL		;POINT BACK TO 0xFF
1253:45098+4	30C6  7C      				LD	A,H		;GET HIGH VALUE
1254:45102+4	30C7  3C      				INC	A		;ADVANCE TO NEXT PAGE
1255:45106+10	30C8  C9      				RET
1256:						;
1257:						; HE'S TRYING TO 'LOAD' SOMETHING, I WONDER IF HE HAS SOMETHING SAVED..
1258:						;
1259:     -	30C9          			LOAD:	;CALL	TON		;TURN ON TAPE AND WAIT
1260:     -	30C9          			LOD1:	;CALL	GETR		;GET A RECORD
1261:							;JP C,	LOD1		;KEEP GOING TILL WE HAVE IT ALL
1262:							;CALL	TOFF		;SHUT TAPE OFF
1263:45116+10	30C9  C31A2A  				JP	RESV		;CLEAR VARIABLES AND GET A NEW COMMAND
1264:						;
1265:						; HE'S TRYING TO 'SAVE' SOMETHING..
1266:						;
1267:45126+11	30CC  D5      			SAVE	PUSH	DE		;SAVE PROGRAM POINTER
1268:45137+10	30CD  110086  				LD	DE,TEXT		;GET ADDRESS OF TEXT
1269:45147+7	30D0  1A      				LD	A, (DE)		;GET FIRST BYTE
1270:45154+4	30D1  3C      				INC	A		;TEST FOR NO PROGRAM
1271:45158+10	30D2  CAEC2C  				JP Z,	RUN		;IF SO, RUN WILL ABORT WITH ERROR
1272:45168+17	30D5  CDBB30  				CALL	GETEOF		;GET ENDING ADDRESS
1273:							;CALL	TDUMP		;DUMP PROGRAM AND RETURN
1274:45185+10	30D8  D1      				POP	DE		;RESTORE PROGRAM POINTER
1275:45195+10	30D9  C9      				RET
1276:						;
1277:						;****************************************************************
1278:						;                 EXPRESSION EVALUATION CODE
1279:						;****************************************************************
1280:						;
1281:						; EVALUATES 16 BIT DECIMAL NUMBERS
1282:						;
1283:45205+10	30DA  010100  			EVAL	LD	BC,1		;MULTIPLIER IS ONE
1284:45215+4	30DD  60      				LD	H,B		;INITIALIZE
1285:45219+4	30DE  68      				LD	L,B		;STARTING RESULT TO ZERO
1286:45223+7	30DF  1A      			ETOP	LD	A, (DE)		;GET DIGIT FROM SOURCE
1287:45230+17	30E0  CDC62A  				CALL	NUM		;TEST FOR INVALID DIGIT
1288:45247+5+6	30E3  D8      				RET C			;IF SO, WE ARE FINISHED
1289:45252+7	30E4  E60F    				AND	0x0F		;CONVERT TO BINARY
1290:						; ADD DIGIT TIMES MULTIPLIER IN B-C TO H-L
1291:45259+4	30E6  3D      			ZLOOP	DEC	A		;REDUCE BY ONE
1292:45263+10	30E7  FAEE30  				JP M,	ESP1		;BEXIT WHEN EXAUSTED
1293:45273+11	30EA  09      				ADD	HL,BC		;ADD MULTIPLIER
1294:45284+10	30EB  C3E630  				JP	ZLOOP		;CONTINUE TILL DONE
1295:						; MULTIPLY MULTIPLIER (BC) BY 10
1296:45294+11	30EE  E5      			ESP1	PUSH	HL		;SAVE H-L
1297:45305+4	30EF  60      				LD	H,B		;GET B-C INTO
1298:45309+4	30F0  69      				LD	L,C		;H-L SO WE CAN USE 'DAD'
1299:45313+11	30F1  09      				ADD	HL,BC		;BC=BC*2
1300:45324+11	30F2  29      				ADD	HL,HL		;BC=BC*4
1301:45335+11	30F3  09      				ADD	HL,BC		;BC=BC*5
1302:45346+11	30F4  29      				ADD	HL,HL		;BC=BC*10
1303:45357+4	30F5  44      				LD	B,H		;SAVE BACK INTO
1304:45361+4	30F6  4D      				LD	C,L		;B-C REGISTER PAIR
1305:45365+10	30F7  E1      				POP	HL		;RESTORE H-L
1306:45375+6	30F8  1B      				DEC	DE		;REDUCE POINTER IN SOURCE
1307:45381+10	30F9  C3DF30  				JP	ETOP		;EVALUATE NEXT CHARACTER
1308:						;
1309:						; SUBROUTINE TESTS FOR VALID ASCII CHARACTERS
1310:						;
1311:45391+7	30FC  FE41    			CHAR	CP	'A'		;TEST FOR < 'A'
1312:45398+5+6	30FE  D8      				RET C			;RETURN SAYING IT'S BAD
1313:45403+7	30FF  FE5B    				CP	'Z'+1		;TEST FOR >'Z'
1314:45410+4	3101  3F      				CCF			;INVERT LOGIC
1315:45414+10	3102  C9      				RET
1316:						;
1317:						; PARSES FORWARD, SEARCHING FOR FIRST NON-BLANK CHARACTER
1318:						;
1319:45424+6	3103  13      			PARSE	INC	DE		;ADVANCE IN SOURCE
1320:45430+7	3104  1A      			PARSE1	LD	A, (DE)		;GET CHARACTER FROM SOURCE
1321:45437+7	3105  FE20    				CP	' '		;TEST FOR SPACE
1322:45444+7+5	3107  28FA    				JR Z,	PARSE		;KEEP LOOKING
1323:45451+7	3109  FE3A    				CP	':'		;TEST FOR END OF STATEMENT
1324:45458+5+6	310B  C8      				RET Z			;IF SO, RETURN WITH Z SET
1325:45463+7	310C  FE0D    				CP	CR		;TEST FOR END OF LINE
1326:45470+10	310E  C9      				RET
1327:						;
1328:						; SKIPS TO NEXT EXPRESSION OR COMMAND
1329:						;
1330:45480+17	310F  CD0431  			SKIP	CALL	PARSE1		;ADVANCE TO NEXT NON-BLANK
1331:45497+6	3112  1B      				DEC	DE		;BACK UP TO POSITION
1332:45503+4	3113  7B      				LD	A,E		;GET LOW ORDER ADDRESS
1333:45507+13	3114  323682  				LD	(PP), A		;SAVE IN POSITION BYTE
1334:						; LOOK FOR DELIMITER
1335:45520+6	3117  13      			SKIP1	INC	DE		;ADVANCE TO NEXT
1336:45526+7	3118  1A      				LD	A, (DE)		;GET CHARACTER
1337:45533+7	3119  FE3A    				CP	':'		;TEST FOR DELIMITER
1338:45540+5+6	311B  C8      				RET Z			;IF SO, RETURN
1339:45545+7	311C  FE2C    				CP	','		;TEST FOR DELIMITER
1340:45552+5+6	311E  C8      				RET Z			;IF SO, RETURN
1341:45557+7	311F  FE0D    				CP	CR		;TEST FOR DELIMITER
1342:45564+5+6	3121  C8      				RET Z			;IF SO, RETURN
1343:45569+7	3122  FE22    				CP	'"'		;TEST FOR QUOTE
1344:45576+10+7	3124  CC2931  				CALL Z,	SKPQUO		;IF SO, ADVANCE TO NEXT QUOTE
1345:45586+12	3127  18EE    				JR	SKIP1		;KEEP LOOKING
1346:						; FIND NEXT QUOTE IN SOURCE
1347:45598+6	3129  13      			SKPQUO	INC	DE		;ADVANCE TO NEXT CHARACTER IN SOURCE
1348:45604+7	312A  1A      				LD	A, (DE)		;GET THE CHARACTER
1349:45611+7	312B  FE22    				CP	'"'		;IS IT A QUOTE?
1350:45618+5+6	312D  C8      				RET Z			;IF SO, WE FOUND IT
1351:45623+7	312E  FE0D    				CP	CR		;IF IT A CARRIAGE RETUEN
1352:45630+7+5	3130  20F7    				JR NZ,	SKPQUO		;IF NOT, OK
1353:45637+10	3132  C37C2A  				JP	SYNT		;UNMATCHED QUOTES WHILE PARSING
1354:						;
1355:						; EVALUATES AN EXPRESSION POINTED TO BY D-E. RETURN WITH CARRY SET
1356:						; INDICATES THAT EXPRESSION WAS A CHARACTER EXPRESSION
1357:						;
1358:45647+17	3135  CD0F31  			EXPR	CALL	SKIP		;ADVANCE TO END OF EXPRESSION
1359:45664+11	3138  D5      				PUSH	DE		;SAVE POINTER TO END
1360:45675+17	3139  CD3E31  				CALL	DOEXP		;EVALUATE
1361:45692+10	313C  D1      				POP	DE		;RESTORE POINTER TO END OF EXPRESSION
1362:45702+10	313D  C9      				RET
1363:						; CALCULATES EXPRESSION BACKWARDS (LIKE APL)
1364:45712+6	313E  1B      			DOEXP	DEC	DE		;BACK UP IN SOURCE
1365:45718+17	313F  CDA033  				CALL	FE		;GET CHARACTER FROM SOURCE
1366:45735+7	3142  FE24    				CP	'$'		;TEST FOR CHARACTER VARIABLE
1367:45742+10	3144  CACC33  				JP Z,	CEXP		;IF SO, ITS A CHARACTER EXPRESSION
1368:45752+7	3147  FE22    				CP	'"'		;TEST FOR QUOTE
1369:45759+10	3149  CACC33  				JP Z,	CEXP		;IF SO, IT'S A CHARACTER EXRESSION
1370:45769+6	314C  13      				INC	DE		;ADVANCE
1371:45775+7	314D  3E3B    				LD	A,';'		;NULL OPERATOR TO START
1372:45782+11	314F  E5      			EGO1	PUSH	HL		;SAVE OLD VALUE
1373:45793+11	3150  F5      				PUSH	AF
1374:45804+6	3151  1B      				DEC	DE		;BACK UP TO VALUE
1375:45810+17	3152  CDA033  				CALL	FE		;GET CHARACTER FROM SOURCE
1376:45827+7	3155  FE29    				CP	')'		;TEST FOR BRACKET
1377:45834+10	3157  CAB931  				JP Z,	BRKTS		;IF SO, RECURSE
1378:45844+7	315A  FE5D    				CP	']'		;TEST FOR ARRAY LOOKUP
1379:45851+10	315C  CABF31  				JP Z,	ARYL		;IF SO, LOOK UP ARRAY VALUE
1380:45861+17	315F  CDFC30  				CALL	CHAR		;TEST FOR VARIABLE
1381:45878+10	3162  D2C931  				JP NC,	LOOKU		;IF SO, LOOK IT UP
1382:45888+7	3165  FE3F    				CP	'?'		;TEST FOR RANDOM NUMBER RETERIVAL
1383:45895+10	3167  CAAD33  				JP Z,	RANDR		;GET RANDOM VALUE
1384:45905+7	316A  FE23    				CP	'#'		;TEST FOR HEX CONSTANT
1385:45912+10	316C  CA7B31  				JP Z,	HEXVL		;IF SO, GET HEV VALUE
1386:45922+17	316F  CDC62A  				CALL	NUM		;TEST FOR A NUMBER
1387:45939+10	3172  DA7C2A  				JP C,	SYNT		;IF NOT, I DON'T KNOW WHAT HE'S DOING
1388:						; DECIMAL NUMBER
1389:45949+17	3175  CDDA30  			CALN	CALL	EVAL		;EVALUATE DECIMAL NUMBER
1390:45966+10	3178  C3CD31  				JP	OLOOK		;LOOK FOR OPERATOR
1391:						; HEX. NUMBER
1392:45976+6	317B  1B      			HEXVL	DEC	DE		;BACK UP IN SOURCE
1393:45982+13	317C  3A3682  				LD	A, (PP)		;GET ENDING POSITION
1394:45995+4	317F  BB      				CP	E		;TEST FOR PASSED THE LIMIT
1395:45999+10	3180  CA9131  				JP Z,	HEXGO		;IF SO, THATS IT
1396:46009+7	3183  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
1397:46016+17	3184  CDC62A  				CALL	NUM		;TEST FOR VALID DIGIT
1398:46033+10	3187  D27B31  				JP NC,	HEXVL		;KEEP GOING TILL WE GET TO START OF STRING
1399:46043+7	318A  D641    				SUB	'A'		;TEST FOR VALID LETTER
1400:46050+7	318C  FE06    				CP	6		;OF 'A' TO 'F'
1401:46057+10	318E  DA7B31  				JP C,	HEXVL		;IF SO, KEEP LOOKING
1402:46067+10	3191  210000  			HEXGO	LD	HL,0		;START WITH A ZERO
1403:46077+4	3194  44      				LD	B,H		;FLAG TO SEE IF ANY DIGITS
1404:46081+11	3195  D5      				PUSH	DE		;SAVE POSITION IN SOURCE
1405:46092+6	3196  13      			GETHX	INC	DE		;ADVANCE TO NEXT DIGIT OF HEX NUMBER
1406:46098+7	3197  1A      				LD	A, (DE)		;GET DIGIT
1407:46105+7	3198  FE23    				CP	'#'		;TEST FOR END OF STRING
1408:46112+10	319A  CAB031  				JP Z,	HGON		;IF SO, WE ARE DONE
1409:46122+4	319D  47      				LD	B,A		;SET FLAG SO WE KNOW WE GOT AT LEAST ONE DIGIT
1410:46126+11	319E  29      				ADD	HL,HL		;SHIFT H-L
1411:46137+11	319F  29      				ADD	HL,HL		;RIGHT IN ORDER
1412:46148+11	31A0  29      				ADD	HL,HL		;TO MAKE ROOM FOR
1413:46159+11	31A1  29      				ADD	HL,HL		;THE NEW DIGIT
1414:46170+7	31A2  D630    				SUB	'0'		;REDUCE TO BINARY
1415:46177+7	31A4  FE0A    				CP	10		;TEST FOR FURTHER REDUCTION NEEDED
1416:46184+10	31A6  DAAB31  				JP C,	HISG		;IF NOT, PROCESS
1417:46194+7	31A9  D607    				SUB	7		;CONVERT LETTER TO BINARY
1418:46201+4	31AB  B5      			HISG	OR	L		;ADD IN BOTTOM DIGIT OF RESULT
1419:46205+4	31AC  6F      				LD	L,A		;REPLACE IN RESULT
1420:46209+10	31AD  C39631  				JP	GETHX		;GET NEXT DIGIT
1421:46219+10	31B0  D1      			HGON	POP	DE		;GET POSITION IN SOURCE BACK
1422:46229+4	31B1  78      				LD	A,B		;GET FLAG
1423:46233+4	31B2  A7      				AND	A		;TEST FOR DIGIT'S PROCESSED
1424:46237+10	31B3  C2CD31  				JP NZ,	OLOOK		;NO PROBLEM
1425:46247+10	31B6  C37C2A  				JP	SYNT		;'#' WITH NO DIGITS... ERROR
1426:						; A ')' HAS BEEN DETECTED
1427:46257+17	31B9  CD3E31  			BRKTS	CALL	DOEXP		;RECURSE ON OURSELVES
1428:46274+10	31BC  C3CC31  				JP	DCLB		;CONTINUE WITH VALUE
1429:						; LOOK UP AN ARRAY VALUE
1430:46284+10	31BF  F1      			ARYL	POP	AF
1431:46294+11	31C0  F5      				PUSH	AF
1432:46305+7	31C1  FE3D    				CP	'='		;TEST FOR ASSIGNMENT
1433:46312+10+7	31C3  C4892F  				CALL NZ, ALOOK		;IF NOT, GET VALUE
1434:46322+10	31C6  C3CC31  				JP	DCLB		;CONTINUE WITH VALUE
1435:						; GET VARIABLE CONTENTS
1436:46332+17	31C9  CDF82F  			LOOKU	CALL	LOOK		;LOOK UP VALUE OF VARIABLE
1437:46349+6	31CC  1B      			DCLB	DEC	DE		;BACK UP IN SOURCE
1438:46355+10	31CD  F1      			OLOOK	POP	AF
1439:46365+10	31CE  C1      				POP	BC		;GET OLD VALUE BACK
1440:						; 16 BIT ADDITION
1441:46375+7	31CF  FE2B    				CP	'+'		;TEST FOR ADDITION
1442:46382+10	31D1  CAE031  				JP Z,	ADD		;IF SO, PERFORM ADD
1443:						; SIXTEEN BIT SUBTRACTION
1444:46392+7	31D4  FE2D    				CP	'-'		;TEST FOR SUBTRACTION
1445:46399+10	31D6  C2E431  				JP NZ,	MULT		;NO, TRY MULTIPLICATION
1446:46409+4	31D9  78      				LD	A,B		;GET B
1447:46413+4	31DA  2F      				CPL			;COMPLEMENT
1448:46417+4	31DB  47      				LD	B,A		;RESAVE
1449:46421+4	31DC  79      				LD	A,C		;GET C
1450:46425+4	31DD  2F      				CPL			;COMPLEMENT
1451:46429+4	31DE  4F      				LD	C,A		;RESAVE
1452:46433+6	31DF  03      				INC	BC		;ADD 1 GIVING TWO'S COMPLEMENT
1453:46439+11	31E0  09      			ADD	ADD	HL,BC		;ADD TO NEW VALUE
1454:46450+10	31E1  C34333  				JP	EGO		;CONTINUE
1455:						; 16 BIT MULTIPLICATION
1456:46460+7	31E4  FE2A    			MULT	CP	'*'		;TEST FOR MULTIPLY
1457:46467+10	31E6  C21332  				JP NZ,	DIV		;NO, TRY DIVIDE
1458:46477+4	31E9  78      				LD	A,B		;TEST OLD VALUE FOR ZERO
1459:46481+4	31EA  B1      				OR	C		;AS IT IS A
1460:46485+10	31EB  CA4033  				JP Z,	EGZ		;SPECIAL CASE
1461:46495+17	31EE  CDF431  				CALL	DMULT		;PERFORM THE MULTIPLY
1462:46512+10	31F1  C34333  				JP	EGO		;AND CONTINUE
1463:						; MULTIPLY SUBROUTINE (ALSO USED BY RANDOM NUMBER GENERATOR)
1464:46522+11	31F4  D5      			DMULT	PUSH	DE		;SAVE POSITION IN SOURCE
1465:46533+10	31F5  110000  				LD	DE,0		;START OUT WITH A ZERO
1466:46543+4	31F8  A7      			MUL1	AND	A		;INSURE CARRY CLEAR
1467:46547+4	31F9  78      				LD	A,B		;GET B
1468:46551+4	31FA  1F      				RRA			;ROTATE
1469:46555+4	31FB  47      				LD	B,A		;RESAVE
1470:46559+4	31FC  79      				LD	A,C		;GET C
1471:46563+4	31FD  1F      				RRA			;ROTATE WITH CARRY
1472:46567+4	31FE  4F      				LD	C,A		;REPLACE
1473:46571+11	31FF  F5      				PUSH	AF
1474:46582+4	3200  B0      				OR	B		;TEST FOR B-C = ZER0
1475:46586+10	3201  CA0F32  				JP Z,	MEXIT		;IF SO, WE ARE DONE
1476:46596+10	3204  F1      				POP	AF
1477:46606+10	3205  D20B32  				JP NC,	NOMAD		;NO ONE BIT, DON'T ADD
1478:46616+4	3208  EB      				EX	DE, HL	
1479:46620+11	3209  19      				ADD	HL,DE		;ADD TO D-E
1480:46631+4	320A  EB      				EX	DE, HL	
1481:46635+11	320B  29      			NOMAD	ADD	HL,HL		;SHIFT H-L RIGHT BY ONE BIT
1482:46646+10	320C  C3F831  				JP	MUL1		;KEEP GOING
1483:46656+11	320F  19      			MEXIT	ADD	HL,DE		;ADD RESULT
1484:46667+10	3210  F1      				POP	AF
1485:46677+10	3211  D1      				POP	DE		;RESTORE SOURCE POSITION
1486:46687+10	3212  C9      				RET
1487:						; 16 BIT DIVISION
1488:46697+7	3213  FE25    			DIV	CP	'%'		;TEST FOR DIVIDE
1489:46704+10	3215  C26B32  				JP NZ,	FLOR		;NO, TRY FLOR
1490:46714+4	3218  78      				LD	A,B		;TEST FOR AN OLD
1491:46718+4	3219  B1      				OR	C		;VALUE OF ZERO,
1492:46722+10	321A  CA5F32  				JP Z,	DIVZE		;BECAUSE THAT IS  A BAD THING
1493:46732+11	321D  D5      				PUSH	DE		;SAVE SOURCE POSITION
1494:46743+17	321E  CD2932  				CALL	DODIV		;PERFORM DIVIDE OPERATION
1495:46760+16	3221  222282  				LD	(VARS+34), HL	;SET 'R' REMAINDER VARIABLE
1496:46776+4	3224  EB      				EX	DE, HL	
1497:46780+10	3225  D1      				POP	DE		;RESTORE SOURCE POSITION
1498:46790+10	3226  C34333  				JP	EGO		;AND CARRY ON
1499:						;
1500:						; PERFORMS 16 BIT(HL) BY 16 BIT(BC) DIVIDE, RESULT IN DE, REM IN HL
1501:						;
1502:46800+4	3229  78      			DODIV	LD	A,B		;GET CONTENTS OV B
1503:46804+4	322A  2F      				CPL			;INVERT
1504:46808+4	322B  47      				LD	B,A		;REPLECE
1505:46812+4	322C  79      				LD	A,C		;GET CONTENTS IN C
1506:46816+4	322D  2F      				CPL			;INVERT
1507:46820+4	322E  4F      				LD	C,A		;REPLACE
1508:46824+6	322F  03      				INC	BC		;COMPLETE TWO COMPLEMENT OPERATION
1509:46830+4	3230  EB      				EX	DE, HL	
1510:46834+10	3231  210000  				LD	HL,0		;ZERO HIGHER HALF
1511:46844+17	3234  CD3732  				CALL	DIVBYT		;PERFORM FIRST HALF
1512:46861+4	3237  7A      			DIVBYT	LD	A,D		;GET UPPER HALF
1513:46865+4	3238  53      				LD	D,E		;SAVE LOWER HALF
1514:46869+7	3239  1E08    				LD	E,8		;GET LOOP COUNT
1515:46876+11	323B  29      			DIVTOP	ADD	HL,HL		;SHIFT LEFT
1516:46887+10	323C  DA5332  				JP C,	OVER1		;OVERFLOWED
1517:46897+4	323F  87      				ADD	A,A		;SHIFT  RESULT
1518:46901+10	3240  D24432  				JP NC,	SUBB		;IF NO CARRY, DON'T INC
1519:46911+6	3243  23      				INC	HL		;ADVANCE UPPER VALUE
1520:46917+11	3244  E5      			SUBB	PUSH	HL		;SAVE VALUE
1521:46928+11	3245  09      				ADD	HL,BC		;SUBTRACT LOWER HALF OF FRACTION
1522:46939+10	3246  DA4D32  				JP C,	OKKK		;IF WRAP PAST ZERO
1523:46949+10	3249  E1      				POP	HL		;RESTORE VALUE
1524:46959+10	324A  C35932  				JP	NXLP		;FINISH LOOP
1525:46969+6	324D  33      			OKKK	INC	SP		;FIX UP
1526:46975+6	324E  33      				INC	SP		;STACK
1527:46981+4	324F  3C      				INC	A		;ADVANCE RESULT
1528:46985+10	3250  C35932  				JP	NXLP		;FINISH LOOP
1529:46995+4	3253  8F      			OVER1	ADC	A,A		;SHIFT RESULT, +1 FOR CARRY
1530:46999+10	3254  D25832  				JP NC,	OVRSUB		;IF NO WRAP
1531:47009+6	3257  23      				INC	HL		;INC. VALUE
1532:47015+11	3258  09      			OVRSUB	ADD	HL,BC		;SUBTRACT LOWER
1533:47026+4	3259  1D      			NXLP	DEC	E		;REDUCE LOOP COUNTER
1534:47030+10	325A  C23B32  				JP NZ,	DIVTOP		;LOOP IF NOT FINISHED
1535:47040+4	325D  5F      				LD	E,A		;LOWER BYTE OF RESULT
1536:47044+10	325E  C9      				RET
1537:						;
1538:						; HE SHOULD KNOW THAT HE CAN'T DIVIDE BY ZERO, BUT JUST IN CASE...
1539:						; WE WILL TELL HIM ANYWAY
1540:						;
1541:47054+10	325F  219F35  			DIVZE	LD	HL,DER		;ADDRESS OF 'DIVIDE BYE ZERO MESSAGE'
1542:47064+10	3262  C3802A  				JP	ERR		;HANDLE LIKE ANY OTHER ERROR
1543:						; COMPARES H-L TO B-C, Z=1 IF HL=BC, C=1 IF HL<BC
1544:47074+4	3265  7C      			COMP	LD	A,H		;GET HIGH BYTE OF HL
1545:47078+4	3266  B8      				CP	B		;COMPARE WITH HIGH BYTE OF BC
1546:47082+5+6	3267  C0      				RET NZ			;IF NOT SAME, LOWER BYTE CAN BE IGNORED
1547:47087+4	3268  7D      				LD	A,L		;GET LOW BYTE OF HL
1548:47091+4	3269  B9      				CP	C		;COMPARE WITH LOW BYTE OF BC
1549:47095+10	326A  C9      				RET
1550:						; FLOOR, RETURNS THE LESSER OF THE TWO NUMBERS
1551:47105+7	326B  FE5C    			FLOR:	CP	'\'		;IS IT FLOOR?
1552:47112+10	326D  C27B32  				JP NZ,	CEIL		;NO, TRY CEILING
1553:47122+17	3270  CD6532  				CALL	COMP		;COMPARE NEW TO OLD
1554:47139+10	3273  DA4333  				JP C,	EGO		;IF LESS, WE ARE OK (RESULT IS ALREADY IN HL)
1555:47149+4	3276  60      			SWAP	LD	H,B		;MAKE OLD NUMBER..
1556:47153+4	3277  69      				LD	L,C		;INTO THE NEW NUMBER..
1557:47157+10	3278  C34333  				JP	EGO		;CONTINUE
1558:						; CEILING, RETURNS THE GREATER OF THE TWO NUMBERS
1559:47167+7	327B  FE2F    			CEIL	CP	'/'		;IS IT CEILING?
1560:47174+10	327D  C28932  				JP NZ,	LAND		;NO, TRY LOGICAL AND
1561:47184+17	3280  CD6532  				CALL	COMP		;COMPARE NEW AND OLD
1562:47201+10	3283  D24333  				JP NC,	EGO		;IF GREATER, WE ARE OK (RESULT ALREADY IN HL)
1563:47211+10	3286  C37632  				JP	SWAP		;MAKE OLD NEW AND CONTINUE
1564:						; LOGICAL AND
1565:47221+7	3289  FE26    			LAND	CP	'&'		;IF IT LOGICAL AND ?
1566:47228+10	328B  C29632  				JP NZ,	LOR		;NO, TRY LOGICAL OR
1567:47238+4	328E  78      				LD	A,B		;GET HIGH BYTE OF OLD
1568:47242+4	328F  A4      				AND	H		;AND WITH HIGH BYTE OF NEW
1569:47246+4	3290  67      				LD	H,A		;AND REPLACE HIGH BYTE OF NEW
1570:47250+4	3291  7D      				LD	A,L		;GET LOW BYTE OF OLD
1571:47254+4	3292  A1      				AND	C		;AND WITH LOW BYTE OF NEW
1572:47258+10	3293  C3A032  				JP	CPYL		;CONTINUE
1573:						; LOGICAL OR
1574:47268+7	3296  FE7C    			LOR	CP	'|'		;TEST FOR LOGICAL OR
1575:47275+10	3298  C2A432  				JP NZ,	GRTR		;NO, TRY GREATER THAN
1576:47285+4	329B  7C      				LD	A,H		;GET HIGH BYTE OF NEW
1577:47289+4	329C  B0      				OR	B		;OR WITH HIGH BYTE OF OLD
1578:47293+4	329D  67      				LD	H,A		;AND REPLACE HIGH BYTE OF NEW
1579:47297+4	329E  7D      				LD	A,L		;GET LOW BYTE OF NEW
1580:47301+4	329F  B1      				OR	C		;OR WITH LOW BYTE OF OLD
1581:47305+4	32A0  6F      			CPYL	LD	L,A		;AND REPLACE LOW BYTE OF NEW
1582:47309+10	32A1  C34333  				JP	EGO		;CONTINUE
1583:						; GREATER THAN, RETURNS ONE OR ZERO
1584:47319+7	32A4  FE3E    			GRTR	CP	'>'		;TEST FOR GREATER THAN
1585:47326+10	32A6  C2B532  				JP NZ,	LETH		;IF NOT, TRY LESS THAN
1586:47336+17	32A9  CD6532  				CALL	COMP		;COMPARE OLD AND NEW
1587:47353+10	32AC  CA4033  				JP Z,	EGZ		;FALSE IF EQUAL
1588:47363+10	32AF  DA4033  				JP C,	EGZ		;FALSE IF LESS THAN
1589:47373+10	32B2  C33A33  				JP	EG1		;TRUE IF NOT LESS OR EQUAL
1590:						; LESS THAN, RETURNS ONE OR ZERO
1591:47383+7	32B5  FE3C    			LETH	CP	'<'		;IS IT LESS THAN?
1592:47390+10	32B7  C2C332  				JP NZ,	ENOP		;NO, TRY NO-OP OPERATOR
1593:47400+17	32BA  CD6532  				CALL	COMP		;COMPARE OLD AND NEW
1594:47417+10	32BD  DA3A33  				JP C,	EG1		;TRUE IF LESS
1595:47427+10	32C0  C34033  				JP	EGZ		;FALSE IF NOT LESS
1596:						; NO-OP OPERATOR, RETURNS NEW VALUE ONLY
1597:47437+7	32C3  FE3B    			ENOP	CP	';'		;IS IT NO-OP?
1598:47444+10	32C5  CA4333  				JP Z,	EGO		;IF SO, DON'T DO ANYTHING
1599:						; ASSIGNMENT, SET A VARIABLE'S VALUE
1600:47454+7	32C8  FE3D    			ASST	CP	'='		;TEST FOR ASSIGNMENT
1601:47461+10	32CA  C20533  				JP NZ,	EQUAL		;IF NOT, TRY EQUALITY
1602:47471+13	32CD  323782  				LD	(EFLAG), A	;SET ASSIGNMENT FLAG
1603:47484+6	32D0  13      				INC	DE		;BACK UP TO VARIABLE NAME
1604:47490+7	32D1  1A      				LD	A, (DE)		;GET VARIABLE CHARACTER
1605:47497+7	32D2  FE5D    				CP	']'		;TEST FOR ARRAY STORAGE
1606:47504+10	32D4  CAEB32  				JP Z,	ASTOR		;IF SO, STORE INTO ARRAY
1607:47514+4	32D7  60      				LD	H,B		;GET OLD VALUE
1608:47518+4	32D8  69      				LD	L,C		;INTO H-L (WHERE STORE WANTS THEM)
1609:47522+7	32D9  FE3F    				CP	'?'		;TEST FOR SETTING RANDOM SEED
1610:47529+10	32DB  CAE532  				JP Z,	SRSEED		;IF SO, SET THE SEED
1611:47539+17	32DE  CDE72F  				CALL	STOR		;STORE VALUE INTO VARIABLE
1612:47556+6	32E1  1B      			STRT	DEC	DE		;STEP BACK FROM VARIABLE
1613:47562+10	32E2  C34333  				JP	EGO		;AND CONTINUE
1614:						; SET THE RANDOM SEED
1615:47572+16	32E5  22FE81  			SRSEED	LD	(SEED), HL	;SO WE CAN STORE IN SEED
1616:47588+10	32E8  C3E132  				JP	STRT		;AND CONTINUE
1617:						; SET THE VALUE OF AN ARRAY ELEMENT
1618:47598+11	32EB  E5      			ASTOR	PUSH	HL		;SAVE H-L
1619:47609+17	32EC  CD3E31  				CALL	DOEXP		;CALCULATE INDEX VALUE
1620:47626+6	32EF  1B      				DEC	DE		;BACK UP PAST '['
1621:47632+7	32F0  1A      				LD	A, (DE)		;GET ARRAY NAME
1622:47639+17	32F1  CD9E2F  				CALL	LOOKT		;LOOK UP IT'S ADDRESS IN THE TABLE
1623:47656+4	32F4  44      				LD	B,H		;GET ARRAY ADDRESS
1624:47660+4	32F5  4D      				LD	C,L		;INTO B-C
1625:47664+10	32F6  E1      				POP	HL		;RERSTORE H-L
1626:47674+7	32F7  1A      				LD	A, (DE)		;GET ARRAY NAME BACK
1627:47681+7	32F8  FE40    				CP	'@'		;TEST FOR 'MAGIC', MEMORY REFERENCE
1628:47688+10	32FA  CA0033  				JP Z,	STMEM		;IF SO, SET MEMORY LOCATION
1629:47698+4	32FD  7C      				LD	A,H		;GET HIGH BYTE OF VALUE
1630:47702+7	32FE  02      				LD	(BC), A		;STASH IN ARRAY
1631:47709+6	32FF  03      				INC	BC		;POINT TO NEXT
1632:47715+4	3300  7D      			STMEM	LD	A,L		;GET LOW BYTE OF VALUE
1633:47719+7	3301  02      				LD	(BC), A		;STASH IN ARRAY
1634:47726+10	3302  C3E132  				JP	STRT		;CONTINUE
1635:						; TEST FOR EQUALITY.  ('==')
1636:47736+7	3305  D681    			EQUAL	SUB	0x81		;IS A '=='?
1637:47743+10	3307  C21333  				JP NZ,	GEQL		;IF NOT, TRY GREATER OR EQUAL
1638:47753+17	330A  CD6532  				CALL	COMP		;COMPARE OLD AND NEW
1639:47770+10	330D  CA3A33  				JP Z,	EG1		;TRUE IF EQUAL
1640:47780+10	3310  C34033  				JP	EGZ		;FALSE IF NOT EQUAL
1641:						; GREATER OR EQUAL.  ('>=')
1642:47790+4	3313  3D      			GEQL	DEC	A		;TEST FOR '>='?
1643:47794+10	3314  C22033  				JP NZ,	LEQL		;NO, TRY LESS OR EQUAL
1644:47804+17	3317  CD6532  				CALL	COMP		;COMPARE OLD AND NEW
1645:47821+10	331A  DA4033  				JP C,	EGZ		;FALSE IF LESS THAN
1646:47831+10	331D  C33A33  				JP	EG1		;TRUE IF GREATER OR EQUAL
1647:						; LESS OR EQUAL.  ('<=')
1648:47841+4	3320  3D      			LEQL	DEC	A		;TEST FOR '<='?
1649:47845+10	3321  C23033  				JP NZ,	NEQL		;IF NOT, TRY NOT EQUAL
1650:47855+17	3324  CD6532  				CALL	COMP		;COMPARE OLD AND NEW
1651:47872+10	3327  CA3A33  				JP Z,	EG1		;TRUE IF SAME
1652:47882+10	332A  DA3A33  				JP C,	EG1		;TRUE IF LESS THAN
1653:47892+10	332D  C34033  				JP	EGZ		;FALSE OTHERWISE
1654:						; TEST FOR NOT EQUAL.  ('-=')
1655:47902+4	3330  3D      			NEQL	DEC	A		;IS IT '-='?
1656:47906+10	3331  C27C2A  				JP NZ,	SYNT		;BEATS ME WHAT IT IS!
1657:47916+17	3334  CD6532  				CALL	COMP		;COMPARE OLD AND NEW
1658:47933+10	3337  CA4033  				JP Z,	EGZ		;IF SAME, FALSE
1659:						; RETURN RESULT OF ONE
1660:47943+10	333A  210100  			EG1	LD	HL,1		;SET RESULT TO ONE
1661:47953+10	333D  C34333  				JP	EGO		;PASS ON RESULT
1662:						; RETURN RESULT OF ZERO
1663:47963+10	3340  210000  			EGZ	LD	HL,0		;SET RESULT TO ZERO
1664:						; END OF OPERATION, GET NEXT OPERATOR
1665:47973+17	3343  CDA033  			EGO	CALL	FE		;GET NEXT CHARACTER
1666:47990+5+6	3346  C8      				RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT
1667:47995+7	3347  FE28    				CP	'('		;ARE WE RETURNING FROM A NEST?
1668:							;RET Z			;IF WE PASS BEGINNING OF EXPRESSION, QUIT	
1669:48002+7+5	3349  2028    				JR  NZ,	EGOP1
1670:										;CHECK FOR FUNCTION				
1671:48009+13	334B  3A3682  				LD	A, (PP)		;GET ADDRESS OF BEGINNING OF LINE
1672:48022+6	334E  1B      				DEC	DE
1673:48028+4	334F  BB      				CP	E		;ARE WE THERE??
1674:48032+7+5	3350  281B    				JR  Z,	EGOF1
1675:48039+6	3352  1B      				DEC	DE
1676:48045+4	3353  BB      				CP	E		;ARE WE THERE??
1677:48049+7+5	3354  2816    				JR  Z,	EGOF2
1678:48056+7	3356  1A      				LD	A,(DE)
1679:48063+7	3357  FE49    				CP	'I'
1680:48070+7+5	3359  2011    				JR NZ,	EGOF2
1681:48077+6	335B  13      				INC	DE
1682:48083+7	335C  1A      				LD	A,(DE)					
1683:48090+7	335D  FE4E    				CP	'N'
1684:48097+7+5	335F  200C    				JR NZ,	EGOF1
1685:							
1686:48104+6	3361  1B      				DEC	DE
1687:48110+11	3362  C5      				PUSH	BC
1688:48121+4	3363  4D      				LD	C,L
1689:48125+12	3364  ED78    				IN	A,(C)
1690:48137+10	3366  C1      				POP	BC
1691:48147+4	3367  6F      				LD	L,A
1692:48151+7	3368  2600    				LD	H,0
1693:							
1694:48158+12	336A  1802    				JR	EGOF0
1695:							
1696:48170+6	336C  13      			EGOF2	INC	DE
1697:48176+6	336D  13      			EGOF1	INC	DE
1698:48182+7	336E  3E28    			EGOF0	LD	A,'('
1699:48189+7	3370  FE28    				CP	'('
1700:48196+10	3372  C9      				RET			;IF SO, BACK UP ONE LEVEL
1701:							
1702:48206+7	3373  FE5B    			EGOP1	CP	'['		;FINISHED AN ARRAY INDEX EVALUATION?
1703:48213+5+6	3375  C8      				RET Z			;RETURN TO MAIN EXPRESSION
1704:48218+7	3376  FE3D    				CP	'='		;IF IT A MULTI-CHARACTER OPERATOR
1705:48225+10	3378  C24F31  				JP NZ,	EGO1		;IF NOT, DON'T PRE-EVALUATE
1706:48235+6	337B  1B      				DEC	DE		;BACK UP TO PRECEDING CHARACTER
1707:48241+7	337C  1A      				LD	A, (DE)		;GET PRECEDING CHARACTER
1708:48248+7	337D  FE3D    				CP	'='		;IS IT '=='?
1709:48255+7	337F  0681    				LD	B,0x81		;SET UNIQUE CODE
1710:48262+10	3381  CA9C33  				JP Z,	EGO2		;IF '==' THEN WE HAVE IT
1711:48272+6	3384  03      				INC	BC		;NEXT UNIQUE CODE
1712:48278+7	3385  FE3E    				CP	'>'		;IS IT '>='?
1713:48285+10	3387  CA9C33  				JP Z,	EGO2		;IF SO, WE HAVE IT
1714:48295+6	338A  03      				INC	BC		;NEXT UNIQUE CODE
1715:48301+7	338B  FE3C    				CP	'<'		;IS IT '<='?
1716:48308+10	338D  CA9C33  				JP Z,	EGO2		;IF SO, WE HAVE IT
1717:48318+6	3390  03      				INC	BC		;NEXT UNIQUE CODE
1718:48324+7	3391  FE2D    				CP	'-'		;IS IT '-='?
1719:48331+10	3393  CA9C33  				JP Z,	EGO2		;IF SO, WE HAVE IT
1720:48341+6	3396  13      				INC	DE		;WASN'T A TWO CHARACTER OPERATOR. BACK UP
1721:48347+7	3397  3E3D    				LD	A,'='		;MUST HAVE BEEN A SIMPLE '='
1722:48354+10	3399  C34F31  				JP	EGO1		;CONTINUE EVALUATING EXPRESSION
1723:48364+4	339C  78      			EGO2	LD	A,B		;SET OPERATOR TO OUR UNIQUE CODE
1724:48368+10	339D  C34F31  				JP	EGO1		;AND CONTINUE EVALUATING EXPRESSION
1725:						; FINDS NEXT CHARACTER IN EXPRESSION, SETS Z FLAG IF WE PASS THE BEGINNING
1726:48378+13	33A0  3A3682  			FE	LD	A, (PP)		;GET ADDRESS OF BEGINNING OF LINE
1727:48391+4	33A3  BB      				CP	E		;ARE WE THERE??
1728:48395+5+6	33A4  C8      				RET Z			;IF SO, WE ARE FINISHED
1729:48400+7	33A5  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
1730:48407+7	33A6  FE20    				CP	' '		;IS A (USELESS) BLANK?
1731:48414+5+6	33A8  C0      				RET NZ			;IF NOT, WE ARE FINISHED
1732:48419+6	33A9  1B      				DEC	DE		;BACK UP ANOTHER CHARACTER
1733:48425+10	33AA  C3A033  				JP	FE		;AND TRY AGAIN
1734:						; CALCULATE A PSEUDO-RANDOM VALUE
1735:48435+16	33AD  2AFE81  			RANDR	LD	HL, (SEED)	;GET RANDOM SEED
1736:48451+4	33B0  7C      				LD	A,H		;GET HIGH BYTE OF SEED
1737:48455+7	33B1  E6F7    				AND	0xF7		;AND WITH HIGH MASK
1738:48462+11	33B3  F5      				PUSH	AF
1739:48473+4	33B4  7D      				LD	A,L		;GET LOW BYTE OF SEED
1740:48477+7	33B5  E642    				AND	0x42		;AND WITH LOW BYTE OF MASK
1741:48484+11	33B7  F5      				PUSH	AF
1742:48495+10	33B8  C1      				POP	BC		;GET FLAGS IN C
1743:48505+4	33B9  79      				LD	A,C		;COPY TO A
1744:48509+10	33BA  C1      				POP	BC		;GET FIRST SET OF FLAGS IN C
1745:48519+4	33BB  A9      				XOR	C		;COMPUTE PARITY FOR ENTIRE WORD
1746:48523+4	33BC  0F      				RRCA			;MOVE COMPUTED
1747:48527+4	33BD  0F      				RRCA			;PARITY INTO
1748:48531+4	33BE  0F      				RRCA			;THE CARRY FLAG
1749:48535+4	33BF  3F      				CCF			;COMP, SO SHIFT IN 1 IF EVEN
1750:48539+4	33C0  7D      				LD	A,L		;GET LOW BYTE OF SEED
1751:48543+4	33C1  17      				RLA			;SHIFT IN CARRY, OUT HIGH BIT
1752:48547+4	33C2  6F      				LD	L,A		;RESAVE
1753:48551+4	33C3  7C      				LD	A,H		;GET HIGH BYTE OF SEED
1754:48555+4	33C4  17      				RLA			;SHIFT IN CARRY (HIGH BIT OF OLD LOWER)
1755:48559+4	33C5  67      				LD	H,A		;RESAVE
1756:48563+16	33C6  22FE81  				LD	(SEED), HL	;RESULT IS NEW SEED
1757:48579+10	33C9  C3CC31  				JP	DCLB		;KEEP GOING
1758:						;
1759:						; EVALUATES A CHARACTER EXPRESSION
1760:						;
1761:48589+17	33CC  CDA334  			CEXP	CALL	CLBF		;CLEAR EXTRA BUFFER
1762:48606+6	33CF  13      				INC	DE		;SKIP TO END OF EXPRESSION
1763:48612+7	33D0  3E2B    				LD	A,'+'		;TO BEGIN, CONCATINATE A NULL STRING
1764:48619+11	33D2  F5      			CG1	PUSH	AF
1765:48630+17	33D3  CDB034  				CALL	PUSHB		;COPY NEW BUFFER INTO OLD BUFFER
1766:48647+17	33D6  CDA334  				CALL	CLBF		;CLEAR THE NEW BUFFER
1767:48664+6	33D9  1B      				DEC	DE		;BACK UP IN SOURCE
1768:48670+17	33DA  CDA033  				CALL	FE		;GET CHARACTER AND TEST FOR END
1769:48687+7	33DD  FE22    				CP	'"'		;TEST FOR QUOTE
1770:48694+10	33DF  CAF733  				JP Z,	CQ		;IF SO, HANDLE QUOTED STRING
1771:48704+7	33E2  FE24    				CP	'$'		;TEST FOR CHARACTER VARIABLE
1772:48711+10	33E4  C27C2A  				JP NZ,	SYNT		;IF NOT, IT'S NOT ANYTHING I RECOGNISE
1773:48721+6	33E7  1B      			CV	DEC	DE		;BACK UP PAST DOLLAR SIGN
1774:48727+7	33E8  1A      				LD	A, (DE)		;GET VARIABLE NAME
1775:48734+7	33E9  FE5D    				CP	']'		;TEST FOR INDEX INTO CHARACTER VARIABLE
1776:48741+10	33EB  CAC334  				JP Z,	CINDX		;GET INDEX VALUE
1777:48751+17	33EE  CDB52F  				CALL	LTA		;GET ADDRESS OF VARIABLE
1778:48768+11	33F1  D5      				PUSH	DE		;SAVE SOURCE POSITION
1779:48779+4	33F2  EB      				EX	DE, HL	
1780:48783+6	33F3  1B      				DEC	DE		;BACK UP IN SOURCE
1781:48789+10	33F4  C30434  				JP	Q0		;SAVE VARIABLE IN NEW BUFFER
1782:						; BACKUP TO PRECEDING QUOTE
1783:48799+6	33F7  1B      			CQ	DEC	DE		;BACKUP IN SOURCE
1784:48805+7	33F8  1A      				LD	A, (DE)		;GET CHARACTER FROM SOURCE
1785:48812+7	33F9  FE0D    				CP	CR		;TEST FOR END OF LINE
1786:48819+10	33FB  CA7C2A  				JP Z,	SYNT		;IF SO, THERE IS NO CLOSEING QUOTE
1787:48829+7	33FE  FE22    				CP	'"'		;TEST FOR CLOSEING QUOTE
1788:48836+10	3400  C2F733  				JP NZ,	CQ		;IF NO, KEEP LOOKING
1789:48846+11	3403  D5      				PUSH	DE		;SAVE ENDING POSITION
1790:48857+10	3404  216480  			Q0	LD	HL,XBF		;GET ADDRESS OF NEW (EXTRA) BUFFER
1791:48867+6	3407  13      			Q1	INC	DE		;ADVANCE TO SOURCE OR VARIABLE CHARACTER
1792:48873+7	3408  1A      				LD	A, (DE)		;GET CHARACTER
1793:48880+7	3409  FE22    				CP	'"'		;TEST FOR CLOSEING QUOTE
1794:48887+10	340B  CA1834  				JP Z,	Q2		;IF SO, STOP COPYING
1795:48897+7	340E  FEFF    				CP	0xFF		;TEST FOR END OF VARIABLE
1796:48904+10	3410  CA1834  				JP Z,	Q2		;IF SO, STOP COPYING
1797:48914+7	3413  77      				LD	(HL),A		;SAVE IN BUFFER
1798:48921+6	3414  23      				INC	HL		;ADVANCE IN BUFFER
1799:48927+10	3415  C30734  				JP	Q1		;KEEP COPYING
1800:48937+10	3418  D1      			Q2	POP	DE		;GET POSITION BACK
1801:48947+6	3419  1B      			Q3	DEC	DE		;BACK UP TO OPERATOR
1802:48953+10	341A  F1      				POP	AF
1803:48963+7	341B  FE2B    				CP	'+'		;TEST FOR CONCATIONATION
1804:48970+10	341D  C23534  				JP NZ,	Q5		;NO, TRY ASSIGNMENT
1805:						; CONCATONATION. XBF=XBF+TB
1806:48980+10	3420  013280  			QPP	LD	BC,TB		;ADDRESS OF TEMPORARY BUFFER
1807:48990+7	3423  0A      			Q4	LD	A, (BC)		;GET CHARACTER FROM BUFFER
1808:48997+7	3424  77      				LD	(HL),A		;MOVE TO BUFFER
1809:49004+6	3425  03      				INC	BC		;ADVANCE IN OLD
1810:49010+6	3426  23      				INC	HL		;ADVANCE IN NEW
1811:49016+4	3427  79      				LD	A,C		;GET ADDRESS IN OLD
1812:49020+7	3428  FE55    				CP	LOW (TB+35)		;TEST FOR OVER
1813:49027+10	342A  DA2334  				JP C,	Q4		;IF SO, STOP
1814:49037+16	342D  2A6480  				LD	HL, (XBF)	;GET CHARACTER FROM BUFFER
1815:49053+7	3430  2600    				LD	H,0		;SET HIGH BYTE TO ZERO
1816:49060+10	3432  C37E34  				JP	Q9		;CONTINUE
1817:						; ASSIGNMENT
1818:49070+7	3435  FE3D    			Q5	CP	'='		;TEST FOR ASSIGNMENT
1819:49077+10	3437  C24E34  				JP NZ,	Q6		;IF NOT, TRY EQUALITY
1820:49087+6	343A  13      				INC	DE		;SKIP TO VARIABLE NAME
1821:49093+6	343B  13      				INC	DE		;SKIP TO DOLLARSIGN
1822:49099+7	343C  1A      				LD	A, (DE)		;GET DOLLARSIGN
1823:49106+6	343D  1B      				DEC	DE		;BACK UP TO VARIABLE NAME
1824:49112+7	343E  FE24    				CP	'$'		;TEST FOR DOLLAR SIGN
1825:49119+10	3440  C27C2A  				JP NZ,	SYNT		;IF NOT, THIS AIN'T NO CHARACTER VARIABLE
1826:49129+13	3443  323782  				LD	(EFLAG), A	;SET ASSIGNMENT FLAG
1827:49142+7	3446  1A      				LD	A, (DE)		;GET VARIABLE NAME
1828:49149+6	3447  1B      				DEC	DE		;BACK UP BAST NAME
1829:49155+17	3448  CDB52F  				CALL	LTA		;GET IT'S ADDRESS
1830:49172+10	344B  C32034  				JP	QPP		;COPY IT OVER
1831:						; TEST FOR EQUALITY
1832:49182+7	344E  FE81    			Q6	CP	0x81		;TEST FOR '=='
1833:49189+10	3450  C27234  				JP NZ,	X0		;NO, TRY '=-'
1834:49199+17	3453  CD5934  				CALL	COMSTR		;COMPARE STRINGS
1835:49216+10	3456  C37E34  				JP	Q9		;CONTINUE
1836:						; COMPARES STRINGS. SETS H-L TO 1 OR 0 IF EQUAL OR NOT EQUAL
1837:49226+10	3459  013280  			COMSTR	LD	BC,TB		;GET ADDRESS OF OLD STRING
1838:49236+10	345C  216480  				LD	HL,XBF		;ADDRESS OF NEW STRING
1839:49246+7	345F  0A      			Q7	LD	A, (BC)		;GET CHARACTER FROM OLD
1840:49253+7	3460  BE      				CP	(HL)		;TEST AGAINST NEW
1841:49260+10	3461  C26E34  				JP NZ,	Q8		;IF NOT, THEY ARE UNEQUAL
1842:49270+6	3464  03      				INC	BC		;NEXT PLACE IN OLD
1843:49276+6	3465  23      				INC	HL		;NEXT PLACE IN NEW
1844:49282+4	3466  3C      				INC	A		;TEST FOR END OF STRING
1845:49286+10	3467  C25F34  				JP NZ,	Q7		;IF NOT, CONTINUE TESTING
1846:49296+10	346A  210100  				LD	HL,1		;INDICATE THEY ARE EQUAL
1847:49306+10	346D  C9      				RET
1848:49316+10	346E  210000  			Q8	LD	HL,0		;INDICATE NOT EQUAL
1849:49326+10	3471  C9      				RET
1850:						; NOT EQUAL .. '-='
1851:49336+7	3472  FE82    			X0	CP	0x82		;TEST FOR '-='
1852:49343+10	3474  C27C2A  				JP NZ,	SYNT		;BEATS ME, BUT IT ISN'T RIGHT
1853:49353+17	3477  CD5934  				CALL	COMSTR		;TEST STRINGS
1854:49370+4	347A  7D      				LD	A,L		;GET RESULT
1855:49374+7	347B  EE01    				XOR	1		;AND COMPLEMENT IT
1856:49381+4	347D  6F      				LD	L,A		;REPLACE IN RESULT
1857:						; GET NEXT STRING
1858:49385+17	347E  CDA033  			Q9	CALL	FE		;GET NEXT CHARACTER
1859:49402+4	3481  37      				SCF			;INDICATE CHARACTER EXPRESSION
1860:49406+5+6	3482  C8      				RET Z			;IF END OF LINE, QUIT
1861:49411+7	3483  FE28    				CP	'('		;TEST FOR END OF NUMERIC SUBSTRING
1862:49418+5+6	3485  C8      				RET Z			;QUIT, INDICATING NUMBERIC RESULT
1863:49423+7	3486  FE3D    				CP	'='		;TEST FOR EQUAL,ASSIGNMENT, OR NOT EQUALS
1864:49430+10	3488  C2D233  				JP NZ,	CG1		;NO, NO NEED TO TEST FURTHER
1865:49440+6	348B  1B      			QTST	DEC	DE		;BACK UP TO PREVIOUS CHARACTER
1866:49446+7	348C  1A      				LD	A, (DE)		;GET CHARACTER
1867:49453+4	348D  47      				LD	B,A		;SAVE FOR COMPARISON
1868:49457+7	348E  FE3D    				CP	'='		;TEST FOR '=='
1869:49464+7	3490  3E81    				LD	A,0x81		;INDICATE '=='
1870:49471+10	3492  CAD233  				JP Z,	CG1		;CONTINUE
1871:49481+4	3495  78      				LD	A,B		;GET CHARACTER BACK
1872:49485+7	3496  FE2D    				CP	'-'		;TEST FOR '-='
1873:49492+7	3498  3E82    				LD	A,0x82		;INDICATE '-='
1874:49499+10	349A  CAD233  				JP Z,	CG1		;CONTINUE
1875:49509+6	349D  13      				INC	DE		;ADVANCE BACK TO PREVIOUS CHARACTER
1876:49515+7	349E  3E3D    				LD	A,'='		;INDICATE '='
1877:49522+10	34A0  C3D233  				JP	CG1		;CONTINUE
1878:						; CLEARS THE TEXT BUFFER
1879:49532+10	34A3  216480  			CLBF	LD	HL,XBF		;GET ADDRESS OF BUFFER
1880:49542+7	34A6  3E28    				LD	A,40		;CLEAR FOR LENGTH OF 40
1881:49549+10	34A8  36FF    			CL2	LD	(HL),0xFF	;CLEAR TO NULL CHARACTER
1882:49559+6	34AA  23      				INC	HL		;NEXT POSITION IN BUFFER
1883:49565+4	34AB  3D      				DEC	A		;REDUCE COUNT OF REMAINING
1884:49569+10	34AC  C2A834  				JP NZ,	CL2		;KEEP GOING TILL WE ARE FINISHED
1885:49579+10	34AF  C9      				RET
1886:						; COPY'S NEW BUFFER INTO OLD BUFFER
1887:49589+11	34B0  D5      			PUSHB	PUSH	DE		;SAVE POSITION IS SOURCE
1888:49600+10	34B1  116480  				LD	DE,XBF		;GET ADDRESS OF NEW BUFFER
1889:49610+10	34B4  213280  				LD	HL,TB		;GET ADDRESS OF OLD BUFFER
1890:49620+7	34B7  0628    				LD	B,40		;COPY 40 CHARACTERS
1891:49627+7	34B9  1A      			PU1	LD	A, (DE)		;GET CHARACTER FROM NEW
1892:49634+7	34BA  77      				LD	(HL),A		;SAVE IN OLD
1893:49641+6	34BB  23      				INC	HL		;NEXT POSITION IN OLD
1894:49647+6	34BC  13      				INC	DE		;NEXT POSITION IN NEW
1895:49653+6	34BD  0B      				DEC	BC		;REDUCE COUNT
1896:49659+10	34BE  C2B934  				JP NZ,	PU1		;KEEP GOING TILL 40 ARE MOVED
1897:49669+10	34C1  D1      				POP	DE		;RESTORE POSITION IN SOURCE
1898:49679+10	34C2  C9      				RET
1899:						; INDEXED CHARACTER VARIABLE, EXTRACT A SINGLE CHARACTER
1900:49689+17	34C3  CD3E31  			CINDX	CALL	DOEXP		;EVALUATE INDEX EXPRESSION
1901:49706+4	34C6  7D      				LD	A,L		;GET INDEX VALUE
1902:49710+11	34C7  F5      				PUSH	AF
1903:49721+6	34C8  1B      				DEC	DE		;BACK UP TO VARIABLE NAME
1904:49727+7	34C9  1A      				LD	A, (DE)		;GET VARIABLE NAME
1905:49734+7	34CA  FE40    				CP	'@'		;TEST FOR 'MAGIC' CHR0x VARIABLE
1906:49741+10	34CC  CAE334  				JP Z,	CHR		;IF SO, HANDLE SPECIAL CASE
1907:49751+17	34CF  CDB52F  				CALL	LTA		;GET TEXT VARIABLE ADDRESS
1908:49768+10	34D2  F1      				POP	AF
1909:49778+7	34D3  FE23    				CP	35		;TEST FOR TOO BIG
1910:49785+10	34D5  D2AF2F  				JP NC,	DIMERR		;IF SO, TELL HIM HE SCREWED UP
1911:49795+4	34D8  4F      				LD	C,A		;GET INTO A DOUBLE PAIR
1912:49799+11	34D9  09      				ADD	HL,BC		;SO WE CAN DAD IT TO THE ADDRESS
1913:49810+7	34DA  7E      				LD	A,(HL)		;AND GET THE CHARACTER
1914:49817+10	34DB  216480  			FILBUF	LD	HL,XBF		;ADDRESS OF TEXT BUFFER
1915:49827+7	34DE  77      				LD	(HL),A		;PLACE CHARACTER THERE
1916:49834+6	34DF  23      				INC	HL		;BUMP TO NEXT POSITION
1917:49840+10	34E0  C31934  				JP	Q3		;AND FILL WITH NULLS
1918:						;
1919:						; 'MAGIC' CHARACTER ARRAY, RETURNS CHARACTER WITH VALUE OF IT'S INDEX
1920:						;
1921:49850+10	34E3  F1      			CHR	POP	AF
1922:49860+10	34E4  C3DB34  				JP	FILBUF		;SAVE IN BUFFER AND PAD WITH NULLS
1923:							
1924:						;*********************************************************************
1925:						;                          PATCH I/O ROUTINES TO Z80MC
1926:							
1927:49870+17	34E7  CD5100  			CTRLC	CALL	BINCHR
1928:49887+7	34EA  FE03    				CP	3
1929:49894+10	34EC  C9      				RET
1930:49904+17	34ED  CD5100  			BGETCHR CALL	BINCHR
1931:49921+7+5	34F0  38FB    				JR C,	BGETCHR
1932:49928+10	34F2  C9      				RET
1933:						; END OF BASIC INTERPRETER CODE SECTION
1934:						;	PAGE
1935:						;
1936:						;*********************************************************************
1937:						;                          COMMAND TABLE
1938:						;
1939:						;   FORMAT IS:
1940:						;               COMMAND WORDS, HIGH BIT SET ON LAST CHARACTER
1941:						;               ADDRESS OF COMMAND PROCESSOR FOLLOWES
1942:						;               ENTRY OF HEX 00 INDICATES LAST ENTRY IN TABLE (DEFAULT)
1943:						;
1944:						;*********************************************************************
1945:						;
1946:						; COMMANDS ALLOWED ONLY FROM WITHING A PROGRAM..
1947:     -	34F3  4E4558  			PTAB	DB	'NEX'
1948:     -	34F6  D4      				DB	'T'+0x80
1949:     -	34F7  E12D    				DW	NEXT
1950:     -	34F9  544845  				DB	'THE'
1951:     -	34FC  CE      				DB	'N'+0x80
1952:     -	34FD  322D    				DW	THEN
1953:     -	34FF  474F5355				DB	'GOSU'
1954:     -	3503  C2      				DB	'B'+0x80
1955:     -	3504  3B2D    				DW	GOSUB
1956:     -	3506  52455455				DB	'RETUR'
	              52
1957:     -	350B  CE      				DB	'N'+0x80
1958:     -	350C  6E2D    				DW	RETURN
1959:     -	350E  464F    				DB	'FO'
1960:     -	3510  D2      				DB	'R'+0x80
1961:     -	3511  7B2D    				DW	FOR
1962:     -	3513  49      				DB	'I'
1963:     -	3514  C6      				DB	'F'+0x80
1964:     -	3515  162E    				DW	IF
1965:     -	3517  444154  			DATCMD	DB	'DAT'
1966:     -	351A  C1      				DB	'A'+0x80
1967:     -	351B  132D    				DW	RNEXT
1968:     -	351D  4C49    				DB	'LI'
1969:     -	351F  C6      				DB	'F'+0x80
1970:     -	3520  392E    				DW	LIF
1971:						; COMMANDS ALLOWED FROM BOTH A PROGRAM, AND INTERACTIVE KEYBOARD ENTRY
1972:     -	3522  474F54  			KTAB	DB	'GOT'
1973:     -	3525  CF      				DB	'O'+0x80
1974:     -	3526  432D    				DW	GOTO
1975:     -	3528  4F55    				DB	'OU'
1976:     -	352A  D4      				DB	'T'+0x80	
1977:     -	352B  672E    				DW	OUTP
1978:     -	352D  4C45    				DB	'LE'
1979:     -	352F  D4      				DB	'T'+0x80
1980:     -	3530  D22D    				DW	LET
1981:     -	3532  5052494E				DB	'PRIN'
1982:     -	3536  D4      				DB	'T'+0x80
1983:     -	3537  8D2E    				DW	BPRINT
1984:     -	3539  5553    				DB	'US'
1985:     -	353B  D2      				DB	'R'+0x80
1986:     -	353C  C82F    				DW	USR
1987:     -	353E  524541  				DB	'REA'
1988:     -	3541  C4      				DB	'D'+0x80
1989:     -	3542  1F30    				DW	READ
1990:     -	3544  504C4F  				DB	'PLO'
1991:     -	3547  D4      				DB	'T'+0x80
1992:     -	3548  442E    				DW	PLOT
1993:     -	354A  5245    				DB	'RE'
1994:     -	354C  CD      				DB	'M'+0x80
1995:     -	354D  152E    				DW	REM
1996:     -	354F  4449    				DB	'DI'
1997:     -	3551  CD      				DB	'M'+0x80
1998:     -	3552  3E2F    				DW	DIM
1999:     -	3554  5255    				DB	'RU'
2000:     -	3556  CE      				DB	'N'+0x80
2001:     -	3557  EC2C    				DW	RUN
2002:     -	3559  4F524445				DB	'ORDE'
2003:     -	355D  D2      				DB	'R'+0x80
2004:     -	355E  0430    				DW	ORDER
2005:     -	3560  494E5055				DB	'INPU'
2006:     -	3564  D4      				DB	'T'+0x80
2007:     -	3565  CB2E    				DW	INPUT
2008:     -	3567  434C4541				DB	'CLEA'
2009:     -	356B  D2      				DB	'R'+0x80
2010:     -	356C  AF2C    				DW	CLEAR
2011:     -	356E  53544F  				DB	'STO'
2012:     -	3571  D0      				DB	'P'+0x80
2013:     -	3572  2C2D    				DW	STOP
2014:     -	3574  454E    				DB	'EN'
2015:     -	3576  C4      				DB	'D'+0x80
2016:     -	3577  1D2A    				DW	INIT
2017:     -	3579  4C4953  				DB	'LIS'
2018:     -	357C  D4      				DB	'T'+0x80
2019:     -	357D  6B2C    				DW	LIST
2020:     -	357F  4E45    				DB	'NE'
2021:     -	3581  D7      				DB	'W'+0x80
2022:     -	3582  152A    				DW	NEW
2023:     -	3584  53495A  				DB	'SIZ'
2024:     -	3587  C5      				DB	'E'+0x80
2025:     -	3588  A930    				DW	SIZE
2026:     -	358A  4C4F41  				DB	'LOA'
2027:     -	358D  C4      				DB	'D'+0x80
2028:     -	358E  C930    				DW	LOAD
2029:     -	3590  534156  				DB	'SAV'
2030:     -	3593  C5      				DB	'E'+0x80
2031:     -	3594  CC30    				DW	SAVE
2032:     -	3596  455849  				DB	'EXI'
2033:     -	3599  D4      				DB	'T'+0x80
2034:     -	359A  4200    				DW	BEXIT
2035:     -	359C  00      				DB	0		;UNRECOGNIZED COMMAND, ASSUME 'LET'
2036:     -	359D  D22D    				DW	LET
2037:						;
2038:						;**************************************************************
2039:						;                    STRINGS AND MESSAGES
2040:						;**************************************************************
2041:						;
2042:						; ERROR MESSAGES..
2043:						;
2044:     -	359F  44495649			DER	DB	'DIVIDE BY ZERO',0 ;DIVIDE BY ZERO
	              44452042
	              59205A45
	              524F00
2045:     -	35AE  42414420			IERMS	DB	'BAD DATA - RETRY',CR,LF,0 ;BAD RESPONSE TO INPUT STATEMENT
	              44415441
	              202D2052
	              45545259
	              0D0A00
2046:     -	35C1  4E455354			CSTK	DB	'NESTING',0	;INVALID FOR/NEXT, GOSUB/RETURN NESTING
	              494E4700
2047:     -	35C9  4C494E45			LIN	DB	'LINE NUMBER',0	;GOTO, GOSUB, OR ORDER TO UNKNOWN LINE
	              204E554D
	              42455200
2048:     -	35D5  4E4F2050			NP	DB	'NO PROGRAM',0	;RUN OR SAVE EMPTY PROGRAM
	              524F4752
	              414D00
2049:     -	35E0  20494E20			INL	DB	' IN LINE ',0	;INDICATES LINE ERROR WAS IN
	              4C494E45
	              2000
2050:     -	35EA  53594E54			SYN	DB	'SYNTAX',0	;DOES NOT FOLLOW SYNTAX RULES
	              415800
2051:     -	35F1  44415441			DTXT	DB	'DATA',0	;BAD LINE OR DATA TYPE
	              00
2052:     -	35F6  44494D45			OVM	DB	'DIMENSION',0	;TO MANY ARRAYS, ARGUMENT OUT OF RANGE
	              4E53494F
	              4E00
2053:						;
2054:						; INFORMATIONAL MESSAGES..
2055:						;
2056:     -	3600  0C204D49			INTRO	DB	0x0C,' MICRO-BASIC COPYRIGHT 1983 BY DAVE DUNFIELD',CR,LF,0
	              43524F2D
	              42415349
	              4320434F
	              50595249
	              47485420
	              31393833
	              20425920
	              44415645
	              2044554E
	              4649454C
	              440D0A00
2057:     -	3630  52454144			RDY	DB	'READY',CR,LF,0	;RREADY PROMPT
	              590D0A00
2058:     -	3638  53544F50			STMSG	DB	'STOP',0	;INDICATES PROGRAM STOPPED
	              00
2059:     -	363D  20455252			EM	DB	' ERROR',0	;INDICATES ERROR OCCURED
	              4F5200
2060:     -	3644  20425954			SIMSG	DB	' BYTES',CR,LF,0 ;DISPLAYED IN RESPONSE TO 'SIZE'
	              45530D0A
	              00
2061:     -	364D          			ENDIT	EQU	$
2062:						;	END	0
2063:							
2064:						;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2065:						;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2066:						;	Appendix_B	Future Use
2067:						;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2068:						;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2069:						;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2070:						;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2071:						;	Appendix_C	RAM. System Ram allocation
2072:						;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2073:						;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2074:						;                       ********      ***     **     **
2075:						;                       *********    *****    ***   ***
2076:						;                       **     **   *** ***   **** ****
2077:						;                       **     **  ***   ***  *********
2078:						;---------------------  ********   *********  ** *** **  ---------------------
2079:						;---------------------  ********   *********  ** *** **  ---------------------
2080:						;                       **  **     **     **  **     **
2081:						;                       **   **    **     **  **     **
2082:						;                       **    **   **     **  **     **
2083:						;                       **     **  **     **  **     **
2084:     -	8000          			RAM_LDRT	equ	0x8000
2085:     -	FA00          					ORG	0xFA00
2086:				;		LINE_BUFF	DS	128
2087:				;		LINE_BUFFEND	DS	2	;Room for CR,LF if needed
2088:				;		LI_FILESIZE	DS	4	;LINE INPUT FILE SIZE, counts down the bytes in the file as Lines are fetched
2089:				;		LI_SDBUFF_PTR	DS	2	;Pointer to Disk Buffer for next Line Read operation
2090:				;		LI_SDLOG_SEC	DS	2	;Logical Sector last read in Buffer
2091:										;Read Hex File Performance counter
2092:				;		RHF_LINES	DS	2	;Line counter
2093:						;----------------------------------------------------------------------------------------------------; RAM SPACE
2094:						;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2095:						;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2096:						;----------------------------------------------------------------------------------------------------; RAM SPACE
2097:						;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2098:						;Reserve space from 0xFB00 to FB1F for Stack
2099:						;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2100:     -	FB00          					ORG	0xFB00
2101:				;		StackTop	equ	$-2	; Stack = 0xFB00
2102:				;		STACKSPACE1	DS	40	;Stack space for ISR L1 calls  (Measured to only need 14 words, resv 20 words)
2103:				;		STACK_ISR1	EQU	$	;Points to top of stack
2104:				;		SP_ISR_SAVE	DS	2	;Space to save SP, Happens on first ISR call
2105:				;		HRAM_CODE	DS	ROM_CODE_LEN	;Code for Returning from ISR (may need to switch to RAM, so it must be here in High RAM)
2106:				;		ISR_DISPATCH	EQU	HRAM_CODE
2107:				;		ISR_RET		EQU	ISR_RET_OFF+HRAM_CODE ;Assign address in the HIGH RAM
2108:				;		GET_MEM		EQU	GET_MEM_OFF+HRAM_CODE ;Assign address in the HIGH RAM	
2109:				;		HR_EXE_GO	DS	HR_EXEC_GS_LEN	;Routine for Switching to RAM and Executing loaded program.
2110:				;		HERE1		EQU	$
2111:     -	0000          				IF HERE1 > 0xFB80
2112:							ENDIF
2113:							
2114:							;FREE RAM 25 BYTES
2115:     -	FB80          					ORG	0xFB80
2116:						;SDFCB:
2117:     -	0000          			FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
2118:     -	0001          			FNAME		EQU	1	;DS 11	;+1  File name
2119:     -	000C          			AFClus0		EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
2120:     -	000E          			CRFClus		EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
2121:     -	0010          			CAFClus		EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
2122:     -	0012          			RFSec		EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
2123:     -	0014          			SSOC		EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
2124:     -	0018          			ABS_SEC		EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
2125:     -	001C          			FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)
2126:						;Warning: FCB's must never cross page boundaries.
2127:				;		SDISKA		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
2128:				;		SDISKB		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
2129:				;		SDISKC		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
2130:				;		SDISKD		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
2131:						;
2132:						;  ********   **     **  *********  *********  *********  ********
2133:						;  *********  **     **  *********  *********  *********  *********
2134:						;  **     **  **     **  **         **         **         **     **
2135:						;  **     **  **     **  **         **         **         **     **
2136:						;  ********   **     **  *******    *******    *******    ********
2137:						;  ********   **     **  *******    *******    *******    ********
2138:						;  **     **  **     **  **         **         **         **  **
2139:						;  **     **  **     **  **         **         **         **   **
2140:						;  *********  *********  **         **         *********  **    **
2141:						;  ********    *******   **         **         *********  **     **
2142:						;
2143:     -	FC00          					ORG	0xFC00
2144:				;		SD_RAM_BUFFER	DS	512	;FC00-FDFF 512 bytes of SD Sector Buffer space
2145:				;		RXBUFFER	DS	256	;FExx      256 bytes of RX Buffer space
2146:						;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2147:						;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2148:						;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2149:     -	FF00          					ORG	0xFF00
2150:				;		BIT_TABLE	DS	8
2151:						;Warning: FCB's must never cross page boundaries.
2152:				;		FCB_PTR		DS	2	;Pointer to Current FCB
2153:				;		FAT_CLEAR	EQU	$	;Clear bytes of RAM after this point on FAT_INIT
2154:				;		GH_START	DS	2	;HEX File, start address
2155:				;		VIEW_FLAGS	DS	1	;View File Load;  File Open View
2156:										;BIT .0=View HEX Load, display file while reading HEX file
2157:										;    .1=GH_START Address has been set
2158:										;    .6=View FILE SIZE during File Open
2159:										;    .7=View File Name & Found or Not status durin File Open
2160:				;		LOGICAL_SEC	DS	2	;Logical Sector for next Read Operation (Input paramater for the File Read)
2161:				;		DIRTY_DATA	DS	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
2162:				;		SD_CARD_TYPE	DS	1	;SD CARD TYPE
2163:				;		SDC_STATUS	DS	1	;SD Status Code returned
2164:				;		SD_PARAM	DS	4	;32 bit address parameter for SD Commands
2165:				;		SD_PART_TYPE	DS	1	;SD PARTITION TYPE
2166:				;		SD_PART_BASE	DS	4	;SD PARTITION STARTING RECORD
2167:				;		SD_PART_SIZE	DS	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
2168:				;		BYTE_P_SEC	DS	2	;0x0B Bytes per Sector (Almost always 512)
2169:				;		SEC_PER_CLUS	DS	1	;0x0D
2170:				;		RESERVED_SEC	DS	2	;0x0E - 0x0F
2171:				;		FAT_COPIES	DS	1	;0x10
2172:				;		ROOTDIR_SIZE	DS	2	;0x11 - 0x12
2173:				;		FILESYS_SEC	DS	4	;0x13 - 0x14 or 0x20 - 0x23
2174:				;		HIDDEN_SEC	DS	4	;0x1C - 0x1F
2175:				;		SEC_PER_FAT	DS	2	;0x16 - 0x17
2176:				;		FAT1START	DS	4	;Calculated Sector to FAT1
2177:				;		DIR_SECTOR	DS	4	;Calculated Sector to Root Directory
2178:				;		DATASTART	DS	4	;Calculated Sector to Data Area
2179:				;		SEC_PTR		DS	4	;Sector Pointer, general use variable that holds the last sector read
2180:				;		ENT_COUNT	DS	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
2181:				;		FAT_CLR_LEN	EQU	$ - FAT_CLEAR
2182:				;		FILENAME	DS	8	;File Name
2183:				;		FILEEXT		DS	3	;File Extension
2184:				;		FILESIZE	DS	4	;File Size
2185:				;		DIVIDE_FUNC	DS	2	;Pointer to the Divide Function
2186:				;		DF_SHIFTCNT	DS	1	;Count of shifts required for Fast Divide
2187:				;		MUL8		DS	1	;8 bit multiplier
2188:				;		MOD_FUNC	DS	2	;Pointer to the Mod Function
2189:				;		MODMASK		DS	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector
2190:				;		IK_HEXL		DS	1	;IMON HEX INPUT
2191:				;		IK_HEXH		DS	1	;IMON HEX INPUT
2192:				;		HEX_SOURCE	DS	2	;Pointer to the HEX INPUT Source (FILE or Serial Port)
2193:				;			IF $ >= 0xFF78
2194:				;			ENDIF
2195:				;		;*** BEGIN COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
2196:     -	FF78          			RAMSIGNATURE	equ	0xFF78	;RAM signature
2197:										;Following bytes are cleared on COLD BOOT
2198:     -	FF80          			RC_TYPE		equ	0xFF80	;(1) Type of Reset (WARNING, Next 7 RC counters must end with lsb bits = 001,010,011,100,101,110,111)
2199:     -	FF81          			RC_SOFT		equ	0xFF81	;(1) Count of Resets by SOFT F-E SWITCH
2200:     -	FF82          			RC_STEP		equ	0xFF82	;(1) Count of Resets by SINGLE STEP
2201:     -	FF83          			RC_CC		equ	0xFF83	;(1) Count of Resets by CTRL-C
2202:     -	FF84          			RC_HALT		equ	0xFF84	;(1) Count of Resets by HALT INSTRUCTION
2203:     -	FF85          			RC_F0		equ	0xFF85	;(1) Count of Resets by pressing F & 0 keys
2204:     -	FF86          			RC_RST0		equ	0xFF86	;(1) Count of Resets by RST 0 INSTRUCTION
2205:     -	FF87          			RC_HARD		equ	0xFF87	;(1) Count of Resets by UNKNOWN RESET LINE
2206:     -	FF88          			ABUSS		equ	0xFF88	;(2)
2207:     -	FF8A          			RegPtr		equ	0xFF8A	;(1) Ptr to Registers
2208:     -	FF8B          			IoPtr		equ	0xFF8B	;(1)  I/O Ptr
2209:     -	FF8C          			RX_ERR_LDRT	equ	0xFF8C	;(1) Counts False Start Bits (Noise Flag)
2210:     -	FF8D          			RX_ERR_STOP	equ	0xFF8D	;(1) Counts Missing Stop Bits (Framing Error)
2211:     -	FF8E          			RX_ERR_OVR	equ	0xFF8E	;(1) Counts Overrun Errors
2212:     -	000F          			CS_CLR_LEN	equ	0xFF8F-RC_TYPE
2213:     -	FF8F          			ACE_BAUD	equ	0xFF8F	;(1) Baudrate of ACE, 12=9600
2214:										;PUTCHAR_EXE and INCHAR_EXE *must be consecutive in this order*
2215:     -	FF90          			PUTCHAR_EXE	equ	0xFF90	;(2) PutChar Execution (Set for PC_LED, PC_BIT, PC_ACE or PC_BOTH)
2216:     -	FF92          			INCHAR_EXE	equ	0xFF92	;(2) InChar Execution (Set for IN_KEY, IN_BIT, IN_ACE or IN_BOTH)
2217:						;*** END COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
2218:     -	FF94          			HW_SETIO	equ	0xFF94	;Serial IO selected, 01=Bit, 02=ACE, 03=BIT & ACE
2219:     -	FF95          			HW_LIST		equ	0xFF95	;Hardware List, 00=NO Boards, 01=FP Only, 02=SIO only, 03=FP & SIO
2220:										;Saved Registers
2221:     -	FF96          			RSSP		equ	0xFF96	;Value of SP upon REGISTER SAVE
2222:     -	FF98          			RSAF		equ	0xFF98	;Value of AF upon REGISTER SAVE
2223:     -	FF9A          			RSBC		equ	0xFF9A	;Value of BC upon REGISTER SAVE
2224:     -	FF9C          			RSDE		equ	0xFF9C	;Value of DE upon REGISTER SAVE
2225:     -	FF9E          			RSHL		equ	0xFF9E	;Value of HL upon REGISTER SAVE
2226:     -	FFA0          			RPC		equ	0xFFA0	;Value of PC upon REGISTER SAVE
2227:     -	FFA2          			RSIX		equ	0xFFA2	;Value of IX upon REGISTER SAVE
2228:     -	FFA4          			RSIY		equ	0xFFA4	;Value of IY upon REGISTER SAVE
2229:     -	FFA6          			RSIR		equ	0xFFA6	;Value of IR upon REGISTER SAVE
2230:     -	FFA8          			RSAF2		equ	0xFFA8	;Value of AF' upon REGISTER SAVE
2231:     -	FFAA          			RSBC2		equ	0xFFAA	;Value of BC' upon REGISTER SAVE
2232:     -	FFAC          			RSDE2		equ	0xFFAC	;Value of DE' upon REGISTER SAVE
2233:     -	FFAE          			RSHL2		equ	0xFFAE	;Value of HL' upon REGISTER SAVE
2234:     -	FFB0          			UiVec		equ	0xFFB0	;(2) User Interrupt Vector
2235:						;*** BEGIN WARM_BOOT_INIT (RAM that is to be initialized on every boot) ***
2236:										;WARNING, Following 34 bytes must be consecutive in this order for Block Write
2237:     -	FFB2          			BEEP_TO		equ	0xFFB2	;(1) Count down the beep (beep duration)
2238:     -	FFB3          			ANBAR_DEF	equ	0xFFB3	;(1) Base setting for the Annunciator LED's (after current function times out)
2239:     -	FFB4          			GET_REG		equ	0xFFB4	;(2) Get Reg Routine (in monitor mode, registers fetched from RAM)
2240:     -	FFB6          			PUT_REG		equ	0xFFB6	;(2) Put Reg Routine
2241:     -	FFB8          			CTRL_C_CHK	equ	0xFFB8	;(2) Vector for CTRL-C Checking
2242:     -	FFBA          			LDISPMODE	equ	0xFFBA	;(2) Last Display Mode (Holds DISPMODE while in HEX Entry)
2243:     -	FFBC          			DISPMODE	equ	0xFFBC	;(2) Display Routine
2244:     -	FFBE          			KEY_EVENT	equ	0xFFBE	;(2) Routine to call upon Key Press (changes based on user actions, see KEY_EVENT_DISPATCH)
2245:     -	FFC0          			IK_TIMER	equ	0xFFC0	;(1) IMON TIMEOUT
2246:     -	FFC1          			KEYBFMODE	equ	0xFFC1	;(1) KEY INPUT MODE. 8F=HEX INPUT, 90=Shiftable
2247:     -	FFC2          			DISPLABEL	equ	0xFFC2	;(1) Display Label Refresh
2248:     -	FFC3          			IK_HEXST	equ	0xFFC3	;(1) IMON HEX Input State
2249:     -	FFC4          			HEX_CURSOR	equ	0xFFC4	;(2) HEX Input Cursor location
2250:     -	FFC6          			HEX_READY	equ	0xFFC6	;(2) HEX Input Ready
2251:     -	FFC8          			LED_CURSOR	equ	0xFFC8	;(2) Cursor location for LED Put_Char
2252:     -	FFCA          			RXBHEAD		equ	0xFFCA	;(2) RS-232 RX BUFFER HEAD
2253:     -	FFCC          			RXBTAIL		equ	0xFFCC	;(2) RS-232 RX BUFFER TAIL
2254:     -	FFCE          			INT_VEC		equ	0xFFCE	;(2) Vector to Interrupt ISR
2255:     -	FFD0          			SCAN_PTR	equ	0xFFD0	;(2) SCAN_PTR points to next LED_DISPLAY byte to output (will always be 1 more
2256:										;    than the current hardware column because hardware automatically advances)
2257:     -	FFD2          			HALT_TEST	equ	0xFFD2	;(2) HALT_TEST
2258:						;*** END WARM_BOOT_INIT (RAM BLOCK that is to be initialized on every boot) ***
2259:     -	FFD4          			CLEARED_SPACE	equ	0xFFD4	;Bytes here and later are cleared upon init (some initialized seperately)
2260:     -	002C          			CLEARED_LEN	equ	0xFFFF - CLEARED_SPACE + 1
2261:     -	FFD4          			SDISPMODE	equ	0xFFD4	;(2)
2262:     -	FFD6          			POS_BIT		equ	0xFFD6	;(1) BIT Bang RS232 Character position
2263:     -	FFD7          			POS_ACE		equ	0xFFD7	;(1) ACE RS232 Character position
2264:     -	FFD8          			ISR_FLAGS	equ	0xFFD8	;(1) Indicates how many levels the ISR has nested
2265:     -	FFD9          			RRSTATE		equ	0xFFD9	;(1) RAM/ROM SELECT STATE (FOR RETURN FROM ISR)	
2266:     -	FFDA          			XTIMER_TIC	equ	0xFFDA	;(1) Counts Down tics until Extended Timer ISR_EXXTIMER
2267:     -	FFDB          			READ_RAMROM	equ	0xFFDB	;(1) Selected RAMROM for Monitor READ Operations.  Bit0 for RAM/ROM, Bits1-4 for Bank
2268:     -	FFDC          			NMI_VEC		equ	0xFFDC	;(2) NMI VEC.  Not used
2269:     -	FFDE          			CTRL_C_TIMER	equ	0xFFDE	;Count down the CTRL-C condition
2270:     -	FFDF          			SOFT_RST_FLAG	equ	0xFFDF	;Flag a Soft Reset (F-E Keys, Single Step)
2271:										;Display/Serial Comms
2272:     -	FFE0          			LED_DISPLAY	equ	0xFFE0	;8 Bytes of LED Output bytes to Scan to hardware
2273:						;8 Bytes			;Warning, LED_DISPLAY must be nibble aligned at E0 (XXE0)
2274:     -	FFE7          			LED_ANBAR	equ	0xFFE7	;LED Annunciator Bar (Part of LED_DISPLAY Buffer)
2275:										;.0 = x7 = BEEPER
2276:										;.1 = x6 = Run Mode
2277:										;.2 = x5 = Monitor Mode (Default Mode upon Power up)
2278:										;.3 = x4 = Send Data to Output Port
2279:										;.4 = x3 = Alter Memory/Register
2280:										;.5 = x2 = Enter Memory Location
2281:										;.6 = x1 = Enter Register
2282:     -	FFE8          			KBCOLSAMPLED	equ	0xFFE8	;Columns Sampled
2283:     -	FFE9          			KBPORTSAMPLE	equ	0xFFE9	;Input Port sampled only once on each scan, saved here
2284:     -	FFEA          			KBHEXSAMPLE	equ	0xFFEA	;KEY SAMPLER Input HEX format
2285:     -	FFEB          			KEYBSCANPV	equ	0xFFEB	;KEY Input HEX format
2286:     -	FFEC          			KEYBSCANTIMER	equ	0xFFEC	;KEY Input TIMER
2287:     -	FFED          			KEY_PRES_EV	equ	0xFFED	;KEY INPUT LAST & Currently Processing
2288:     -	FFEE          			KEY_PRES_RTN	equ	0xFFEE	;KEY LAST, for Return To Normal between strokes
2289:     -	FFEF          			KEY_PRESSED	equ	0xFFEF	;(1) KEY PRESSED
2290:     -	FFF0          			TicCounter	equ	0xFFF0	;Tic Counter
2291:						;TicCounter	equ	0xFFF1	;
2292:     -	FFF2          			ECHO_STATE	equ	0xFFF2	;Echo characters
2293:     -	FFF3          			XMSEQ		equ	0xFFF3	;XMODEM SEQUENCE NUMBER
2294:     -	FFF4          			XMTYPE		equ	0xFFF4	;XMODEM BLOCK TYPE (CRC/CS)
2295:     -	FFF5          			SCAN_LED	equ	0xFFF5	;Holds the next LED output
2296:     -	FFF6          			LED_DISPLAY_SB	equ	0xFFF6	;10 Bytes FFF6=Start BIT, 7,8,9,A,B,C,D,E=Data bits, F=Stop BIT
2297:						;10 bytes	equ	0xFFFF	;Warning, LED_DISPLAY_TBL must be at this address (XXF6) Roll over to xx00 tested
2298:						;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2299:						;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2300:						;	Appendix_D	HOOK LOCATIONS
2301:						;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
2302:						;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
2303:     -	0042          					org	0x0042
2304:				;		VMAIN_MENU	JP	MAIN_MENU	;MONITOR
2305:				;		VPUT_CHAR	JP	PUT_CHAR	;PUT_CHAR
2306:				;		VGET_POS	JP	GET_POS		;Return the Position of the cursor on the line
2307:				;		VGET_CHAR	JP	GET_CHAR
2308:				;		VRX_COUNT	JP	RX_COUNT	;Count of Characters waiting in the RX Buffer
2309:				;		VIN_CHAR	JP	IN_CHAR		;Returns a char or C=1 if none.
2310:				;		VTIMED_GETCHAR	JP	TIMED_GETCHAR
2311:				;		VPRINT		JP	PRINT
2312:				;		VBEEP		JP	BEEP
2313:				;		VSET_ECHO	JP	SET_ECHO
2314:				;		VDELAY_C	JP	DELAY_C		;Loop based on C, 100mSEC
2315:				;		VDELAY_A	JP	DELAY_A		;Milli seconds based on A, requires FP board
2316:				;				org	0x006B
2317:				;		VPUT_VERSION	JP	PUT_VERSION
2318:				;		VPUT_HEX	JP	PUT_HEX
2319:				;		VPUT_BYTE	JP	PUT_BYTE
2320:				;		VPUT_BC		JP	PUT_BC
2321:				;		VPUT_DE		JP	PUT_DE
2322:				;		VPUT_HL		JP	PUT_HL
2323:				;		VPUT_SPACE	JP	PUT_SPACE
2324:				;		VPUT_NEW_LINE	JP	PUT_NEW_LINE
2325:				;		VGET_BYTE	JP	GET_BYTE
2326:				;		VGET_WORD	JP	GET_WORD	;DE
2327:				;		VGET_HEX	JP	GET_HEX
2328:				;		VCLEAR_BLOCK	JP	CLEAR_BLOCK	;CLEAR_BLOCK
2329:				;		VLD_HL_HL	JP	LD_HL_HL
2330:				;		VADD_HL_A	JP	ADD_HL_A
2331:				;		VMOV_32_HL	JP	MOV_32_HL	;Move (HL) to 32 bit register BCDE
2332:				;		VMOV_HL_32	JP	MOV_HL_32	;Move 32 bit register BCDE to (HL)
2333:				;		VADD_32_HL	JP	ADD_32_HL	;ADD (HL) to 32 bit register BCDE - (returns with HL changed to last byte)
2334:				;		VCMP_HL_32	JP	CMP_HL_32	;Compare BCDE with 32bit word at HL
2335:				;		VINC_32		JP	INC_32		;INC BCDE
2336:				;		VDEC_32		JP	DEC_32		;DEC BCDE
2337:				;		VTSTZ_32	JP	TSTZ_32		;TEST_ZERO BCDE
2338:				;		VASC2BIN	JP	ASC2BIN
2339:				;		VASC2HEX	JP	ASC2HEX
2340:				;		VHEX2ASC	JP	HEX2ASC		
2341:				;		VTO_UPPER	JP	TO_UPPER
2342:				;		VSET_IO		JP	SET_IO
2343:				;		VIC_KEY		JP	IC_KEY
2344:				;		VLED_UPDATE	JP	LED_UPDATE	;Turn ON/OFF LED UPDATE & KEY MON
2345:				;		VLED_GET_POS	JP	LED_GET_POS
2346:				;		VLED_SET_POS	JP	LED_SET_POS
2347:				;		VLED_HOME	JP	LED_HOME
2348:				;		VLED_PUT_CHAR	JP	PC_LED		;C = CHAR
2349:				;		VLED_PRINT	JP	LED_PRINT
2350:				;		VLED_PUT_BYTE	JP	LED_PUT_BYTE
2351:				;		VLED_PUT_HEX	JP	LED_PUT_HEX
2352:				;		VLED_CLEAR	JP	LED_CLEAR
2353:				;		VLED_RIGHT	JP	LED_RIGHT
2354:				;		VLED_LEFT	JP	LED_LEFT
2355:				;		VPRINT_FNAME	JP	PRINT_FILENAME
2356:				;		VINPUT_FNAME	JP	INPUT_FILENAME
2357:				;		VSD_OPEN	JP	SD_OPEN			;Copy FCB to filename then search & open
2358:				;		VSD_OPEN_FILENAME JP	SD_OPEN_FILENAME	;Copy Filename to FCB then search & open
2359:				;		VPRINT_DIR	JP	PRINT_DIR
2360:				;		VDISK_READ	JP	DISK_READ
2361:				;		VSD_READ_SEC	JP	SD_READ_SEC
2362:				;		VLINE_INPUT	JP	LINE_INPUT
2363:     -	0042          					ENd
**** zmcv15.asm ****
7086:				
7087:				
7088:				
7089:				
7090:				
7091:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7092:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7093:				;	Appendix_B	Future Use
7094:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7095:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7096:				
7097:				
7098:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7099:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7100:				;	Appendix_C	RAM. System Ram allocation
7101:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7102:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7103:				
7104:				
7105:				;                       ********      ***     **     **
7106:				;                       *********    *****    ***   ***
7107:				;                       **     **   *** ***   **** ****
7108:				;                       **     **  ***   ***  *********
7109:				;---------------------  ********   *********  ** *** **  ---------------------
7110:				;---------------------  ********   *********  ** *** **  ---------------------
7111:				;                       **  **     **     **  **     **
7112:				;                       **   **    **     **  **     **
7113:				;                       **    **   **     **  **     **
7114:				;                       **     **  **     **  **     **
7115:				
7116:     -	8000          	RAM_LDRT	equ	0x8000
7117:				
7118:				
7119:     -	FA00          			ORG	0xFA00
7120:     -	FA00          	LINE_BUFF	DS	128
7121:     -	FA80          	LINE_BUFFEND	DS	2	;Room for CR,LF if needed
7122:     -	FA82          	LI_FILESIZE	DS	4	;LINE INPUT FILE SIZE, counts down the bytes in the file as Lines are fetched
7123:     -	FA86          	LI_SDBUFF_PTR	DS	2	;Pointer to Disk Buffer for next Line Read operation
7124:     -	FA88          	LI_SDLOG_SEC	DS	2	;Logical Sector last read in Buffer
7125:				
7126:				
7127:								;Read Hex File Performance counter
7128:     -	FA8A          	RHF_LINES	DS	2	;Line counter
7129:				
7130:				
7131:				;----------------------------------------------------------------------------------------------------; RAM SPACE
7132:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7133:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7134:				;----------------------------------------------------------------------------------------------------; RAM SPACE
7135:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
7136:				;Reserve space from 0xFB00 to FB1F for Stack
7137:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
7138:     -	FB00          			ORG	0xFB00
7139:     -	FAFE          	StackTop	equ	$-2	; Stack = 0xFB00
7140:				
7141:     -	FB00          	STACKSPACE1	DS	40	;Stack space for ISR L1 calls  (Measured to only need 14 words, resv 20 words)
7142:     -	FB28          	STACK_ISR1	EQU	$	;Points to top of stack
7143:     -	FB28          	SP_ISR_SAVE	DS	2	;Space to save SP, Happens on first ISR call
7144:				
7145:				
7146:     -	FB2A          	HRAM_CODE	DS	ROM_CODE_LEN	;Code for Returning from ISR (may need to switch to RAM, so it must be here in High RAM)
7147:				
7148:     -	FB2A          	ISR_DISPATCH	EQU	HRAM_CODE
7149:     -	FB3B          	ISR_RET		EQU	ISR_RET_OFF+HRAM_CODE ;Assign address in the HIGH RAM
7150:     -	FB45          	GET_MEM		EQU	GET_MEM_OFF+HRAM_CODE ;Assign address in the HIGH RAM	
7151:				
7152:				
7153:     -	FB53          	HR_EXE_GO	DS	HR_EXEC_GS_LEN	;Routine for Switching to RAM and Executing loaded program.
7154:				
7155:     -	FB5B          	HERE1		EQU	$
7156:				
7157:     -	0000          		IF HERE1 > 0xFB80
7158:					   ERROR RAM OVERLAP AT 0xFB80
7159:					ENDIF
7160:					
7161:					;FREE RAM 25 BYTES
7162:				
7163:     -	FB80          			ORG	0xFB80
7164:				;SDFCB:
7165:     -	0000          	FSTAT		EQU	0	;DS  1	;+0  Status of FCB, 00=File Not Open, 01=File Opened, 80=EOF (Line_Input)
7166:     -	0001          	FNAME		EQU	1	;DS 11	;+1  File name
7167:     -	000C          	AFClus0		EQU	12	;DS  2	;+12 First Cluster of File as given by the Directory Entry.
7168:     -	000E          	CRFClus		EQU	14	;DS  2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
7169:     -	0010          	CAFClus		EQU	16	;DS  2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
7170:     -	0012          	RFSec		EQU	18	;DS  2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
7171:     -	0014          	SSOC		EQU	20	;DS  4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
7172:     -	0018          	ABS_SEC		EQU	24	;DS  4	;+24 Absolute Sector of Current Relative Sector
7173:     -	001C          	FSIZE		EQU	28	;DS  4	;+28 File Size of file (not used, just kept for completness)
7174:				
7175:				;Warning: FCB's must never cross page boundaries.
7176:     -	FB80          	SDISKA		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
7177:     -	FBA0          	SDISKB		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
7178:     -	FBC0          	SDISKC		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
7179:     -	FBE0          	SDISKD		DS	32	;File Control Block	;No FCB must cross a page boundary (simple 8 bit addition used for offseting into struct.)
7180:				
7181:				;
7182:				;  ********   **     **  *********  *********  *********  ******** 
7183:				;  *********  **     **  *********  *********  *********  *********
7184:				;  **     **  **     **  **         **         **         **     **
7185:				;  **     **  **     **  **         **         **         **     **
7186:				;  ********   **     **  *******    *******    *******    ******** 
7187:				;  ********   **     **  *******    *******    *******    ******** 
7188:				;  **     **  **     **  **         **         **         **  **   
7189:				;  **     **  **     **  **         **         **         **   **  
7190:				;  *********  *********  **         **         *********  **    ** 
7191:				;  ********    *******   **         **         *********  **     **
7192:				;
7193:     -	FC00          			ORG	0xFC00
7194:     -	FC00          	SD_RAM_BUFFER	DS	512	;FC00-FDFF 512 bytes of SD Sector Buffer space
7195:				
7196:     -	FE00          	RXBUFFER	DS	256	;FExx      256 bytes of RX Buffer space
7197:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
7198:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
7199:				;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
7200:				
7201:				
7202:     -	FF00          			ORG	0xFF00
7203:     -	FF00          	BIT_TABLE	DS	8
7204:				
7205:				;Warning: FCB's must never cross page boundaries.
7206:     -	FF08          	FCB_PTR		DS	2	;Pointer to Current FCB
7207:				
7208:				
7209:     -	FF0A          	FAT_CLEAR	EQU	$	;Clear bytes of RAM after this point on FAT_INIT
7210:     -	FF0A          	GH_START	DS	2	;HEX File, start address
7211:     -	FF0C          	VIEW_FLAGS	DS	1	;View File Load;  File Open View
7212:								;BIT .0=View HEX Load, display file while reading HEX file
7213:								;    .1=GH_START Address has been set
7214:								;    .6=View FILE SIZE during File Open
7215:								;    .7=View File Name & Found or Not status durin File Open
7216:				
7217:     -	FF0D          	LOGICAL_SEC	DS	2	;Logical Sector for next Read Operation (Input paramater for the File Read)
7218:				
7219:     -	FF0F          	DIRTY_DATA	DS	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
7220:     -	FF10          	SD_CARD_TYPE	DS	1	;SD CARD TYPE
7221:     -	FF11          	SDC_STATUS	DS	1	;SD Status Code returned
7222:     -	FF12          	SD_PARAM	DS	4	;32 bit address parameter for SD Commands
7223:     -	FF16          	SD_PART_TYPE	DS	1	;SD PARTITION TYPE
7224:     -	FF17          	SD_PART_BASE	DS	4	;SD PARTITION STARTING RECORD
7225:     -	FF1B          	SD_PART_SIZE	DS	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
7226:     -	FF1F          	BYTE_P_SEC	DS	2	;0x0B Bytes per Sector (Almost always 512)
7227:     -	FF21          	SEC_PER_CLUS	DS	1	;0x0D
7228:     -	FF22          	RESERVED_SEC	DS	2	;0x0E - 0x0F
7229:     -	FF24          	FAT_COPIES	DS	1	;0x10
7230:     -	FF25          	ROOTDIR_SIZE	DS	2	;0x11 - 0x12
7231:     -	FF27          	FILESYS_SEC	DS	4	;0x13 - 0x14 or 0x20 - 0x23
7232:     -	FF2B          	HIDDEN_SEC	DS	4	;0x1C - 0x1F
7233:     -	FF2F          	SEC_PER_FAT	DS	2	;0x16 - 0x17
7234:     -	FF31          	FAT1START	DS	4	;Calculated Sector to FAT1
7235:     -	FF35          	DIR_SECTOR	DS	4	;Calculated Sector to Root Directory
7236:     -	FF39          	DATASTART	DS	4	;Calculated Sector to Data Area
7237:     -	FF3D          	SEC_PTR		DS	4	;Sector Pointer, general use variable that holds the last sector read
7238:     -	FF41          	ENT_COUNT	DS	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
7239:     -	0039          	FAT_CLR_LEN	EQU	$ - FAT_CLEAR 
7240:     -	FF43          	FILENAME	DS	8	;File Name
7241:     -	FF4B          	FILEEXT		DS	3	;File Extension
7242:     -	FF4E          	FILESIZE	DS	4	;File Size
7243:				
7244:				
7245:     -	FF52          	DIVIDE_FUNC	DS	2	;Pointer to the Divide Function
7246:     -	FF54          	DF_SHIFTCNT	DS	1	;Count of shifts required for Fast Divide
7247:     -	FF55          	MUL8		DS	1	;8 bit multiplier
7248:     -	FF56          	MOD_FUNC	DS	2	;Pointer to the Mod Function
7249:     -	FF58          	MODMASK		DS	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector
7250:				
7251:     -	FF59          	IK_HEXL		DS	1	;IMON HEX INPUT
7252:     -	FF5A          	IK_HEXH		DS	1	;IMON HEX INPUT
7253:     -	FF5B          	HEX_SOURCE	DS	2	;Pointer to the HEX INPUT Source (FILE or Serial Port)
7254:				
7255:     -	0000          		IF $ >= 0xFF78
7256:					   ERROR RAM ALLOCATION ERROR
7257:					ENDIF
7258:				
7259:				;*** BEGIN COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
7260:     -	FF78          	RAMSIGNATURE	equ	0xFF78	;RAM signature
7261:								;Following bytes are cleared on COLD BOOT
7262:     -	FF80          	RC_TYPE		equ	0xFF80	;(1) Type of Reset (WARNING, Next 7 RC counters must end with lsb bits = 001,010,011,100,101,110,111)
7263:     -	FF81          	RC_SOFT		equ	0xFF81	;(1) Count of Resets by SOFT F-E SWITCH
7264:     -	FF82          	RC_STEP		equ	0xFF82	;(1) Count of Resets by SINGLE STEP
7265:     -	FF83          	RC_CC		equ	0xFF83	;(1) Count of Resets by CTRL-C
7266:     -	FF84          	RC_HALT		equ	0xFF84	;(1) Count of Resets by HALT INSTRUCTION
7267:     -	FF85          	RC_F0		equ	0xFF85	;(1) Count of Resets by pressing F & 0 keys
7268:     -	FF86          	RC_RST0		equ	0xFF86	;(1) Count of Resets by RST 0 INSTRUCTION
7269:     -	FF87          	RC_HARD		equ	0xFF87	;(1) Count of Resets by UNKNOWN RESET LINE
7270:				
7271:     -	FF88          	ABUSS		equ	0xFF88	;(2) 
7272:     -	FF8A          	RegPtr		equ	0xFF8A	;(1) Ptr to Registers
7273:     -	FF8B          	IoPtr		equ	0xFF8B	;(1)  I/O Ptr
7274:     -	FF8C          	RX_ERR_LDRT	equ	0xFF8C	;(1) Counts False Start Bits (Noise Flag)
7275:     -	FF8D          	RX_ERR_STOP	equ	0xFF8D	;(1) Counts Missing Stop Bits (Framing Error)
7276:     -	FF8E          	RX_ERR_OVR	equ	0xFF8E	;(1) Counts Overrun Errors
7277:				
7278:     -	000F          	CS_CLR_LEN	equ	0xFF8F-RC_TYPE
7279:				
7280:     -	FF8F          	ACE_BAUD	equ	0xFF8F	;(1) Baudrate of ACE, 12=9600
7281:				
7282:								;PUTCHAR_EXE and INCHAR_EXE *must be consecutive in this order*
7283:     -	FF90          	PUTCHAR_EXE	equ	0xFF90	;(2) PutChar Execution (Set for PC_LED, PC_BIT, PC_ACE or PC_BOTH)
7284:     -	FF92          	INCHAR_EXE	equ	0xFF92	;(2) InChar Execution (Set for IN_KEY, IN_BIT, IN_ACE or IN_BOTH)
7285:				;*** END COLD_BOOT_INIT (RAM that is to be initialized upon COLD BOOT) ***
7286:				
7287:     -	FF94          	HW_SETIO	equ	0xFF94	;Serial IO selected, 01=Bit, 02=ACE, 03=BIT & ACE
7288:     -	FF95          	HW_LIST		equ	0xFF95	;Hardware List, 00=NO Boards, 01=FP Only, 02=SIO only, 03=FP & SIO
7289:				
7290:								;Saved Registers
7291:     -	FF96          	RSSP		equ	0xFF96	;Value of SP upon REGISTER SAVE
7292:     -	FF98          	RSAF		equ	0xFF98	;Value of AF upon REGISTER SAVE
7293:     -	FF9A          	RSBC		equ	0xFF9A	;Value of BC upon REGISTER SAVE
7294:     -	FF9C          	RSDE		equ	0xFF9C	;Value of DE upon REGISTER SAVE
7295:     -	FF9E          	RSHL		equ	0xFF9E	;Value of HL upon REGISTER SAVE
7296:     -	FFA0          	RPC		equ	0xFFA0	;Value of PC upon REGISTER SAVE
7297:     -	FFA2          	RSIX		equ	0xFFA2	;Value of IX upon REGISTER SAVE
7298:     -	FFA4          	RSIY		equ	0xFFA4	;Value of IY upon REGISTER SAVE
7299:     -	FFA6          	RSIR		equ	0xFFA6	;Value of IR upon REGISTER SAVE
7300:     -	FFA8          	RSAF2		equ	0xFFA8	;Value of AF' upon REGISTER SAVE
7301:     -	FFAA          	RSBC2		equ	0xFFAA	;Value of BC' upon REGISTER SAVE
7302:     -	FFAC          	RSDE2		equ	0xFFAC	;Value of DE' upon REGISTER SAVE
7303:     -	FFAE          	RSHL2		equ	0xFFAE	;Value of HL' upon REGISTER SAVE
7304:				
7305:     -	FFB0          	UiVec		equ	0xFFB0	;(2) User Interrupt Vector
7306:				
7307:				
7308:				;*** BEGIN WARM_BOOT_INIT (RAM that is to be initialized on every boot) ***
7309:								;WARNING, Following 34 bytes must be consecutive in this order for Block Write
7310:     -	FFB2          	BEEP_TO		equ	0xFFB2	;(1) Count down the beep (beep duration)
7311:     -	FFB3          	ANBAR_DEF	equ	0xFFB3	;(1) Base setting for the Annunciator LED's (after current function times out)
7312:     -	FFB4          	GET_REG		equ	0xFFB4	;(2) Get Reg Routine (in monitor mode, registers fetched from RAM)
7313:     -	FFB6          	PUT_REG		equ	0xFFB6	;(2) Put Reg Routine
7314:     -	FFB8          	CTRL_C_CHK	equ	0xFFB8	;(2) Vector for CTRL-C Checking
7315:     -	FFBA          	LDISPMODE	equ	0xFFBA	;(2) Last Display Mode (Holds DISPMODE while in HEX Entry)
7316:     -	FFBC          	DISPMODE	equ	0xFFBC	;(2) Display Routine
7317:     -	FFBE          	KEY_EVENT	equ	0xFFBE	;(2) Routine to call upon Key Press (changes based on user actions, see KEY_EVENT_DISPATCH)
7318:     -	FFC0          	IK_TIMER	equ	0xFFC0	;(1) IMON TIMEOUT
7319:     -	FFC1          	KEYBFMODE	equ	0xFFC1	;(1) KEY INPUT MODE. 8F=HEX INPUT, 90=Shiftable
7320:     -	FFC2          	DISPLABEL	equ	0xFFC2	;(1) Display Label Refresh
7321:     -	FFC3          	IK_HEXST	equ	0xFFC3	;(1) IMON HEX Input State
7322:     -	FFC4          	HEX_CURSOR	equ	0xFFC4	;(2) HEX Input Cursor location
7323:     -	FFC6          	HEX_READY	equ	0xFFC6	;(2) HEX Input Ready
7324:     -	FFC8          	LED_CURSOR	equ	0xFFC8	;(2) Cursor location for LED Put_Char
7325:     -	FFCA          	RXBHEAD		equ	0xFFCA	;(2) RS-232 RX BUFFER HEAD
7326:     -	FFCC          	RXBTAIL		equ	0xFFCC	;(2) RS-232 RX BUFFER TAIL
7327:     -	FFCE          	INT_VEC		equ	0xFFCE	;(2) Vector to Interrupt ISR
7328:     -	FFD0          	SCAN_PTR	equ	0xFFD0	;(2) SCAN_PTR points to next LED_DISPLAY byte to output (will always be 1 more
7329:								;    than the current hardware column because hardware automatically advances)
7330:     -	FFD2          	HALT_TEST	equ	0xFFD2	;(2) HALT_TEST
7331:				;*** END WARM_BOOT_INIT (RAM BLOCK that is to be initialized on every boot) ***
7332:				
7333:				
7334:     -	FFD4          	CLEARED_SPACE	equ	0xFFD4	;Bytes here and later are cleared upon init (some initialized seperately)
7335:     -	002C          	CLEARED_LEN	equ	0xFFFF - CLEARED_SPACE + 1
7336:				
7337:     -	FFD4          	SDISPMODE	equ	0xFFD4	;(2)
7338:     -	FFD6          	POS_BIT		equ	0xFFD6	;(1) BIT Bang RS232 Character position
7339:     -	FFD7          	POS_ACE		equ	0xFFD7	;(1) ACE RS232 Character position
7340:     -	FFD8          	ISR_FLAGS	equ	0xFFD8	;(1) Indicates how many levels the ISR has nested
7341:     -	FFD9          	RRSTATE		equ	0xFFD9	;(1) RAM/ROM SELECT STATE (FOR RETURN FROM ISR)	
7342:     -	FFDA          	XTIMER_TIC	equ	0xFFDA	;(1) Counts Down tics until Extended Timer ISR_EXXTIMER
7343:     -	FFDB          	READ_RAMROM	equ	0xFFDB	;(1) Selected RAMROM for Monitor READ Operations.  Bit0 for RAM/ROM, Bits1-4 for Bank
7344:				
7345:     -	FFDC          	NMI_VEC		equ	0xFFDC	;(2) NMI VEC.  Not used
7346:				
7347:     -	FFDE          	CTRL_C_TIMER	equ	0xFFDE	;Count down the CTRL-C condition
7348:     -	FFDF          	SOFT_RST_FLAG	equ	0xFFDF	;Flag a Soft Reset (F-E Keys, Single Step)
7349:				
7350:								;Display/Serial Comms
7351:     -	FFE0          	LED_DISPLAY	equ	0xFFE0	;8 Bytes of LED Output bytes to Scan to hardware
7352:				;8 Bytes			;Warning, LED_DISPLAY must be nibble aligned at E0 (XXE0)
7353:     -	FFE7          	LED_ANBAR	equ	0xFFE7	;LED Annunciator Bar (Part of LED_DISPLAY Buffer)
7354:								;.0 = x7 = BEEPER
7355:								;.1 = x6 = Run Mode
7356:								;.2 = x5 = Monitor Mode (Default Mode upon Power up)
7357:								;.3 = x4 = Send Data to Output Port
7358:								;.4 = x3 = Alter Memory/Register
7359:								;.5 = x2 = Enter Memory Location
7360:								;.6 = x1 = Enter Register
7361:				
7362:     -	FFE8          	KBCOLSAMPLED	equ	0xFFE8	;Columns Sampled
7363:     -	FFE9          	KBPORTSAMPLE	equ	0xFFE9	;Input Port sampled only once on each scan, saved here
7364:     -	FFEA          	KBHEXSAMPLE	equ	0xFFEA	;KEY SAMPLER Input HEX format
7365:     -	FFEB          	KEYBSCANPV	equ	0xFFEB	;KEY Input HEX format
7366:     -	FFEC          	KEYBSCANTIMER	equ	0xFFEC	;KEY Input TIMER
7367:     -	FFED          	KEY_PRES_EV	equ	0xFFED	;KEY INPUT LAST & Currently Processing
7368:     -	FFEE          	KEY_PRES_RTN	equ	0xFFEE	;KEY LAST, for Return To Normal between strokes
7369:     -	FFEF          	KEY_PRESSED	equ	0xFFEF	;(1) KEY PRESSED
7370:				
7371:     -	FFF0          	TicCounter	equ	0xFFF0	;Tic Counter
7372:				;TicCounter	equ	0xFFF1	;
7373:     -	FFF2          	ECHO_STATE	equ	0xFFF2	;Echo characters
7374:     -	FFF3          	XMSEQ		equ	0xFFF3	;XMODEM SEQUENCE NUMBER
7375:     -	FFF4          	XMTYPE		equ	0xFFF4	;XMODEM BLOCK TYPE (CRC/CS)
7376:     -	FFF5          	SCAN_LED	equ	0xFFF5	;Holds the next LED output
7377:     -	FFF6          	LED_DISPLAY_SB	equ	0xFFF6	;10 Bytes FFF6=Start BIT, 7,8,9,A,B,C,D,E=Data bits, F=Stop BIT
7378:				;10 bytes	equ	0xFFFF	;Warning, LED_DISPLAY_TBL must be at this address (XXF6) Roll over to xx00 tested
7379:				
7380:				
7381:				
7382:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7383:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7384:				;	Appendix_D	HOOK LOCATIONS
7385:				;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
7386:				;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
7387:				
7388:     -	0042          			org	0x0042
7389:49938+10	0042  C3E203  	VMAIN_MENU	JP	MAIN_MENU	;MONITOR
7390:49948+10	0045  C3EC13  	VPUT_CHAR	JP	PUT_CHAR	;PUT_CHAR
7391:49958+10	0048  C3CD13  	VGET_POS	JP	GET_POS		;Return the Position of the cursor on the line
7392:49968+10	004B  C3E013  	VGET_CHAR	JP	GET_CHAR
7393:49978+10	004E  C30814  	VRX_COUNT	JP	RX_COUNT	;Count of Characters waiting in the RX Buffer
7394:49988+10	0051  C32114  	VIN_CHAR	JP	IN_CHAR		;Returns a char or C=1 if none.
7395:49998+10	0054  C34B14  	VTIMED_GETCHAR	JP	TIMED_GETCHAR
7396:50008+10	0057  C3BD0D  	VPRINT		JP	PRINT
7397:50018+10	005A  C3D127  	VBEEP		JP	BEEP
7398:				
7399:50028+10	005D  C3D527  	VSET_ECHO	JP	SET_ECHO
7400:50038+10	0060  C32C0E  	VDELAY_C	JP	DELAY_C		;Loop based on C, 100mSEC
7401:50048+10	0063  C33A0E  	VDELAY_A	JP	DELAY_A		;Milli seconds based on A, requires FP board
7402:				
7403:     -	006B          			org	0x006B
7404:50058+10	006B  C39B08  	VPUT_VERSION	JP	PUT_VERSION
7405:50068+10	006E  C3090E  	VPUT_HEX	JP	PUT_HEX
7406:50078+10	0071  C3F60D  	VPUT_BYTE	JP	PUT_BYTE
7407:50088+10	0074  C3D80D  	VPUT_BC		JP	PUT_BC
7408:50098+10	0077  C3E10D  	VPUT_DE		JP	PUT_DE
7409:50108+10	007A  C3EA0D  	VPUT_HL		JP	PUT_HL
7410:50118+10	007D  C3190E  	VPUT_SPACE	JP	PUT_SPACE
7411:50128+10	0080  C31F0E  	VPUT_NEW_LINE	JP	PUT_NEW_LINE
7412:				
7413:50138+10	0083  C34C0D  	VGET_BYTE	JP	GET_BYTE
7414:50148+10	0086  C3790D  	VGET_WORD	JP	GET_WORD	;DE
7415:50158+10	0089  C3950D  	VGET_HEX	JP	GET_HEX
7416:				
7417:50168+10	008C  C3100C  	VCLEAR_BLOCK	JP	CLEAR_BLOCK	;CLEAR_BLOCK
7418:50178+10	008F  C34A0E  	VLD_HL_HL	JP	LD_HL_HL
7419:50188+10	0092  C3450E  	VADD_HL_A	JP	ADD_HL_A
7420:50198+10	0095  C33E27  	VMOV_32_HL	JP	MOV_32_HL	;Move (HL) to 32 bit register BCDE
7421:50208+10	0098  C34927  	VMOV_HL_32	JP	MOV_HL_32	;Move 32 bit register BCDE to (HL)
7422:50218+10	009B  C35427  	VADD_32_HL	JP	ADD_32_HL	;ADD (HL) to 32 bit register BCDE - (returns with HL changed to last byte)
7423:50228+10	009E  C37827  	VCMP_HL_32	JP	CMP_HL_32	;Compare BCDE with 32bit word at HL
7424:50238+10	00A1  C36527  	VINC_32		JP	INC_32		;INC BCDE
7425:50248+10	00A4  C36B27  	VDEC_32		JP	DEC_32		;DEC BCDE
7426:50258+10	00A7  C37327  	VTSTZ_32	JP	TSTZ_32		;TEST_ZERO BCDE
7427:				
7428:50268+10	00AA  C3C227  	VASC2BIN	JP	ASC2BIN
7429:50278+10	00AD  C3980D  	VASC2HEX	JP	ASC2HEX
7430:50288+10	00B0  C30F0E  	VHEX2ASC	JP	HEX2ASC		
7431:50298+10	00B3  C3B227  	VTO_UPPER	JP	TO_UPPER
7432:				
7433:50308+10	00B6  C38613  	VSET_IO		JP	SET_IO
7434:50318+10	00B9  C3BA14  	VIC_KEY		JP	IC_KEY
7435:50328+10	00BC  C3D927  	VLED_UPDATE	JP	LED_UPDATE	;Turn ON/OFF LED UPDATE & KEY MON
7436:				
7437:50338+10	00BF  C3E927  	VLED_GET_POS	JP	LED_GET_POS
7438:50348+10	00C2  C3EF27  	VLED_SET_POS	JP	LED_SET_POS
7439:50358+10	00C5  C37714  	VLED_HOME	JP	LED_HOME
7440:50368+10	00C8  C38A14  	VLED_PUT_CHAR	JP	PC_LED		;C = CHAR
7441:50378+10	00CB  C3781C  	VLED_PRINT	JP	LED_PRINT
7442:50388+10	00CE  C3601C  	VLED_PUT_BYTE	JP	LED_PUT_BYTE
7443:50398+10	00D1  C36C1C  	VLED_PUT_HEX	JP	LED_PUT_HEX
7444:50408+10	00D4  C38014  	VLED_CLEAR	JP	LED_CLEAR
7445:50418+10	00D7  C3F727  	VLED_RIGHT	JP	LED_RIGHT
7446:50428+10	00DA  C30C28  	VLED_LEFT	JP	LED_LEFT
7447:				
7448:50438+10	00DD  C30521  	VPRINT_FNAME	JP	PRINT_FILENAME
7449:50448+10	00E0  C32A21  	VINPUT_FNAME	JP	INPUT_FILENAME
7450:50458+10	00E3  C3B61D  	VSD_OPEN	JP	SD_OPEN			;Copy FCB to filename then search & open
7451:50468+10	00E6  C3A91D  	VSD_OPEN_FILENAME JP	SD_OPEN_FILENAME	;Copy Filename to FCB then search & open
7452:50478+10	00E9  C35E1D  	VPRINT_DIR	JP	PRINT_DIR
7453:50488+10	00EC  C38821  	VDISK_READ	JP	DISK_READ
7454:50498+10	00EF  C39624  	VSD_READ_SEC	JP	SD_READ_SEC
7455:50508+10	00F2  C3281E  	VLINE_INPUT	JP	LINE_INPUT
7456:				
7457:     -	0000          			END	0



Statistics:

     4	passes
     0	jr promotions
  1170	symbols
 13526	bytes



Symbol Table:

ABF1            27C6      10182
ABFND           2B86      11142
ABF_GOODHEX     27CB      10187
ABORT_CHECK     1370      4976
ABS_SEC        =18        24
ABUSS          =FF88      65416
ACE_BAUD       =FF8F      65423
ACE_BAUD0      =C8        200
ACE_BAUD1      =C9        201
ACE_DATA       =C8        200
ACE_LCR        =CB        203
ACE_MSR        =CE        206
ACE_OUT        =CC        204
ACE_RESET      =C7        199
ACE_SCRATCH    =CF        207
ACE_SET_BAUD    14F6      5366
ACE_STATUS     =CD        205
ACK            =06        6
ADD             31E0      12768
ADD_32_HL       2754      10068
ADD_HL_A         E45      3653
AFClus0        =0C        12
ALOOK           2F89      12169
ANBAR_DEF      =FFB3      65459
ARYL            31BF      12735
ARYLOC         =81FD      33277
ASC2BIN         27C2      10178
ASC2HEX          D98      3480
ASST            32C8      13000
ASTOR           32EB      13035
AUTO_BOOT_DO     39B      923
AUTO_BOOT_GO     3C1      961
AUTO_BOOT_LP     3B6      950
AUTO_BOOT_MENU   391      913
BADLIN          2D68      11624
BADLN           2ACD      10957
BASIC           2A00      10752
BEEP            27D1      10193
BEEP_TO        =FFB2      65458
BEXIT          =42        66
BGETCHR         34ED      13549
BINCHR         =51        81
BITS_Q2        =C2        194
BITS_Q3        =C3        195
BIT_MARCH       1248      4680
BIT_TABLE       FF00      65280
BOOT_SDVIEW     1D3B      7483
BPRINT          2E8D      11917
BPUTCHR        =45        69
BPUTNL         =80        128
BPUTSP         =7D        125
BRKTS           31B9      12729
BUFF           =8000      32768
BYTEMARCH2      11DB      4571
BYTE_P_SEC      FF1F      65311
CAFClus        =10        16
CALN            3175      12661
CALS            2CDA      11482
CAN            =18        24
CDAT            3037      12343
CEIL            327B      12923
CEXP            33CC      13260
CG1             33D2      13266
CH3_R1          278D      10125
CH3_R2          278E      10126
CH3_R3          278F      10127
CHAR            30FC      12540
CHK_RESET        194      404
CHR             34E3      13539
CINDX           34C3      13507
CL2             34A8      13480
CLBF            34A3      13475
CLEAR           2CAF      11439
CLEARED_LEN    =2C        44
CLEARED_SPACE  =FFD4      65492
CLEAR_BLOCK      C10      3088
CLEAR_LINE_BUFF 1EBA      7866
CLRARY          2CCD      11469
CMD             2A4E      10830
CMD1            2A65      10853
CMDL            2A52      10834
CMPF_RETFAIL    217D      8573
CMP_DE_HL       2791      10129
CMP_FILENAME    2163      8547
CMP_HL_32       2778      10104
CMP_STRING      2180      8576
COLD_START       1A5      421
COMA            308B      12427
COMP            3265      12901
COMSTR          3459      13401
CPYL            32A0      12960
CP_HL_DE         B0B      2827
CQ              33F7      13303
CR             =0D        13
CRC_UPC         10FB      4347
CRC_UPDATE      10D6      4310
CRFClus        =0E        14
CS             =81FA      33274
CSAV            2FDA      12250
CSP            =81FB      33275
CSTK            35C1      13761
CS_CLR_LEN     =0F        15
CTRLC           34E7      13543
CTRL_C_CHK     =FFB8      65464
CTRL_C_CHK_OFF  1835      6197
CTRL_C_CHK_ON   182E      6190
CTRL_C_IN_Q     1825      6181
CTRL_C_RET      17B2      6066
CTRL_C_TEST     1817      6167
CTRL_C_TIMER   =FFDE      65502
CURSOR         =80FB      33019
CV              33E7      13287
CVL1            2CC6      11462
CVLP            2CB9      11449
DAT1            307E      12414
DATA           =8238      33336
DATASTART       FF39      65337
DATCMD          3517      13591
DBS_LP          2730      10032
DC1            =11        17
DC3            =13        19
DCLB            31CC      12748
DD_NEXT         1DA4      7588
DD_TAB_LP       1D97      7575
DECP1           2EB7      11959
DECPRT          2EB2      11954
DEC_32          276B      10091
DEC_32NB        2771      10097
DEL             2BB6      11190
DELAY_100mS      E2A      3626
DELAY_A          E3A      3642
DELAY_C          E2C      3628
DELAY_LP         E2F      3631
DELETE         =7F        127
DELLP           2BBF      11199
DELNX           2BBA      11194
DER             359F      13727
DERR            3019      12313
DF_SHIFTCNT     FF54      65364
DGC_DOT         1440      5184
DGC_RET         1447      5191
DIM             2F3E      12094
DIM0            2F42      12098
DIMERR          2FAF      12207
DIRTY_DATA      FF0F      65295
DIR_SECTOR      FF35      65333
DISK_READ       2188      8584
DISPLABEL      =FFC2      65474
DISPMODE       =FFBC      65468
DISP_RRBANK      87A      2170
DIV             3213      12819
DIV16BY8        2717      10007
DIV16BY8SPC     2714      10004
DIV16BY8_LP     271D      10013
DIV16BY8_SK     2726      10022
DIVBYSHIFT      272C      10028
DIVBYT          3237      12855
DIVIDE_FUNC     FF52      65362
DIVTOP          323B      12859
DIVZE           325F      12895
DLE            =10        16
DLOOP           2F5C      12124
DL_P1E           AD4      2772
DL_P1L           AC1      2753
DL_P2            ADC      2780
DL_P2K1          AF8      2808
DL_P2K2          AFE      2814
DL_P2L           AEF      2799
DL_PSE2          AED      2797
DL_PSL2          AE3      2787
DMULT           31F4      12788
DODIV           3229      12841
DOEXP           313E      12606
DOT_GETCHAR     1432      5170
DO_DIR          1D4A      7498
DO_HALT_TEST    16EC      5868
DRR_ROM          892      2194
DRSS_LP         2288      8840
DRSS_SHIFT      2290      8848
DRS_0           224F      8783
DR_1            21B3      8627
DR_BIGGER_CLUS  21F9      8697
DR_DIFF_CLUS    21F0      8688
DR_NEW_SEC      21D0      8656
DR_READ_IT      22D5      8917
DR_SAME_CLUS    22B2      8882
DR_SEEK_1       223B      8763
DR_SEEK_DONE    2269      8809
DR_SEEK_FAT     2201      8705
DR_SEEK_LP      2204      8708
DTXT            35F1      13809
DUMP_LINE        AAA      2730
DlyLp            E3F      3647
ECHO_STATE     =FFF2      65522
EDBUF          =8100      33024
EDIT            2BAF      11183
EFLAG          =8237      33335
EG1             333A      13114
EGO             3343      13123
EGO1            314F      12623
EGO2            339C      13212
EGOF0           336E      13166
EGOF1           336D      13165
EGOF2           336C      13164
EGOP1           3373      13171
EGZ             3340      13120
ELOOP           2B9E      11166
EM              363D      13885
ENDAT           306B      12395
ENDIT          =364D      13901
ENOP            32C3      12995
ENT_COUNT       FF41      65345
EOF             2C4E      11342
EOS            =00        0
EOT            =04        4
EQUAL           3305      13061
ERR             2A80      10880
ESP1            30EE      12526
ETOP            30DF      12511
EVAL            30DA      12506
EXEC_RAM_2F8     185      389
EXPR            3135      12597
FAT1START       FF31      65329
FAT_CLEAR      =FF0A      65290
FAT_CLR_LEN    =39        57
FAT_COPIES      FF24      65316
FB_LP            C17      3095
FCB_PTR         FF08      65288
FE              33A0      13216
FILBUF          34DB      13531
FILEEXT         FF4B      65355
FILENAME        FF43      65347
FILESIZE        FF4E      65358
FILESYS_SEC     FF27      65319
FILL_BLOCK       C16      3094
FILL_BT          146      326
FINTO           2D84      11652
FIXIT           2AB4      10932
FLOR            326B      12907
FNAME          =01        1
FNDLIN          2C19      11289
FOR             2D7B      11643
FSIZE          =1C        28
FSOL            2AA2      10914
FSTAT          =00        0
FTHEN           2E1B      11803
GADV            2B49      11081
GB_1             D57      3415
GB_2             D6B      3435
GB_RET           D73      3443
GB_RET1          D6E      3438
GCHR            2F0C      12044
GDEND           308C      12428
GEQL            3313      13075
GETDAT          305D      12381
GETEOF          30BB      12475
GETHEXFILE       E4F      3663
GETHX           3196      12694
GETLN           2B9B      11163
GET_BYTE         D4C      3404
GET_CHAR        13E0      5088
GET_CHAR_LP     13E6      5094
GET_CHAR_NE     13DA      5082
GET_CONTINUE     A82      2690
GET_DISPMODE    1AA9      6825
GET_HEX          D95      3477
GET_MEM        =FB45      64325
GET_MEM_OFF    =1B        27
GET_POS         13CD      5069
GET_REG        =FFB4      65460
GET_REGISTER     C6D      3181
GET_REGNAME      C2E      3118
GET_REG_MON      C71      3185
GET_REG_RUN      C7C      3196
GET_STRING      2797      10135
GET_WORD         D79      3449
GE_STACKFAIL     BDB      3035
GF0             2B6D      11117
GF1             2B6C      11116
GF2             2B79      11129
GF3             2B7A      11130
GFIND           2B67      11111
GHC_ARET         DB8      3512
GHC_NOT_RET      DB6      3510
GHC_NRET         DBA      3514
GHENDTO          EA8      3752
GH_EXEC         2032      8242
GH_EXEC_GO      2059      8281
GH_EXEC_GO2     205C      8284
GH_START        FF0A      65290
GIN1            2B95      11157
GINST           2B8A      11146
GLINE           2AD0      10960
GLPD            2D53      11603
GLPO            2D4B      11595
GLPX            30C0      12480
GO              2C89      11401
GOSUB           2D3B      11579
GOTCMD          2A6F      10863
GOTDEF          2A6E      10862
GOTO            2D43      11587
GO_BASIC        2A00      10752
GO_EXEC          B71      2929
GO_EXEC_T        B60      2912
GO_SD_CARD      1C93      7315
GO_SINGLE       1A40      6720
GREEN_LED      =C6        198
GRR_SUB          CC1      3265
GRR_SUB_AF       CC7      3271
GRR_SUB_AFA      CF3      3315
GRR_SUB_BC       CCF      3279
GRR_SUB_BCA      CF8      3320
GRR_SUB_DE       CD2      3282
GRR_SUB_DEA      CFD      3325
GRR_SUB_HL       CD5      3285
GRR_SUB_HLA      D02      3330
GRR_SUB_IR       CEC      3308
GRR_SUB_IX       CE4      3300
GRR_SUB_IY       CE8      3304
GRR_SUB_PC       CDD      3293
GRR_TBL          CA1      3233
GRTR            32A4      12964
GRUB            2B58      11096
GSC_INIT        1C94      7316
GS_ESC          10C5      4293
GS_OK           1A6E      6766
GS_SEQ          10C8      4296
GW_LP            D87      3463
HALT_TEST      =FFD2      65490
HERE1          =FB5B      64347
HEX2ABUSS       1920      6432
HEX2ASC          E0F      3599
HEX2IN_Ptr      1978      6520
HEX2MEM         1984      6532
HEX2OUT_PORT    198F      6543
HEX2OUT_Ptr     197E      6526
HEX2REG         1929      6441
HEXGO           3191      12689
HEXVL           317B      12667
HEX_CURSOR     =FFC4      65476
HEX_READY      =FFC6      65478
HEX_SOURCE      FF5B      65371
HGON            31B0      12720
HIDDEN_SEC      FF2B      65323
HISG            31AB      12715
HPOUT           2C57      11351
HRAM_CODE       FB2A      64298
HR_EXEC_GO_SUB  2083      8323
HR_EXEC_GS_LEN =08        8
HR_EXE_GO       FB53      64339
HW_LIST        =FF95      65429
HW_SETIO       =FF94      65428
ICMA_IO         1ACF      6863
ICMA_REG        1AC8      6856
ICMB_IO         1AFA      6906
ICMB_REG        1AE9      6889
ICMD0           1897      6295
ICMD0_R         1AEC      6892
ICMD1           199B      6555
ICMD2           199B      6555
ICMD3           199B      6555
ICMD4           199B      6555
ICMD4_EXEC      184F      6223
ICMD5           199B      6555
ICMD6           19B8      6584
ICMD7           1A30      6704
ICMDA           1AB5      6837
ICMDB           1AD6      6870
ICMDD           1B01      6913
ICMDE           18AD      6317
ICMD_AMEM       1B0A      6922
ICMD_BREAK      1800      6144
ICMD_BREAK_RET  1802      6146
ICMD_BYTE       1938      6456
ICMD_BYTE2      1969      6505
ICMD_IO         1B45      6981
ICMD_IO_OUT     1B4A      6986
ICMD_REG        1B29      6953
ICMD_SET_REG    1AEF      6895
ICMD_SR_OK      1AF4      6900
ICMD_WORD       18CA      6346
ICMD_WORD1      1901      6401
ICMD_WORD2      1908      6408
ICMD_WORDN1     18F4      6388
ICMD_WORD_RET   190F      6415
IC_ACE          14CF      5327
IC_BIT          1517      5399
IC_BOTH         146A      5226
IC_KEY          14BA      5306
IDDR_DISP       19EC      6636
IDISP_DELAY     1C40      7232
IDISP_IN        1BD0      7120
IDISP_IN_DATA   1BE7      7143
IDISP_MEM       1B9C      7068
IDISP_MEM_DATA  1BB4      7092
IDISP_OFF       1C2C      7212
IDISP_OUT       1C05      7173
IDISP_OUT_DATA  1C1C      7196
IDISP_REG       1B67      7015
IDISP_REG_DATA  1B79      7033
IDISP_RET       17E3      6115
IDO_LP          1C34      7220
IDRRC_2ROM      1A2A      6698
IDRRC_RET       1A2B      6699
IDRRC_ROM       1A26      6694
IDRR_ROM        1A05      6661
IERMS           35AE      13742
IF              2E16      11798
IFLAG          =8235      33333
IKC_REFRESH     17CF      6095
IKC_RESET_CMD   17BE      6078
IKEY0_UP        172F      5935
IKEY1_UP        1738      5944
IKEYF_UP        174B      5963
IKEYP_EVENT     1773      6003
IKEYP_EVENT_DN  1779      6009
IKEYP_NCOS      175D      5981
IKEY_DEBOUNCE   1754      5972
IKEY_DONE       17DF      6111
IKEY_NO_BEEP    17F0      6128
IKEY_SCAN_END   17F6      6134
IKR_QREFRESH    17D5      6101
IK_HEXH         FF5A      65370
IK_HEXL         FF59      65369
IK_HEXST       =FFC3      65475
IK_KEYDN_EVENT  1796      6038
IK_KEYUP_EVENT  1788      6024
IK_NOKEY_EVENT  17AE      6062
IK_RTN          17A0      6048
IK_TIMER       =FFC0      65472
IL01            2BEA      11242
IL02            2C0A      11274
ILP             2BD0      11216
IMON_CMD        1842      6210
IMON_TBL        1857      6231
INCHAR_EXE     =FF92      65426
INC_32          2765      10085
IND             2B18      11032
INERR           2F31      12081
INIT            2A1D      10781
INITFAT_C1_DONE 2382      9090
INITFAT_C2_DONE 23A1      9121
INITFAT_C2_LP   2390      9104
INITFAT_C3_0    23DA      9178
INITFAT_C3_1    23FD      9213
INITFAT_C3_ERR  23C3      9155
INITFAT_C3_LP   23AD      9133
INITFAT_C3_LP2  23DC      9180
INITFAT_C3_LP3  23EC      9196
INITFAT_C4_1    2412      9234
INITFAT_C4_2    2428      9256
INITFAT_C4_3    242D      9261
INITFAT_C4_LP   240D      9229
INITFAT_FAIL    246B      9323
INITFAT_FAIL1   2455      9301
INITFAT_PGOOD   231B      8987
INITFAT_TFS_DONE 2361      9057
INITFAT_TFS_OK  235A      9050
INIT_FAIL       25CA      9674
INIT_FAT        22DC      8924
INIT_SDCARD     259B      9627
INIT_SYSTEM      210      528
INL             35E0      13792
INLF            2ABD      10941
INLN            2BDF      11231
INOK            2B2C      11052
INP1            2EDF      11999
INPUT           2ECB      11979
INPUT_FILENAME  212A      8490
INS             2BC7      11207
INTRO           3600      13824
INT_VEC        =FFCE      65486
IN_CHAR         1421      5153
IOCON          =80FF      33023
IOD_TABLE       13BD      5053
IO_MSG           7CD      1997
IRAMROMBANK     19DD      6621
IRAMROMBANK_CHG 1A13      6675
IRXD_BAD        1685      5765
IRXD_INC        1680      5760
IRXD_NB         164C      5708
IRXD_NI         1654      5716
IRXD_RESET      168B      5771
IRXD_SAVE       1668      5736
IRXD_STP        165B      5723
IRXD_TINC       1688      5768
IRXD_VS         163D      5693
IRXD_WS         16A4      5796
ISD_0           25A0      9632
ISD_1           25DB      9691
ISD_2           25FC      9724
ISD_3           2616      9750
ISD_4           263F      9791
ISD_5           266F      9839
ISD_6           2678      9848
ISD_LP1         25BF      9663
ISD_LP2         2629      9769
ISET_PRESSED    183C      6204
ISINGLE         1A75      6773
ISINGLE_DONE    1A9C      6812
ISINGLE_LP      1A95      6805
ISR_DISPATCH   =FB2A      64298
ISR_EXTIMER     16B9      5817
ISR_EXTIMER_RET 1700      5888
ISR_EXXTIMER    1714      5908
ISR_FLAGS      =FFD8      65496
ISR_RET        =FB3B      64315
ISR_RET_OFF    =11        17
ISR_RXD         163B      5691
ISR_TIMER       16AC      5804
IS_CRLF         202C      8236
IS_LETTER       27BB      10171
IoPtr          =FF8B      65419
KBCOLSAMPLED   =FFE8      65512
KBHEXSAMPLE    =FFEA      65514
KBPORTSAMPLE   =FFE9      65513
KEYBFMODE      =FFC1      65473
KEYBSCANPV     =FFEB      65515
KEYBSCANTIMER  =FFEC      65516
KEY_EVENT      =FFBE      65470
KEY_PRESSED    =FFEF      65519
KEY_PRES_EV    =FFED      65517
KEY_PRES_RTN   =FFEE      65518
KTAB            3522      13602
LAND            3289      12937
LAST           =823A      33338
LB_0             9F2      2546
LB_1             9F8      2552
LB_2             A03      2563
LB_OUT           A06      2566
LB_RET           A0F      2575
LDISPMODE      =FFBA      65466
LD_HL_HL         E4A      3658
LEDL_LP         2818      10264
LEDR_LP         2803      10243
LED_ANBAR      =FFE7      65511
LED_CLEAR       1480      5248
LED_CURSOR     =FFC8      65480
LED_DISPLAY    =FFE0      65504
LED_DISPLAY_SB =FFF6      65526
LED_FONT        2920      10528
LED_GET_POS     27E9      10217
LED_HEX         2900      10496
LED_HOME        1477      5239
LED_HOME_PRINTI 1C8A      7306
LED_LEFT        280C      10252
LED_PRINT       1C78      7288
LED_PRINTI      1C8D      7309
LED_PRINT_LP    1C7A      7290
LED_PRINT_RET   1C87      7303
LED_PUT_BYTE    1C60      7264
LED_PUT_BYTE_HL 1C4A      7242
LED_PUT_HEX     1C6C      7276
LED_PUT_HEX_HL  1C53      7251
LED_RIGHT       27F7      10231
LED_SET_POS     27EF      10223
LED_SPLASH_TBL   27C      636
LED_UPDATE      27D9      10201
LEQL            3320      13088
LET             2DD2      11730
LETH            32B5      12981
LF             =0A        10
LIF             2E39      11833
LIN             35C9      13769
LINEF           2C1F      11295
LINE_BUFF       FA00      64000
LINE_BUFFEND    FA80      64128
LINE_INPUT      1E28      7720
LIRET           2CAD      11437
LIST            2C6B      11371
LI_1            1E66      7782
LI_1B           1E7D      7805
LI_2            1E81      7809
LI_3            1E8D      7821
LI_4            1E91      7825
LI_EOL          1E96      7830
LI_FILESIZE     FA82      64130
LI_GETDATA      1EA2      7842
LI_LP           1E63      7779
LI_SDBUFF_PTR   FA86      64134
LI_SDLOG_SEC    FA88      64136
LI_TP           1E56      7766
LNXT            2E3C      11836
LOAD            30C9      12489
LOAD_HIGH_RAM   2821      10273
LOD1            30C9      12489
LOGICAL_SEC     FF0D      65293
LOOK            2FF8      12280
LOOKT           2F9E      12190
LOOKU           31C9      12745
LOOP1           2AD7      10967
LOOP_BACK_LP     9E7      2535
LOOP_BACK_TEST   9B7      2487
LOR             3296      12950
LSPLASH_CNT      278      632
LSTCHR         =80F9      33017
LTA             2FB5      12213
MAIN_MENU        3E2      994
MEM_DUMP         A5F      2655
MEM_DUMP_0       A61      2657
MEM_DUMP_LP      A68      2664
MEM_DUMP_PAGED   A7E      2686
MEM_EDIT         B1D      2845
MEM_ENTER        A15      2581
MEM_ENTER_NEXTL  A18      2584
MEM_EXEC         B43      2883
MEN_1            A37      2615
MEN_CHK          A2F      2607
MEN_LP           A1F      2591
MEN_RET          A29      2601
MEXIT           320F      12815
ME_1             B5D      2909
ME_LP            B21      2849
MODBYMASK       2739      10041
MODMASK         FF58      65368
MOD_FUNC        FF56      65366
MORDAT          3051      12369
MOVL            2B3D      11069
MOV_32_HL       273E      10046
MOV_HL_32       2749      10057
MUL1            31F8      12792
MUL8            FF55      65365
MULT            31E4      12772
NAK            =15        21
NEGTEXT        =7A        122
NEQL            3330      13104
NEW             2A15      10773
NEXT            2DE1      11745
NEXTL           2C39      11321
NMI_VEC        =FFDC      65500
NOMAD           320B      12811
NOMORE          2E11      11793
NOON            2D5E      11614
NOTFND          2C46      11334
NOT_COLD         2F1      753
NP              35D5      13781
NSTERR          2D75      11637
NUM             2AC6      10950
NXLP            3259      12889
OKKK            324D      12877
OKPRT           2B07      11015
OLOOK           31CD      12749
ORDER           3004      12292
OUTP            2E67      11879
OUTPR           2E8B      11915
OVER1           3253      12883
OVM             35F6      13814
OVRSUB          3258      12888
PARSE           3103      12547
PARSE1          3104      12548
PCA_LP          14E6      5350
PCLC_1          14AE      5294
PCLC_LP         14A8      5288
PCL_CTRL        149D      5277
PCL_RET2        14B4      5300
PCL_RETC        14B1      5297
PC_0            1578      5496
PC_1            157A      5498
PC_10           15C1      5569
PC_11           15C4      5572
PC_12           15CE      5582
PC_13           15D3      5587
PC_14           15D8      5592
PC_15           15E5      5605
PC_16           15E6      5606
PC_17           15F3      5619
PC_18           15F8      5624
PC_19           15FD      5629
PC_2            157F      5503
PC_20           1609      5641
PC_3            1587      5511
PC_4            1590      5520
PC_5            159F      5535
PC_6            15A6      5542
PC_7            15AB      5547
PC_8            15B5      5557
PC_9            15B8      5560
PC_ACE          14E0      5344
PC_BIT          1538      5432
PC_BOTH         1470      5232
PC_LED          148A      5258
PC_LP0          154D      5453
PC_NCR          1403      5123
PC_NOFP         155A      5466
PC_POS_UPDATE   13FC      5116
PC_REDO         1541      5441
PC_RET          1622      5666
PC_RET1         1639      5689
PERR            2A92      10898
PLOT            2E44      11844
PNUM            2C51      11345
POPD            2DC7      11719
POPS            2DB4      11700
PORT_INP         BFC      3068
PORT_OUT         C06      3078
PORT_SPEED       80B      2059
POS_ACE        =FFD7      65495
POS_BIT        =FFD6      65494
POUT            2C62      11362
PP             =8236      33334
PRINS           2C92      11410
PRINT            DBD      3517
PRINTB           DD0      3536
PRINTI           DCA      3530
PRINTM         =57        87
PRINT_BS        211D      8477
PRINT_DIR       1D5E      7518
PRINT_FILENAME  2105      8453
PRINT_LP         DBE      3518
PRINT_MENU       479      1145
PRINT_RET        DC8      3528
PSH1            2DAE      11694
PSH2            2DAF      11695
PTAB            34F3      13555
PU1             34B9      13497
PURGE           142A      5162
PURRS_RET        C8D      3213
PURR_SUB_AF      D08      3336
PURR_SUB_AFA     D35      3381
PURR_SUB_BC      D0F      3343
PURR_SUB_BCA     D3A      3386
PURR_SUB_DE      D12      3346
PURR_SUB_DEA     D3F      3391
PURR_SUB_HL      D19      3353
PURR_SUB_HLA     D44      3396
PURR_SUB_IR      D2E      3374
PURR_SUB_IX      D26      3366
PURR_SUB_IY      D2A      3370
PURR_SUB_PC      D20      3360
PURR_SUB_SP      D07      3335
PURR_TBL         CB1      3249
PUSHB           34B0      13488
PUSHD           2DBD      11709
PUSHS           2DA9      11689
PUTCHAR_EXE    =FF90      65424
PUT_3C_SPACES    B11      2833
PUT_3C_SPACES_L  B12      2834
PUT_BC           DD8      3544
PUT_BYTE         DF6      3574
PUT_CHAR        13EC      5100
PUT_DE           DE1      3553
PUT_HEX          E09      3593
PUT_HL           DEA      3562
PUT_IOMSG        7BA      1978
PUT_NEW_LINE     E1F      3615
PUT_REG        =FFB6      65462
PUT_REGISTER     C82      3202
PUT_REG_MON      C86      3206
PUT_REG_RUN      C91      3217
PUT_SPACE        E19      3609
PUT_VERSION      89B      2203
PV1             2EA5      11941
PVH_0            8F8      2296
PVH_1            906      2310
PZ              2EA8      11944
Port40         =40        64
Q0              3404      13316
Q1              3407      13319
Q2              3418      13336
Q3              3419      13337
Q4              3423      13347
Q5              3435      13365
Q6              344E      13390
Q7              345F      13407
Q8              346E      13422
Q9              347E      13438
QPP             3420      13344
QTST            348B      13451
RAMROM         =C1        193
RAMSIGNATURE   =FF78      65400
RAMSIGN_LP       2EA      746
RAMSIG_LP        19B      411
RAM_LDRT       =8000      32768
RAM_TEST        1104      4356
RANDR           33AD      13229
RC_CC          =FF83      65411
RC_F0          =FF85      65413
RC_HALT        =FF84      65412
RC_HARD        =FF87      65415
RC_RST0        =FF86      65414
RC_SOFT        =FF81      65409
RC_STEP        =FF82      65410
RC_TYPE        =FF80      65408
RDY             3630      13872
READ            301F      12319
READ_HEX_EXEC   1EC3      7875
READ_HEX_FILE   1EF4      7924
READ_RAMROM    =FFDB      65499
READ_SERIAL      EC3      3779
RECT            2B0E      11022
REGNAMES         C39      3129
REGORDER         942      2370
REG_DISP_ALL     91F      2335
REG_MENU         915      2325
REM             2E15      11797
RESERVED_SEC    FF22      65314
RESET           2CDF      11487
RESETLDRT        100      256
RESV            2A1A      10778
RETRY           2EF2      12018
RETURN          2D6E      11630
RFLAG          =8234      33332
RFSec          =12        18
RGON            2CFC      11516
RHF_BYTE_LP     1F4D      8013
RHF_BYTE_LP2    1F4B      8011
RHF_DO          1F29      7977
RHF_DO_NEXTL    2029      8233
RHF_ERR_ON_LINE 1F8E      8078
RHF_LINE        1F30      7984
RHF_LINES       FA8A      64138
RHF_LOOP        1F01      7937
RHF_NOT_HEX     1F60      8032
RHF_OK1         1F47      8007
RHF_OK2         1F79      8057
RHF_OK3         1FAC      8108
RHF_OK4         1FC8      8136
RHF_OK5         1FDC      8156
RHF_OK6         200C      8204
RHF_OK7         2024      8228
RLOOP           2D04      11524
RM_2             966      2406
RM_3             971      2417
RM_4             976      2422
RM_5             98C      2444
RM_6             99A      2458
RM_DUMP_REG      9AB      2475
RM_DUMP_REG_C    9AA      2474
RM_ERR           986      2438
RM_LP            921      2337
RM_NOTALL        94F      2383
RNEWL           2D01      11521
RNEXT           2D13      11539
ROM_CODE        282D      10285
ROM_CODE_LEN   =29        41
ROOTDIR_SIZE    FF25      65317
RPC            =FFA0      65440
RRSTATE        =FFD9      65497
RS232_SPLASH     316      790
RSAF           =FF98      65432
RSAF2          =FFA8      65448
RSBC           =FF9A      65434
RSBC2          =FFAA      65450
RSDE           =FF9C      65436
RSDE2          =FFAC      65452
RSHL           =FF9E      65438
RSHL2          =FFAE      65454
RSIR           =FFA6      65446
RSIS_LP          136      310
RSIS_OK          141      321
RSIX           =FFA2      65442
RSIY           =FFA4      65444
RSSP           =FF96      65430
RST38_LEN      =06        6
RS_CLP           EC9      3785
RS_COK           EDC      3804
RS_LP            ECB      3787
RS_TIMEOUT       EEB      3819
RT1_LP0         112F      4399
RT1_LP1         1132      4402
RT1_LP2         1134      4404
RT1_LP3         113E      4414
RT1_LP4         1144      4420
RT1_LP5         1149      4425
RT1_LP6         114F      4431
RT1_LP7         115E      4446
RT2_LP0         1187      4487
RT2_LP1         1188      4488
RT2_LP2         1191      4497
RT2_LP3         1197      4503
RT2_LP4         119D      4509
RT2_NX1         11AC      4524
RT3_LP1         124A      4682
RT3_LP2         1252      4690
RT3_LP3         1253      4691
RT3_LP4         125D      4701
RT3_LP5         125E      4702
RT3_NX1         1277      4727
RT4_LP0         11DD      4573
RT4_LP1         11E2      4578
RT4_LP2         11E4      4580
RT4_LP3         11ED      4589
RT4_LP4         11F4      4596
RT4_LP5         11FC      4604
RT4_LP6         1201      4609
RT4_LP7         120E      4622
RT4_LP8         121D      4637
RT4_NX          1218      4632
RT5_LP1         1297      4759
RT5_LP2         12A0      4768
RT5_LP3         12AF      4783
RT5_NX1         12A4      4772
RT5_NX2         12B3      4787
RTHW_ADV         160      352
RTHW_EXIT        167      359
RTHW_LP          150      336
RTHW_OK          15D      349
RTHW_SIOT_LP     170      368
RTHW_SIO_EXIT    17E      382
RT_FAIL1        12E2      4834
RT_FAIL2        1305      4869
RT_FAIL3        1328      4904
RT_FAIL5        134A      4938
RT_GO           111C      4380
RUN             2CEC      11500
RXBHEAD        =FFCA      65482
RXBTAIL        =FFCC      65484
RXBUFFER        FE00      65024
RXC_ACE         14C4      5316
RXC_BIT         1509      5385
RXC_BOTH        1461      5217
RXC_DO          140E      5134
RX_COUNT        1408      5128
RX_ERR_LDRT    =FF8C      65420
RX_ERR_OVR     =FF8E      65422
RX_ERR_STOP    =FF8D      65421
R_CC             345      837
R_COLD           326      806
R_F0             357      855
R_HALT           34E      846
R_HARD           369      873
R_RST0           361      865
R_SOFT           333      819
R_STEP           340      832
RegPtr         =FF8A      65418
SAVE            30CC      12492
SCAN_LED       =FFF5      65525
SCAN_PTR       =FFD0      65488
SDCLK          =C0        192
SDCS           =C4        196
SDC_1           26A5      9893
SDC_2           26AC      9900
SDC_LP          26CF      9935
SDC_MENU        1CE8      7400
SDC_RET         26DC      9948
SDC_STATUS      FF11      65297
SDFF_LP         20C0      8384
SDISKA          FB80      64384
SDISKB          FBA0      64416
SDISKC          FBC0      64448
SDISKD          FBE0      64480
SDISPMODE      =FFD4      65492
SDLF_LP         1D74      7540
SDO_DO          1DC8      7624
SDO_RET         1E22      7714
SDTX           =C5        197
SDV_FIND_FILE   208B      8331
SDV_FOUND       20AF      8367
SD_CARD_TYPE    FF10      65296
SD_CLEAR_ARG    258D      9613
SD_CMD          2695      9877
SD_DELAY        2690      9872
SD_DELAY100     268E      9870
SD_DESELECT     267D      9853
SD_FETCH        20D7      8407
SD_FIND_FILE    20BD      8381
SD_LDIR1        20CB      8395
SD_LDIRN        20E0      8416
SD_OPEN         1DB6      7606
SD_OPEN_FILENAME 1DA9      7593
SD_PARAM        FF12      65298
SD_PART_BASE    FF17      65303
SD_PART_SIZE    FF1B      65307
SD_PART_TYPE    FF16      65302
SD_RAM_BUFFER   FC00      64512
SD_READ_SEC     2496      9366
SD_RS_0         24CD      9421
SD_RS_1         24DC      9436
SD_RS_FORCED    24B4      9396
SD_RS_LP0       24BF      9407
SD_RS_LP1       24CF      9423
SD_RS_LP2       24DF      9439
SD_SELECT       2688      9864
SD_TEST         20DD      8413
SD_WRITE_SEC    24F4      9460
SD_WR_FAIL      2557      9559
SD_WR_LP        250C      9484
SEC_PER_CLUS    FF21      65313
SEC_PER_FAT     FF2F      65327
SEC_PTR         FF3D      65341
SEED           =81FE      33278
SET_BANK         871      2161
SET_ECHO        27D5      10197
SET_IO          1386      4998
SET_PARAM       2572      9586
SHORTNWAY        C94      3220
SIGT           =823C      33340
SIMSG           3644      13892
SIO_OK          13A2      5026
SIO_RET         13B9      5049
SIO_ZERO        13A0      5024
SIZE            30A9      12457
SKIP            310F      12559
SKIP1           3117      12567
SKIP_HALT_TEST  16F9      5881
SKIP_TABLE1      2BC      700
SKIP_TABLE2      377      887
SKPQUO          3129      12585
SL1             3048      12360
SOFT_RST_FLAG  =FFDF      65503
SOH            =01        1
SPACE_GET_BYTE   D49      3401
SPACE_GET_WORD   D76      3446
SPACE_PUT_BYTE   DF3      3571
SPI_RX          26DE      9950
SPI_TX          26E0      9952
SPI_TX_LP       26E4      9956
SPLASH_VERSION   374      884
SP_ISR_SAVE     FB28      64296
SP_RET          2583      9603
SRSEED          32E5      13029
SSOC           =14        20
STACK          =80F7      33015
STACKSPACE1     FB00      64256
STACK_ISR1     =FB28      64296
STLIN           2AAF      10927
STMEM           3300      13056
STMSG           3638      13880
STOP            2D2C      11564
STOR            2FE7      12263
STRT            32E1      13025
SUBB            3244      12868
SW2_ACE          7AC      1964
SW2_BIT          7A4      1956
SW2_BOTH         7B4      1972
SWAP            3276      12918
SYN             35EA      13802
SYNT            2A7C      10876
StackTop       =FAFE      64254
TABENT          2F7D      12157
TB             =8032      32818
TEMP           =823E      33342
TEST_SIGNATURE  2483      9347
TEXT           =8600      34304
TGC_LP1         144E      5198
TGC_LP2         1450      5200
TGC_RET         145E      5214
THEN            2D32      11570
TIMED1_GETCHAR  1449      5193
TIMED_GETCHAR   144B      5195
TINC             E26      3622
TLP0            2A51      10833
TOP             2A2C      10796
TO_UPPER        27B2      10162
TRY             2C26      11302
TSTZ_32         2773      10099
TicCounter     =FFF0      65520
URET            2FDD      12253
UR_NOTRAM        865      2149
UR_RET           86B      2155
UR_RET1          86E      2158
USE_RAM          831      2097
USR             2FC8      12232
USROUT         =80FD      33021
UiVec          =FFB0      65456
UiVec_RET       17FF      6143
V1              2FC2      12226
VADD_32_HL      9B        155
VADD_HL_A       92        146
VARS           =8200      33280
VASC2BIN        AA        170
VASC2HEX        AD        173
VBEEP           5A        90
VCALL_HL         CA0      3232
VCHAR           2A78      10872
VCLEAR_BLOCK    8C        140
VCMP_HL_32      9E        158
VDEC_32         A4        164
VDELAY_A        63        99
VDELAY_C        60        96
VDISK_READ      EC        236
VER1            309B      12443
VERDAT          3094      12436
VGET_BYTE       83        131
VGET_CHAR       4B        75
VGET_HEX        89        137
VGET_POS        48        72
VGET_WORD       86        134
VHEX2ASC        B0        176
VIC_KEY         B9        185
VIEW_FLAGS      FF0C      65292
VINC_32         A1        161
VINPUT_FNAME    E0        224
VIN_CHAR        51        81
VLD_HL_HL       8F        143
VLED_CLEAR      D4        212
VLED_GET_POS    BF        191
VLED_HOME       C5        197
VLED_LEFT       DA        218
VLED_PRINT      CB        203
VLED_PUT_BYTE   CE        206
VLED_PUT_CHAR   C8        200
VLED_PUT_HEX    D1        209
VLED_RIGHT      D7        215
VLED_SET_POS    C2        194
VLED_UPDATE     BC        188
VLINE_INPUT     F2        242
VMAIN_MENU      42        66
VMOV_32_HL      95        149
VMOV_HL_32      98        152
VPRINT          57        87
VPRINT_DIR      E9        233
VPRINT_FNAME    DD        221
VPUT_BC         74        116
VPUT_BYTE       71        113
VPUT_CHAR       45        69
VPUT_DE         77        119
VPUT_HEX        6E        110
VPUT_HL         7A        122
VPUT_NEW_LINE   80        128
VPUT_SPACE      7D        125
VPUT_VERSION    6B        107
VRX_COUNT       4E        78
VSD_OPEN        E3        227
VSD_OPEN_FILENAME E6        230
VSD_READ_SEC    EF        239
VSET_ECHO       5D        93
VSET_IO         B6        182
VTIMED_GETCHAR  54        84
VTO_UPPER       B3        179
VTSTZ_32        A7        167
WAIT_NOT_BUSY   26F4      9972
WARM_START       1CF      463
WB_NOT_STEP      387      903
WHICH_PORT       7DA      2010
WNB_0           270A      9994
WNB_LP          26F8      9976
WNB_LP2         26FA      9978
WP_NOACE         806      2054
WP_NOBIT         7F6      2038
WRITE_BLOCK      C1D      3101
WS_NOFP          1F8      504
WS_SET           204      516
X0              3472      13426
XBF            =8064      32868
XMDN             F04      3844
XMDN_LP          F11      3857
XMGET_HDR       10B3      4275
XMODEM           EEE      3822
XMR_ACK         109D      4253
XMR_BLK_LP      106B      4203
XMR_CCS         1094      4244
XMR_CRC         1007      4103
XMR_CS          101E      4126
XMR_INIT        1000      4096
XMR_LP          103A      4154
XMR_NAK         10A7      4263
XMR_RECV        1035      4149
XMR_SEQ_OK      1063      4195
XMR_TSEQ        104F      4175
XMSEQ          =FFF3      65523
XMS_BLP          F69      3945
XMS_CS           F86      3974
XMS_DO           F4A      3914
XMS_EOT          FA6      4006
XMS_INIT         F2E      3886
XMS_INIT_LP      F35      3893
XMS_INIT_RT      F45      3909
XMS_RESEND       F4E      3918
XMS_SEND         F52      3922
XMTYPE         =FFF4      65524
XMUP             F1F      3871
XMUP_LP          F26      3878
XM_CANCEL        FDA      4058
XM_DONE          FBA      4026
XTIMER_TIC     =FFDA      65498
Z1              2F18      12056
Z2              2F28      12072
Z3              2F29      12073
ZLOOP           30E6      12518
