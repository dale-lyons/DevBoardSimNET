0001   0000             ;
0002   0000             ; Monitor using CP/M BIOS
0003   0000             ;
0004   0000             ;
0005   0000             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006   0000             ;
0007   0000             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008   0000             ;
0009   0000             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010   0000             ; of this software and associated documentation files (the "Software"), to deal
0011   0000             ; in the Software without restriction, including without limitation the rights
0012   0000             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013   0000             ; copies of the Software, and to permit persons to whom the Software is
0014   0000             ; furnished to do so, subject to the following conditions:
0015   0000             ; 
0016   0000             ; The above copyright notice and this permission notice shall be included in all
0017   0000             ; copies or substantial portions of the Software.
0018   0000             ; 
0019   0000             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020   0000             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021   0000             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022   0000             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023   0000             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024   0000             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025   0000             ; SOFTWARE.
0026   0000             ;
0027   0000                                 .MODULE  main
0028   0000             
0029   0000             MONITOR_START       .EQU   0DF00h
0030   0000             
0031   DF00                                 .ORG   MONITOR_START
0032   DF00 CD E1 F3                        CALL   configure_hardware
0033   DF03             
0034   DF03 3E 01                           LD      A, 1
0035   DF05 32 03 00                        LD      (iobyte), A
0036   DF08             
0037   DF08 3E 24                           LD      A, DRIVE_B_PAGE
0038   DF0A 32 38 FF                        LD      (drive_b_mem_page), A
0039   DF0D             
0040   DF0D 21 37 E9    _clock_check        LD      HL, timer_int
0041   DF10 22 FE FD                        LD      (0FDFEh), HL
0042   DF13             
0043   DF13 3E 01                           LD      A, 1
0044   DF15 32 04 FF                        LD      (timer), A
0045   DF18 3E 03                           LD      A, 3
0046   DF1A CD 28 E9                        CALL    detect_int
0047   DF1D             
0048   DF1D 79                              LD      A, C
0049   DF1E B0                              OR      B
0050   DF1F 20 0A                           JR      NZ, _clock_detected
0051   DF21             
0052   DF21 CD C9 F3    _no_clock           CALL    m_print_inline
0053   DF24 2E 00                           .DB     ".", 0
0054   DF26             
0055   DF26 CD 0D F5                        CALL    _do_reti
0056   DF29 18 E2                           JR      _clock_check
0057   DF2B             
0058   DF2B 3E 07       _clock_detected     LD      A, 7
0059   DF2D CD 28 E9                        CALL    detect_int
0060   DF30 79                              LD      A, C
0061   DF31 B0                              OR      B 
0062   DF32 28 ED                           JR      Z, _no_clock
0063   DF34             
0064   DF34                                 ; At this point BC ~= 13 * (clock * 100)
0065   DF34                                 ; Divide by 13, round lowest digit up/down
0066   DF34             
0067   DF34 C5                              PUSH    BC
0068   DF35 E1                              POP     HL
0069   DF36 0E 0D                           LD      C, 13
0070   DF38 CD 44 E9                        CALL    divide_hl_c
0071   DF3B             
0072   DF3B E5                              PUSH    HL
0073   DF3C D1                              POP     DE
0074   DF3D CD 51 E9                        CALL    de_to_bcd
0075   DF40             
0076   DF40 3A 89 E9                        LD      A, (bcd_scratch)         ; Units
0077   DF43 FE 06                           CP      6
0078   DF45 38 11                           JR      C, _display_speed
0079   DF47             
0080   DF47 2A 8A E9                        LD      HL, (bcd_scratch+1)
0081   DF4A 06 04                           LD      B,  4
0082   DF4C             
0083   DF4C 7E          _increment_bcd      LD      A, (HL)
0084   DF4D 3C                              INC     A
0085   DF4E 77                              LD      (HL), A
0086   DF4F FE 0A                           CP      10
0087   DF51 38 05                           JR      C, _display_speed        ; No carry here
0088   DF53 AF                              XOR     A
0089   DF54 77                              LD      (HL), A
0090   DF55 23                              INC     HL
0091   DF56 10 F4                           DJNZ    _increment_bcd
0092   DF58             
0093   DF58 3A 8C E9    _display_speed      LD      A, (bcd_scratch+3)
0094   DF5B A7                              AND     A
0095   DF5C 28 05                           JR      Z, _skip_leading
0096   DF5E C6 30                           ADD     A, '0'
0097   DF60 32 8A DF                        LD      (_speed_value),A
0098   DF63 3A 8B E9    _skip_leading       LD       A, (bcd_scratch+2)
0099   DF66 C6 30                           ADD     A, '0'
0100   DF68 32 8B DF                        LD      (_speed_value+1), A
0101   DF6B 3A 8A E9                        LD      A, (bcd_scratch+1)
0102   DF6E C6 30                           ADD     A, '0'
0103   DF70 32 8D DF                        LD      (_speed_value+3), A
0104   DF73             
0105   DF73 01 60 00                        LD      BC, 60h
0106   DF76 CD 11 E9                        CALL    pause_for_ticks
0107   DF79             
0108   DF79 CD C9 F3                        CALL    m_print_inline
0109   DF7C 0A 0D 43 6C                     .DB     NEWLINE, CARRIAGE_RETURN, "Clock speed "
0109   DF80 6F 63 6B 20 
0109   DF84 73 70 65 65 
0109   DF88 64 20 
0110   DF8A 20 30 2C 30 _speed_value        .DB     " 0,0Mhz", 0
0110   DF8E 4D 68 7A 00 
0111   DF92             
0112   DF92 21 B6 F4                        LD      HL, interrupt_handler
0113   DF95 22 FE FD                        LD      (0FDFEh), HL
0114   DF98             
0115   DF98 01 60 00                        LD      BC, 60h
0116   DF9B CD 11 E9                        CALL    pause_for_ticks
0117   DF9E             
0118   DF9E CD C9 F3                        CALL    m_print_inline
0119   DFA1 0A 0D 4D 69                     .DB     NEWLINE, CARRIAGE_RETURN, "MicroBeast Monitor 1.6", 0
0119   DFA5 63 72 6F 42 
0119   DFA9 65 61 73 74 
0119   DFAD 20 4D 6F 6E 
0119   DFB1 69 74 6F 72 
0119   DFB5 20 31 2E 36 
0119   DFB9 00 
0120   DFBA             
0121   DFBA 01 60 00                        LD      BC, 60h
0122   DFBD CD 11 E9                        CALL    pause_for_ticks
0123   DFC0             
0124   DFC0 0E 0A                           LD      C, NEWLINE
0125   DFC2 CD 00 F0                        CALL    bios_conout
0126   DFC5             
0127   DFC5 CD 8E E9    _monitor_menu       CALL    rtc_display_time
0128   DFC8             
0129   DFC8 01 40 00                        LD      BC, 040h
0130   DFCB CD 11 E9                        CALL    pause_for_ticks
0131   DFCE             
0132   DFCE CD 71 EF    _monitor_read       CALL    bios_conist
0133   DFD1 A7                              AND     A
0134   DFD2 28 F1                           JR      Z, _monitor_menu
0135   DFD4             
0136   DFD4 CD 9A EF                        CALL    bios_conin
0137   DFD7             
0138   DFD7 21 FE DF                        LD      HL, main_menu
0139   DFDA CD 42 E8                        CALL    start_menu
0140   DFDD 18 E6                           JR      _monitor_menu
0141   DFDF             
0142   DFDF             
0143   DFDF CD C9 F3    boot_cpm            CALL    m_print_inline
0144   DFE2 0A 0D 46 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Format RAM disk", 0
0144   DFE6 72 6D 61 74 
0144   DFEA 20 52 41 4D 
0144   DFEE 20 64 69 73 
0144   DFF2 6B 00 
0145   DFF4             
0146   DFF4 CD 73 E7                        CALL    format_memdisk
0147   DFF7             
0148   DFF7 21 F1 EE    boot_without_format LD      HL, bios_boot
0149   DFFA E5                              PUSH    HL
0150   DFFB C3 31 EF                        JP      load_ccp
0151   DFFE             
0152   DFFE             
0153   DFFE 53 65 6C 65 main_menu           .DB     "Select action", 0
0153   E002 63 74 20 61 
0153   E006 63 74 69 6F 
0153   E00A 6E 00 
0154   E00C             
0155   E00C DF DF                           .DW     boot_cpm
0156   E00E 4C 61 75 6E                     .DB     "Launch CP/M", 0
0156   E012 63 68 20 43 
0156   E016 50 2F 4D 00 
0157   E01A             
0158   E01A 78 E5                           .DW     memory_view
0159   E01C 4D 65 6D 6F                     .DB     "Memory Editor", 0
0159   E020 72 79 20 45 
0159   E024 64 69 74 6F 
0159   E028 72 00 
0160   E02A             
0161   E02A B2 E1                           .DW     ymodem_loader
0162   E02C 59 2D 4D 6F                     .DB     "Y-Modem Transfer", 0
0162   E030 64 65 6D 20 
0162   E034 54 72 61 6E 
0162   E038 73 66 65 72 
0162   E03C 00 
0163   E03D             
0164   E03D 55 E0                           .DW     set_date
0165   E03F 53 65 74 20                     .DB     "Set Date", 0
0165   E043 44 61 74 65 
0165   E047 00 
0166   E048             
0167   E048 1C E1                           .DW     set_time
0168   E04A 53 65 74 20                     .DB     "Set Time", 0
0168   E04E 54 69 6D 65 
0168   E052 00 
0169   E053 00 00                           .DW     0
0170   E055             
0171   E055             
0172   E055                                 .INCLUDE monitor_dates.asm
0001+  E055             ;
0002+  E055             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E055             ;
0004+  E055             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E055             ;
0006+  E055             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E055             ; of this software and associated documentation files (the "Software"), to deal
0008+  E055             ; in the Software without restriction, including without limitation the rights
0009+  E055             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E055             ; copies of the Software, and to permit persons to whom the Software is
0011+  E055             ; furnished to do so, subject to the following conditions:
0012+  E055             ; 
0013+  E055             ; The above copyright notice and this permission notice shall be included in all
0014+  E055             ; copies or substantial portions of the Software.
0015+  E055             ; 
0016+  E055             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E055             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E055             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E055             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E055             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E055             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E055             ; SOFTWARE.
0023+  E055             ;
0024+  E055             
0025+  E055 3A 2D FF    set_date            LD      A, (cursor_row)
0026+  E058 C6 1F                           ADD     A, 31
0027+  E05A 32 75 E0                        LD      (_set_date_row), A
0028+  E05D 32 88 E0                        LD      (_set_week_row), A
0029+  E060 CD C9 F3                        CALL    m_print_inline
0030+  E063 0D 44 61 74                     .DB     CARRIAGE_RETURN, "Date YY/MM/DD", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0030+  E067 65 20 59 59 
0030+  E06B 2F 4D 4D 2F 
0030+  E06F 44 44 1B 4B 
0030+  E073 1B 59 
0031+  E075 00          _set_date_row       .DB     0
0032+  E076 25 00                           .DB     31+6, 0
0033+  E078 21 63 E1                        LD      HL, date_limits
0034+  E07B CD 71 E1                        CALL    get_date_time
0035+  E07E             
0036+  E07E 3E 01                           LD      A, 1
0037+  E080 32 69 E1    _select_loop        LD      (day_of_week), A
0038+  E083             
0039+  E083 CD C9 F3                        CALL    m_print_inline
0040+  E086 1B 59                           .DB     ESCAPE_CHAR, "Y", 
0041+  E088 00          _set_week_row       .DB     0
0042+  E089 2F 00                           .DB     31+16, 0
0043+  E08B             
0044+  E08B 3A 69 E1                        LD      A, (day_of_week)
0045+  E08E 47                              LD      B, A
0046+  E08F 21 27 EA                        LD      HL, weekdays
0047+  E092 10 0A       _week_loop          DJNZ    _next_week
0048+  E094             
0049+  E094 7E          _print_week         LD      A, (HL)
0050+  E095 23                              INC     HL
0051+  E096 A7                              AND     A
0052+  E097 28 0C                           JR      Z, _select_week
0053+  E099 CD D6 F3                        CALL    m_print_a_safe
0054+  E09C 18 F6                           JR      _print_week
0055+  E09E             
0056+  E09E 7E          _next_week          LD      A, (HL)
0057+  E09F 23                              INC     HL
0058+  E0A0 A7                              AND     A
0059+  E0A1 20 FB                           JR      NZ, _next_week
0060+  E0A3 18 ED                           JR      _week_loop
0061+  E0A5             
0062+  E0A5 CD 71 EF    _select_week        CALL    bios_conist
0063+  E0A8 A7                              AND     A
0064+  E0A9 28 FA                           JR      Z, _select_week
0065+  E0AB CD 9A EF                        CALL    bios_conin
0066+  E0AE FE 80                           CP      KEY_UP
0067+  E0B0 20 0A                           JR      NZ, _test_down
0068+  E0B2 3A 69 E1                        LD      A, (day_of_week)
0069+  E0B5 FE 07                           CP      7
0070+  E0B7 28 EC                           JR      Z, _select_week
0071+  E0B9 3C                              INC     A
0072+  E0BA 18 C4                           JR      _select_loop
0073+  E0BC FE 81       _test_down          CP      KEY_DOWN
0074+  E0BE 20 0A                           JR      NZ, _test_enter 
0075+  E0C0 3A 69 E1                        LD      A, (day_of_week)
0076+  E0C3 FE 01                           CP      1
0077+  E0C5 28 DE                           JR      Z, _select_week
0078+  E0C7 3D                              DEC     A
0079+  E0C8 18 B6                           JR      _select_loop
0080+  E0CA FE 0D       _test_enter         CP      KEY_ENTER
0081+  E0CC 20 D7                           JR      NZ, _select_week
0082+  E0CE             
0083+  E0CE F3                              DI
0084+  E0CF 26 6F                           LD      H, RTC_ADDRESS      
0085+  E0D1 2E 03                           LD      L, RTC_REG_WKDAY
0086+  E0D3 CD 3C F9                        CALL    i2c_write_to
0087+  E0D6 D2 05 E1                        JP      NC, _clock_error
0088+  E0D9             
0089+  E0D9 21 69 E1                        LD      HL, day_of_week
0090+  E0DC 7E                              LD      A, (HL)
0091+  E0DD 23                              INC     HL
0092+  E0DE             
0093+  E0DE F6 08                           OR      RTC_WEEKDAY_RUNNING
0094+  E0E0 CD 50 F9                        CALL    i2c_write
0095+  E0E3 D2 05 E1                        JP      NC, _clock_error
0096+  E0E6             
0097+  E0E6 46          _write_date_loop    LD      B, (HL)
0098+  E0E7 23                              INC     HL
0099+  E0E8             
0100+  E0E8 7E                              LD      A, (HL)
0101+  E0E9 23                              INC     HL
0102+  E0EA CB 27                           SLA     A
0103+  E0EC CB 27                           SLA     A
0104+  E0EE CB 27                           SLA     A
0105+  E0F0 CB 27                           SLA     A
0106+  E0F2             
0107+  E0F2 B0                              OR      B
0108+  E0F3 FE FF                           CP      0ffh
0109+  E0F5 CA 00 E1                        JP      Z, _start_clock
0110+  E0F8 CD 50 F9                        CALL    i2c_write
0111+  E0FB D2 05 E1                        JP      NC, _clock_error
0112+  E0FE 18 E6                           JR      _write_date_loop
0113+  E100             
0114+  E100 CD 04 F9    _start_clock        CALL    i2c_stop
0115+  E103 FB                              EI
0116+  E104 C9                              RET
0117+  E105             
0118+  E105 CD 04 F9    _clock_error        CALL    i2c_stop
0119+  E108 FB                              EI
0120+  E109 CD C9 F3                        CALL    m_print_inline
0121+  E10C 0D 52 54 43                     .DB     CARRIAGE_RETURN, "RTC Error", ESCAPE_CHAR, "K", 0
0121+  E110 20 45 72 72 
0121+  E114 6F 72 1B 4B 
0121+  E118 00 
0122+  E119 C3 9A EF                        JP      bios_conin
0123+  E11C             
0124+  E11C 3A 2D FF    set_time            LD      A, (cursor_row)
0125+  E11F C6 1F                           ADD     A, 31
0126+  E121 32 39 E1                        LD      (_set_time_row), A
0127+  E124 CD C9 F3                        CALL    m_print_inline
0128+  E127 0D 54 69 6D                     .DB     CARRIAGE_RETURN, "Time HH/mm/ss", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0128+  E12B 65 20 48 48 
0128+  E12F 2F 6D 6D 2F 
0128+  E133 73 73 1B 4B 
0128+  E137 1B 59 
0129+  E139 00          _set_time_row       .DB     0
0130+  E13A 25 00                           .DB     31+6, 0
0131+  E13C 21 5D E1                        LD      HL, time_limits
0132+  E13F CD 71 E1                        CALL    get_date_time
0133+  E142             
0134+  E142 3A 6B E1                        LD      A, (digit_values+1)
0135+  E145 F6 08                           OR      08h
0136+  E147 32 6B E1                        LD      (digit_values+1), A
0137+  E14A CD 9A EF                        CALL    bios_conin
0138+  E14D             
0139+  E14D F3                              DI
0140+  E14E 26 6F                           LD      H, RTC_ADDRESS      
0141+  E150 2E 00                           LD      L, RTC_REG_SEC
0142+  E152 CD 3C F9                        CALL    i2c_write_to
0143+  E155 D2 05 E1                        JP      NC, _clock_error
0144+  E158             
0145+  E158 21 6A E1                        LD      HL, digit_values
0146+  E15B 18 89                           JR      _write_date_loop
0147+  E15D                                 
0148+  E15D 09 05 09 05 time_limits         .DB     9,5,9,5,3,2
0148+  E161 03 02 
0149+  E163             
0150+  E163 01 03 02 01 date_limits         .DB     1,3,2,1,9,9
0150+  E167 09 09 
0151+  E169             
0152+  E169 01          day_of_week         .DB     1
0153+  E16A 00 00 00 00 digit_values        .DB     0,0,0,0,0,0
0153+  E16E 00 00 
0154+  E170 FF                              .DB     0FFh
0155+  E171             
0156+  E171 11 6A E1    get_date_time       LD      DE, digit_values
0157+  E174 01 06 00                        LD      BC, 6
0158+  E177 ED B0                           LDIR
0159+  E179 2B                              DEC     HL
0160+  E17A 1B                              DEC     DE
0161+  E17B 06 06                           LD      B, 6
0162+  E17D             
0163+  E17D E5          _get_digit          PUSH    HL
0164+  E17E D5                              PUSH    DE
0165+  E17F C5                              PUSH    BC
0166+  E180 CD 9A EF                        CALL    bios_conin
0167+  E183 C1                              POP     BC
0168+  E184 D1                              POP     DE
0169+  E185 E1                              POP     HL
0170+  E186 D6 30                           SUB     '0'
0171+  E188 38 F3                           JR      C, _get_digit
0172+  E18A 4F                              LD      C, A
0173+  E18B 1A                              LD      A, (DE)
0174+  E18C 32 A1 E1                        LD      (_digit_compare+1),A
0175+  E18F B9                              CP      C
0176+  E190 38 EB                           JR      C, _get_digit
0177+  E192             
0178+  E192 79                              LD      A, C
0179+  E193 12                              LD      (DE), A
0180+  E194 C6 30                           ADD     A,'0'
0181+  E196 CD D6 F3                        CALL    m_print_a_safe
0182+  E199             
0183+  E199 1A                              LD      A,(DE)
0184+  E19A 2B                              DEC     HL
0185+  E19B 1B                              DEC     DE
0186+  E19C CB 40                           BIT     0, B
0187+  E19E 20 0A                           JR      NZ, _next_tuple
0188+  E1A0 FE 00       _digit_compare      CP      0
0189+  E1A2 28 03                           JR      Z, _next_digit
0190+  E1A4 3E 09                           LD      A, 9
0191+  E1A6 12                              LD      (DE), A
0192+  E1A7 10 D4       _next_digit         DJNZ    _get_digit
0193+  E1A9 C9                              RET
0194+  E1AA CD C9 F3    _next_tuple         CALL    m_print_inline
0195+  E1AD 1B 43 00                        .DB     ESCAPE_CHAR, 'C', 0
0196+  E1B0 18 F5                           JR      _next_digit0173   E1B2             
0174   E1B2             
0175   E1B2 AF          ymodem_loader       XOR     A
0176   E1B3 32 04 E4                        LD      (_ymodem_set), A
0177   E1B6 21 7D E4                        LD      HL, ymodem_menu
0178   E1B9 CD 42 E8                        CALL    start_menu
0179   E1BC                                 
0180   E1BC 3A 04 E4                        LD      A, (_ymodem_set)
0181   E1BF A7                              AND     A
0182   E1C0 C8                              RET     Z
0183   E1C1             
0184   E1C1 ED 5B 01 E4                     LD      DE, (_ymodem_address)
0185   E1C5 3A 03 E4                        LD      A, (_ymodem_page)
0186   E1C8 21 6F DE                        LD      HL, MONITOR_START-YMODEM_BUFFER
0187   E1CB F3                              DI
0188   E1CC CD B1 EA                        CALL    ymodem
0189   E1CF FB                              EI
0190   E1D0 A7                              AND     A
0191   E1D1 CA 83 E2                        JP      Z, _ymodem_success
0192   E1D4             
0193   E1D4 3D                              DEC     A
0194   E1D5 5F                              LD      E, A
0195   E1D6 16 00                           LD      D, 0
0196   E1D8 21 03 E2                        LD      HL, _ymodem_errors
0197   E1DB 19                              ADD     HL, DE
0198   E1DC 19                              ADD     HL, DE
0199   E1DD             
0200   E1DD 7E                              LD      A, (HL)
0201   E1DE 23                              INC     HL
0202   E1DF 66                              LD      H, (HL)
0203   E1E0 6F                              LD      L, A
0204   E1E1             
0205   E1E1 79                              LD      A, C
0206   E1E2 C6 30                           ADD     A, '0'
0207   E1E4 32 3F E2                        LD      (_packet_err_code), A
0208   E1E7             
0209   E1E7 E5                              PUSH    HL
0210   E1E8 CD C9 F3                        CALL    m_print_inline
0211   E1EB 0D 45 52 52                     .DB     CARRIAGE_RETURN, "ERROR: ", 0
0211   E1EF 4F 52 3A 20 
0211   E1F3 00 
0212   E1F4             
0213   E1F4 E1                              POP     HL
0214   E1F5             
0215   E1F5 7E          _ymodem_err_loop    LD      A, (HL)
0216   E1F6 23                              INC     HL
0217   E1F7 A7                              AND     A
0218   E1F8 CA 9A EF                        JP      Z, bios_conin                   ; Wait for a key then go to main menu..
0219   E1FB 4F                              LD      C, A
0220   E1FC E5                              PUSH    HL
0221   E1FD CD 00 F0                        CALL    bios_conout
0222   E200 E1                              POP     HL
0223   E201 18 F2                           JR      _ymodem_err_loop
0224   E203             
0225   E203 13 E2       _ymodem_errors      .DW     _y_msg_timeout
0226   E205 1D E2                           .DW     _y_msg_unknown
0227   E207 2E E2                           .DW     _y_msg_cancel     
0228   E209 37 E2                           .DW     _y_msg_packet
0229   E20B 44 E2                           .DW     _y_msg_length
0230   E20D 52 E2                           .DW     _y_msg_no_dest
0231   E20F 63 E2                           .DW     _y_msg_send
0232   E211 72 E2                           .DW     _y_msg_files
0233   E213             
0234   E213 54 69 6D 65 _y_msg_timeout      .DB     "Timeout", ESCAPE_CHAR, "K", 0
0234   E217 6F 75 74 1B 
0234   E21B 4B 00 
0235   E21D 55 6E 6B 6E _y_msg_unknown      .DB     "Unknown packet", ESCAPE_CHAR, "K", 0
0235   E221 6F 77 6E 20 
0235   E225 70 61 63 6B 
0235   E229 65 74 1B 4B 
0235   E22D 00 
0236   E22E 43 61 6E 63 _y_msg_cancel       .DB     "Cancel", ESCAPE_CHAR, "K", 0
0236   E232 65 6C 1B 4B 
0236   E236 00 
0237   E237 50 61 63 6B _y_msg_packet       .DB     "Packet (", 
0237   E23B 65 74 20 28 
0238   E23F             
0239   E23F 30 29 1B 4B _packet_err_code    .DB     "0)", ESCAPE_CHAR, "K", 0
0239   E243 00 
0240   E244             
0241   E244 46 69 6C 65 _y_msg_length       .DB     "File length", ESCAPE_CHAR, "K", 0
0241   E248 20 6C 65 6E 
0241   E24C 67 74 68 1B 
0241   E250 4B 00 
0242   E252 4E 6F 20 64 _y_msg_no_dest      .DB     "No destination", ESCAPE_CHAR, "K", 0
0242   E256 65 73 74 69 
0242   E25A 6E 61 74 69 
0242   E25E 6F 6E 1B 4B 
0242   E262 00 
0243   E263 53 65 6E 64 _y_msg_send         .DB     "Send Timeout", ESCAPE_CHAR, "K", 0
0243   E267 20 54 69 6D 
0243   E26B 65 6F 75 74 
0243   E26F 1B 4B 00 
0244   E272 4D 75 6C 74 _y_msg_files        .DB     "Multiple files", ESCAPE_CHAR, "K", 0
0244   E276 69 70 6C 65 
0244   E27A 20 66 69 6C 
0244   E27E 65 73 1B 4B 
0244   E282 00 
0245   E283             
0246   E283 CD C9 F3    _ymodem_success     CALL    m_print_inline           
0247   E286 0D 4F 4B 20                     .DB     CARRIAGE_RETURN, "OK ",0
0247   E28A 00 
0248   E28B 3A 73 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0249   E28E FE FF                           CP      0FFh
0250   E290 28 06                           JR      Z, _ymodem_no_high
0251   E292 C6 30                           ADD     A, '0'
0252   E294 4F                              LD      C, A
0253   E295 CD 00 F0                        CALL    bios_conout
0254   E298 3A 72 DE    _ymodem_no_high     LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0255   E29B CD D0 E8                        CALL    hex_out
0256   E29E 3A 71 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_low)
0257   E2A1 CD D0 E8                        CALL    hex_out
0258   E2A4 CD C9 F3                        CALL    m_print_inline
0259   E2A7 20 42 59 54                     .DB     " BYTES @ ", 0
0259   E2AB 45 53 20 40 
0259   E2AF 20 00 
0260   E2B1 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)
0261   E2B4 17                              RLA
0262   E2B5 38 10                           JR      C, _ymodem_show_addr
0263   E2B7 1F                              RRA
0264   E2B8 CD D0 E8                        CALL    hex_out
0265   E2BB 0E 2F                           LD      C, '/'
0266   E2BD CD 00 F0                        CALL    bios_conout
0267   E2C0 3A 79 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0268   E2C3 D6 40                           SUB     40h
0269   E2C5 18 03                           JR      _ymodem_addr
0270   E2C7             
0271   E2C7 3A 79 DE    _ymodem_show_addr   LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0272   E2CA CD D0 E8    _ymodem_addr        CALL    hex_out
0273   E2CD 3A 78 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0274   E2D0 CD D0 E8                        CALL    hex_out
0275   E2D3 CD C9 F3                        CALL    m_print_inline
0276   E2D6 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0277   E2D9 CD 71 EF    _ymodem_waitkey     CALL    bios_conist                  
0278   E2DC A7                              AND     A
0279   E2DD 28 FA                           JR      Z, _ymodem_waitkey
0280   E2DF             
0281   E2DF CD 9A EF                        CALL    bios_conin
0282   E2E2             
0283   E2E2             
0284   E2E2 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)      ; Do something with the file.
0285   E2E5 17                              RLA
0286   E2E6 30 06                           JR      NC, _ymodem_handle_page
0287   E2E8             
0288   E2E8 21 05 E4                        LD      HL, ymodem_mem_menu
0289   E2EB C3 42 E8                        JP      start_menu
0290   E2EE             
0291   E2EE             
0292   E2EE 21 32 E4    _ymodem_handle_page LD      HL, ymodem_page_menu
0293   E2F1 C3 42 E8                        JP      start_menu
0294   E2F4             
0295   E2F4 2A 78 DE    _ymodem_view        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0296   E2F7 22 72 E5                        LD      (monitor_address), HL
0297   E2FA C3 51 E6                        JP      edit_memory
0298   E2FD             
0299   E2FD 2A 78 DE    _ymodem_exec        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0300   E300 E5                              PUSH    HL
0301   E301 C9          _ymodem_exit        RET
0302   E302             
0303   E302 CD C9 F3    _ymodem_flash       CALL    m_print_inline
0304   E305 0D 0A 50 61                     .DB     CARRIAGE_RETURN, NEWLINE, "Page 00-1f >", ESCAPE_CHAR, "K", 0
0304   E309 67 65 20 30 
0304   E30D 30 2D 31 66 
0304   E311 20 3E 1B 4B 
0304   E315 00 
0305   E316             
0306   E316 06 02                           LD      B, 2
0307   E318 CD BC E7                        CALL    hex_input
0308   E31B CD 2E E8                        CALL    delete_or_enter
0309   E31E 3A 2C E8                        LD      A, (hex_input_result)
0310   E321 FE 1F                           CP      1fh
0311   E323 30 DD                           JR      NC, _ymodem_flash
0312   E325             
0313   E325 CD C9 F3                        CALL    m_print_inline
0314   E328 20 59 2F 4E                     .DB     " Y/N?", 0
0314   E32C 3F 00 
0315   E32E CD 9A EF                        CALL    bios_conin
0316   E331 FE 79                           CP      'y'
0317   E333 20 B9                           JR      NZ, _ymodem_handle_page
0318   E335             
0319   E335 CD C9 F3                        CALL    m_print_inline
0320   E338 0D 0A 57 72                     .DB     CARRIAGE_RETURN, NEWLINE, "Writing", ESCAPE_CHAR, "K", 0
0320   E33C 69 74 69 6E 
0320   E340 67 1B 4B 00 
0321   E344             
0322   E344 3A 2C E8                        LD      A, (hex_input_result)
0323   E347 17                              RLA
0324   E348 17                              RLA
0325   E349 57                              LD      D, A
0326   E34A             
0327   E34A 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0328   E34D 32 03 E4    _next_page          LD      (_ymodem_page), A
0329   E350 D3 71                           OUT     (IO_MEM_1), A
0330   E352             
0331   E352 2A 72 DE                        LD      HL, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0332   E355 7D                              LD      A, L
0333   E356 E6 C0                           AND     0c0h
0334   E358 B4                              OR      H
0335   E359 20 22                           JR      NZ, _full_page
0336   E35B             
0337   E35B ED 4B 71 DE                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0338   E35F 78                              LD      A, B
0339   E360 B1                              OR      C
0340   E361 28 06                           JR      Z, _flash_done
0341   E363 21 00 40                        LD      HL, 4000h
0342   E366 CD 88 FD                        CALL    flash_write
0343   E369             
0344   E369 3E 20       _flash_done         LD      A, RAM_PAGE_0
0345   E36B D3 70                           OUT     (IO_MEM_0), A
0346   E36D             
0347   E36D CD C9 F3                        CALL    m_print_inline
0348   E370 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0           
0348   E374 6E 65 20 1B 
0348   E378 4B 00 
0349   E37A C3 9A EF                        JP      bios_conin
0350   E37D             
0351   E37D 01 40 00    _full_page          LD      BC, 0040h
0352   E380 AF                              XOR     A
0353   E381 ED 42                           SBC     HL, BC
0354   E383 22 72 DE                        LD      (MONITOR_START-YMODEM_INFO+ym_length_mid), HL
0355   E386 21 00 40                        LD      HL, 4000h
0356   E389 44                              LD      B, H
0357   E38A 4D                              LD      C, L
0358   E38B CD 88 FD                        CALL    flash_write
0359   E38E 14                              INC     D
0360   E38F 3A 03 E4                        LD      A,(_ymodem_page)
0361   E392 3C                              INC     A
0362   E393 18 B8                           JR      _next_page
0363   E395             
0364   E395 3A 73 DE    _ymodem_firmware    LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0365   E398 A7                              AND     A
0366   E399 20 52                           JR      NZ, _not_firmware
0367   E39B 3A 72 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0368   E39E FE 40                           CP      040h
0369   E3A0 30 4B                           JR      NC, _not_firmware
0370   E3A2             
0371   E3A2 CD C9 F3                        CALL    m_print_inline
0372   E3A5 0D 57 72 69                     .DB     CARRIAGE_RETURN, "Write firmware, Y/N?", ESCAPE_CHAR, "K", 0
0372   E3A9 74 65 20 66 
0372   E3AD 69 72 6D 77 
0372   E3B1 61 72 65 2C 
0372   E3B5 20 59 2F 4E 
0372   E3B9 3F 1B 4B 00 
0373   E3BD CD 9A EF                        CALL    bios_conin
0374   E3C0 FE 79                           CP      'y'
0375   E3C2 C2 EE E2                        JP      NZ, _ymodem_handle_page
0376   E3C5             
0377   E3C5 ED 4B 71 DE                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0378   E3C9 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0379   E3CC D3 71                           OUT     (IO_MEM_1), A
0380   E3CE                                 
0381   E3CE 21 00 40                        LD      HL, 4000h
0382   E3D1 16 00                           LD      D, 0
0383   E3D3 CD 88 FD                        CALL    flash_write
0384   E3D6             
0385   E3D6 CD C9 F3                        CALL    m_print_inline
0386   E3D9 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0
0386   E3DD 6E 65 20 1B 
0386   E3E1 4B 00 
0387   E3E3 ED 5B 71 DE                     LD      DE, (MONITOR_START-YMODEM_INFO+ym_length_low)
0388   E3E7 CD C9 E8                        CALL    hex_word
0389   E3EA C3 9A EF                        JP      bios_conin
0390   E3ED             
0391   E3ED CD C9 F3    _not_firmware       CALL    m_print_inline
0392   E3F0 0D 0A 54 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Too large", ESCAPE_CHAR, "K", 0
0392   E3F4 6F 20 6C 61 
0392   E3F8 72 67 65 1B 
0392   E3FC 4B 00 
0393   E3FE C3 9A EF                        JP      bios_conin
0394   E401             
0395   E401             
0396   E401 00 00       _ymodem_address     .DW     0
0397   E403 00          _ymodem_page        .DB     0
0398   E404 00          _ymodem_set         .DB     0
0399   E405             
0400   E405 46 69 6C 65 ymodem_mem_menu     .DB     "File actions", 0
0400   E409 20 61 63 74 
0400   E40D 69 6F 6E 73 
0400   E411 00 
0401   E412 F4 E2                           .DW     _ymodem_view
0402   E414 56 69 65 77                     .DB     "View file", 0
0402   E418 20 66 69 6C 
0402   E41C 65 00 
0403   E41E FD E2                           .DW     _ymodem_exec
0404   E420 52 75 6E 00                     .DB     "Run", 0
0405   E424 01 E3                           .DW     _ymodem_exit
0406   E426 4D 61 69 6E                     .DB     "Main menu", 0
0406   E42A 20 6D 65 6E 
0406   E42E 75 00 
0407   E430 00 00                           .DW     0
0408   E432             
0409   E432 46 69 6C 65 ymodem_page_menu    .DB     "File actions", 0
0409   E436 20 61 63 74 
0409   E43A 69 6F 6E 73 
0409   E43E 00 
0410   E43F 02 E3                           .DW     _ymodem_flash
0411   E441 43 6F 70 79                     .DB     "Copy to flash", 0
0411   E445 20 74 6F 20 
0411   E449 66 6C 61 73 
0411   E44D 68 00 
0412   E44F F7 DF                           .DW     boot_without_format
0413   E451 43 50 4D 20                     .DB     "CPM Drive B", 0
0413   E455 44 72 69 76 
0413   E459 65 20 42 00 
0414   E45D 95 E3                           .DW     _ymodem_firmware
0415   E45F 55 70 64 61                     .DB     "Update firmware", 0
0415   E463 74 65 20 66 
0415   E467 69 72 6D 77 
0415   E46B 61 72 65 00 
0416   E46F 01 E3                           .DW     _ymodem_exit
0417   E471 4D 61 69 6E                     .DB     "Main menu", 0
0417   E475 20 6D 65 6E 
0417   E479 75 00 
0418   E47B 00 00                           .DW     0
0419   E47D             
0420   E47D 44 6F 77 6E ymodem_menu         .DB     "Download options", 0
0420   E481 6C 6F 61 64 
0420   E485 20 6F 70 74 
0420   E489 69 6F 6E 73 
0420   E48D 00 
0421   E48E CF E4                           .DW     _ymodem_from_file
0422   E490 41 64 64 72                     .DB     "Address from file", 0
0422   E494 65 73 73 20 
0422   E498 66 72 6F 6D 
0422   E49C 20 66 69 6C 
0422   E4A0 65 00 
0423   E4A2 F0 E4                           .DW     _ymodem_logical
0424   E4A4 43 50 55 20                     .DB     "CPU (Logical) address",0
0424   E4A8 28 4C 6F 67 
0424   E4AC 69 63 61 6C 
0424   E4B0 29 20 61 64 
0424   E4B4 64 72 65 73 
0424   E4B8 73 00 
0425   E4BA 26 E5                           .DW     _ymodem_physical
0426   E4BC 50 68 79 73                     .DB     "Physical address", 0
0426   E4C0 69 63 61 6C 
0426   E4C4 20 61 64 64 
0426   E4C8 72 65 73 73 
0426   E4CC 00 
0427   E4CD 00 00                           .DW     0
0428   E4CF             
0429   E4CF 11 FF FF    _ymodem_from_file   LD      DE, 0FFFFh
0430   E4D2 ED 53 01 E4                     LD      (_ymodem_address), DE
0431   E4D6 ED 53 03 E4                     LD      (_ymodem_page), DE
0432   E4DA CD C9 F3    _ymodem_transfer    CALL    m_print_inline
0433   E4DD 0D 53 74 61                     .DB     CARRIAGE_RETURN, "Start transfer", ESCAPE_CHAR, "K", 0
0433   E4E1 72 74 20 74 
0433   E4E5 72 61 6E 73 
0433   E4E9 66 65 72 1B 
0433   E4ED 4B 00 
0434   E4EF C9                              RET
0435   E4F0             
0436   E4F0 CD C9 F3    _ymodem_logical     CALL    m_print_inline
0437   E4F3 0D 41 64 64                     .DB     CARRIAGE_RETURN, "Address 0000-FFFF >", ESCAPE_CHAR, "K", 0
0437   E4F7 72 65 73 73 
0437   E4FB 20 30 30 30 
0437   E4FF 30 2D 46 46 
0437   E503 46 46 20 3E 
0437   E507 1B 4B 00 
0438   E50A 06 04                           LD      B, 4
0439   E50C CD BC E7                        CALL    hex_input
0440   E50F CD 2E E8                        CALL    delete_or_enter
0441   E512 3E FF                           LD      A, 0FFh
0442   E514 32 03 E4                        LD      (_ymodem_page), A
0443   E517             
0444   E517 ED 5B 2C E8 _ymodem_set_and_go  LD      DE, (hex_input_result)
0445   E51B ED 53 01 E4                     LD      (_ymodem_address), DE
0446   E51F 3E FF                           LD      A, 0FFh
0447   E521 32 04 E4                        LD      (_ymodem_set), A
0448   E524 18 B4                           JR      _ymodem_transfer
0449   E526             
0450   E526 CD C9 F3    _ymodem_physical    CALL    m_print_inline
0451   E529 0D 50 61 67                     .DB     CARRIAGE_RETURN, "Page 20-3F >", ESCAPE_CHAR, "K", 0
0451   E52D 65 20 32 30 
0451   E531 2D 33 46 20 
0451   E535 3E 1B 4B 00 
0452   E539 06 02                           LD      B, 2
0453   E53B CD BC E7                        CALL    hex_input
0454   E53E CD 2E E8                        CALL    delete_or_enter
0455   E541 3A 2C E8                        LD      A, (hex_input_result)
0456   E544 32 03 E4                        LD      (_ymodem_page), A
0457   E547 CD C9 F3                        CALL    m_print_inline
0458   E54A 0D 4F 66 66                     .DB     CARRIAGE_RETURN, "Offset 0000-3FFF >", ESCAPE_CHAR, "K", 0
0458   E54E 73 65 74 20 
0458   E552 30 30 30 30 
0458   E556 2D 33 46 46 
0458   E55A 46 20 3E 1B 
0458   E55E 4B 00 
0459   E560 06 04                           LD      B, 4
0460   E562 CD BC E7                        CALL    hex_input
0461   E565 CD 2E E8                        CALL    delete_or_enter
0462   E568 3A 2D E8                        LD      A, (hex_input_result+1)         ; YModem loads to page 1, so allow for offset..
0463   E56B F6 40                           OR      040h
0464   E56D 32 2D E8                        LD      (hex_input_result+1), A
0465   E570 18 A5                           JR      _ymodem_set_and_go
0466   E572             
0467   E572             ;------------------------------ Memory Editor --------------------------------------------
0468   E572             
0469   E572 00 80       monitor_address     .DW     08000h              ; Default address is 0x8000
0470   E574 00          monitor_mode        .DB     0                   ; 0 = show address + 3 characters, ~0 = hide address + 8 characters
0471   E575 00          edit_col            .DB     0                   ; Column currently being edited..
0472   E576 00 00       edit_digit          .DW     0
0473   E578             
0474   E578 CD 0E E7    memory_view         CALL    display_mem_row
0475   E57B             
0476   E57B CD 71 EF    _wait_key           CALL    bios_conist
0477   E57E A7                              AND     A
0478   E57F 28 FA                           JR      Z, _wait_key
0479   E581 CD 9A EF                        CALL    bios_conin
0480   E584             
0481   E584 FE 80                           CP      KEY_UP
0482   E586 20 0D                           JR      NZ, _not_up
0483   E588 2A 72 E5    memory_up           LD      HL, (monitor_address)
0484   E58B 11 08 00                        LD      DE, 8
0485   E58E ED 52                           SBC     HL, DE
0486   E590 22 72 E5                        LD      (monitor_address), HL
0487   E593 18 E3                           JR      memory_view
0488   E595             
0489   E595 FE 81       _not_up             CP      KEY_DOWN
0490   E597 20 0C                           JR      NZ, _not_down
0491   E599 2A 72 E5    memory_down         LD      HL, (monitor_address)
0492   E59C 11 08 00                        LD      DE, 8
0493   E59F 19                              ADD     HL, DE
0494   E5A0 22 72 E5                        LD      (monitor_address), HL
0495   E5A3 18 D3                           JR      memory_view
0496   E5A5             
0497   E5A5 FE 20       _not_down           CP      ' '
0498   E5A7 20 09                           JR      NZ, _not_space
0499   E5A9 3A 74 E5                        LD      A, (monitor_mode)
0500   E5AC 2F                              CPL
0501   E5AD 32 74 E5                        LD      (monitor_mode), A
0502   E5B0 18 C6                           JR      memory_view
0503   E5B2             
0504   E5B2 FE 0D       _not_space          CP      CARRIAGE_RETURN
0505   E5B4 28 0E                           JR      Z, _input_address
0506   E5B6             
0507   E5B6 FE 83                           CP      KEY_RIGHT
0508   E5B8 CA 51 E6                        JP      Z, edit_memory
0509   E5BB FE 08                           CP      KEY_BACKSPACE
0510   E5BD C8                              RET     Z
0511   E5BE             
0512   E5BE FE 78                           CP      'x'
0513   E5C0 28 1C                           JR      Z, execute
0514   E5C2 18 B7                           JR      _wait_key
0515   E5C4             
0516   E5C4 AF          _input_address      XOR     A
0517   E5C5 32 74 E5                        LD      (monitor_mode), A
0518   E5C8 CD 0E E7                        CALL    display_mem_row
0519   E5CB 0E 0D                           LD      C, CARRIAGE_RETURN
0520   E5CD CD 00 F0                        CALL    bios_conout
0521   E5D0             
0522   E5D0 06 04                           LD      B, 4
0523   E5D2 CD BC E7                        CALL    hex_input
0524   E5D5 2A 2C E8                        LD      HL, (hex_input_result)
0525   E5D8 22 72 E5                        LD      (monitor_address), HL
0526   E5DB C3 78 E5                        JP      memory_view
0527   E5DE             
0528   E5DE AF          execute             XOR     A
0529   E5DF 32 75 E5                        LD      (edit_col), A
0530   E5E2 CD C9 F3    execute_col         CALL    m_print_inline
0531   E5E5 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, "Execute from ", 0
0531   E5E9 45 78 65 63 
0531   E5ED 75 74 65 20 
0531   E5F1 66 72 6F 6D 
0531   E5F5 20 00 
0532   E5F7 21 35 E6                        LD      HL, _exec_done
0533   E5FA E5                              PUSH    HL
0534   E5FB 2A 72 E5                        LD      HL, (monitor_address)
0535   E5FE 3A 75 E5                        LD      A, (edit_col)
0536   E601 5F                              LD      E, A
0537   E602 16 00                           LD      D, 0
0538   E604 19                              ADD     HL, DE
0539   E605                                 
0540   E605 E5                              PUSH    HL
0541   E606 EB                              EX      DE, HL
0542   E607 CD C9 E8                        CALL    hex_word
0543   E60A CD C9 F3                        CALL    m_print_inline
0544   E60D 20 59 2F 4E                     .DB     " Y/N?", ESCAPE_CHAR, "K", 0
0544   E611 3F 1B 4B 00 
0545   E615             
0546   E615 CD 9A EF    _exec_loop          CALL    bios_conin
0547   E618 FE 79                           CP      'y'
0548   E61A 28 09                           JR      Z, _exec_go
0549   E61C FE 6E                           CP      'n'
0550   E61E 20 F5                           JR      NZ, _exec_loop
0551   E620 E1                              POP     HL
0552   E621 E1                              POP     HL
0553   E622 C3 78 E5                        JP      memory_view
0554   E625             
0555   E625 CD C9 F3    _exec_go            CALL    m_print_inline
0556   E628 0A 0D 52 75                     .DB     NEWLINE, CARRIAGE_RETURN, "Running", ESCAPE_CHAR, "K", 0
0556   E62C 6E 6E 69 6E 
0556   E630 67 1B 4B 00 
0557   E634 C9                              RET
0558   E635             
0559   E635 F5          _exec_done          PUSH    AF
0560   E636 CD C9 F3                        CALL    m_print_inline
0561   E639 0A 0D 44 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Done. A=",0
0561   E63D 6E 65 2E 20 
0561   E641 41 3D 00 
0562   E644 F1                              POP     AF
0563   E645 CD D0 E8                        CALL    hex_out
0564   E648 CD C9 F3                        CALL    m_print_inline
0565   E64B 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0566   E64E CD 9A EF                        CALL    bios_conin ;pause for a key, then return to memory edit at the execution location
0567   E651             
0568   E651             
0569   E651 AF          edit_memory         XOR     A
0570   E652 32 75 E5    _set_col_and_edit   LD      (edit_col), A
0571   E655 CD 0E E7    _edit_loop          CALL    display_mem_row
0572   E658 3A 75 E5                        LD      A, (edit_col)
0573   E65B 87                              ADD     A, A
0574   E65C 4F                              LD      C, A
0575   E65D 3A 74 E5                        LD      A, (monitor_mode)
0576   E660 A7                              AND     A
0577   E661 20 04                           JR      NZ, _address_hidden
0578   E663 3E 05                           LD      A, 5
0579   E665 81                              ADD     A, C
0580   E666 4F                              LD      C, A
0581   E667 3A 2D FF    _address_hidden     LD      A, (cursor_row)
0582   E66A C6 1F                           ADD     A, 31
0583   E66C 32 7D E6                        LD      (_edit_set_row), A
0584   E66F 79                              LD      A, C
0585   E670 C6 20                           ADD     A, 32
0586   E672 32 7E E6                        LD      (_edit_set_col), A
0587   E675             
0588   E675 CD C9 F3                        CALL    m_print_inline
0589   E678 1B 62 27                        .DB     ESCAPE_CHAR, 'b', CPM_NUM+8         ; Set the correct brightness
0590   E67B 1B 59                           .DB     ESCAPE_CHAR, 'Y'                    ; And position the cursor
0591   E67D 00          _edit_set_row       .DB     0
0592   E67E 00          _edit_set_col       .DB     0
0593   E67F 00                              .DB     0
0594   E680             
0595   E680 11 00 02                        LD      DE, 0200h
0596   E683 ED 53 76 E5 _edit_next_digit    LD      (edit_digit), DE
0597   E687             
0598   E687 CD 9A EF    _edit_input         CALL    bios_conin
0599   E68A FE 78                           CP      'x'
0600   E68C CA E2 E5                        JP      Z, execute_col
0601   E68F             
0602   E68F FE 83                           CP      KEY_RIGHT
0603   E691 20 1B                           JR      NZ, _not_right
0604   E693 3A 75 E5    _edit_right         LD      A, (edit_col)
0605   E696 FE 07                           CP      7
0606   E698 28 03                           JR      Z, _edit_wrap_down
0607   E69A 3C                              INC     A
0608   E69B 18 B5                           JR      _set_col_and_edit
0609   E69D             
0610   E69D AF          _edit_wrap_down     XOR     A
0611   E69E 32 75 E5                        LD      (edit_col),A
0612   E6A1 11 08 00    _edit_down          LD      DE, 08h
0613   E6A4 2A 72 E5    _edit_move          LD      HL, (monitor_address)
0614   E6A7 19                              ADD     HL, DE
0615   E6A8 22 72 E5                        LD      (monitor_address), HL
0616   E6AB C3 55 E6                        JP      _edit_loop
0617   E6AE             
0618   E6AE FE 82       _not_right          CP      KEY_LEFT
0619   E6B0 20 13                           JR      NZ, _not_left
0620   E6B2 3A 75 E5                        LD      A, (edit_col)
0621   E6B5 A7                              AND     A
0622   E6B6 28 03                           JR      Z, _edit_wrap_up
0623   E6B8 3D                              DEC     A
0624   E6B9 18 97                           JR      _set_col_and_edit
0625   E6BB             
0626   E6BB 3E 07       _edit_wrap_up       LD      A, 7
0627   E6BD 32 75 E5                        LD      (edit_col),A
0628   E6C0 11 F8 FF    _edit_up            LD      DE, 0FFF8h
0629   E6C3 18 DF                           JR      _edit_move
0630   E6C5             
0631   E6C5 FE 80       _not_left           CP      KEY_UP
0632   E6C7 CA C0 E6                        JP      Z, _edit_up
0633   E6CA FE 81                           CP      KEY_DOWN
0634   E6CC CA A1 E6                        JP      Z, _edit_down
0635   E6CF FE 08                           CP      KEY_BACKSPACE
0636   E6D1 C2 DF E6                        JP      NZ, _not_delete
0637   E6D4             
0638   E6D4 3A 77 E5                        LD      A, (edit_digit+1)
0639   E6D7 FE 02                           CP      2
0640   E6D9 CA 78 E5                        JP      Z, memory_view
0641   E6DC C3 55 E6                        JP      _edit_loop
0642   E6DF             
0643   E6DF CD F7 E8    _not_delete         CALL    valid_hex_char
0644   E6E2 38 A3                           JR      C, _edit_input
0645   E6E4             
0646   E6E4 4F                              LD      C, A
0647   E6E5 CD 07 E9                        CALL    hex_char_to_num
0648   E6E8 F5                              PUSH    AF
0649   E6E9 CD 00 F0                        CALL    bios_conout
0650   E6EC F1                              POP     AF
0651   E6ED                                 
0652   E6ED ED 5B 76 E5                     LD      DE, (edit_digit)
0653   E6F1 CB 23                           SLA     E
0654   E6F3 CB 23                           SLA     E
0655   E6F5 CB 23                           SLA     E
0656   E6F7 CB 23                           SLA     E
0657   E6F9 B3                              OR      E
0658   E6FA 5F                              LD      E, A
0659   E6FB 15                              DEC     D
0660   E6FC 20 85                           JR      NZ, _edit_next_digit
0661   E6FE             
0662   E6FE 3A 75 E5                        LD      A, (edit_col)
0663   E701 4F                              LD      C, A
0664   E702 06 00                           LD      B, 0
0665   E704 2A 72 E5                        LD      HL, (monitor_address)
0666   E707 09                              ADD     HL, BC
0667   E708 73                              LD      (HL), E
0668   E709 CD 0E E7                        CALL    display_mem_row
0669   E70C 18 85                           JR      _edit_right
0670   E70E             
0671   E70E 0E 0D       display_mem_row     LD      C, CARRIAGE_RETURN
0672   E710 CD 00 F0                        CALL    bios_conout
0673   E713 3A 74 E5                        LD      A, (monitor_mode)
0674   E716 A7                              AND     A
0675   E717 20 14                           JR      NZ, _hex_values
0676   E719             
0677   E719 CD C9 F3                        CALL    m_print_inline
0678   E71C 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0678   E720 00 
0679   E721             
0680   E721 ED 5B 72 E5                     LD      DE, (monitor_address)
0681   E725 CD C9 E8                        CALL    hex_word
0682   E728             
0683   E728 0E 20                           LD      C, ' '
0684   E72A CD 00 F0                        CALL    bios_conout
0685   E72D             
0686   E72D CD C9 F3    _hex_values         CALL    m_print_inline
0687   E730 1B 62 27 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+8, 0
0688   E734             
0689   E734 2A 72 E5                        LD      HL, (monitor_address)
0690   E737 06 08                           LD      B, 8
0691   E739 7E          _mem_hex            LD      A, (HL)
0692   E73A E5                              PUSH    HL
0693   E73B C5                              PUSH    BC
0694   E73C CD D0 E8                        CALL    hex_out
0695   E73F C1                              POP     BC
0696   E740 E1                              POP     HL
0697   E741 23                              INC     HL
0698   E742 10 F5                           DJNZ    _mem_hex
0699   E744             
0700   E744 CD C9 F3                        CALL    m_print_inline
0701   E747 1B 62 2E 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0702   E74B             
0703   E74B 2A 72 E5                        LD      HL, (monitor_address)
0704   E74E 06 03                           LD      B, 3
0705   E750 3A 74 E5                        LD      A, (monitor_mode)
0706   E753 A7                              AND     A
0707   E754 28 02                           JR      Z, _mem_char
0708   E756 06 08                           LD      B, 8
0709   E758             
0710   E758 7E          _mem_char           LD      A, (HL)
0711   E759 FE 20                           CP      ' '
0712   E75B D2 60 E7                        JP      NC, _not_control_char
0713   E75E 3E 2E                           LD      A, '.'
0714   E760 FE 80       _not_control_char   CP      128
0715   E762 DA 67 E7                        JP      C, _not_extended_char
0716   E765 3E 2E                           LD      A, '.'
0717   E767 E5          _not_extended_char  PUSH    HL
0718   E768 C5                              PUSH    BC
0719   E769 4F                              LD      C, A
0720   E76A CD 00 F0                        CALL    bios_conout
0721   E76D C1                              POP     BC
0722   E76E E1                              POP     HL
0723   E76F 23                              INC     HL
0724   E770 10 E6                           DJNZ    _mem_char
0725   E772 C9                              RET
0726   E773             
0727   E773             ; Format memory disk
0728   E773             ;
0729   E773 3E 01       format_memdisk      LD      A, 1
0730   E775 4F                              LD      C, A
0731   E776 CD F4 F2                        CALL    bios_seldsk
0732   E779             
0733   E779 21 80 00                        LD      HL, BIOS_SECTOR_ADDRESS     ; Sector buffer
0734   E77C 22 BA E7                        LD      (_fmt_address),HL
0735   E77F             
0736   E77F 54                              LD      D, H                        ; Fill sector buffer with 0E5h (blank byte)
0737   E780 5D                              LD      E, L
0738   E781 13                              INC     DE
0739   E782 3E E5                           LD      A, 0E5h
0740   E784 77                              LD      (HL),A
0741   E785 01 7F 00                        LD      BC, 07fh
0742   E788 ED B0                           LDIR
0743   E78A             
0744   E78A 3E 02                           LD      A,BIOS_BOOT_TRACKS          ; First track (Offset = 2)
0745   E78C 32 B8 E7    _fmt_track_loop     LD      (_fmt_track),A
0746   E78F 4F                              LD      C,A                         ; Set track
0747   E790 CD 0F F3                        CALL    bios_settrk
0748   E793             
0749   E793 AF                              XOR     A                           ; Initial sector
0750   E794 32 B9 E7    _fmt_sector_loop    LD      (_fmt_sector),A
0751   E797             
0752   E797 FE 1A                           CP      MEMDISK_SECTORS
0753   E799 28 14                           JR      Z,_fmt_next_track
0754   E79B 4F                              LD      C,A                         ; Set sector
0755   E79C CD 14 F3                        CALL    bios_setsec
0756   E79F ED 4B BA E7                     LD      BC,(_fmt_address)           ; Address to write from
0757   E7A3 CD 19 F3                        CALL    bios_setdma
0758   E7A6 CD 57 F3                        CALL    bios_write
0759   E7A9 3A B9 E7                        LD      A,(_fmt_sector)
0760   E7AC             
0761   E7AC 3C                              INC     A
0762   E7AD 18 E5                           JR      _fmt_sector_loop
0763   E7AF             
0764   E7AF 3A B8 E7    _fmt_next_track     LD      A,(_fmt_track)
0765   E7B2 FE 4F                           CP      MEMDISK_TRACKS
0766   E7B4 C8                              RET     Z
0767   E7B5 3C                              INC     A
0768   E7B6 18 D4                           JR      _fmt_track_loop
0769   E7B8             
0770   E7B8 00          _fmt_track          .DB     0
0771   E7B9 00          _fmt_sector         .DB     0
0772   E7BA 00 00       _fmt_address        .DW     0
0773   E7BC             
0774   E7BC             ;------------------------------------------------------
0775   E7BC             ; Read hex input into the (input_hex) address
0776   E7BC             ; Params - B = number of characters to input
0777   E7BC             ;
0778   E7BC 78          hex_input           LD      A, B
0779   E7BD 32 01 E8                        LD      (_hi_size), A
0780   E7C0 21 00 00                        LD      HL, 0
0781   E7C3 22 2C E8                        LD      (hex_input_result), HL
0782   E7C6             
0783   E7C6 C5          _hi_loop            PUSH    BC
0784   E7C7 CD EB E8    _hi_loop_join       CALL    hex_char_in
0785   E7CA FE 08                           CP      KEY_BACKSPACE
0786   E7CC 28 34                           JR      Z, _hi_delete
0787   E7CE 4F                              LD      C, A
0788   E7CF F5                              PUSH    AF
0789   E7D0 CD 00 F0                        CALL    bios_conout
0790   E7D3 F1                              POP     AF
0791   E7D4 CD 07 E9                        CALL    hex_char_to_num
0792   E7D7 2A 2C E8                        LD      HL, (hex_input_result)
0793   E7DA CB 27                           SLA     A
0794   E7DC CB 27                           SLA     A
0795   E7DE CB 27                           SLA     A
0796   E7E0 CB 27                           SLA     A
0797   E7E2             
0798   E7E2 CB 27                           SLA     A
0799   E7E4 CB 15                           RL      L
0800   E7E6 CB 14                           RL      H
0801   E7E8 CB 27                           SLA     A
0802   E7EA CB 15                           RL      L
0803   E7EC CB 14                           RL      H
0804   E7EE CB 27                           SLA     A
0805   E7F0 CB 15                           RL      L
0806   E7F2 CB 14                           RL      H
0807   E7F4 CB 27                           SLA     A
0808   E7F6 CB 15                           RL      L
0809   E7F8 CB 14                           RL      H
0810   E7FA 22 2C E8                        LD      (hex_input_result), HL
0811   E7FD C1                              POP     BC
0812   E7FE 10 C6                           DJNZ    _hi_loop
0813   E800 C9                              RET
0814   E801             
0815   E801 00          _hi_size            .DB     0
0816   E802             
0817   E802 C1          _hi_delete          POP     BC
0818   E803 3A 01 E8    _hi_delete_join     LD      A, (_hi_size)
0819   E806 B8                              CP      B
0820   E807 28 BD                           JR      Z, _hi_loop
0821   E809 04                              INC     B
0822   E80A C5                              PUSH    BC
0823   E80B             
0824   E80B 2A 2C E8                        LD      HL, (hex_input_result)
0825   E80E CB 3C                           SRL     H
0826   E810 CB 1D                           RR      L
0827   E812 CB 3C                           SRL     H
0828   E814 CB 1D                           RR      L
0829   E816 CB 3C                           SRL     H
0830   E818 CB 1D                           RR      L
0831   E81A CB 3C                           SRL     H
0832   E81C CB 1D                           RR      L
0833   E81E 22 2C E8                        LD      (hex_input_result), HL
0834   E821             
0835   E821 CD C9 F3                        CALL    m_print_inline
0836   E824 1B 44 20 1B                     .DB     ESCAPE_CHAR, "D ", ESCAPE_CHAR, "D", 0
0836   E828 44 00 
0837   E82A 18 9B                           JR      _hi_loop_join
0838   E82C             
0839   E82C 00 00       hex_input_result    .DW     0
0840   E82E             
0841   E82E             delete_or_enter     ; Wait for Delete or enter keys and handle..
0842   E82E CD 9A EF                        CALL    bios_conin
0843   E831 FE 0D                           CP      CARRIAGE_RETURN
0844   E833 C8                              RET     Z
0845   E834 06 00                           LD      B, 0
0846   E836 FE 08                           CP      KEY_BACKSPACE
0847   E838 CC 03 E8                        CALL    Z, _hi_delete_join
0848   E83B 18 F1                           JR      delete_or_enter
0849   E83D             
0850   E83D             
0851   E83D             ;------------------------------------------------------
0852   E83D             ; Menu system
0853   E83D 00          menu_index          .DB     0
0854   E83E 00 00       menu_address        .DW     0
0855   E840 00 00       menu_current        .DW     0
0856   E842             
0857   E842 AF          start_menu          XOR    A
0858   E843 32 3D E8                        LD     (menu_index), A
0859   E846 22 3E E8                        LD     (menu_address), HL
0860   E849             
0861   E849 CD 89 E8    _menu_loop          CALL   _display_menu
0862   E84C 01 58 02                        LD     BC, 600
0863   E84F CD 11 E9                        CALL   pause_for_ticks
0864   E852 CD 71 EF                        CALL   bios_conist
0865   E855 A7                              AND    A
0866   E856 C8                              RET    Z
0867   E857             
0868   E857 CD 9A EF    _menu_key           CALL   bios_conin
0869   E85A FE 81                           CP     KEY_DOWN
0870   E85C 20 09                           JR     NZ, _menu_up
0871   E85E             
0872   E85E 3A 3D E8                        LD      A, (menu_index)
0873   E861 3C                              INC     A
0874   E862 32 3D E8    _menu_set_index     LD      (menu_index),A
0875   E865 18 E2                           JR      _menu_loop
0876   E867             
0877   E867 FE 80       _menu_up            CP      KEY_UP
0878   E869 20 08                           JR      NZ, _menu_delete
0879   E86B 3A 3D E8                        LD      A, (menu_index)
0880   E86E 3D                              DEC     A
0881   E86F 28 D8                           JR      Z, _menu_loop
0882   E871 18 EF                           JR      _menu_set_index
0883   E873             
0884   E873 FE 08       _menu_delete        CP      KEY_BACKSPACE
0885   E875 C8                              RET     Z
0886   E876             
0887   E876 FE 0D       _menu_enter         CP      KEY_ENTER
0888   E878 20 CF                           JR      NZ, _menu_loop
0889   E87A 3A 3D E8                        LD      A, (menu_index)
0890   E87D A7                              AND     A
0891   E87E 28 C9                           JR      Z, _menu_loop
0892   E880 2A 40 E8                        LD      HL, (menu_current)
0893   E883 7E                              LD      A, (HL)
0894   E884 23                              INC     HL
0895   E885 66                              LD      H, (HL)
0896   E886 6F                              LD      L, A
0897   E887 E5                              PUSH    HL
0898   E888 C9                              RET
0899   E889             
0900   E889             
0901   E889             
0902   E889 0E 0D       _display_menu       LD      C, CARRIAGE_RETURN
0903   E88B CD 00 F0                        CALL    bios_conout
0904   E88E             
0905   E88E 3A 3D E8                        LD      A, (menu_index)
0906   E891 2A 3E E8                        LD      HL, (menu_address)
0907   E894 A7          _entry_loop         AND     A
0908   E895 28 12                           JR      Z, _display_entry
0909   E897 47                              LD      B, A
0910   E898 7E          _next_menu          LD      A, (HL)
0911   E899 23                              INC     HL
0912   E89A A7                              AND     A
0913   E89B 20 FB                           JR      NZ, _next_menu
0914   E89D             
0915   E89D 22 40 E8                        LD      (menu_current), HL
0916   E8A0 7E                              LD      A, (HL)
0917   E8A1 23                              INC     HL
0918   E8A2 5E                              LD      E, (HL)
0919   E8A3 23                              INC     HL
0920   E8A4 B3                              OR      E
0921   E8A5 28 19                           JR      Z, _menu_end
0922   E8A7 10 EF                           DJNZ    _next_menu
0923   E8A9                                 
0924   E8A9 7E          _display_entry      LD      A, (HL)
0925   E8AA A7                              AND     A
0926   E8AB 28 09                           JR      Z, _entry_end
0927   E8AD 4F                              LD      C, A
0928   E8AE E5                              PUSH    HL
0929   E8AF CD 00 F0                        CALL    bios_conout
0930   E8B2 E1                              POP     HL
0931   E8B3 23                              INC     HL
0932   E8B4 18 F3                           JR      _display_entry
0933   E8B6 0E 1B       _entry_end          LD      C, ESCAPE_CHAR
0934   E8B8 CD 00 F0                        CALL    bios_conout
0935   E8BB 0E 4B                           LD      C, 'K'
0936   E8BD C3 00 F0                        JP      bios_conout
0937   E8C0             
0938   E8C0 3A 3D E8    _menu_end           LD      A, (menu_index)
0939   E8C3 3D                              DEC     A
0940   E8C4 32 3D E8                        LD      (menu_index), A
0941   E8C7 18 C0                           JR      _display_menu
0942   E8C9             
0943   E8C9             
0944   E8C9             ;------------------------------------------------------
0945   E8C9             ; Write the Hex value of DE as four characters to conout
0946   E8C9             ;
0947   E8C9 D5          hex_word            PUSH    DE
0948   E8CA 7A                              LD      A, D
0949   E8CB CD D0 E8                        CALL    hex_out
0950   E8CE D1                              POP     DE
0951   E8CF 7B                              LD      A, E                ; Fall into hex_out..
0952   E8D0             
0953   E8D0             ;------------------------------------------------------
0954   E8D0             ; Write the Hex value of A as two characters to conout
0955   E8D0             ;
0956   E8D0 4F          hex_out             LD      C, A
0957   E8D1 CB 3F                           SRL     A
0958   E8D3 CB 3F                           SRL     A
0959   E8D5 CB 3F                           SRL     A
0960   E8D7 CB 3F                           SRL     A
0961   E8D9 C5                              PUSH    BC
0962   E8DA CD DF E8                        CALL    _nibble
0963   E8DD C1                              POP     BC
0964   E8DE 79                              LD      A, C
0965   E8DF             
0966   E8DF E6 0F       _nibble             AND     $0F      ;LOW NIBBLE ONLY
0967   E8E1 C6 90                           ADD     A,$90
0968   E8E3 27                              DAA 
0969   E8E4 CE 40                           ADC     A,$40
0970   E8E6 27                              DAA 
0971   E8E7 4F                              LD      C,A
0972   E8E8 C3 00 F0                        JP      bios_conout
0973   E8EB             
0974   E8EB             
0975   E8EB             ;------------------------------------------------------
0976   E8EB             ; Only accept hex characters (0-9, a-f), or DELETE from the input
0977   E8EB             ; Returns with character in A, a-f are capitalised
0978   E8EB             ;
0979   E8EB CD 9A EF    hex_char_in         CALL    bios_conin
0980   E8EE FE 08                           CP      KEY_BACKSPACE
0981   E8F0 C8                              RET     Z
0982   E8F1 CD F7 E8                        CALL    valid_hex_char
0983   E8F4 38 F5                           JR      C, hex_char_in
0984   E8F6 C9                              RET
0985   E8F7             ;
0986   E8F7             ; Return with carry CLEAR if the character is a valid hex digit
0987   E8F7             ; Enter with A = character to test
0988   E8F7             ; Returns with A capitalised
0989   E8F7 FE 30       valid_hex_char      CP      '0'
0990   E8F9 D8                              RET     C
0991   E8FA FE 3A                           CP      ':'
0992   E8FC 3F                              CCF
0993   E8FD D0                              RET     NC
0994   E8FE FE 61                           CP      'a'
0995   E900 D8                              RET     C
0996   E901 FE 67                           CP      'g'
0997   E903 CB AF                           RES     5, a                ; Capitalise it..
0998   E905 3F                              CCF
0999   E906 C9                              RET
1000   E907             
1001   E907 FE 41       hex_char_to_num     CP      'A'
1002   E909 30 03                           JR      NC, _alpha_char
1003   E90B D6 30                           SUB     '0'
1004   E90D C9                              RET
1005   E90E D6 37       _alpha_char         SUB     'A'-10
1006   E910 C9                              RET
1007   E911             
1008   E911             ;
1009   E911             ; Pause for BC ticks
1010   E911             ; Uses HL, DE
1011   E911             ;
1012   E911 ED 5B 04 FF pause_for_ticks     LD      DE, (timer)
1013   E915 C5          _pause_loop         PUSH    BC
1014   E916 D5                              PUSH    DE
1015   E917 CD 71 EF                        CALL    bios_conist
1016   E91A D1                              POP     DE
1017   E91B C1                              POP     BC
1018   E91C A7                              AND     A
1019   E91D C0                              RET     NZ
1020   E91E 2A 04 FF                        LD      HL, (timer)
1021   E921 ED 52                           SBC     HL, DE
1022   E923 ED 42                           SBC     HL, BC
1023   E925 38 EE                           JR      C, _pause_loop
1024   E927 C9                              RET
1025   E928             ;
1026   E928             ; Detect (and time) interrupt
1027   E928             ; Enter with A containing the mask for which bits of the timer byte we check for zero
1028   E928             ; Return when the timer is zero, with BC containing 72 + 48*t-states taken
1029   E928             ;
1030   E928 01 00 00    detect_int          LD      BC, 0
1031   E92B 57                              LD      D, A
1032   E92C 3A 04 FF    _wait_for_tick      LD      A, (timer)               ; 13            ; Loop = 13+4+5+6+4+4+12 (=48) * BC + (13 + 4 + 11 + 13 + 4 + 17 + 10 (CALL)) = 72
1033   E92F A2                              AND     D                        ; 4
1034   E930 C8                              RET     Z                        ; 5 / 11
1035   E931 03                              INC     BC                       ; 6
1036   E932 79                              LD      A, C                     ; 4
1037   E933 B0                              OR      B                        ; 4
1038   E934 20 F6                           JR      NZ, _wait_for_tick       ; 7 / 12
1039   E936 C9                              RET
1040   E937             ;
1041   E937             ; Fast int routine to allow us to time CPU speed
1042   E937             ;
1043   E937 F3          timer_int           DI
1044   E938 E5                              PUSH    HL
1045   E939 2A 04 FF                        LD      HL, (timer)
1046   E93C 23                              INC     HL
1047   E93D 22 04 FF                        LD      (timer), HL
1048   E940 E1                              POP     HL
1049   E941 FB                              EI
1050   E942 ED 4D                           RETI
1051   E944             
1052   E944             ; Divide HL by C (unsigned)
1053   E944             ;Inputs:
1054   E944             ;     HL is the numerator
1055   E944             ;     C is the denominator
1056   E944             ;Outputs:
1057   E944             ;     A is the remainder
1058   E944             ;     B is 0
1059   E944             ;     C is not changed
1060   E944             ;     DE is not changed
1061   E944             ;     HL is the quotient
1062   E944             ;
1063   E944             divide_hl_c
1064   E944 06 10                           LD      B, 16
1065   E946 AF                              XOR     A
1066   E947 29          _div0               ADD     HL, HL
1067   E948 17                              RLA
1068   E949 B9                              CP      C
1069   E94A 38 02                           JR      C,_div1
1070   E94C 2C                              INC     L
1071   E94D 91                              SUB     C
1072   E94E 10 F7       _div1               DJNZ    _div0
1073   E950 C9                              RET
1074   E951             
1075   E951             ;
1076   E951             ; Convert DE to a five digit BCD value stored in bcd_scratch
1077   E951             ; 
1078   E951 AF          de_to_bcd           XOR     A
1079   E952 21 89 E9                        LD      HL, bcd_scratch
1080   E955 06 05                           LD      B, 5
1081   E957 77          _clear_scratch      LD      (HL), A
1082   E958 23                              INC     HL
1083   E959 10 FC                           DJNZ    _clear_scratch
1084   E95B                 
1085   E95B 06 10                           LD      B, 16           ; Convert 16 bits
1086   E95D 0E 05       _bcd_loop           LD      C, 5
1087   E95F 21 89 E9                        LD      HL, bcd_scratch
1088   E962 7E          _correct_digits     LD      A, (HL)
1089   E963 FE 05                           CP      5
1090   E965 38 03                           JR      C, _digit_ok
1091   E967 C6 03                           ADD     A, 3
1092   E969 77                              LD      (HL), A
1093   E96A 23          _digit_ok           INC     HL
1094   E96B 0D                              DEC     C
1095   E96C 20 F4                           JR      NZ, _correct_digits                   
1096   E96E             
1097   E96E 21 89 E9                        LD      HL, bcd_scratch
1098   E971 0E 05                           LD      C, 5
1099   E973 CB 23                           SLA     E
1100   E975 CB 12                           RL      D
1101   E977             
1102   E977 7E          _shift_digits       LD      A, (HL)
1103   E978 CB 17                           RL      A
1104   E97A CB 67                           BIT     4, A
1105   E97C 28 03                           JR      Z, _skip_carry
1106   E97E E6 0F                           AND     0Fh
1107   E980 37                              SCF
1108   E981 77          _skip_carry         LD      (HL), A
1109   E982 23                              INC     HL
1110   E983 0D                              DEC     C
1111   E984 20 F1                           JR      NZ, _shift_digits
1112   E986 10 D5                           DJNZ    _bcd_loop
1113   E988 C9                              RET
1114   E989             
1115   E989 00 00 00 00 bcd_scratch         .DB      0,0,0,0,0      ; Five bytes - 0 to 99,999. Smallest digit (units) first
1115   E98D 00 
1116   E98E             
1117   E98E                                 .INCLUDE  "monitor_rtc.asm"
0001+  E98E             ;
0002+  E98E             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E98E             ;
0004+  E98E             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E98E             ;
0006+  E98E             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E98E             ; of this software and associated documentation files (the "Software"), to deal
0008+  E98E             ; in the Software without restriction, including without limitation the rights
0009+  E98E             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E98E             ; copies of the Software, and to permit persons to whom the Software is
0011+  E98E             ; furnished to do so, subject to the following conditions:
0012+  E98E             ; 
0013+  E98E             ; The above copyright notice and this permission notice shall be included in all
0014+  E98E             ; copies or substantial portions of the Software.
0015+  E98E             ; 
0016+  E98E             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E98E             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E98E             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E98E             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E98E             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E98E             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E98E             ; SOFTWARE.
0023+  E98E             ;
0024+  E98E                                     .MODULE monitor_rtc
0025+  E98E             
0026+  E98E             _offset_sec             .EQU    0
0027+  E98E             _offset_min             .EQU    1
0028+  E98E             _offset_hour            .EQU    2
0029+  E98E             _offset_wkday           .EQU    3
0030+  E98E             _offset_date            .EQU    4
0031+  E98E             _offset_month           .EQU    5
0032+  E98E             _offset_year            .EQU    6
0033+  E98E             
0034+  E98E             
0035+  E98E CD 73 EA    rtc_display_time        CALL    rtc_get_time
0036+  E991 0E 0D                               LD      C, CARRIAGE_RETURN
0037+  E993 CD 00 F0                            CALL    bios_conout
0038+  E996                                     
0039+  E996 3A E4 FC                            LD      A, (time_scratch+_offset_wkday)
0040+  E999 21 27 EA                            LD      HL, weekdays
0041+  E99C E6 07                               AND     7
0042+  E99E 4F                                  LD      C, A
0043+  E99F             
0044+  E99F CD 11 EA                            CALL    _search_word
0045+  E9A2                                     
0046+  E9A2 CD F2 E9    _get_date               CALL    _space
0047+  E9A5 3A E5 FC                            LD      A, (time_scratch+_offset_date)
0048+  E9A8 E6 3F                               AND     03Fh
0049+  E9AA CD F7 E9                            CALL    _two_chars
0050+  E9AD CD F2 E9                            CALL    _space
0051+  E9B0             
0052+  E9B0 3A E6 FC                            LD      A, (time_scratch+_offset_month)
0053+  E9B3 21 43 EA                            LD      HL, _months
0054+  E9B6 E6 1F                               AND     01fh
0055+  E9B8 CB 67                               BIT     4, A
0056+  E9BA 28 02                               JR      Z, _month_ok
0057+  E9BC D6 06                               SUB     6
0058+  E9BE 4F          _month_ok               LD      C,A
0059+  E9BF             
0060+  E9BF CD 11 EA                            CALL    _search_word
0061+  E9C2 CD F2 E9                            CALL    _space
0062+  E9C5 3E 20                               LD      A, 20h
0063+  E9C7 CD F7 E9                            CALL    _two_chars
0064+  E9CA             
0065+  E9CA 3A E7 FC                            LD      A, (time_scratch+_offset_year)
0066+  E9CD CD F7 E9                            CALL    _two_chars
0067+  E9D0 CD F2 E9                            CALL    _space
0068+  E9D3             
0069+  E9D3 3A E3 FC                            LD      A, (time_scratch+_offset_hour)
0070+  E9D6 E6 3F                               AND     03fh
0071+  E9D8 CD F7 E9                            CALL    _two_chars
0072+  E9DB CD F2 E9                            CALL    _space
0073+  E9DE             
0074+  E9DE 3A E2 FC                            LD      A, (time_scratch+_offset_min)
0075+  E9E1 E6 7F                               AND     07fh
0076+  E9E3 CD F7 E9                            CALL    _two_chars
0077+  E9E6 CD F2 E9                            CALL    _space
0078+  E9E9             
0079+  E9E9 3A E1 FC                            LD      A, (time_scratch+_offset_sec)
0080+  E9EC E6 7F                               AND     07fh
0081+  E9EE CD F7 E9                            CALL    _two_chars
0082+  E9F1 C9                                  RET
0083+  E9F2             
0084+  E9F2 0E 20       _space                  LD      C, ' '
0085+  E9F4 C3 00 F0                            JP      bios_conout
0086+  E9F7             
0087+  E9F7 4F          _two_chars              LD      C,A
0088+  E9F8 CB 3F                               SRL     A
0089+  E9FA CB 3F                               SRL     A
0090+  E9FC CB 3F                               SRL     A
0091+  E9FE CB 3F                               SRL     A
0092+  EA00 C6 30                               ADD     A, '0'
0093+  EA02 C5                                  PUSH    BC
0094+  EA03 4F                                  LD      C, A
0095+  EA04 CD 00 F0                            CALL    bios_conout
0096+  EA07 C1                                  POP     BC
0097+  EA08 79                                  LD      A,C
0098+  EA09 E6 0F                               AND     0fh
0099+  EA0B C6 30                               ADD     A, '0'
0100+  EA0D 4F                                  LD      C, A
0101+  EA0E C3 00 F0                            JP      bios_conout
0102+  EA11             ;
0103+  EA11             ; Search table pointed to by HL for the C'th word (1-based)
0104+  EA11             ; Prints the chosen word to conout
0105+  EA11             ;
0106+  EA11 0D          _search_word            DEC     C
0107+  EA12 20 0C                               JR      NZ, _next_char
0108+  EA14                                     
0109+  EA14 7E          _print_word             LD      A, (HL)
0110+  EA15 23                                  INC     HL
0111+  EA16 A7                                  AND     A
0112+  EA17 C8                                  RET     Z
0113+  EA18 4F                                  LD      C, A
0114+  EA19 E5                                  PUSH    HL
0115+  EA1A CD 00 F0                            CALL    bios_conout
0116+  EA1D E1                                  POP     HL
0117+  EA1E 18 F4                               JR      _print_word
0118+  EA20             
0119+  EA20 7E          _next_char              LD      A, (HL)
0120+  EA21 23                                  INC     HL
0121+  EA22 A7                                  AND     A
0122+  EA23 20 FB                               JR      NZ, _next_char
0123+  EA25 18 EA                               JR      _search_word
0124+  EA27             
0125+  EA27             
0126+  EA27 4D 6F 6E 00 weekdays                .DB "Mon",0
0127+  EA2B 54 75 65 00                         .DB "Tue",0
0128+  EA2F 57 65 64 00                         .DB "Wed",0
0129+  EA33 54 68 75 00                         .DB "Thu",0
0130+  EA37 46 72 69 00                         .DB "Fri",0
0131+  EA3B 53 61 74 00                         .DB "Sat",0
0132+  EA3F 53 75 6E 00                         .DB "Sun",0
0133+  EA43             
0134+  EA43 4A 61 6E 00 _months                 .DB "Jan",0
0135+  EA47 46 65 62 00                         .DB "Feb",0
0136+  EA4B 4D 61 72 00                         .DB "Mar",0
0137+  EA4F 41 70 72 00                         .DB "Apr",0
0138+  EA53 4D 61 79 00                         .DB "May",0
0139+  EA57 4A 75 6E 00                         .DB "Jun",0
0140+  EA5B 4A 75 6C 00                         .DB "Jul",0
0141+  EA5F 41 75 67 00                         .DB "Aug",0
0142+  EA63 53 65 70 00                         .DB "Sep",0
0143+  EA67 4F 63 74 00                         .DB "Oct",0
0144+  EA6B 4E 6F 76 00                         .DB "Nov",0
0145+  EA6F 44 65 63 00                         .DB "Dec",0
0146+  EA73             
0147+  EA73             ;
0148+  EA73             ; Read the time into the temp_data area
0149+  EA73             ; Returns with Carry SET if successful, else Carry CLEAR
0150+  EA73             ;
0151+  EA73 26 6F       rtc_get_time            LD      H, RTC_ADDRESS
0152+  EA75 2E 00                               LD      L, RTC_REG_SEC
0153+  EA77 CD 1B F9                            CALL    i2c_read_from
0154+  EA7A 30 18                               JR      NC, _get_error
0155+  EA7C 21 E1 FC                            LD      HL, time_scratch
0156+  EA7F 06 07                               LD      B, 7
0157+  EA81 18 08                               JR      _store_time
0158+  EA83 C5          _get_loop               PUSH    BC 
0159+  EA84 CD 70 F9                            CALL    i2c_ack
0160+  EA87 CD 5D F9                            CALL    i2c_read
0161+  EA8A C1                                  POP     BC
0162+  EA8B 77          _store_time             LD      (HL), A
0163+  EA8C 23                                  INC     HL
0164+  EA8D 10 F4                               DJNZ    _get_loop
0165+  EA8F CD 04 F9                            CALL    i2c_stop
0166+  EA92 37                                  SCF
0167+  EA93 C9                                  RET
0168+  EA94             
0169+  EA94 CD 04 F9    _get_error              CALL    i2c_stop
0170+  EA97 CD C9 F3                            CALL    m_print_inline 
0171+  EA9A 45 72 72 6F                         .DB     "Error getting time\r\n", 0
0171+  EA9E 72 20 67 65 
0171+  EAA2 74 74 69 6E 
0171+  EAA6 67 20 74 69 
0171+  EAAA 6D 65 0D 0A 
0171+  EAAE 00 
0172+  EAAF AF                                  XOR     A
0173+  EAB0 C9                                  RET
0174+  EAB1             
0175+  EAB1                                     .MODULE main1118   EAB1                                 .INCLUDE "ymodem.asm"
0001+  EAB1             ;
0002+  EAB1             ; YModem implementation.
0003+  EAB1             ; File format: The filename MAY indicate the load address in memory for the file. If so, the format is:
0004+  EAB1             ;       filename_mHHHH.suffix
0005+  EAB1             ;    or filename_pHH.suffix
0006+  EAB1             ;
0007+  EAB1             ; Where:  _mHHHH indicates a preferred destination address of HHHH (in memory) - four digits hexadecimal value (uppercase).
0008+  EAB1             ;   or    _pHH   indicates the page in memory that the file is intended for (assumes start at offset 0 in page..)
0009+  EAB1             ;
0010+  EAB1             ; When _p is used, the file is always written to bank 1 - address 4000h. It is expected that the calling program will
0011+  EAB1             ; then copy the data to the target page, which can be retrieved from the ym_file_mode return value.
0012+  EAB1             ; 
0013+  EAB1             ;
0014+  EAB1             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0015+  EAB1             ;
0016+  EAB1             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0017+  EAB1             ;
0018+  EAB1             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0019+  EAB1             ; of this software and associated documentation files (the "Software"), to deal
0020+  EAB1             ; in the Software without restriction, including without limitation the rights
0021+  EAB1             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0022+  EAB1             ; copies of the Software, and to permit persons to whom the Software is
0023+  EAB1             ; furnished to do so, subject to the following conditions:
0024+  EAB1             ; 
0025+  EAB1             ; The above copyright notice and this permission notice shall be included in all
0026+  EAB1             ; copies or substantial portions of the Software.
0027+  EAB1             ; 
0028+  EAB1             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0029+  EAB1             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0030+  EAB1             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0031+  EAB1             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0032+  EAB1             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0033+  EAB1             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0034+  EAB1             ; SOFTWARE.
0035+  EAB1             ;
0036+  EAB1             
0037+  EAB1                                 .MODULE ymodem
0038+  EAB1             
0039+  EAB1             _PAGE_PREFIX        .EQU    'p'
0040+  EAB1             _DEST_PREFIX        .EQU    'm'
0041+  EAB1             
0042+  EAB1             ; Return values
0043+  EAB1             YMODEM_SUCCESS      .EQU    000h
0044+  EAB1             YMODEM_TIMEOUT      .EQU    001h
0045+  EAB1             YMODEM_UNKNOWN      .EQU    002h            ; Unknown packet type (Packet byte in C)
0046+  EAB1             YMODEM_CANCEL       .EQU    003h            ; Cancelled by sender
0047+  EAB1             YMODEM_PACKET_ERROR .EQU    004h            ; Packet data error (Error code in C)
0048+  EAB1             YMODEM_LENGTH_ERROR .EQU    005h            ; Length data in zeroth packet is invalid
0049+  EAB1             YMODEM_NO_DEST      .EQU    006h            ; No destination provided
0050+  EAB1             YMODEM_SEND_TIMEOUT .EQU    007h
0051+  EAB1             YMODEM_MULTI_FILES  .EQU    008h            ; Cannot receive more than one file 
0052+  EAB1             
0053+  EAB1             _SOH                .EQU    001h            ; 128 byte data packet header
0054+  EAB1             _STX                .EQU    002h            ; 1024 byte data packet header
0055+  EAB1             _EOT                .EQU    004h            ; End transfer
0056+  EAB1             _ACK                .EQU    006h            ; Respond
0057+  EAB1             _NAK                .EQU    015h            ; No response
0058+  EAB1             _CAN                .EQU    018h            ; Transmission aborted
0059+  EAB1             _C                  .EQU    043h            ; Request packet
0060+  EAB1             
0061+  EAB1             _SOH_PACKET_SIZE    .EQU    128
0062+  EAB1             _STX_PACKET_SIZE    .EQU    1024
0063+  EAB1             _FRAME_OVERHEAD     .EQU    5               ; Three byte header + two byte CRC (high byte first)
0064+  EAB1             
0065+  EAB1             _TIMEOUT_COUNT      .EQU    50000
0066+  EAB1             
0067+  EAB1             _ERR_PACKET_COUNT   .EQU    1               ; Wrong packet index
0068+  EAB1             _ERR_CHECK_HIGH     .EQU    2               ; High byte of CRC failed
0069+  EAB1             _ERR_CHECK_LOW      .EQU    3               ; Low byte of CRC failed
0070+  EAB1             _ERR_CANCEL         .EQU    4               ; Got a cancel request without second cancel
0071+  EAB1             _ERR_ZERO_PACKET    .EQU    5               ; Zeroth packet must be SOH
0072+  EAB1             
0073+  EAB1             YM_DEST_FROM_FILE   .EQU    0FEh            ; File destination set from filename
0074+  EAB1             
0075+  EAB1             ymodem_data_length  .EQU    17              ; Size of data block before buffer
0076+  EAB1             
0077+  EAB1             ym_file_mode        .EQU    -17             ; FFh : Normal transfer,  FEh : Destination set by file, 0-7Fh : Page write 
0078+  EAB1             ym_file_count       .EQU    -16
0079+  EAB1             ym_length_low       .EQU    -15             ; Length specified in header packet
0080+  EAB1             ym_length_mid       .EQU    -14
0081+  EAB1             ym_length_high      .EQU    -13
0082+  EAB1             ym_loaded_high      .EQU    -12             ; Tracks high byte of length during load.
0083+  EAB1             ym_soh_saved_len    .EQU    -11             ; We have to copy part of a final SOH packet from the buffer - track actual length needed
0084+  EAB1             ym_soh_saved_len_h  .EQU    -10 
0085+  EAB1             ym_current_page     .EQU    -9              ; FFh if no paging, otherwise page to send data to
0086+  EAB1             ym_dest_low         .EQU    -8              ; If specified in file header - the destination address of the file
0087+  EAB1             ym_dest_high        .EQU    -7
0088+  EAB1             ym_current_packet   .EQU    -6              ; Expected packet number
0089+  EAB1             ym_packet_type      .EQU    -5              ; Packet type - SOH/STX
0090+  EAB1             ym_packet_num       .EQU    -4              ; Packet number we're currently receiving
0091+  EAB1             ym_packet_num_cpl   .EQU    -3              ; Complement..
0092+  EAB1             ym_crc_low          .EQU    -2              ; CRC Low byte
0093+  EAB1             ym_crc_high         .EQU    -1              ; CRC High byte
0094+  EAB1             
0095+  EAB1             YMODEM_BUFFER       .EQU    _SOH_PACKET_SIZE + ymodem_data_length
0096+  EAB1             YMODEM_INFO         .EQU    _SOH_PACKET_SIZE
0097+  EAB1             
0098+  EAB1             ;
0099+  EAB1             ; ymodem - Main entry point. Call with:
0100+  EAB1             ;     HL = Address of YMODEM_BUFFER (=128 + ymodem_data_length) byte buffer for receiving data
0101+  EAB1             ;     DE = (Optional) address to write data. 0xFFFF to accept destination from filename otherwise
0102+  EAB1             ;      A = Page to write data. 0xFF to disable paging/accept page from filename otherwise
0103+  EAB1             ;
0104+  EAB1             ; If using A to set a Page destination, DE should be an offset within Bank 1 (ie 4000h - 7FFFh)
0105+  EAB1             ; If the file specifies a page destination, DE is initialised to 4000h - the start of the page
0106+  EAB1             ;
0107+  EAB1             ; Returns status code in A:
0108+  EAB1             ;     YMODEM_SUCCESS : (=0) If the file was successfully received
0109+  EAB1             ;     YMODEM_xxxx    : (Non zero) If the receiver timed out waiting for a byte
0110+  EAB1             ;
0111+  EAB1             ; Note Bank 1 may have been set to a new page destination if one was specified.
0112+  EAB1             
0113+  EAB1 01 11 00    ymodem              LD      BC, ymodem_data_length      ; Skip data block at start of buffer
0114+  EAB4 09                              ADD     HL, BC
0115+  EAB5 E5                              PUSH    HL
0116+  EAB6 DD E1                           POP     IX
0117+  EAB8 DD 77 F7                        LD      (IX+ym_current_page), A
0118+  EABB DD 77 EF                        LD      (IX+ym_file_mode), A           ; Default normal transfer, 0FFh, else page 
0119+  EABE AF                              XOR     A                           
0120+  EABF DD 77 F0                        LD      (IX+ym_file_count), A
0121+  EAC2 3D                              DEC     A
0122+  EAC3 DD 73 F8                        LD      (IX+ym_dest_low), E
0123+  EAC6 DD 72 F9                        LD      (IX+ym_dest_high), D
0124+  EAC9             
0125+  EAC9 AF          _ymodem_start       XOR     A                           ; Set initial packet number
0126+  EACA DD 77 FA                        LD      (IX+ym_current_packet), A
0127+  EACD FD 21 FF FF                     LD      IY, 0FFFFh                  ; IY - bytes to load. Default - load all bytes
0128+  EAD1             
0129+  EAD1                                 ; Now we can load.
0130+  EAD1                                 ; DE = destination
0131+  EAD1                                 ; IY = low 16 bits of length
0132+  EAD1                                 ; IX = load buffer
0133+  EAD1             
0134+  EAD1 CD 5E ED    _packet_loop        CALL    _recieve_safe
0135+  EAD4 20 07                           JR      NZ, _packet_byte
0136+  EAD6 3E 43       _send_crc_and_loop  LD      A, _C
0137+  EAD8 CD 89 ED                        CALL    _send_byte
0138+  EADB 18 F4                           JR      _packet_loop
0139+  EADD             
0140+  EADD FE 01       _packet_byte        CP      _SOH
0141+  EADF C2 EA EA                        JP      NZ, _check_stx
0142+  EAE2             
0143+  EAE2 DD E5                           PUSH    IX                          ; SOH - May be zero'th or last packet
0144+  EAE4 E1                              POP     HL
0145+  EAE5 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0146+  EAE8 18 40                           JR      _receive_packet
0147+  EAEA             
0148+  EAEA FE 02       _check_stx          CP      _STX
0149+  EAEC 20 07                           JR      NZ, _check_eot
0150+  EAEE                                                                     
0151+  EAEE 62                              LD      H, D                        ; STX packets go straight to DE
0152+  EAEF 6B                              LD      L, E
0153+  EAF0 01 00 04                        LD      BC, _STX_PACKET_SIZE    
0154+  EAF3 18 35                           JR      _receive_packet
0155+  EAF5             
0156+  EAF5 FE 04       _check_eot          CP      _EOT
0157+  EAF7 20 0A                           JR      NZ, _check_can
0158+  EAF9                                                                     ; End of transmission
0159+  EAF9 3E 06                           LD      A, _ACK 
0160+  EAFB CD 89 ED                        CALL    _send_byte
0161+  EAFE             
0162+  EAFE DD 34 F0                        INC     (IX+ym_file_count)      
0163+  EB01 18 C6                           JR      _ymodem_start  
0164+  EB03             
0165+  EB03 FE 18       _check_can          CP      _CAN
0166+  EB05 20 1E                           JR      NZ, _unknown_packet
0167+  EB07                                                                     ; Single cancel request. Check for another
0168+  EB07 CD 69 ED                        CALL    _receive_byte
0169+  EB0A FE 18                           CP      _CAN
0170+  EB0C 3E 04                           LD      A, _ERR_CANCEL
0171+  EB0E 20 10                           JR      NZ, _packet_error
0172+  EB10             
0173+  EB10 3E 06                           LD      A, _ACK 
0174+  EB12 CD 89 ED                        CALL    _send_byte
0175+  EB15 CD 5E ED    _purge              CALL    _recieve_safe               ; Purge remains of any cancel request
0176+  EB18 20 FB                           JR      NZ, _purge
0177+  EB1A             
0178+  EB1A 3E 03                           LD      A, YMODEM_CANCEL
0179+  EB1C A7                              AND     A
0180+  EB1D C9                              RET
0181+  EB1E             
0182+  EB1E 3E 05       _zero_error         LD      A, _ERR_ZERO_PACKET
0183+  EB20 4F          _packet_error       LD      C, A                        ; Packet data error - return error code in C
0184+  EB21 3E 04                           LD      A, YMODEM_PACKET_ERROR
0185+  EB23 A7                              AND     A
0186+  EB24 C9                              RET
0187+  EB25             
0188+  EB25 4F          _unknown_packet     LD      C, A                        ; Unknown packet type - return header byte in C
0189+  EB26 3E 02                           LD      A, YMODEM_UNKNOWN
0190+  EB28 A7                              AND     A
0191+  EB29 C9                              RET     
0192+  EB2A             
0193+  EB2A             ; Receive data for both SOH and STX packets..
0194+  EB2A             ; At this point HL is destination (either DE or IX-buffer), and BC is a byte count
0195+  EB2A             ;
0196+  EB2A DD 77 FB    _receive_packet     LD      (IX+ym_packet_type), A   
0197+  EB2D             
0198+  EB2D DD 7E F7                        LD      A, (IX+ym_current_page)
0199+  EB30 FE FF                           CP      0FFh
0200+  EB32 28 02                           JR      Z, _no_page_specified
0201+  EB34 D3 71                           OUT     (IO_MEM_1), A
0202+  EB36             
0203+  EB36 AF          _no_page_specified  XOR     A
0204+  EB37 DD 77 F5                        LD      (IX+ym_soh_saved_len), A     ; Reset how many bytes of an SOH packet we actually loaded..
0205+  EB3A DD 77 F6                        LD      (IX+ym_soh_saved_len_h), A
0206+  EB3D             
0207+  EB3D DD BE FA                        CP      (IX+ym_current_packet)         ; If this is the zeroth packet, it must be SOH
0208+  EB40 20 07                           JR      NZ, _not_zeroth_packet
0209+  EB42 3E 01                           LD      A, _SOH
0210+  EB44 DD 96 FB                        SUB     (IX+ym_packet_type)            ; Leave A as zero if this is OK
0211+  EB47 20 D5                           JR      NZ, _zero_error
0212+  EB49             
0213+  EB49 DD 77 FF    _not_zeroth_packet  LD      (IX+ym_crc_high), A
0214+  EB4C DD 77 FE                        LD      (IX+ym_crc_low), A
0215+  EB4F             
0216+  EB4F CD 69 ED                        CALL    _receive_byte   
0217+  EB52 DD 77 FC                        LD      (IX+ym_packet_num), A
0218+  EB55 CD 69 ED                        CALL    _receive_byte   
0219+  EB58 DD 77 FD                        LD      (IX+ym_packet_num_cpl), A
0220+  EB5B             
0221+  EB5B 7D          _data_loop          LD      A, L                        ; Handle paging if we're loading into paged memory..
0222+  EB5C A7                              AND     A
0223+  EB5D 20 12                           JR      NZ, _data_receive
0224+  EB5F 7C                              LD      A, H
0225+  EB60 FE 80                           CP      80h
0226+  EB62 20 0D                           JR      NZ, _data_receive
0227+  EB64 DD 7E F7                        LD      A, (IX+ym_current_page)
0228+  EB67 3C                              INC     A
0229+  EB68 28 07                           JR      Z, _data_receive           ; Paging disabled
0230+  EB6A             
0231+  EB6A DD 77 F7                        LD      (IX+ym_current_page), A        ; Move to next page
0232+  EB6D D3 71                           OUT     (IO_MEM_1), A
0233+  EB6F 26 40                           LD      H, 40h
0234+  EB71                                 
0235+  EB71 CD 69 ED    _data_receive       CALL    _receive_byte
0236+  EB74             
0237+  EB74 77                              LD      (HL), A
0238+  EB75             
0239+  EB75 CD 2B ED                        CALL    _calc_checksum  
0240+  EB78             
0241+  EB78 C5                              PUSH    BC                          ; Count down the bytes remaining, and once we get to zero, send bytes to _dev_null
0242+  EB79 01 FF FF                        LD      BC, -1
0243+  EB7C FD 09                           ADD     IY, BC                      ; Carry set if IY not zero
0244+  EB7E C1                              POP     BC
0245+  EB7F 38 10                           JR      C, _in_range
0246+  EB81             
0247+  EB81 DD 35 F4                        DEC     (IX+ym_loaded_high)
0248+  EB84 F2 91 EB                        JP      P, _in_range
0249+  EB87                  
0250+  EB87 DD 34 F4                        INC     (IX+ym_loaded_high)      ; Keep resetting counter...
0251+  EB8A FD 23                           INC     IY
0252+  EB8C 21 5D ED                        LD      HL, _dev_null
0253+  EB8F 18 09                           JR      _do_next
0254+  EB91             
0255+  EB91 DD 34 F5    _in_range           INC     (IX+ym_soh_saved_len)
0256+  EB94 20 03                           JR      NZ, _packet_part_ok
0257+  EB96 DD 34 F6                        INC     (IX+ym_soh_saved_len_h)
0258+  EB99 23          _packet_part_ok     INC     HL
0259+  EB9A             
0260+  EB9A 0B          _do_next            DEC     BC
0261+  EB9B             
0262+  EB9B 78                              LD      A, B
0263+  EB9C B1                              OR      C
0264+  EB9D 20 BC                           JR      NZ, _data_loop
0265+  EB9F             
0266+  EB9F AF                              XOR     A
0267+  EBA0 CD 2B ED                        CALL    _calc_checksum  
0268+  EBA3 AF                              XOR     A
0269+  EBA4 CD 2B ED                        CALL    _calc_checksum  
0270+  EBA7             
0271+  EBA7 CD 69 ED                        CALL    _receive_byte
0272+  EBAA 47                              LD      B, A
0273+  EBAB CD 69 ED                        CALL    _receive_byte   
0274+  EBAE 4F                              LD      C, A
0275+  EBAF             ;
0276+  EBAF             ; Now do checks...
0277+  EBAF             
0278+  EBAF DD 7E FC                        LD      A, (IX+ym_packet_num)
0279+  EBB2 2F                              CPL
0280+  EBB3 DD BE FD                        CP      (IX+ym_packet_num_cpl)
0281+  EBB6 3E 01                           LD      A, _ERR_PACKET_COUNT
0282+  EBB8 C2 20 EB                        JP      NZ, _packet_error
0283+  EBBB DD 7E FF                        LD      A, (IX+ym_crc_high)
0284+  EBBE B8                              CP      B
0285+  EBBF 3E 02                           LD      A, _ERR_CHECK_HIGH
0286+  EBC1 C2 20 EB                        JP      NZ, _packet_error
0287+  EBC4 DD 7E FE                        LD      A, (IX+ym_crc_low)
0288+  EBC7 B9                              CP      C
0289+  EBC8 3E 03                           LD      A, _ERR_CHECK_LOW
0290+  EBCA C2 20 EB                        JP      NZ, _packet_error
0291+  EBCD             
0292+  EBCD             ; CRC and packet number check out... 
0293+  EBCD DD 7E FC                        LD      A, (IX+ym_packet_num)
0294+  EBD0 DD BE FA                        CP      (IX+ym_current_packet)
0295+  EBD3 20 23                           JR      NZ, _retry_packet               ; We need to restore IY (length) if we wish to survive.. DE is not updated until later, so OK
0296+  EBD5 DD 34 FA                        INC     (IX+ym_current_packet)
0297+  EBD8 A7                              AND     A
0298+  EBD9 28 4A                           JR      Z, _header_packet
0299+  EBDB             
0300+  EBDB DD 7E FB                        LD      A, (IX+ym_packet_type)
0301+  EBDE FE 01                           CP      _SOH
0302+  EBE0 20 0C                           JR      NZ, _not_soh
0303+  EBE2             
0304+  EBE2             ; SOH packets must be copied to DE -> 
0305+  EBE2 DD 4E F5                        LD      C, (IX+ym_soh_saved_len)
0306+  EBE5 06 00                           LD      B, 0
0307+  EBE7 DD E5                           PUSH    IX
0308+  EBE9 E1                              POP     HL
0309+  EBEA ED B0                           LDIR
0310+  EBEC 18 02                           JR      _send_ack
0311+  EBEE             
0312+  EBEE 54          _not_soh            LD      D, H
0313+  EBEF 5D                              LD      E, L
0314+  EBF0 3E 06       _send_ack           LD      A, _ACK 
0315+  EBF2 CD 89 ED    _send_and_loop      CALL    _send_byte
0316+  EBF5 C3 D6 EA                        JP      _send_crc_and_loop      
0317+  EBF8             
0318+  EBF8 AF          _retry_packet       XOR     A                           ; Clear carry
0319+  EBF9 ED 52                           SBC     HL, DE
0320+  EBFB 30 0D                           JR      NC, _retry_page_ok          
0321+  EBFD             
0322+  EBFD DD 7E F7                        LD      A,(IX+ym_current_page)         ; If HL (latest write dest) is less than DE (write dest at start of packet) assume we've changed pages..
0323+  EC00 FE FF                           CP      0FFH
0324+  EC02 28 06                           JR      Z, _retry_page_ok           ; We're not paging anyway...
0325+  EC04 3D                              DEC     A 
0326+  EC05 DD 77 F7                        LD      (IX+ym_current_page), A
0327+  EC08 D3 71                           OUT     (IO_MEM_1),A
0328+  EC0A             
0329+  EC0A DD 4E F5    _retry_page_ok      LD      C, (IX+ym_soh_saved_len)     ; Restore IY (length)
0330+  EC0D DD 46 F6                        LD      B, (IX+ym_soh_saved_len_h)
0331+  EC10 FD E5                           PUSH    IY
0332+  EC12 E1                              POP     HL
0333+  EC13 09                              ADD     HL, BC
0334+  EC14 30 03                           JR      NC, _retry_iy_ok
0335+  EC16 DD 34 F4                        INC     (IX+ym_loaded_high)
0336+  EC19 E5          _retry_iy_ok        PUSH    HL
0337+  EC1A FD E1                           POP     IY
0338+  EC1C                                                                     ; TODO: If we've changed the page, that needs to be restored as well
0339+  EC1C             
0340+  EC1C             
0341+  EC1C CD 5E ED    _retry_drain        CALL   _recieve_safe                ; Drain the incoming stream before sending nak
0342+  EC1F 20 FB                           JR      NZ, _retry_drain
0343+  EC21             
0344+  EC21 3E 15                           LD      A, _NAK
0345+  EC23 18 CD                           JR      _send_and_loop
0346+  EC25             
0347+  EC25             
0348+  EC25 DD E5       _header_packet      PUSH    IX
0349+  EC27 E1                              POP     HL
0350+  EC28 7E                              LD      A, (HL)                     ; Empty zeroth packet means end of batch send
0351+  EC29 A7                              AND     A
0352+  EC2A 20 09                           JR      NZ, _check_filecount
0353+  EC2C             
0354+  EC2C 3E 06                           LD      A, _ACK 
0355+  EC2E CD 89 ED                        CALL    _send_byte
0356+  EC31 3E 00                           LD      A, YMODEM_SUCCESS   
0357+  EC33 A7                              AND     A
0358+  EC34 C9                              RET
0359+  EC35             
0360+  EC35 DD 7E F0    _check_filecount    LD      A, (IX+ym_file_count)
0361+  EC38 A7                              AND     A
0362+  EC39 28 04                           JR      Z, _next_filechar
0363+  EC3B             
0364+  EC3B 3E 08                           LD      A, YMODEM_MULTI_FILES
0365+  EC3D A7                              AND     A
0366+  EC3E C9                              RET
0367+  EC3F             
0368+  EC3F 7E          _next_filechar      LD      A, (HL)
0369+  EC40 23                              INC     HL
0370+  EC41 A7          _check_char         AND     A
0371+  EC42 28 71                           JR      Z, _read_length
0372+  EC44 FE 5F                           CP      '_'                     ; Check for special transfer modes
0373+  EC46 20 F7                           JR      NZ, _next_filechar
0374+  EC48 7E                              LD      A, (HL)
0375+  EC49 4F                              LD      C, A                    ; Remember the prefix char in C
0376+  EC4A 23                              INC     HL
0377+  EC4B FE 6D                           CP      _DEST_PREFIX
0378+  EC4D 20 07                           JR      NZ, _check_flash
0379+  EC4F 06 04                           LD      B, 4
0380+  EC51 11 00 00                        LD      DE, 0
0381+  EC54 18 09                           JR      _parse_dest
0382+  EC56             
0383+  EC56 FE 70       _check_flash        CP      _PAGE_PREFIX
0384+  EC58 20 E7                           JR      NZ, _check_char
0385+  EC5A 06 02                           LD      B, 2
0386+  EC5C 11 00 00                        LD      DE, 0
0387+  EC5F             
0388+  EC5F 7E          _parse_dest         LD      A, (HL)
0389+  EC60 23                              INC     HL
0390+  EC61 D6 30                           SUB     '0'
0391+  EC63 38 48                           JR      C, _invalid_dest
0392+  EC65 FE 0A                           CP      10
0393+  EC67 38 08                           JR      C, _digit_checked
0394+  EC69 D6 07                           SUB     7
0395+  EC6B 38 40                           JR      C, _invalid_dest
0396+  EC6D FE 10                           CP      16
0397+  EC6F 30 3C                           JR      NC, _invalid_dest
0398+  EC71             
0399+  EC71 E5          _digit_checked      PUSH    HL                          ; Shift existing dest left 4 bits and merge new hex digit
0400+  EC72 62                              LD      H, D
0401+  EC73 6B                              LD      L, E
0402+  EC74 29                              ADD     HL, HL
0403+  EC75 29                              ADD     HL, HL
0404+  EC76 29                              ADD     HL, HL
0405+  EC77 29                              ADD     HL, HL
0406+  EC78 B5                              OR      L
0407+  EC79 54                              LD      D, H
0408+  EC7A 5F                              LD      E, A
0409+  EC7B E1                              POP     HL
0410+  EC7C 10 E1                           DJNZ    _parse_dest
0411+  EC7E             
0412+  EC7E 79                              LD      A, C                        ; Which char did we start with?
0413+  EC7F FE 70                           CP      _PAGE_PREFIX
0414+  EC81 20 12                           JR      NZ, _memory_dest
0415+  EC83             
0416+  EC83 DD 7E F7                        LD      A, (IX+ym_current_page)        ; Page prefix. Use original value if set when ymodem was called
0417+  EC86 FE FF                           CP      0FFh
0418+  EC88 20 B5                           JR      NZ, _next_filechar
0419+  EC8A             
0420+  EC8A DD 73 EF                        LD      (IX+ym_file_mode), E           ; Otherwise use the file specified value and load from 4000h
0421+  EC8D DD 73 F7                        LD      (IX+ym_current_page), E
0422+  EC90 11 00 40                        LD      DE,04000h    
0423+  EC93 18 10                           JR      _store_dest
0424+  EC95             
0425+  EC95 3E FF       _memory_dest        LD      A, 0FFh                     ; Only set the dest from the filename if 
0426+  EC97 DD BE F8                        CP      (IX+ym_dest_low)               ; the routine was called with a destination of 0FFFFh
0427+  EC9A 20 A3                           JR      NZ, _next_filechar
0428+  EC9C DD BE F9                        CP      (IX+ym_dest_high)
0429+  EC9F 20 9E                           JR      NZ, _next_filechar
0430+  ECA1             
0431+  ECA1 DD 36 EF FE                     LD      (IX+ym_file_mode), YM_DEST_FROM_FILE
0432+  ECA5             
0433+  ECA5 DD 73 F8    _store_dest         LD      (IX+ym_dest_low), E
0434+  ECA8 DD 72 F9                        LD      (IX+ym_dest_high), D
0435+  ECAB             
0436+  ECAB 18 92                           JR      _next_filechar
0437+  ECAD             
0438+  ECAD DD 5E F8    _invalid_dest       LD      E, (IX+ym_dest_low)            ; We silently skip invalid destination values
0439+  ECB0 DD 56 F9                        LD      D, (IX+ym_dest_high)
0440+  ECB3 18 8A                           JR      _next_filechar
0441+  ECB5             
0442+  ECB5 3E FF       _read_length        LD      A, 0FFh                     ; At this point we should have a valid destination
0443+  ECB7 DD BE F8                        CP      (IX+ym_dest_low)               
0444+  ECBA 20 09                           JR      NZ, _dest_ok
0445+  ECBC DD BE F9                        CP      (IX+ym_dest_high)
0446+  ECBF 20 04                           JR      NZ, _dest_ok
0447+  ECC1             
0448+  ECC1 3E 06                           LD      A, YMODEM_NO_DEST
0449+  ECC3 A7                              AND     A
0450+  ECC4 C9                              RET
0451+  ECC5             
0452+  ECC5 3E FF       _dest_ok            LD      A, 0FFh
0453+  ECC7 DD 77 F1                        LD      (IX+ym_length_low), A       ; Reset the length counter///
0454+  ECCA DD 77 F2                        LD      (IX+ym_length_mid), A
0455+  ECCD DD 77 F3                        LD      (IX+ym_length_high), A         
0456+  ECD0 DD 77 F4                        LD      (IX+ym_loaded_high), A
0457+  ECD3 FD 21 FF FF                     LD      IY, 0FFFFh 
0458+  ECD7 44                              LD      B, H
0459+  ECD8 4D                              LD      C, L               
0460+  ECD9 21 00 00                        LD      HL, 0
0461+  ECDC 0A                              LD      A, (BC)                     ; Length is optional
0462+  ECDD A7                              AND     A
0463+  ECDE CA F0 EB                        JP      Z, _send_ack
0464+  ECE1             
0465+  ECE1 0A          _parse_length       LD      A, (BC)
0466+  ECE2 03                              INC     BC
0467+  ECE3 A7                              AND     A
0468+  ECE4 28 2F                           JR      Z, _length_end
0469+  ECE6 FE 20                           CP      ' '
0470+  ECE8 28 2B                           JR      Z, _length_end
0471+  ECEA D6 30                           SUB     '0'
0472+  ECEC 38 39                           JR      C, _invalid_length
0473+  ECEE FE 0A                           CP      10
0474+  ECF0 30 35                           JR      NC, _invalid_length
0475+  ECF2             
0476+  ECF2 C5                              PUSH    BC
0477+  ECF3 D5                              PUSH    DE
0478+  ECF4 F5                              PUSH    AF
0479+  ECF5             
0480+  ECF5 EB                              EX      DE, HL              ; HL into DE 
0481+  ECF6 3E 0A                           LD      A, 10
0482+  ECF8             
0483+  ECF8                                 ; DE x A  -> AHL  (from http://z80-heaven.wikidot.com/advanced-math#toc12)
0484+  ECF8                                 ; preserves DE
0485+  ECF8 01 00 08                        LD      BC, 0800h
0486+  ECFB 61                              LD      H, C
0487+  ECFC 69                              LD      L, C
0488+  ECFD 29          _pl_loop            ADD     HL, HL
0489+  ECFE 17                              RLA
0490+  ECFF 30 02                           JR      NC, _pl_skip
0491+  ED01 19                              ADD     HL, DE
0492+  ED02 89                              ADC     A, C
0493+  ED03 10 F8       _pl_skip            DJNZ    _pl_loop
0494+  ED05             
0495+  ED05 DD 77 F3                        LD      (IX+ym_length_high), A     ; Note we only handle overflow for one digit.. max value 655,359?
0496+  ED08 F1                              POP     AF
0497+  ED09 5F                              LD      E, A
0498+  ED0A 51                              LD      D, C
0499+  ED0B 19                              ADD     HL, DE
0500+  ED0C 30 03                           JR      NC, _pl_length_ok
0501+  ED0E DD 34 F3                        INC     (IX+ym_length_high)
0502+  ED11             
0503+  ED11 D1          _pl_length_ok       POP     DE
0504+  ED12 C1                              POP     BC
0505+  ED13 18 CC                           JR      _parse_length
0506+  ED15             
0507+  ED15 E5          _length_end         PUSH    HL
0508+  ED16 FD E1                           POP     IY
0509+  ED18 DD 75 F1                        LD      (IX+ym_length_low), L
0510+  ED1B DD 74 F2                        LD      (IX+ym_length_mid), H
0511+  ED1E DD 7E F3                        LD      A, (IX+ym_length_high)
0512+  ED21 DD 77 F4                        LD      (IX+ym_loaded_high), A
0513+  ED24 C3 F0 EB                        JP      _send_ack
0514+  ED27             
0515+  ED27 3E 05       _invalid_length     LD      A, YMODEM_LENGTH_ERROR      ; Hard fail on invalid length data
0516+  ED29 A7                              AND     A
0517+  ED2A C9                              RET
0518+  ED2B             
0519+  ED2B             ;-----
0520+  ED2B             ; Calculate the checksum from A
0521+  ED2B E5          _calc_checksum      PUSH    HL
0522+  ED2C C5                              PUSH    BC
0523+  ED2D             
0524+  ED2D 06 01                           LD      B, 1
0525+  ED2F 4F                              LD      C, A
0526+  ED30 DD 66 FF                        LD      H, (IX+ym_crc_high)
0527+  ED33 DD 6E FE                        LD      L, (IX+ym_crc_low)
0528+  ED36             
0529+  ED36 29          _crc_loop           ADD     HL, HL
0530+  ED37 F5                              PUSH    AF
0531+  ED38             
0532+  ED38 CB 21                           SLA     C
0533+  ED3A CB 10                           RL      B
0534+  ED3C 30 02                           JR      NC, _no_in_overflow
0535+  ED3E CB C1                           SET     0, C
0536+  ED40             _no_in_overflow
0537+  ED40 CB 40                           BIT     0, B
0538+  ED42 28 01                           JR      Z, _no_in_bit
0539+  ED44 23                              INC     HL
0540+  ED45             _no_in_bit                    
0541+  ED45 F1                              POP     AF
0542+  ED46 30 08                           JR      NC, _no_crc_overflow
0543+  ED48 3E 21                           LD      A, 021h
0544+  ED4A AD                              XOR     L 
0545+  ED4B 6F                              LD      L,A
0546+  ED4C 3E 10                           LD      A, 010h
0547+  ED4E AC                              XOR     H 
0548+  ED4F 67                              LD      H, A
0549+  ED50             _no_crc_overflow
0550+  ED50 CB 41                           BIT     0, C
0551+  ED52 28 E2                           JR      Z, _crc_loop    
0552+  ED54             
0553+  ED54 DD 74 FF                        LD      (IX+ym_crc_high), H
0554+  ED57 DD 75 FE                        LD      (IX+ym_crc_low), L
0555+  ED5A C1                              POP     BC
0556+  ED5B E1                              POP     HL
0557+  ED5C C9                              RET
0558+  ED5D             
0559+  ED5D 00          _dev_null           .DB     0
0560+  ED5E             
0561+  ED5E             ;
0562+  ED5E             ; Recieve a byte with timeout, without exiting ymodem
0563+  ED5E             ; If success, A contains byte, non-zero flag set
0564+  ED5E             ; Otherwise A is zero, Zero flag is set
0565+  ED5E             ;
0566+  ED5E 21 67 ED    _recieve_safe       LD      HL, _back_safe
0567+  ED61 E5                              PUSH    HL
0568+  ED62 CD 69 ED                        CALL    _receive_byte
0569+  ED65 E1                              POP     HL
0570+  ED66 C9                              RET
0571+  ED67 AF          _back_safe          XOR     A
0572+  ED68 C9                              RET     
0573+  ED69             
0574+  ED69             ;
0575+  ED69             ; Receive a byte with timeout
0576+  ED69             ; If success: A contains byte, non-zero flag set
0577+  ED69             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_TIMEOUT
0578+  ED69             ;
0579+  ED69 C5          _receive_byte       PUSH    BC
0580+  ED6A 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0581+  ED6D DB 25       _receive_loop       IN      A, (UART_LINE_STATUS)
0582+  ED6F CB 47                           BIT     0, A
0583+  ED71 20 12                           JR      NZ, _receive_ready
0584+  ED73 78                              LD      A, B
0585+  ED74 06 0A                           LD      B, 10
0586+  ED76 A7          _rx_delay           AND     A
0587+  ED77 10 FD                           DJNZ    _rx_delay
0588+  ED79 47                              LD      B, A
0589+  ED7A 0B                              DEC     BC
0590+  ED7B 78                              LD      A, B
0591+  ED7C B1                              OR      C
0592+  ED7D 20 EE                           JR      NZ, _receive_loop
0593+  ED7F C1                              POP     BC
0594+  ED80 C1                              POP     BC
0595+  ED81 3E 01                           LD      A, YMODEM_TIMEOUT
0596+  ED83 A7                              AND     A
0597+  ED84 C9                              RET
0598+  ED85             
0599+  ED85 DB 20       _receive_ready      IN      A, (UART_TX_RX)
0600+  ED87 C1                              POP     BC
0601+  ED88 C9                              RET
0602+  ED89             
0603+  ED89             ;
0604+  ED89             ; Send a byte with timeout
0605+  ED89             ; If success: returns normally, no registers affected
0606+  ED89             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_SEND_TIMEOUT
0607+  ED89             ;
0608+  ED89 C5          _send_byte          PUSH    BC
0609+  ED8A F5                              PUSH    AF
0610+  ED8B 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0611+  ED8E DB 25       _send_loop          IN      A, (UART_LINE_STATUS)
0612+  ED90 CB 6F                           BIT     5, A
0613+  ED92 C2 A2 ED                        JP      NZ, _send_ready             ; Bit 5 is set when the UART is ready
0614+  ED95 0B                              DEC     BC
0615+  ED96 78                              LD      A, B
0616+  ED97 B1                              OR      C
0617+  ED98 C2 8E ED                        JP      NZ, _send_loop
0618+  ED9B             
0619+  ED9B F1                              POP     AF
0620+  ED9C C1                              POP     BC
0621+  ED9D C1                              POP     BC
0622+  ED9E             
0623+  ED9E 3E 07                           LD      A, YMODEM_SEND_TIMEOUT
0624+  EDA0 A7                              AND     A
0625+  EDA1 C9                              RET
0626+  EDA2             
0627+  EDA2 F1          _send_ready         POP     AF
0628+  EDA3 C1                              POP     BC
0629+  EDA4 D3 20                           OUT     (UART_TX_RX), A
0630+  EDA6 C9                              RET
0631+  EDA7             
0632+  EDA7                                 .MODULE main1119   EDA7             
1120   EDA7~            .IF $ >= BIOS_START
1121   EDA7~                .ECHO "End of Monitor is too high ("
1122   EDA7~                .ECHO $
1123   EDA7~                .ECHO " > "
1124   EDA7~                .ECHO BIOS_START
1125   EDA7~                .ECHO ") \n\n"
1126   EDA7~                .STOP
1127   EDA7             .ENDIF
1128   EDA7             
1129   EDA7             .ECHO "Spare after monitor "
1130   EDA7             .ECHO BIOS_START-$
1131   EDA7             .ECHO "\n\n"
1132   EDA7             
1133   EDA7 FF FF FF FF                     .FILL  BIOS_START-$
1133   EDAB FF FF FF FF 
1133   EDAF FF FF FF FF 
1133   EDB3 FF FF FF FF 
1133   EDB7 FF FF FF FF 
1133   EDBB FF FF FF FF 
1133   EDBF FF FF FF FF 
1133   EDC3 FF FF FF FF 
1133   EDC7 FF FF FF FF 
1133   EDCB FF FF FF FF 
1133   EDCF FF FF FF FF 
1133   EDD3 FF FF FF FF 
1133   EDD7 FF FF FF FF 
1133   EDDB FF FF FF FF 
1133   EDDF FF FF FF FF 
1133   EDE3 FF FF FF FF 
1133   EDE7 FF FF FF FF 
1133   EDEB FF FF FF FF 
1133   EDEF FF FF FF FF 
1133   EDF3 FF FF FF FF 
1133   EDF7 FF FF FF FF 
1133   EDFB FF FF FF FF 
1133   EDFF FF 
1134   EE00             
1135   EE00                                 .INCLUDE "bios.asm"
0001+  EE00             ;
0002+  EE00             ; Simple-ish CP/M compatible BIOS
0003+  EE00             ;
0004+  EE00             ; References - http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.htm - CPM Manual 'Simple skeletal BIOS'
0005+  EE00             ;
0006+  EE00             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007+  EE00             ;
0008+  EE00             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009+  EE00             ;
0010+  EE00             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011+  EE00             ; of this software and associated documentation files (the "Software"), to deal
0012+  EE00             ; in the Software without restriction, including without limitation the rights
0013+  EE00             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014+  EE00             ; copies of the Software, and to permit persons to whom the Software is
0015+  EE00             ; furnished to do so, subject to the following conditions:
0016+  EE00             ; 
0017+  EE00             ; The above copyright notice and this permission notice shall be included in all
0018+  EE00             ; copies or substantial portions of the Software.
0019+  EE00             ; 
0020+  EE00             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021+  EE00             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022+  EE00             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023+  EE00             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024+  EE00             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025+  EE00             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026+  EE00             ; SOFTWARE.
0027+  EE00             ;
0028+  EE00                                 .MODULE  main
0029+  EE00             
0030+  EE00             BIOS_START          .EQU    0EE00h
0031+  EE00             BIOS_TOP            .EQU    0FDFDh
0032+  EE00             
0033+  EE00             CCP                 .EQU    BIOS_START - 01600h
0034+  EE00             BDOS                .EQU    CCP + 0806h
0035+  EE00             
0036+  EE00             CCP_SECTOR_COUNT    .EQU    (BIOS_START-CCP)/128
0037+  EE00             
0038+  EE00~            .IF (CCP_SECTOR_COUNT * 128) < (BIOS_START-CCP)
0039+  EE00~                .ECHO "CCP isn't an exact multiple of 128 byte sectors\n"
0040+  EE00~                .ECHO "  Got "
0041+  EE00~                .ECHO (BIOS_START-CCP)
0042+  EE00~                .ECHO "\n"
0043+  EE00~                .STOP
0044+  EE00             .ENDIF
0045+  EE00             
0046+  EE00             iobyte              .EQU    03h     ; Location of Intel standard I/O definition byte
0047+  EE00             usrdrv              .EQU    04h     ; Location of Current user number and drive
0048+  EE00             tpabuf              .EQU    0080h   ; Default I/O buffer and command line storage
0049+  EE00             
0050+  EE00             IO_BAT              .EQU    02h     ; CONsole IO defined by RDR for input, LST for output
0051+  EE00             
0052+  EE00             bios_start          .ORG    BIOS_START
0053+  EE00             
0054+  EE00 C3 F1 EE                        JP      bios_boot     ;  0 Initialize
0055+  EE03 C3 08 EF    wboote              JP      bios_wboot    ;  1 Warm boot
0056+  EE06 C3 71 EF                        JP      bios_conist   ;  2 Console status - Return A = 0FFH if character ready, 00H if not
0057+  EE09 C3 9A EF                        JP      bios_conin    ;  3 Console input  - Wait for input, returning character in A
0058+  EE0C C3 00 F0                        JP      bios_conout   ;  4 Console OUTput - Write character in C to console
0059+  EE0F C3 EF F2                        JP      bios_list     ;  5 List OUTput
0060+  EE12 C3 F1 F2                        JP      bios_punch    ;  6 punch OUTput
0061+  EE15 C3 F3 F2                        JP      bios_reader   ;  7 Reader input
0062+  EE18 C3 0D F3                        JP      bios_home     ;  8 Home disk
0063+  EE1B C3 F4 F2                        JP      bios_seldsk   ;  9 Select disk
0064+  EE1E C3 0F F3                        JP      bios_settrk   ; 10 Select track
0065+  EE21 C3 14 F3                        JP      bios_setsec   ; 11 Select sector
0066+  EE24 C3 19 F3                        JP      bios_setdma   ; 12 Set DMA ADDress
0067+  EE27 C3 1E F3                        JP      bios_read     ; 13 Read 128 bytes
0068+  EE2A C3 57 F3                        JP      bios_write    ; 14 Write 128 bytes
0069+  EE2D C3 C4 F3                        JP      bios_listst   ; 15 List status
0070+  EE30 C3 C6 F3                        JP      bios_sectrn   ; 16 Sector translate
0071+  EE33             
0072+  EE33             MEMDISK_SECTORS     .EQU    26
0073+  EE33             MEMDISK_TRACKS      .EQU    79
0074+  EE33             
0075+  EE33             BIOS_BOOT_TRACKS    .EQU    2
0076+  EE33             BIOS_SECTOR_ADDRESS .EQU    tpabuf
0077+  EE33             
0078+  EE33             DRIVE_A_PAGE        .EQU    04h     ; Page 4 of ROM - offset 010000h
0079+  EE33             DRIVE_B_PAGE        .EQU    24h     ; Page 4 of RAM
0080+  EE33             
0081+  EE33             ; Disk Parameter Headers -------------------------------------------------------
0082+  EE33             ; These are 256K discs, equivalent to this disc format (for cpmtools)
0083+  EE33             ; 
0084+  EE33             ; References : https://www.idealine.info/sharpmz/dpb.htm - Explanation of values
0085+  EE33             ;              https://jeelabs.org/article/1715b/        - Bootstrapping CP/M
0086+  EE33             ;
0087+  EE33             ; diskdef memotech-type50
0088+  EE33             ;  seclen 128
0089+  EE33             ;  tracks 79
0090+  EE33             ;  sectrk 26
0091+  EE33             ;  blocksize 1024
0092+  EE33             ;  maxdir 64
0093+  EE33             ;  skew 1
0094+  EE33             ;  boottrk 2
0095+  EE33             ;  os 2.2
0096+  EE33             ; end
0097+  EE33             ;
0098+  EE33             MAX_DRIVES          .EQU    2
0099+  EE33             
0100+  EE33 00 00 00 00 dpbase              .DW     0,0,0,0,dirbuf,dpb0,0,sys_alv0      ; Disk 0 is Flash
0100+  EE37 00 00 00 00 
0100+  EE3B 71 EE 53 EE 
0100+  EE3F 00 00 44 FF 
0101+  EE43 00 00 00 00                     .DW     0,0,0,0,dirbuf,dpb1,0,sys_alv1      ; Disk 1 is RAM
0101+  EE47 00 00 00 00 
0101+  EE4B 71 EE 62 EE 
0101+  EE4F 00 00 64 FF 
0102+  EE53             
0103+  EE53 1A 00       dpb0                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0104+  EE55 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0105+  EE56 07                              .DB     7                   ; BLM - block mask
0106+  EE57 00                              .DB     0                   ; EXM - Extent mask
0107+  EE58 F8 00                           .DW     248                 ; DSM - Storage size (blocks - 1)
0108+  EE5A 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0109+  EE5C C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0110+  EE5D 00                              .DB     0                   ; AL1 - ... 8 more bits
0111+  EE5E 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0112+  EE60 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0113+  EE62             
0114+  EE62 1A 00       dpb1                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0115+  EE64 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0116+  EE65 07                              .DB     7                   ; BLM - block mask
0117+  EE66 00                              .DB     0                   ; EXM - Extent mask
0118+  EE67 F8 00                           .DW     248                 ; DSM - Storage size (blocks - 1)
0119+  EE69 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0120+  EE6B C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0121+  EE6C 00                              .DB     0                   ; AL1 - ... 8 more bits
0122+  EE6D 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0123+  EE6F 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0124+  EE71             
0125+  EE71 00 00 00 00 dirbuf              .FILL   128, 0 ; disk directory scratch area
0125+  EE75 00 00 00 00 
0125+  EE79 00 00 00 00 
0125+  EE7D 00 00 00 00 
0125+  EE81 00 00 00 00 
0125+  EE85 00 00 00 00 
0125+  EE89 00 00 00 00 
0125+  EE8D 00 00 00 00 
0125+  EE91 00 00 00 00 
0125+  EE95 00 00 00 00 
0125+  EE99 00 00 00 00 
0125+  EE9D 00 00 00 00 
0125+  EEA1 00 00 00 00 
0125+  EEA5 00 00 00 00 
0125+  EEA9 00 00 00 00 
0125+  EEAD 00 00 00 00 
0125+  EEB1 00 00 00 00 
0125+  EEB5 00 00 00 00 
0125+  EEB9 00 00 00 00 
0125+  EEBD 00 00 00 00 
0125+  EEC1 00 00 00 00 
0125+  EEC5 00 00 00 00 
0125+  EEC9 00 00 00 00 
0125+  EECD 00 00 00 00 
0125+  EED1 00 00 00 00 
0125+  EED5 00 00 00 00 
0125+  EED9 00 00 00 00 
0125+  EEDD 00 00 00 00 
0125+  EEE1 00 00 00 00 
0125+  EEE5 00 00 00 00 
0125+  EEE9 00 00 00 00 
0125+  EEED 00 00 00 00 
0126+  EEF1             
0127+  EEF1             ; BIOS Entry points ---------------------------------------------------------------
0128+  EEF1             
0129+  EEF1             bios_boot     ;  0 Initialize - This is called on first boot when CCP and BIOS have all been read into memory. Initialise hardware and start CCP
0130+  EEF1 F3                              DI
0131+  EEF2 31 00 00                        LD      SP,000h
0132+  EEF5 21 00 EE                        LD      HL,BIOS_START        ; Why are we doing this?
0133+  EEF8 22 FE FF                        LD      (0FFFEh),HL
0134+  EEFB CD E1 F3                        CALL    configure_hardware
0135+  EEFE AF                              XOR     A
0136+  EEFF 32 04 00                        LD      (usrdrv),A
0137+  EF02 3C                              INC     A
0138+  EF03 32 03 00                        LD      (iobyte),A           ; Input on keyboard, output on display
0139+  EF06 18 07                           JR      start_cpm
0140+  EF08             
0141+  EF08             ;------------------------------------------------------                    
0142+  EF08             bios_wboot    ;  1 Warm boot - Hardware is intialised, but CCP should be reloaded before being run
0143+  EF08 F3                              DI
0144+  EF09 31 00 00                        LD      SP,000h
0145+  EF0C                                 ;CALL    setup_screen
0146+  EF0C CD 31 EF                        CALL    load_ccp
0147+  EF0F             
0148+  EF0F FB          start_cpm           EI                           ; Make sure interrupts are enabled
0149+  EF10 21 80 00                        LD      HL,tpabuf            ; Address of BIOS DMA buffer
0150+  EF13 22 3F FF                        LD      (sys_dmaaddr),hl
0151+  EF16 3E C3                           LD      A, 0C3h              ; Opcode for 'JP'
0152+  EF18 32 00 00                        LD      (00h),A              ; Load at start of RAM
0153+  EF1B 21 03 EE                        LD      HL,wboote            ; Address of jump for a warm boot
0154+  EF1E 22 01 00                        LD      (01h),HL
0155+  EF21 32 05 00                        LD      (05h),a              ; Opcode for 'JP'
0156+  EF24 21 06 E0                        LD      HL,BDOS              ; Address of jump for the BDOS
0157+  EF27 22 06 00                        LD      (06h),HL
0158+  EF2A 3A 04 00                        LD      A,(usrdrv)           ; Save new drive number (0)  ; TODO: Ugh? Where is this set, what does it mean???
0159+  EF2D 4F                              LD      C, A                 ; Pass drive number in C
0160+  EF2E C3 00 D8                        JP      CCP                  ; Start CP/M by jumping to the CCP
0161+  EF31             
0162+  EF31                                 ; Load CCP - Note we're doing this through BIOS calls, so if we move the OS to a different
0163+  EF31                                 ;       drive, the code should still function...
0164+  EF31 0E 00       load_ccp            LD      C, 0
0165+  EF33 CD F4 F2                        CALL    bios_seldsk
0166+  EF36 CD 0D F3                        CALL    bios_home            ; Go to track 0
0167+  EF39             
0168+  EF39 06 2C                           LD      B, CCP_SECTOR_COUNT
0169+  EF3B 0E 00                           LD      C, 0                 ; Track number
0170+  EF3D 16 00                           LD      D, 0                 ; Sector to read - start with sector 0 (TODO: Check sectors are 0 based)
0171+  EF3F 21 00 D8                        LD      HL, CCP
0172+  EF42 C5          _read_ccp           PUSH    BC
0173+  EF43 D5                              PUSH    DE
0174+  EF44 E5                              PUSH    HL
0175+  EF45 4A                              LD      C, D                 ; Set the sector to read
0176+  EF46 CD 14 F3                        CALL    bios_setsec
0177+  EF49 C1                              POP     BC
0178+  EF4A C5                              PUSH    BC
0179+  EF4B CD 19 F3                        CALL    bios_setdma
0180+  EF4E CD 1E F3                        CALL    bios_read
0181+  EF51 A7                              AND     A                    ; Reboot if error 
0182+  EF52 20 B4                           JR      NZ, bios_wboot
0183+  EF54             
0184+  EF54 E1                              POP     HL                   ; Calculate next address to read
0185+  EF55 11 80 00                        LD      DE, 128
0186+  EF58 19                              ADD     HL, DE
0187+  EF59 D1                              POP     DE                   ; Count down the sectors
0188+  EF5A C1                              POP     BC
0189+  EF5B 05                              DEC     B
0190+  EF5C C8                              RET     Z                    ; And return if we've read 'em all
0191+  EF5D             
0192+  EF5D 14                              INC     D                    ; Otherwise, increment sector   
0193+  EF5E 7A                              LD      A, D
0194+  EF5F FE 1B                           CP      27
0195+  EF61 38 DF                           JR      C, _read_ccp
0196+  EF63             
0197+  EF63 16 01                           LD      D, 1                 ; Or, set sector back to 1 and increment track 
0198+  EF65 0C                              INC     C
0199+  EF66             
0200+  EF66 C5                              PUSH    BC
0201+  EF67 D5                              PUSH    DE
0202+  EF68 E5                              PUSH    HL
0203+  EF69 CD 0F F3                        CALL    bios_settrk
0204+  EF6C E1                              POP     HL
0205+  EF6D D1                              POP     DE
0206+  EF6E C1                              POP     BC
0207+  EF6F 18 D1                           JR      _read_ccp
0208+  EF71             
0209+  EF71             
0210+  EF71                                 
0211+  EF71             ;------------------------------------------------------  
0212+  EF71             bios_conist   ; CONSOLE STATUS, - Return A = 0FFH if character ready, 00H if not
0213+  EF71 3A 03 00                        LD      A, (iobyte)                ; Check input on CON
0214+  EF74 E6 03                           AND     03h
0215+  EF76 28 12                           JR      Z, _coninst_tty
0216+  EF78 FE 02                           CP      IO_BAT
0217+  EF7A 28 15                           JR      Z, _coninst_rdr
0218+  EF7C             
0219+  EF7C 3A 36 FF    _coninst_kbd        LD      A, (console_identify)
0220+  EF7F A7                              AND     A
0221+  EF80 20 05                           JR      NZ, _coninst_has_char
0222+  EF82             
0223+  EF82 3A 28 FF                        LD      A, (input_size)
0224+  EF85 A7                              AND     A
0225+  EF86 C8                              RET     Z
0226+  EF87 3E FF       _coninst_has_char   LD      A, 0FFh
0227+  EF89 C9                              RET
0228+  EF8A              
0229+  EF8A AF          _coninst_tty        XOR     A
0230+  EF8B CD 76 F8                        CALL    uart_ready
0231+  EF8E D0                              RET     NC
0232+  EF8F 3D                              DEC     A
0233+  EF90 C9                              RET     
0234+  EF91 3A 03 00    _coninst_rdr        LD      A, (iobyte)                 ; Input is determined by RDR
0235+  EF94 E6 0C                           AND     0Ch
0236+  EF96 28 F2                           JR      Z, _coninst_tty
0237+  EF98 18 E2                           JR      _coninst_kbd
0238+  EF9A             
0239+  EF9A             ;------------------------------------------------------  
0240+  EF9A             bios_conin    ;  3 Console input - Wait for input, returning character in A
0241+  EF9A 3A 03 00                        LD      A, (iobyte)
0242+  EF9D E6 03                           AND     03h
0243+  EF9F 28 17                           JR      Z, _conin_tty
0244+  EFA1 FE 02                           CP      02h
0245+  EFA3 28 19                           JR      Z, _conin_rdr
0246+  EFA5                                 
0247+  EFA5 3A 36 FF    _conin_kbd          LD      A, (console_identify)           ; If the terminal has been sent an identity request escape sequence, return the response
0248+  EFA8 3D                              DEC     A
0249+  EFA9 FA C7 EF                        JP      M, _conin_read_char
0250+  EFAC 32 36 FF                        LD      (console_identify), A
0251+  EFAF 21 FD EF                        LD      HL, _indentity_sequence
0252+  EFB2 4F                              LD      C, A
0253+  EFB3 06 00                           LD      B, 0
0254+  EFB5 09                              ADD     HL, BC
0255+  EFB6 7E                              LD      A, (HL) 
0256+  EFB7 C9                              RET        
0257+  EFB8             
0258+  EFB8 CD 85 F8    _conin_tty          CALL    uart_receive
0259+  EFBB D8                              RET     C
0260+  EFBC 18 FA                           JR      _conin_tty
0261+  EFBE                  
0262+  EFBE 3A 03 00    _conin_rdr          LD      A, (iobyte)
0263+  EFC1 E6 0C                           AND     0ch
0264+  EFC3 28 F3                           JR      Z, _conin_tty
0265+  EFC5 18 DE                           JR      _conin_kbd
0266+  EFC7             
0267+  EFC7 3A 28 FF    _conin_read_char    LD      A, (input_size)                 ; Don't blink cursor if there is a character already waiting..
0268+  EFCA A7                              AND     A
0269+  EFCB 28 03                           JR      Z, _conin_wait
0270+  EFCD C3 49 F7                        JP      get_key
0271+  EFD0             
0272+  EFD0 3A 32 FF    _conin_wait         LD      A, (console_flags)              ; Turn the cursor on..
0273+  EFD3 F6 01                           OR      CFLAGS_SHOW_CURSOR
0274+  EFD5 32 32 FF                        LD      (console_flags), A
0275+  EFD8 F3                              DI
0276+  EFD9 ED 5B 2D FF                     LD      DE, (cursor_row)
0277+  EFDD 7A                              LD      A, D                            ; Force cursor update...
0278+  EFDE 3D                              DEC     A
0279+  EFDF 32 2E FF                        LD      (cursor_col),A
0280+  EFE2 CD 20 F1                        CALL    _conout_csr_update
0281+  EFE5 FB                              EI
0282+  EFE6 CD 49 F7                        CALL    get_key
0283+  EFE9 47                              LD      B, A
0284+  EFEA 3A 32 FF                        LD      A, (console_flags)
0285+  EFED E6 FE                           AND     ~CFLAGS_SHOW_CURSOR
0286+  EFEF 32 32 FF                        LD      (console_flags), A
0287+  EFF2                                 ;
0288+  EFF2 C5                              PUSH    BC
0289+  EFF3 1E 00                           LD      E, 0
0290+  EFF5 F3                              DI
0291+  EFF6 CD 9F F5                        CALL    update_cursor
0292+  EFF9 FB                              EI
0293+  EFFA C1                              POP     BC
0294+  EFFB 78                              LD      A, B
0295+  EFFC C9                              RET
0296+  EFFD                  
0297+  EFFD 4B 2F 1B    _indentity_sequence .DB     'K', '/', ESCAPE_CHAR           ; RETURNED BY VT-52 emulation - note sequence is reversed
0298+  F000             IDENTITY_LENGTH     .EQU    3
0299+  F000             
0300+  F000             ;------------------------------------------------------  
0301+  F000             bios_conout   ;  4 Console OUTput  - Write character in C to console
0302+  F000 3A 03 00                        LD      A, (iobyte)
0303+  F003 E6 03                           AND     03h
0304+  F005 FE 02                           CP      IO_BAT
0305+  F007 20 0B                           JR      NZ, _conout_disp_tty
0306+  F009             
0307+  F009 3A 03 00                        LD      A, (iobyte)
0308+  F00C E6 C0                           AND     0C0h
0309+  F00E 20 08                           JR      NZ, _conout_disp 
0310+  F010 79                              LD      A, C
0311+  F011 C3 59 F8                        JP      uart_send
0312+  F014             
0313+  F014 79          _conout_disp_tty    LD      A, C
0314+  F015 CD 59 F8                        CALL    uart_send
0315+  F018             
0316+  F018 3A 34 FF    _conout_disp        LD      A, (console_escape)             ; Test to see if handling an escape sequence and expect more parameters
0317+  F01B B7                              OR      A
0318+  F01C C2 D1 F0                        JP      NZ, _conout_escape_seq
0319+  F01F             
0320+  F01F 3A 32 FF                        LD      A, (console_flags)              ; Test to see if we're expecting an escape character
0321+  F022 E6 08                           AND     CFLAGS_ESCAPE
0322+  F024 CA BE F0                        JP      Z, _conout_check_esc
0323+  F027             
0324+  F027                                                                         ; If so, this is the first character after we got an escape...
0325+  F027 ED 5B 2D FF                     LD      DE, (cursor_row)                ; Get cursor position in DE
0326+  F02B 3A 32 FF                        LD      A,(console_flags)               ; Reset the escape flag
0327+  F02E E6 F7                           AND     ~CFLAGS_ESCAPE
0328+  F030 32 32 FF                        LD      (console_flags),A
0329+  F033             
0330+  F033 79                              LD      A, C
0331+  F034             
0332+  F034 FE 41                           CP      'A'
0333+  F036 20 04                           JR      NZ, _conout_not_up
0334+  F038 1D                              DEC     E
0335+  F039 C3 20 F1                        JP      _conout_csr_update
0336+  F03C             
0337+  F03C FE 42       _conout_not_up      CP      'B'
0338+  F03E 20 04                           JR      NZ, _conout_not_down
0339+  F040 1C                              INC     E
0340+  F041 C3 20 F1                        JP      _conout_csr_update
0341+  F044             
0342+  F044 FE 43       _conout_not_down    CP      'C'
0343+  F046 20 09                           JR      NZ, _conout_not_right
0344+  F048 3A 30 FF                        LD      A, (console_width)
0345+  F04B BA                              CP      D
0346+  F04C C8                              RET     Z                           
0347+  F04D 14                              INC     D
0348+  F04E C3 20 F1                        JP      _conout_csr_update
0349+  F051             
0350+  F051 FE 44       _conout_not_right   CP      'D'
0351+  F053 20 05                           JR      NZ, _conout_not_left
0352+  F055 15                              DEC     D
0353+  F056 C8                              RET     Z
0354+  F057 C3 20 F1                        JP      _conout_csr_update
0355+  F05A             
0356+  F05A FE 46       _conout_not_left    CP      'F'                         ; Enter graphics mode.. not supported
0357+  F05C C8                              RET     Z
0358+  F05D             
0359+  F05D FE 47                           CP      'G'                         ; Exit graphics mode
0360+  F05F C8                              RET     Z
0361+  F060             
0362+  F060 FE 48                           CP      'H'
0363+  F062 20 06                           JR      NZ, _conout_not_home
0364+  F064 11 01 01                        LD      DE, 0101h
0365+  F067 C3 20 F1                        JP      _conout_csr_update
0366+  F06A             
0367+  F06A FE 49       _conout_not_home    CP      'I'                         ; Reverse line feed. Insert line above and move cursor up. Not supported
0368+  F06C C8                              RET     Z                    
0369+  F06D             
0370+  F06D FE 4A                           CP      'J'
0371+  F06F 20 19                           JR      NZ, _conout_not_clr_sc
0372+  F071             
0373+  F071 CD 94 F0                        CALL    _conout_clr_ln
0374+  F074 ED 4B 2D FF                     LD      BC, (cursor_row)
0375+  F078 0E 00                           LD      C, 0
0376+  F07A 04          _conout_clr_scrn    INC     B
0377+  F07B 3A 2F FF                        LD      A, (console_height)
0378+  F07E B8                              CP      B
0379+  F07F CA AA F1                        JP      Z, _redraw_buffer
0380+  F082 C5                              PUSH    BC
0381+  F083 78                              LD      A, B
0382+  F084 CD C8 F2                        CALL    clear_screen_row
0383+  F087 C1                              POP     BC
0384+  F088 18 F0                           JR      _conout_clr_scrn
0385+  F08A             
0386+  F08A FE 4B       _conout_not_clr_sc  CP      'K'
0387+  F08C 20 11                           JR      NZ, _conout_not_clr_ln
0388+  F08E             
0389+  F08E CD 94 F0                        CALL   _conout_clr_ln
0390+  F091 C3 AA F1                        JP     _redraw_buffer
0391+  F094             
0392+  F094 ED 4B 2D FF _conout_clr_ln      LD      BC, (cursor_row)
0393+  F098 05                              DEC     B
0394+  F099 79                              LD      A, C
0395+  F09A 3D                              DEC     A
0396+  F09B 48                              LD      C, B
0397+  F09C C3 C8 F2                        JP      clear_screen_row
0398+  F09F             
0399+  F09F FE 59       _conout_not_clr_ln  CP      'Y'
0400+  F0A1 20 08                           JR      NZ, _conout_not_pos
0401+  F0A3             
0402+  F0A3 32 34 FF    _conout_start_esc   LD      (console_escape), A         ; Start an escape sequence
0403+  F0A6 AF                              XOR     A
0404+  F0A7 32 35 FF                        LD      (console_param1), A
0405+  F0AA C9                              RET
0406+  F0AB             
0407+  F0AB FE 5A       _conout_not_pos     CP      'Z'
0408+  F0AD 20 06                           JR      NZ, _conout_not_ident
0409+  F0AF 3E 03                           LD      A, IDENTITY_LENGTH
0410+  F0B1 32 36 FF                        LD      (console_identify), A
0411+  F0B4 C9                              RET
0412+  F0B5             
0413+  F0B5 FE 62       _conout_not_ident   CP      'b'
0414+  F0B7 28 EA                           JR      Z, _conout_start_esc
0415+  F0B9 FE 63                           CP      'c'
0416+  F0BB 28 E6                           JR      Z, _conout_start_esc
0417+  F0BD             
0418+  F0BD                                 ; TODO: Any addtional escape sequences here...
0419+  F0BD C9                              RET
0420+  F0BE             
0421+  F0BE 79          _conout_check_esc   LD      A, C                    
0422+  F0BF FE 1B                           CP      ESCAPE_CHAR
0423+  F0C1 C2 71 F2                        JP      NZ, _conout_character
0424+  F0C4             
0425+  F0C4 3A 32 FF                        LD      A, (console_flags)
0426+  F0C7 F6 08                           OR      CFLAGS_ESCAPE
0427+  F0C9 32 32 FF                        LD      (console_flags), A
0428+  F0CC AF                              XOR     A
0429+  F0CD 32 34 FF                        LD      (console_escape),A
0430+  F0D0 C9                              RET
0431+  F0D1             
0432+  F0D1 3A 34 FF    _conout_escape_seq  LD      A,(console_escape)
0433+  F0D4 FE 59                           CP      'Y'
0434+  F0D6 28 0D                           JR      Z, _conout_esc_pos
0435+  F0D8 FE 62                           CP      'b'
0436+  F0DA 28 20                           JR      Z, _conout_esc_foreg
0437+  F0DC FE 63                           CP      'c'
0438+  F0DE 28 2D                           JR      Z, _conout_esc_backg
0439+  F0E0             
0440+  F0E0                                 ; All unknown sequences reset the escape sequence
0441+  F0E0 AF          _conout_reset_seq   XOR     A
0442+  F0E1 32 34 FF                        LD      (console_escape),A
0443+  F0E4 C9                              RET
0444+  F0E5             
0445+  F0E5 3A 35 FF    _conout_esc_pos     LD      A, (console_param1)
0446+  F0E8 A7                              AND     A
0447+  F0E9 20 05                           JR      NZ, _conout_pos_param
0448+  F0EB 79                              LD      A, C
0449+  F0EC 32 35 FF                        LD      (console_param1),A
0450+  F0EF C9                              RET
0451+  F0F0             
0452+  F0F0 D6 1F       _conout_pos_param   SUB     31
0453+  F0F2 5F                              LD      E, A
0454+  F0F3 79                              LD      A, C
0455+  F0F4 D6 1F                           SUB     31
0456+  F0F6 57                              LD      D, A
0457+  F0F7 CD E0 F0                        CALL    _conout_reset_seq
0458+  F0FA 18 24                           JR      _conout_csr_update
0459+  F0FC             
0460+  F0FC 3A 31 FF    _conout_esc_foreg   LD      A, (console_colour)
0461+  F0FF E6 F0                           AND     0F0h
0462+  F101 47                              LD      B, A
0463+  F102 79                              LD      A, C
0464+  F103 D6 1F                           SUB     31
0465+  F105 E6 0F                           AND     0Fh
0466+  F107 B0          _conout_set_colour  OR      B
0467+  F108 32 31 FF                        LD      (console_colour), A
0468+  F10B 18 D3                           JR      _conout_reset_seq
0469+  F10D             
0470+  F10D 3A 31 FF    _conout_esc_backg   LD      A, (console_colour)
0471+  F110 E6 0F                           AND     0Fh
0472+  F112 47                              LD      B, A
0473+  F113 79                              LD      A, C
0474+  F114 D6 1F                           SUB     31
0475+  F116 CB 27                           SLA     A
0476+  F118 CB 27                           SLA     A
0477+  F11A CB 27                           SLA     A
0478+  F11C CB 27                           SLA     A
0479+  F11E 18 E7                           JR      _conout_set_colour
0480+  F120             
0481+  F120             ; Cursor position has changed, check if we need to update the whole display.
0482+  F120             ; This is entered with DE as D = new cursor column, E = new cursor row
0483+  F120             ;         Writes new cursor poition to (cursor_row, cursor_column)
0484+  F120             ;         Returns HL = updated display column, row to track the cursor position..
0485+  F120             ; Assume column is always within range, row may be before start/after end of visible screen
0486+  F120             ;
0487+  F120 2A 2B FF    _conout_csr_update  LD      HL, (display_row)           ; HL = current display column, row..
0488+  F123 ED 4B 2D FF                     LD      BC, (cursor_row)            ; BC = old values of cursor column, row
0489+  F127 7B                              LD      A, E                        
0490+  F128 B9                              CP      C
0491+  F129 32 2D FF                        LD      (cursor_row), A
0492+  F12C 20 09                           JR      NZ, _conout_check_row       ; If cursor row has changed, we must update display_row and optionally screen_offset
0493+  F12E             
0494+  F12E 7A          _conout_track_col   LD      A, D
0495+  F12F B8                              CP      B
0496+  F130 32 2E FF                        LD      (cursor_col), A
0497+  F133 20 19                           JR      NZ, _conout_check_col       ; If only column has changed, we may update display_col..
0498+  F135 18 73                           JR      _redraw_buffer              ; Otherwise, nothing has changed. Make sure display is up to date
0499+  F137             
0500+  F137 A7          _conout_check_row   AND     A                           
0501+  F138 20 05                           JR      NZ, _conout_chk_bottom         
0502+  F13A 3C                              INC     A                           ; We're above the screen, fix the cursor_row but set L (display row) to -1 
0503+  F13B 32 2D FF                        LD      (cursor_row), A
0504+  F13E             
0505+  F13E AF                              XOR     A
0506+  F13F             
0507+  F13F 3D          _conout_chk_bottom  DEC     A
0508+  F140 6F                              LD      L, A                        ; Update the display row in HL which will force refresh
0509+  F141 3A 2F FF                        LD      A, (console_height)
0510+  F144 BD                              CP      L
0511+  F145 20 03                           JR      NZ, _conout_not_bottom
0512+  F147             
0513+  F147 32 2D FF                        LD      (cursor_row), A
0514+  F14A             
0515+  F14A 7A          _conout_not_bottom  LD      A, D                        ; Write col here since it wasn't previously set...
0516+  F14B 32 2E FF                        LD      (cursor_col), A
0517+  F14E             
0518+  F14E 7C          _conout_check_col   LD      A, H                        ; Current display col
0519+  F14F 3C                              INC     A
0520+  F150 92                              SUB     D                           ; Subtract new cursor col
0521+  F151 30 18                           JR      NC, _conout_scroll_l        ; Cursor col is before beginning of screen
0522+  F153             
0523+  F153 3A 32 FF                        LD      A, (console_flags)
0524+  F156 E6 01                           AND     CFLAGS_SHOW_CURSOR
0525+  F158 3E 01                           LD      A, 1
0526+  F15A 28 01                           JR      Z, _conout_keep_left
0527+  F15C 3D                              DEC     A
0528+  F15D C6 18       _conout_keep_left   ADD     A, DISPLAY_WIDTH          
0529+  F15F 47                              LD      B, A
0530+  F160 84                              ADD     A, H                        ; Right hand edge of display...
0531+  F161 BA                              CP      D
0532+  F162 30 0A                           JR      NC, _conout_refresh
0533+  F164             
0534+  F164 7A                              LD      A, D                        ; Cursor col is after end of screen
0535+  F165 90                              SUB     B
0536+  F166 30 05                           JR      NC, _conout_scroll_done
0537+  F168 AF                              XOR     A
0538+  F169 18 02                           JR      _conout_scroll_done
0539+  F16B             
0540+  F16B 7A          _conout_scroll_l    LD      A, D
0541+  F16C 3D                              DEC     A
0542+  F16D 67          _conout_scroll_done LD      H, A
0543+  F16E             
0544+  F16E             
0545+  F16E             ; We enter with HL = new display column, row
0546+  F16E             ; At this point one or both of display row or column may changed, so update the whole display...   
0547+  F16E             ; If row is -1, we're before the beginning of the screen - need to scroll up
0548+  F16E             ; And if row > console_height, we need to scroll down.. Display row stays constant, but screen_offset changes..
0549+  F16E             
0550+  F16E             ; Do scroll first, then only change display row/col if console_flags is set to track cursor..
0551+  F16E             ; If display row/col have changed, compare screen buffer with display buffer and update whichever characters/brightnesses have changed..
0552+  F16E             ;
0553+  F16E             ; 
0554+  F16E             _conout_refresh     
0555+  F16E 7D                              LD      A, L
0556+  F16F B7                              OR      A
0557+  F170 F2 87 F1                        JP      P, _conout_row_postv
0558+  F173             
0559+  F173                                 ; Display row negative
0560+  F173 AF                              XOR     A
0561+  F174 6F                              LD      L, A                        ; Reset display row to zero
0562+  F175 3A 2A FF                        LD      A, (screen_offset)
0563+  F178 3D                              DEC     A
0564+  F179 E6 3F                           AND     03Fh
0565+  F17B 32 2A FF                        LD      (screen_offset), A
0566+  F17E E5                              PUSH    HL
0567+  F17F 0E 00                           LD      C, 0
0568+  F181 CD C8 F2                        CALL    clear_screen_row
0569+  F184 E1                              POP     HL
0570+  F185 18 19                           JR      _conout_update_display
0571+  F187             
0572+  F187 3A 2F FF    _conout_row_postv   LD      A, (console_height)
0573+  F18A 4F                              LD      C, A                        ; Remember for later on
0574+  F18B BD                              CP      L
0575+  F18C 20 12                           JR      NZ, _conout_update_display
0576+  F18E             
0577+  F18E                                 ; display row below screen
0578+  F18E 3A 2A FF                        LD      A, (screen_offset)
0579+  F191 3C                              INC     A
0580+  F192 E6 3F                           AND     03Fh
0581+  F194 32 2A FF                        LD      (screen_offset), A
0582+  F197 79                              LD      A, C
0583+  F198 E5                              PUSH    HL
0584+  F199 0E 00                           LD      C, 0
0585+  F19B CD C8 F2                        CALL    clear_screen_row
0586+  F19E E1                              POP     HL 
0587+  F19F 2D                              DEC     L
0588+  F1A0             
0589+  F1A0             _conout_update_display
0590+  F1A0                                 ; We've scrolled if necessary, update the display row if required..
0591+  F1A0 3A 32 FF                        LD      A, (console_flags)
0592+  F1A3 E6 02                           AND     CFLAGS_TRACK_CURSOR         
0593+  F1A5 28 03                           JR      Z, _redraw_buffer
0594+  F1A7 22 2B FF                        LD      (display_row), HL           ; Only move display row if we're tracking the cursor
0595+  F1AA             
0596+  F1AA F3          _redraw_buffer      DI
0597+  F1AB CD B0 F1                        CALL    unsafe_redraw
0598+  F1AE FB                              EI
0599+  F1AF C9                              RET
0600+  F1B0             
0601+  F1B0             ;----------------------------------------------------------------------------------------------------
0602+  F1B0             ; Note that this uses Mem Page 1
0603+  F1B0             ;
0604+  F1B0 2A 2B FF    unsafe_redraw       LD      HL, (display_row)       ; Calculate our screen source in DE
0605+  F1B3 3A 2A FF                        LD      A, (screen_offset)      
0606+  F1B6 85                              ADD     A, L
0607+  F1B7             
0608+  F1B7 E6 3F                           AND     03Fh
0609+  F1B9 F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0610+  F1BB 57                              LD      D, A
0611+  F1BC 7C                              LD      A, H
0612+  F1BD CB 27                           SLA     A
0613+  F1BF 5F                              LD      E, A
0614+  F1C0             
0615+  F1C0 21 84 FF                        LD      HL, display_buffer
0616+  F1C3 06 18                           LD      B, DISPLAY_WIDTH
0617+  F1C5 0E 00                           LD      C, 0
0618+  F1C7             
0619+  F1C7 3A 32 FF                        LD      A, (console_flags)      ; Don't draw last character if we've moved
0620+  F1CA E6 04                           AND     CFLAGS_SHOW_MOVED
0621+  F1CC 28 01                           JR      Z, _full_redraw
0622+  F1CE 05                              DEC     B
0623+  F1CF             
0624+  F1CF 3A 29 FF    _full_redraw        LD      A, (screen_page)
0625+  F1D2 D3 71                           OUT     (IO_MEM_1), A
0626+  F1D4             
0627+  F1D4 1A          _redraw_loop        LD      A, (DE)
0628+  F1D5 BE                              CP      (HL)
0629+  F1D6 28 0A                           JR      Z, _redraw_skip_char
0630+  F1D8 77                              LD      (HL), A
0631+  F1D9 C5                              PUSH    BC
0632+  F1DA E5                              PUSH    HL
0633+  F1DB D5                              PUSH    DE
0634+  F1DC CD 08 FB                        CALL    disp_character
0635+  F1DF D1                              POP     DE
0636+  F1E0 E1                              POP     HL
0637+  F1E1 C1                              POP     BC
0638+  F1E2             
0639+  F1E2 23          _redraw_skip_char   INC     HL
0640+  F1E3 13                              INC     DE
0641+  F1E4             
0642+  F1E4 3A 32 FF                        LD      A, (console_flags)
0643+  F1E7 E6 04                           AND     CFLAGS_SHOW_MOVED
0644+  F1E9 1A                              LD      A, (DE)  
0645+  F1EA 28 05                           JR      Z, _redraw_normal
0646+  F1EC             
0647+  F1EC CB 3F                           SRL     A
0648+  F1EE CB 3F                           SRL     A
0649+  F1F0 3C                              INC     A
0650+  F1F1             
0651+  F1F1 BE          _redraw_normal      CP      (HL)
0652+  F1F2 28 12                           JR      Z, _redraw_skip_bri
0653+  F1F4 77                              LD      (HL), A
0654+  F1F5 C5                              PUSH    BC
0655+  F1F6 E5                              PUSH    HL
0656+  F1F7 D5                              PUSH    DE
0657+  F1F8 79                              LD      A, C                    ; Ugh... disp_char_bright has parameters in other order..
0658+  F1F9 4E                              LD      C, (HL)
0659+  F1FA CB 21                           SLA     C
0660+  F1FC CB 21                           SLA     C
0661+  F1FE CB 21                           SLA     C
0662+  F200 CD CA FA                        CALL    disp_char_bright    ; Column A, brightness C
0663+  F203 D1                              POP     DE
0664+  F204 E1                              POP     HL
0665+  F205 C1                              POP     BC
0666+  F206             
0667+  F206 23          _redraw_skip_bri    INC     HL
0668+  F207 13                              INC     DE
0669+  F208 0C                              INC     C
0670+  F209 10 C9                           DJNZ    _redraw_loop
0671+  F20B             
0672+  F20B 3A 32 FF                        LD      A, (console_flags)
0673+  F20E 4F                              LD      C, A
0674+  F20F E6 04                           AND     CFLAGS_SHOW_MOVED
0675+  F211 28 53                           JR      Z, _redraw_done
0676+  F213             
0677+  F213                                 ; We've moved the cursor, so draw the last character as our location bitmap..
0678+  F213 36 00       _redraw_moved       LD      (HL), 0
0679+  F215 23                              INC     HL
0680+  F216 36 80                           LD      (HL), DISP_DEFAULT_BRIGHTNESS
0681+  F218 79                              LD      A, C
0682+  F219 E6 02                           AND     CFLAGS_TRACK_CURSOR
0683+  F21B 20 4F                           JR      NZ, _redraw_tracking
0684+  F21D             
0685+  F21D 21 00 00                        LD      HL, 0
0686+  F220 ED 4B 2D FF                     LD      BC, (cursor_row)
0687+  F224 0D                              DEC     C
0688+  F225                                 
0689+  F225 ED 5B 2B FF                     LD      DE, (display_row)
0690+  F229 7B                              LD      A, E
0691+  F22A A7                              AND     A
0692+  F22B 20 05                           JR      NZ, _redraw_not_top
0693+  F22D 21 01 00                        LD      HL, MOVE_TOP_BITMAP
0694+  F230 18 0A                           JR      _redraw_not_bottom
0695+  F232             
0696+  F232 3A 2F FF    _redraw_not_top     LD      A, (console_height)
0697+  F235 3D                              DEC     A
0698+  F236 BB                              CP      E
0699+  F237 20 03                           JR      NZ, _redraw_not_bottom
0700+  F239 21 08 00                        LD      HL, MOVE_BOTTOM_BITMAP
0701+  F23C             
0702+  F23C 7B          _redraw_not_bottom  LD      A, E
0703+  F23D B9                              CP      C
0704+  F23E 01 00 00                        LD      BC, 0
0705+  F241 20 04                           JR      NZ, _redraw_not_row
0706+  F243 0E C0                           LD      C, MOVE_ROW_BITMAP_L
0707+  F245 18 08                           JR      _redraw_map
0708+  F247             
0709+  F247 06 28       _redraw_not_row     LD      B, MOVE_BELOW_BITMAP_H
0710+  F249 38 02                           JR      C, _redraw_not_above
0711+  F24B 18 02                           JR      _redraw_map
0712+  F24D             
0713+  F24D 06 05       _redraw_not_above   LD      B, MOVE_ABOVE_BITMAP_H
0714+  F24F             
0715+  F24F 09          _redraw_map         ADD     HL, BC
0716+  F250 3A 2C FF                        LD      A, (display_col)
0717+  F253 A7                              AND     A
0718+  F254 20 04                           JR      NZ, _redraw_map2
0719+  F256 3E 30                           LD      A, MOVE_AT_LEFT_BITMAP
0720+  F258 B5                              OR      L
0721+  F259 6F                              LD      L, A
0722+  F25A 3E 17       _redraw_map2        LD      A, DISPLAY_WIDTH-1
0723+  F25C CD 29 FB                        CALL    disp_bitmask
0724+  F25F             
0725+  F25F 3E 17                           LD      A, DISPLAY_WIDTH-1
0726+  F261 0E 80                           LD      C, DISP_DEFAULT_BRIGHTNESS
0727+  F263 CD CA FA                        CALL    disp_char_bright
0728+  F266             
0729+  F266 3A 3A FF    _redraw_done        LD      A, (page_1_mapping)
0730+  F269 D3 71                           OUT     (IO_MEM_1), A
0731+  F26B C9                              RET
0732+  F26C             
0733+  F26C 21 3F 2D    _redraw_tracking    LD      HL, 2d3fh          ; Tracking symbol
0734+  F26F 18 E9                           JR      _redraw_map2
0735+  F271             
0736+  F271             MOVE_TOP_BITMAP     .EQU    0001h
0737+  F271             MOVE_BOTTOM_BITMAP  .EQU    0008h
0738+  F271             MOVE_ROW_BITMAP_L   .EQU    0c0h
0739+  F271             MOVE_ABOVE_BITMAP_H .EQU    05h
0740+  F271             MOVE_BELOW_BITMAP_H .EQU    28h
0741+  F271             MOVE_AT_LEFT_BITMAP .EQU    030h
0742+  F271             
0743+  F271             ;---------------------------------------- Simple character output.. 
0744+  F271 ED 5B 2D FF _conout_character   LD      DE, (cursor_row)
0745+  F275 FE 0D                           CP      CARRIAGE_RETURN
0746+  F277 20 05                           JR      NZ, _conout_not_cr
0747+  F279                
0748+  F279 16 01                           LD      D, 1
0749+  F27B C3 20 F1                        JP      _conout_csr_update
0750+  F27E             
0751+  F27E FE 0A       _conout_not_cr      CP      NEWLINE
0752+  F280 20 04                           JR      NZ, _conout_not_lf
0753+  F282             
0754+  F282 1C                              INC     E
0755+  F283 C3 20 F1                        JP      _conout_csr_update
0756+  F286             
0757+  F286 FE 08       _conout_not_lf      CP      BACKSPACE_CHAR
0758+  F288 20 05                           JR      NZ, _conout_visible
0759+  F28A             
0760+  F28A 15                              DEC     D
0761+  F28B C2 20 F1                        JP      NZ, _conout_csr_update
0762+  F28E C9                              RET
0763+  F28F             
0764+  F28F                                 ; Now, C is character to write,
0765+  F28F ED 5B 2D FF _conout_visible     LD      DE, (cursor_row)
0766+  F293 15                              DEC     D                       ; 1 based col
0767+  F294 1D                              DEC     E                       ; 1 based row
0768+  F295             
0769+  F295 3A 2A FF                        LD      A, (screen_offset)      ; Write the character and colour into our screen buffer
0770+  F298 83                              ADD     A, E
0771+  F299             
0772+  F299 E6 3F                           AND     03Fh
0773+  F29B F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0774+  F29D 67                              LD      H, A
0775+  F29E 7A                              LD      A, D
0776+  F29F CB 27                           SLA     A
0777+  F2A1 6F                              LD      L, A
0778+  F2A2 3A 29 FF                        LD      A, (screen_page)
0779+  F2A5 D3 71                           OUT     (IO_MEM_1), A
0780+  F2A7 71                              LD      (HL), C
0781+  F2A8 3A 31 FF                        LD      A, (console_colour)
0782+  F2AB 23                              INC     HL
0783+  F2AC 77                              LD      (HL), A
0784+  F2AD 3A 3A FF                        LD      A, (page_1_mapping)
0785+  F2B0 D3 71                           OUT     (IO_MEM_1), A
0786+  F2B2             
0787+  F2B2 ED 5B 2D FF                     LD      DE, (cursor_row)
0788+  F2B6 3A 30 FF                        LD      A, (console_width)
0789+  F2B9 6F                              LD      L, A
0790+  F2BA 7A                              LD      A, D
0791+  F2BB BD                              CP      L
0792+  F2BC 28 04                           JR      Z, _conout_wrap
0793+  F2BE 14                              INC     D
0794+  F2BF C3 20 F1                        JP      _conout_csr_update
0795+  F2C2             
0796+  F2C2 16 01       _conout_wrap        LD      D, 1
0797+  F2C4 1C                              INC     E
0798+  F2C5 C3 20 F1                        JP      _conout_csr_update          ; If we've wrapped, use the new wrap position..
0799+  F2C8             ;
0800+  F2C8             ;
0801+  F2C8             ; Fill the row of the screen buffer with space chars..
0802+  F2C8             ; Enter with A -> row of screen buffer, C -> start column
0803+  F2C8             ;          Uses HL, C
0804+  F2C8             ;
0805+  F2C8 67          clear_screen_row    LD      H, A
0806+  F2C9 3A 2A FF                        LD      A, (screen_offset)
0807+  F2CC 84                              ADD     A, H
0808+  F2CD             
0809+  F2CD E6 3F                           AND    03Fh
0810+  F2CF F6 40                           OR     040h
0811+  F2D1 67                              LD     H, A
0812+  F2D2 79                              LD     A, C
0813+  F2D3 81                              ADD    A, C
0814+  F2D4 6F                              LD     L, A
0815+  F2D5             
0816+  F2D5 3A 31 FF                        LD      A, (console_colour)
0817+  F2D8 4F                              LD      C, A
0818+  F2D9             
0819+  F2D9 3A 29 FF                        LD      A, (screen_page)
0820+  F2DC D3 71                           OUT     (IO_MEM_1), A
0821+  F2DE             
0822+  F2DE 3E 20                           LD      A, ' '
0823+  F2E0 77          _clear_loop         LD      (HL), A
0824+  F2E1 2C                              INC     L
0825+  F2E2 71                              LD      (HL), C
0826+  F2E3 2C                              INC     L
0827+  F2E4 3E FE                           LD      A, 0FEh
0828+  F2E6 BD                              CP      L
0829+  F2E7 20 F7                           JR      NZ, _clear_loop
0830+  F2E9             
0831+  F2E9 3A 3A FF                        LD      A, (page_1_mapping)
0832+  F2EC D3 71                           OUT     (IO_MEM_1), A
0833+  F2EE C9                              RET
0834+  F2EF             ;------------------------------------------------------  
0835+  F2EF             bios_list     ;  5 List OUTput
0836+  F2EF AF                              XOR     A
0837+  F2F0 C9                              RET
0838+  F2F1                                 
0839+  F2F1             ;------------------------------------------------------  
0840+  F2F1             bios_punch    ;  6 punch OUTput
0841+  F2F1 AF                              XOR     A
0842+  F2F2 C9                              RET
0843+  F2F3                                 
0844+  F2F3             ;------------------------------------------------------  
0845+  F2F3             bios_reader   ;  7 Reader input
0846+  F2F3 C9                              RET
0847+  F2F4                                 
0848+  F2F4             
0849+  F2F4                                 
0850+  F2F4             ;------------------------------------------------------  
0851+  F2F4             bios_seldsk   ;  9 Select disk - Select disc in C, returns HL =  address of DPH, or 0 if error
0852+  F2F4                                 ; Store C in A, Check drive is in range
0853+  F2F4 79                              LD      A, C
0854+  F2F5 21 00 00                        LD      HL, 0
0855+  F2F8 FE 02                           CP      MAX_DRIVES
0856+  F2FA D0                              RET     NC
0857+  F2FB             
0858+  F2FB 06 00                           LD      B, 0
0859+  F2FD CB 21                           SLA     C
0860+  F2FF CB 21                           SLA     C
0861+  F301 CB 21                           SLA     C
0862+  F303 CB 21                           SLA     C
0863+  F305 21 33 EE                        LD      HL, dpbase
0864+  F308 09                              ADD     HL, BC
0865+  F309 32 43 FF                        LD      (sys_seldsk), A
0866+  F30C C9                              RET
0867+  F30D             
0868+  F30D             ;------------------------------------------------------  
0869+  F30D             bios_home     ;  8 Home disk
0870+  F30D 0E 00                           LD      C, 0            
0871+  F30F             ;------------------------------------------------------  
0872+  F30F             bios_settrk   ; 10 Select track - Move drive to track stored in C - 0 based (0-76)
0873+  F30F 79                              LD      A, C
0874+  F310 32 3C FF                        LD      (sys_track), A
0875+  F313 C9                              RET
0876+  F314                                 
0877+  F314             ;------------------------------------------------------  
0878+  F314             bios_setsec   ; 11 Select sector - Move drive to sector stored in BC - 1 based (1-26) - TODO: Confirm this, not sure if true..
0879+  F314 ED 43 3D FF                     LD      (sys_sector), BC
0880+  F318 C9                              RET
0881+  F319                                 
0882+  F319             ;------------------------------------------------------  
0883+  F319             bios_setdma   ; 12 Set DMA ADDress - Set the DMA address to BC - source or destination for disk read/write
0884+  F319                           ; Note: CP/M 2.2 appears to only set this to the DIRBUF address defined in the DPF, or the USER DMA address (0x80h)
0885+  F319 ED 43 3F FF                     LD      (sys_dmaaddr), BC
0886+  F31D C9                              RET
0887+  F31E                                 
0888+  F31E             ;------------------------------------------------------  
0889+  F31E             ;
0890+  F31E             ; Uses Mem Page 1, 2
0891+  F31E             ;
0892+  F31E             bios_read     ; 13 Read 128 bytes
0893+  F31E CD 8A F3                        CALL    _get_memdisc_addr
0894+  F321 F3                              DI
0895+  F322 D3 71                           OUT     (IO_MEM_1), A
0896+  F324 CB F0                           SET     6, B            ; Point B into page 1
0897+  F326 C5                              PUSH    BC
0898+  F327 E1                              POP     HL
0899+  F328 0E 80                           LD      C, 128
0900+  F32A             
0901+  F32A ED 5B 3F FF                     LD      DE, (sys_dmaaddr)
0902+  F32E 7A                              LD      A, D
0903+  F32F 07                              RLCA
0904+  F330 07                              RLCA
0905+  F331 E6 03                           AND     03h             ; Bottom two bits
0906+  F333 F6 20                           OR      RAM_PAGE_0
0907+  F335 47                              LD      B, A            ; B is destination page
0908+  F336 D3 72       _read_page          OUT     (IO_MEM_2), A
0909+  F338             
0910+  F338 CB FA                           SET     7, D            ; Point D to second page
0911+  F33A CB B2                           RES     6, D
0912+  F33C             
0913+  F33C ED A0       _read_next          LDI
0914+  F33E 79                              LD      A, C
0915+  F33F B7                              OR      A
0916+  F340 28 08                           JR      Z, _read_write_done
0917+  F342             
0918+  F342 CB 72                           BIT     6, D
0919+  F344 28 F6                           JR      Z, _read_next
0920+  F346             
0921+  F346 04                              INC     B
0922+  F347 78                              LD      A, B
0923+  F348 18 EC                           JR      _read_page
0924+  F34A             
0925+  F34A 3A 3A FF    _read_write_done    LD      A, (page_1_mapping)   ; Return page map to normal
0926+  F34D D3 71                           OUT     (IO_MEM_1), A
0927+  F34F 3A 3B FF                        LD      A, (page_2_mapping)
0928+  F352 D3 72                           OUT     (IO_MEM_2), A
0929+  F354 FB                              EI
0930+  F355 AF                              XOR     A               ; No errors
0931+  F356 C9                              RET
0932+  F357                                 
0933+  F357             ;------------------------------------------------------  
0934+  F357             ;
0935+  F357             ; Uses Mem Page 1, 2
0936+  F357             ;
0937+  F357             bios_write    ; 14 Write 128 bytes
0938+  F357 3A 43 FF                        LD      A, (sys_seldsk)
0939+  F35A B7                              OR      A
0940+  F35B 20 02                           JR      NZ, _write_ok
0941+  F35D 3C                              INC     A
0942+  F35E C9                              RET
0943+  F35F             
0944+  F35F CD 8A F3    _write_ok           CALL    _get_memdisc_addr
0945+  F362 F3                              DI
0946+  F363 D3 71                           OUT     (IO_MEM_1), A
0947+  F365 CB F0                           SET     6, B
0948+  F367 C5                              PUSH    BC
0949+  F368 D1                              POP     DE
0950+  F369 0E 80                           LD      C, 128
0951+  F36B             
0952+  F36B 2A 3F FF                        LD      HL, (sys_dmaaddr)
0953+  F36E 7C                              LD      A, H
0954+  F36F 07                              RLCA
0955+  F370 07                              RLCA
0956+  F371 E6 03                           AND     03h              ; Bottom two bits
0957+  F373 F6 20                           OR      RAM_PAGE_0
0958+  F375 47                              LD      B, A             ; B is source page
0959+  F376 D3 72       _write_page         OUT     (IO_MEM_2), A
0960+  F378             
0961+  F378 CB FC                           SET     7, H
0962+  F37A CB B4                           RES     6, H
0963+  F37C             
0964+  F37C ED A0       _write_next         LDI
0965+  F37E 79                              LD      A, C
0966+  F37F B7                              OR      A
0967+  F380 28 C8                           JR      Z, _read_write_done
0968+  F382             
0969+  F382 CB 74                           BIT     6, H
0970+  F384 28 F6                           JR      Z, _write_next
0971+  F386             
0972+  F386 04                              INC     B
0973+  F387 78                              LD      A, B
0974+  F388 18 EC                           JR      _write_page
0975+  F38A                                 
0976+  F38A             ; IN THIS CASE, WE HAVE SAVED THE DISK NUMBER IN 'DISKNO' (0, 1)
0977+  F38A             ;           THE TRACK NUMBER IN 'TRACK' (0-76)
0978+  F38A             ;           THE SECTOR NUMBER IN 'SECTOR' (1-26)
0979+  F38A             ;           THE DMA ADDRESS IN 'DMAAD' (0-65535)
0980+  F38A             ;
0981+  F38A             ; Returns BC = address in page for sector
0982+  F38A             ;          A = page number (ROM/RAM)
0983+  F38A             ;
0984+  F38A             ; Note: BC is always aligned to page boundaries, so a sector will never overlap the end of a page.
0985+  F38A             ;
0986+  F38A 21 00 00    _get_memdisc_addr   LD      HL, 0
0987+  F38D ED 4B 3C FF                     LD      BC, (sys_track)     ; C is track, B is sector (up to 256!)
0988+  F391 68                              LD      L, B
0989+  F392 44                              LD      B, H 
0990+  F393 CB 21                           SLA     C                   ; x 2
0991+  F395 CB 10                           RL      B
0992+  F397 09                              ADD     HL, BC
0993+  F398 CB 21                           SLA     C                   ; x 4
0994+  F39A CB 10                           RL      B
0995+  F39C CB 21                           SLA     C                   ; x 8
0996+  F39E CB 10                           RL      B
0997+  F3A0 09                              ADD     HL, BC
0998+  F3A1 CB 21                           SLA     C                   ; x 16
0999+  F3A3 CB 10                           RL      B
1000+  F3A5 09                              ADD     HL, BC              ; HL = Sector + BC * (2 + 8 + 16) = sector + track * 26
1001+  F3A6             
1002+  F3A6 7D                              LD      A, L
1003+  F3A7 E6 7F                           AND     07Fh
1004+  F3A9 47                              LD      B, A
1005+  F3AA 0E 00                           LD      C, 0
1006+  F3AC CB 38                           SRL     B
1007+  F3AE CB 19                           RR      C                   ; BC = Address in page of sector
1008+  F3B0             
1009+  F3B0 CB 25                           SLA     L
1010+  F3B2 CB 14                           RL      H                   ; H is now page number 
1011+  F3B4             
1012+  F3B4 3A 43 FF                        LD      A, (sys_seldsk)
1013+  F3B7 B7                              OR      A
1014+  F3B8 28 05                           JR      Z, _get_memdisk_a
1015+  F3BA 3A 38 FF                        LD      A, (drive_b_mem_page)
1016+  F3BD 84                              ADD     A, H
1017+  F3BE C9                              RET
1018+  F3BF 3A 37 FF    _get_memdisk_a      LD      A, (drive_a_mem_page)
1019+  F3C2 84                              ADD     A, H
1020+  F3C3 C9                              RET
1021+  F3C4             
1022+  F3C4             
1023+  F3C4             ;------------------------------------------------------  
1024+  F3C4             bios_listst   ; 15 List status
1025+  F3C4 AF                              XOR     A
1026+  F3C5 C9                              RET
1027+  F3C6                                 
1028+  F3C6             ;------------------------------------------------------  
1029+  F3C6             bios_sectrn   ; 16 Sector translate - BC = logical sector number (zero based), DE = address of translation table. Return HL as physical sector number
1030+  F3C6 69                              LD      L, C                ; No skewing needed, just return BC in HL
1031+  F3C7 60                              LD      H, B
1032+  F3C8 C9                              RET
1033+  F3C9                                 
1034+  F3C9             ;------------------------------------------------------
1035+  F3C9             ; Inline print. Preserves HL, DE, BC
1036+  F3C9             ;
1037+  F3C9 E3          m_print_inline      EX      (SP), HL
1038+  F3CA 7E          _inline_loop        LD      A, (HL)
1039+  F3CB 23                              INC     HL
1040+  F3CC A7                              AND     A
1041+  F3CD 28 05                           JR      Z, _inline_done
1042+  F3CF CD D6 F3                        CALL    m_print_a_safe
1043+  F3D2 18 F6                           JR      _inline_loop
1044+  F3D4             
1045+  F3D4 E3          _inline_done        EX      (SP), HL
1046+  F3D5 C9                              RET
1047+  F3D6             
1048+  F3D6             ;------------------------------------------------------
1049+  F3D6             ; Print character in A. Preserves HL, DE, BC
1050+  F3D6             ;
1051+  F3D6 E5          m_print_a_safe      PUSH    HL
1052+  F3D7 D5                              PUSH    DE
1053+  F3D8 C5                              PUSH    BC
1054+  F3D9 4F                              LD      C, A
1055+  F3DA CD 00 F0                        CALL    bios_conout
1056+  F3DD C1                              POP     BC
1057+  F3DE D1                              POP     DE
1058+  F3DF E1                              POP     HL
1059+  F3E0 C9                              RET
1060+  F3E1             
1061+  F3E1             ;------------------------------------------------------  
1062+  F3E1             
1063+  F3E1 F3          configure_hardware  DI     
1064+  F3E2 3E 20                           LD      A, RAM_PAGE_0
1065+  F3E4 D3 70                           OUT     (IO_MEM_0), A       ; Page 0 is RAM 0 
1066+  F3E6 32 39 FF                        LD      (page_0_mapping), A
1067+  F3E9 3C                              INC     A
1068+  F3EA D3 71                           OUT     (IO_MEM_1), A       ; Page 1 is RAM 1
1069+  F3EC 32 3A FF                        LD      (page_1_mapping), A
1070+  F3EF 3C                              INC      A
1071+  F3F0 D3 72                           OUT     (IO_MEM_2), A       ; Page 2 is RAM 2 
1072+  F3F2 32 3B FF                        LD      (page_2_mapping), A
1073+  F3F5             
1074+  F3F5 21 00 FE                        LD      HL, 0FE00h          ; Set up the IM 2 table
1075+  F3F8 06 00                           LD      B, 0
1076+  F3FA 36 FD       _fill_vector        LD      (HL), 0FDh
1077+  F3FC 23                              INC     HL
1078+  F3FD 10 FB                           DJNZ    _fill_vector
1079+  F3FF             
1080+  F3FF CD C9 F5                        CALL    keyboard_init       ; Set up the keyboard status tables
1081+  F402             
1082+  F402 3E C3                           LD      A, 0C3h             ; JP reset   instruction
1083+  F404 32 FD FD                        LD      (0FDFDh), A
1084+  F407 21 B6 F4                        LD      HL, interrupt_handler
1085+  F40A 22 FE FD                        LD      (0FDFEh), HL
1086+  F40D             
1087+  F40D 3E 02                           LD      A, 2
1088+  F40F D3 13                           OUT     (PIO_B_CTRL),A      ; Zero interrupt vector
1089+  F411             
1090+  F411 3E B7                           LD      A, 0B7h             ; Enable interrupts on any of the following bits
1091+  F413 D3 13                           OUT     (PIO_B_CTRL),A
1092+  F415 00                              NOP
1093+  F416 3E CF                           LD      A, 0CFh             ; Just B5 (RTC interrupt) 
1094+  F418 D3 13                           OUT     (PIO_B_CTRL),A
1095+  F41A             
1096+  F41A 3E FE                           LD      A, 0FEh
1097+  F41C ED 47                           LD      I, A
1098+  F41E ED 5E                           IM      2
1099+  F420             
1100+  F420 CD 7A F4                        CALL    setup_screen
1101+  F423             
1102+  F423 3E 04                           LD      A, DRIVE_A_PAGE
1103+  F425 32 37 FF                        LD      (drive_a_mem_page), A
1104+  F428             
1105+  F428 FB                              EI
1106+  F429             
1107+  F429 3E 00                           LD      A, 0
1108+  F42B CD 2D F8                        CALL    uart_init           ; Reinitialise the UART to make sure we've not missed anything
1109+  F42E             
1110+  F42E CD 3C FC                        CALL    rtc_init            ; Make sure clock is running and reset time if necesary
1111+  F431             
1112+  F431 06 04       _set_ctrl           LD      B, 4                ; Set RTC Coarse mode and Output Pin to Square wave - gives 64 Hz pulse
1113+  F433 C5          _set_ctrl_loop      PUSH    BC
1114+  F434 26 6F                           LD      H, RTC_ADDRESS      
1115+  F436 2E 07                           LD      L, RTC_REG_CTRL
1116+  F438 CD 3C F9                        CALL    i2c_write_to
1117+  F43B 30 0B                           JR      NC, _rtc_ack_error
1118+  F43D 3E 44                           LD      A, RTC_64HZ_ENABLED
1119+  F43F CD 50 F9                        CALL    i2c_write
1120+  F442 30 04                           JR      NC, _rtc_ack_error
1121+  F444 AF                              XOR     A
1122+  F445 CD 50 F9                        CALL    i2c_write
1123+  F448 CD 04 F9    _rtc_ack_error      CALL    i2c_stop
1124+  F44B             
1125+  F44B CD 56 F4                        CALL    _pause
1126+  F44E             
1127+  F44E CD 5B F4                        CALL    _check_ctrl
1128+  F451 C1                              POP     BC
1129+  F452 C8                              RET     Z
1130+  F453 10 DE                           DJNZ    _set_ctrl_loop
1131+  F455 C9                              RET
1132+  F456             
1133+  F456 06 00       _pause              LD      B, 0
1134+  F458 10 FE                           DJNZ    $
1135+  F45A C9                              RET
1136+  F45B             
1137+  F45B             ; Check that the control is set to coarse trim and 0 offset
1138+  F45B             ; Returns with Zero flag set if settings are good.
1139+  F45B             ;
1140+  F45B 26 6F       _check_ctrl         LD      H, RTC_ADDRESS      
1141+  F45D 2E 07                           LD      L, RTC_REG_CTRL
1142+  F45F CD 1B F9                        CALL    i2c_read_from
1143+  F462 16 02                           LD      D, 2
1144+  F464 30 11                           JR      NC, _ctrl_error
1145+  F466 5F                              LD      E, A
1146+  F467 CD 70 F9                        CALL    i2c_ack
1147+  F46A CD 5D F9                        CALL    i2c_read
1148+  F46D 57                              LD      D, A
1149+  F46E CD 04 F9                        CALL    i2c_stop
1150+  F471 7B                              LD      A, E
1151+  F472 06 04                           LD      B, 4
1152+  F474 FE 44                           CP      RTC_64HZ_ENABLED
1153+  F476 C0                              RET     NZ
1154+  F477 7A          _ctrl_error         LD      A, D
1155+  F478 A7                              AND     A
1156+  F479 C9                              RET 
1157+  F47A             
1158+  F47A             ; SHOULD NOT BE CALLED WITH INTERRUPTS ENABLED!
1159+  F47A             ;
1160+  F47A 11 29 FF    setup_screen        LD      DE, screen_page     ; Copy the startup defaults to the shared_data area
1161+  F47D 21 A8 F4                        LD      HL, _screen_defaults
1162+  F480 01 0E 00                        LD      BC, _defaults_length
1163+  F483 ED B0                           LDIR
1164+  F485 3A 29 FF                        LD      A, (screen_page)    ; Clear the screen buffer
1165+  F488 D3 71                           OUT     (IO_MEM_1), A       ; Screen buffer is in PAGE_1
1166+  F48A 21 00 40                        LD      HL, PAGE_1_START
1167+  F48D 11 02 40                        LD      DE, PAGE_1_START+2
1168+  F490 0E 20                           LD      C, ' '
1169+  F492 3A 31 FF                        LD      A, (console_colour)
1170+  F495 47                              LD      B, A
1171+  F496 ED 43 00 40                     LD      (PAGE_1_START), BC
1172+  F49A 01 FA 3F                        LD      BC, 16378           ; Don't over write last couple of bytes (VideoBeast)
1173+  F49D ED B0                           LDIR
1174+  F49F             
1175+  F49F CD 6E FB                        CALL    disp_clear          ; Clear the LED screen
1176+  F4A2             
1177+  F4A2 3A 3A FF    restore_page_return LD      A, (page_1_mapping)       ; Return Page 1 to normal RAM
1178+  F4A5 D3 71                           OUT     (IO_MEM_1), A
1179+  F4A7 C9                              RET
1180+  F4A8             
1181+  F4A8 3F          _screen_defaults    .DB     RAM_PAGE_31         ; Screen buffer page
1182+  F4A9 00                              .DB     0                   ; Row offset in buffer
1183+  F4AA 00 00                           .DB     0,0                 ; Row, column being shown on LED Display
1184+  F4AC 01 01                           .DB     1,1                 ; Row, column of cursor
1185+  F4AE 18 40                           .DB     24,64               ; Console height (rows), width (columns)
1186+  F4B0 0F                              .DB     00Fh                ; Current colour [7:4] = background, [3:0] = foreground
1187+  F4B1 02                              .DB     CFLAGS_TRACK_CURSOR ; Flags
1188+  F4B2 00                              .DB     0                   ; Timer
1189+  F4B3 00 00                           .DB     0, 0                ; Escape char and first parameter
1190+  F4B5 00                              .DB     0                   ; Disable identifier sequence
1191+  F4B6             _defaults_length    .EQU    $-_screen_defaults
1192+  F4B6             
1193+  F4B6 F3          interrupt_handler   DI
1194+  F4B7 ED 73 D4 FF                     LD      (intr_stack), SP
1195+  F4BB 31 D4 FF                        LD      SP, intr_stack
1196+  F4BE F5                              PUSH    AF
1197+  F4BF D9                              EXX
1198+  F4C0 CD DF F5                        CALL    keyboard_poll
1199+  F4C3             
1200+  F4C3 3A 13 FF                        LD      A,(control_key_pressed)
1201+  F4C6 A7                              AND     A
1202+  F4C7 C4 0F F5                        CALL    NZ, handle_screen_shift
1203+  F4CA             
1204+  F4CA 3A 33 FF                        LD      A, (console_timer)
1205+  F4CD 3D                              DEC     A
1206+  F4CE FA E1 F4                        JP      M, _not_moved
1207+  F4D1 32 33 FF                        LD      (console_timer), A
1208+  F4D4 20 0B                           JR      NZ, _not_moved
1209+  F4D6             
1210+  F4D6 3A 32 FF                        LD      A, (console_flags)
1211+  F4D9 E6 FB                           AND     ~CFLAGS_SHOW_MOVED
1212+  F4DB 32 32 FF                        LD      (console_flags), A
1213+  F4DE CD B0 F1                        CALL    unsafe_redraw
1214+  F4E1             
1215+  F4E1 2A 04 FF    _not_moved          LD      HL, (timer)
1216+  F4E4 5D                              LD      E, L                ; E is old low byte of timer - used to blink cursor
1217+  F4E5 23                              INC     HL
1218+  F4E6 22 04 FF                        LD      (timer), HL
1219+  F4E9 7C                              LD      A, H
1220+  F4EA B5                              OR      L
1221+  F4EB 20 07                           JR      NZ, _timer_done
1222+  F4ED 2A 06 FF                        LD      HL, (timer+2)
1223+  F4F0 23                              INC     HL
1224+  F4F1 22 06 FF                        LD      (timer+2),HL   
1225+  F4F4             
1226+  F4F4 3A 32 FF    _timer_done         LD      A, (console_flags)
1227+  F4F7 E6 01                           AND     CFLAGS_SHOW_CURSOR
1228+  F4F9 28 0B                           JR      Z, _int_done
1229+  F4FB             
1230+  F4FB 3A 04 FF                        LD      A, (timer)          ; Blink when timer bit changes
1231+  F4FE AB                              XOR     E
1232+  F4FF E6 20                           AND     020h
1233+  F501 28 03                           JR      Z, _int_done
1234+  F503 CD 9F F5                        CALL    update_cursor
1235+  F506             
1236+  F506 D9          _int_done           EXX
1237+  F507 F1                              POP     AF
1238+  F508 ED 7B D4 FF                     LD      SP, (intr_stack)
1239+  F50C FB                              EI
1240+  F50D ED 4D       _do_reti            RETI
1241+  F50F             
1242+  F50F             ; Enter with A containing a special control character
1243+  F50F             ;
1244+  F50F             ;
1245+  F50F FE 90       handle_screen_shift CP      KEY_CTRL_UP
1246+  F511 20 25                           JR      NZ, _not_ctrl_up
1247+  F513             
1248+  F513 3A 2B FF                        LD      A, (display_row)
1249+  F516 3D                              DEC     A
1250+  F517 FA 9A F5                        JP      M, _shift_done
1251+  F51A F5          _shift_row          PUSH    AF
1252+  F51B 1E 00                           LD      E, 0
1253+  F51D CD 9F F5                        CALL    update_cursor
1254+  F520 F1                              POP     AF
1255+  F521 32 2B FF                        LD      (display_row), A
1256+  F524             
1257+  F524 3A 32 FF    _shift_complete     LD      A, (console_flags)
1258+  F527 E6 FD                           AND     ~CFLAGS_TRACK_CURSOR
1259+  F529 F6 04       _flags_and_redraw   OR      CFLAGS_SHOW_MOVED
1260+  F52B 32 32 FF                        LD      (console_flags), A
1261+  F52E 3E 3C                           LD      A, SHOW_MOVE_DELAY
1262+  F530 32 33 FF                        LD      (console_timer),A
1263+  F533 CD B0 F1                        CALL    unsafe_redraw
1264+  F536 18 62                           JR      _shift_done
1265+  F538             
1266+  F538 FE 91       _not_ctrl_up        CP      KEY_CTRL_DOWN
1267+  F53A 20 0D                           JR      NZ, _not_ctrl_down
1268+  F53C             
1269+  F53C 3A 2F FF    _shift_down         LD      A, (console_height)
1270+  F53F 4F                              LD      C, A
1271+  F540 3A 2B FF                        LD      A, (display_row)
1272+  F543 3C                              INC     A
1273+  F544 B9                              CP      C
1274+  F545 28 53                           JR      Z, _shift_done
1275+  F547 18 D1                           JR      _shift_row
1276+  F549             
1277+  F549 FE 93       _not_ctrl_down      CP      KEY_CTRL_RIGHT
1278+  F54B 20 0F                           JR      NZ, _not_ctrl_right
1279+  F54D             
1280+  F54D 3A 30 FF                        LD      A, (console_width)
1281+  F550 D6 17                           SUB     DISPLAY_WIDTH-1
1282+  F552 4F                              LD      C, A
1283+  F553 3A 2C FF                        LD      A, (display_col)
1284+  F556 3C                              INC     A
1285+  F557 B9                              CP      C
1286+  F558 28 40                           JR      Z, _shift_done
1287+  F55A 18 0B                           JR      _shift_col
1288+  F55C             
1289+  F55C FE 92       _not_ctrl_right     CP      KEY_CTRL_LEFT
1290+  F55E 20 13                           JR      NZ, _not_ctrl_left
1291+  F560             
1292+  F560 3A 2C FF                        LD      A, (display_col)
1293+  F563 3D                              DEC     A
1294+  F564 FA 9A F5                        JP      M, _shift_done
1295+  F567 F5          _shift_col          PUSH    AF
1296+  F568 1E 00                           LD      E, 0
1297+  F56A CD 9F F5                        CALL    update_cursor
1298+  F56D F1                              POP     AF
1299+  F56E 32 2C FF                        LD      (display_col), A
1300+  F571 18 B1                           JR      _shift_complete
1301+  F573             
1302+  F573 FE 94       _not_ctrl_left      CP      KEY_CTRL_ENTER
1303+  F575 20 19                           JR      NZ, _not_ctrl_enter
1304+  F577 3A 2D FF                        LD      A, (cursor_row)
1305+  F57A 3D                              DEC     A
1306+  F57B 32 2B FF                        LD      (display_row), A
1307+  F57E 3A 2E FF                        LD      A, (cursor_col)
1308+  F581 D6 16                           SUB     DISPLAY_WIDTH-2
1309+  F583 30 01                           JR      NC, _col_ok
1310+  F585 AF                              XOR     A
1311+  F586             
1312+  F586 32 2C FF    _col_ok             LD      (display_col), A
1313+  F589 3A 32 FF                        LD      A, (console_flags)
1314+  F58C F6 02                           OR      CFLAGS_TRACK_CURSOR
1315+  F58E 18 99                           JR      _flags_and_redraw
1316+  F590             
1317+  F590 FE 95       _not_ctrl_enter     CP      KEY_CTRL_SPACE
1318+  F592 20 06                           JR      NZ, _shift_done
1319+  F594             
1320+  F594 AF                              XOR     A
1321+  F595 32 2C FF                        LD      (display_col), A
1322+  F598 18 A2                           JR      _shift_down
1323+  F59A             
1324+  F59A AF          _shift_done         XOR     A
1325+  F59B 32 13 FF                        LD      (control_key_pressed),A
1326+  F59E C9                              RET
1327+  F59F             
1328+  F59F             ;
1329+  F59F             ; Blinks the cursor 
1330+  F59F             ;  Enter with E = timer low byte. 
1331+  F59F             ;  If CURSOR_BIT is 1, show the cursor at the line, otherwise restore the existing character
1332+  F59F             ;
1333+  F59F 3A 2B FF    update_cursor       LD      A, (display_row)    ; Are we on the same row as the cursor?
1334+  F5A2 47                              LD      B, A
1335+  F5A3 3A 2D FF                        LD      A, (cursor_row)
1336+  F5A6 3D                              DEC     A
1337+  F5A7 B8                              CP      B
1338+  F5A8 C0                              RET     NZ
1339+  F5A9             
1340+  F5A9 3A 2C FF                        LD      A, (display_col)    ; Check the cursor column is within the display window
1341+  F5AC 47                              LD      B, A
1342+  F5AD 3A 2E FF                        LD      A, (cursor_col)
1343+  F5B0 3D                              DEC     A
1344+  F5B1 90                              SUB     B
1345+  F5B2 F8                              RET     M
1346+  F5B3             
1347+  F5B3 FE 18                           CP      DISPLAY_WIDTH
1348+  F5B5 D0                              RET     NC
1349+  F5B6             
1350+  F5B6                                 ; At this point, A holds the current display column for the cursor..
1351+  F5B6 4F                              LD      C, A
1352+  F5B7 06 00                           LD      B, 0
1353+  F5B9 21 84 FF                        LD      HL, display_buffer
1354+  F5BC 09                              ADD     HL, BC
1355+  F5BD 09                              ADD     HL, BC
1356+  F5BE 7B                              LD      A, E
1357+  F5BF E6 20                           AND     20h
1358+  F5C1 7E                              LD      A, (HL)
1359+  F5C2 28 02                           JR      Z, _unblink
1360+  F5C4 3E 5F                           LD      A, '_'
1361+  F5C6 C3 08 FB    _unblink            JP    disp_character
1362+  F5C9             
1363+  F5C9                                 .INCLUDE "../ports.asm"
0001++ F5C9             ;
0002++ F5C9             ; Port definintions
0003++ F5C9             ;
0004++ F5C9             ;
0005++ F5C9             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F5C9             ;
0007++ F5C9             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F5C9             ;
0009++ F5C9             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F5C9             ; of this software and associated documentation files (the "Software"), to deal
0011++ F5C9             ; in the Software without restriction, including without limitation the rights
0012++ F5C9             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F5C9             ; copies of the Software, and to permit persons to whom the Software is
0014++ F5C9             ; furnished to do so, subject to the following conditions:
0015++ F5C9             ; 
0016++ F5C9             ; The above copyright notice and this permission notice shall be included in all
0017++ F5C9             ; copies or substantial portions of the Software.
0018++ F5C9             ; 
0019++ F5C9             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F5C9             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F5C9             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F5C9             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F5C9             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F5C9             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F5C9             ; SOFTWARE.
0026++ F5C9             ;
0027++ F5C9             
0028++ F5C9             BACKSPACE_CHAR      .EQU  08h
0029++ F5C9             CARRIAGE_RETURN     .EQU  0Dh
0030++ F5C9             NEWLINE             .EQU  0Ah
0031++ F5C9             ESCAPE_CHAR         .EQU  1Bh
0032++ F5C9             CPM_NUM             .EQU  1Fh
0033++ F5C9             
0034++ F5C9             ;=================================== UART ============================================
0035++ F5C9             UART_TX_RX          .EQU    020h    ; Read: receiver buffer, Write: transmitter buffer
0036++ F5C9             UART_INT_ENABLE     .EQU    021h    ; Interrupt enable register
0037++ F5C9             UART_INT_ID         .EQU    022h    ; Read: Interrupt identification register
0038++ F5C9             UART_FIFO_CTRL      .EQU    022h    ; Write: FIFO Control register
0039++ F5C9             UART_LINE_CTRL      .EQU    023h    ; Line control register
0040++ F5C9             UART_MODEM_CTRL     .EQU    024h    ; Modem control
0041++ F5C9             UART_LINE_STATUS    .EQU    025h    ; Line status
0042++ F5C9             UART_MODEM_STATUS   .EQU    026h    ; Modem status
0043++ F5C9             UART_SCRATCH        .EQU    027h    ; Scratch register
0044++ F5C9             
0045++ F5C9             ;==================================== PIO ============================================
0046++ F5C9             PIO_A_DATA          .EQU  010h
0047++ F5C9             PIO_A_CTRL          .EQU  012h
0048++ F5C9             
0049++ F5C9             PIO_B_DATA          .EQU  011h
0050++ F5C9             PIO_B_CTRL          .EQU  013h
0051++ F5C9             
0052++ F5C9             PIO_MODE_0          .EQU  00Fh      ; Mode 0: All outputs
0053++ F5C9             PIO_MODE_1          .EQU  04fh      ; Mode 1: All inputs
0054++ F5C9             PIO_MODE_2          .EQU  080h      ; Mode 2 (Port A only): Bi-directional
0055++ F5C9             PIO_MODE_3          .EQU  0CFh      ; Mode 3: Per-pin I/O on the given port - write an additional word with bits set (1) for input, reset (0) for output on the matching pin.
0056++ F5C9             
0057++ F5C9             PIO_SET_INTERRUPT   .EQU  007h      ; Set interrupt control world. By itself, this wil disable interrupts on the given port. OR with the following constants to change this
0058++ F5C9             PIO_ENABLE_INT      .EQU  080h      ; Enable interrupts on the given port, when OR'd with the PIO_SET_INTERRUPT control word.
0059++ F5C9             PIO_INT_MASK        .EQU  010h      ; When OR'd with the PIO_SET_INTERRUPT control word, the following word will enable interrupts for pins where the matching bit is zero
0060++ F5C9             
0061++ F5C9             ;================================== AUDIO ============================================
0062++ F5C9             ; Constants for Audio output
0063++ F5C9             AUDIO_PIO           .EQU  1         ; Audio on PIO (rev. 0.1 boards)
0064++ F5C9             AUDIO_UART          .EQU  2         ; Audio on UART (rev. 0.2 boards)
0065++ F5C9             
0066++ F5C9             AUDIO_VERSION       .EQU  AUDIO_UART
0067++ F5C9             
0068++ F5C9~            #IF AUDIO_VERSION = AUDIO_PIO
0069++ F5C9~            PORT_B_IOMASK       .EQU  0EFh      ; All inputs, apart from bit 4 (audio out)
0070++ F5C9~            AUDIO_MASK          .EQU  010h      ; Bitmask for audio output on Port B. The bit is set for the output pin.
0071++ F5C9~            AUDIO_PORT          .EQU  PIO_B_DATA
0072++ F5C9~            
0073++ F5C9             #ELSE
0074++ F5C9             PORT_B_IOMASK       .EQU  0FFh      ; All inputs
0075++ F5C9             AUDIO_MASK          .EQU  008h      ; Bitmask for audio output on UART Out 2. The bit is set for the output pin
0076++ F5C9             AUDIO_PORT          .EQU  UART_MODEM_CTRL
0077++ F5C9             
0078++ F5C9             #ENDIF
0079++ F5C9             
0080++ F5C9             
0081++ F5C9             ;=================================== MEMORY PAGING ===================================
0082++ F5C9             IO_MEM_0            .EQU    070h      ; Page 0: 0000h - 3fffh
0083++ F5C9             IO_MEM_1            .EQU    071h      ; Page 1: 4000h - 7fffh
0084++ F5C9             IO_MEM_2            .EQU    072h      ; Page 2: 8000h - bfffh
0085++ F5C9             IO_MEM_3            .EQU    073h      ; Page 3: c000h - ffffh
0086++ F5C9             
0087++ F5C9             IO_MEM_CTRL         .EQU    074h      ; Paging enable register
0088++ F5C9             IO_MEM_ENABLE       .EQU    1
0089++ F5C9             IO_MEM_DISABLE      .EQU    0 
0090++ F5C9             
0091++ F5C9             RAM_PAGE_0          .EQU    020h
0092++ F5C9             RAM_PAGE_1          .EQU    021h
0093++ F5C9             RAM_PAGE_2          .EQU    022h
0094++ F5C9             RAM_PAGE_3          .EQU    023h
0095++ F5C9             
0096++ F5C9             RAM_PAGE_16         .EQU    030h
0097++ F5C9             RAM_PAGE_31         .EQU    03Fh
0098++ F5C9             
0099++ F5C9             ROM_PAGE_0          .EQU    000h
0100++ F5C9             ROM_PAGE_16         .EQU    010h
0101++ F5C9             
0102++ F5C9             PAGE_1_START        .EQU    4000h
0103++ F5C9             
0104++ F5C9             ;====================================== I2C DEVICES ===================================
0105++ F5C9             I2C_DATA_BIT            .equ    7
0106++ F5C9             I2C_CLK_BIT             .equ    6
0107++ F5C9             
0108++ F5C9             I2C_DATA_MASK           .equ    1 << I2C_DATA_BIT
0109++ F5C9             I2C_CLK_MASK            .equ    1 << I2C_CLK_BIT
0110++ F5C9             
0111++ F5C9             ; Display
0112++ F5C9             ;==========
0113++ F5C9             DL_ADDRESS              .EQU    050h     ; Left  Matrix controller I2C address
0114++ F5C9             DR_ADDRESS              .EQU    053h     ; Right Matrix controller I2C address
0115++ F5C9             
0116++ F5C9             DISP_REG_CRWL           .EQU    0FEh     ; Command Register write lock
0117++ F5C9             DISP_UNLOCK             .EQU    0C5h     ; Unlock command
0118++ F5C9             
0119++ F5C9             DISP_DEFAULT_BRIGHTNESS .EQU    080h     ; Default brightness
0120++ F5C9             DISP_DIMMED             .EQU    018h     ; Dimmed
0121++ F5C9             
0122++ F5C9             DISPLAY_WIDTH           .EQU    24       ; 24 characters
0123++ F5C9             
0124++ F5C9             ; RTC
0125++ F5C9             ;==========
0126++ F5C9             RTC_ADDRESS             .EQU    06fh
0127++ F5C9             
0128++ F5C9             RTC_REG_SEC             .EQU    000h    ; Also has oscillator enable bit in B7, 1 = run
0129++ F5C9             RTC_REG_MIN             .EQU    001h
0130++ F5C9             RTC_REG_HOUR            .EQU    002h    ; B6: 1 = 12hr/ 0 = 24hr clock (r/w) 
0131++ F5C9                                                     ;        If 12 hr clock, B5: 1 = PM/ 0 = AM. B4: hour tens. Otherwise B5-4: hour tens, B3-0: hour units
0132++ F5C9             RTC_REG_WKDAY           .EQU    003h    ; Oscillator status bit in B5, 1 = enabled and running. 
0133++ F5C9                                                     ;   B4: 1 = power was lost, write 0 to clear (timestamp registers are set)
0134++ F5C9                                                     ;   B3: 1 = enable external battery supply (VBAT)
0135++ F5C9                                                     ;   B2-0: Weekday, from 1 to 7 
0136++ F5C9             RTC_REG_DATE            .EQU    004h    ; BCD Date (1 to 31)
0137++ F5C9             RTC_REG_MTH             .EQU    005h    ; B5: 1 = Leap year (read only). B4: month tens, B3-0: month units  (Month is 1 to 12)
0138++ F5C9             RTC_REG_YEAR            .EQU    006h    ; BCD Year
0139++ F5C9             
0140++ F5C9             RTC_REG_CTRL            .EQU    007h    ; B7: If Square wave and Alarm 0 and Alarm 1 are disabled, sets Output Pin level
0141++ F5C9                                                     ;   B6: SQWEN, 1 = Enable square wave on Output Pin, Alarms disabled
0142++ F5C9                                                     ;   B5, B4: Alarm 1, 0 Enable. 1 = Alarm is enabled
0143++ F5C9                                                     ;   B3: 1 = Use external oscillator
0144++ F5C9                                                     ;   B2: CRSTRIM, 1 = Coarse trim mode, Output pin is 64Hz
0145++ F5C9                                                     ;   B1-0: If SQWEN = 1 & CRSTRIM = 0, sets Output pin freq. 00 -> 1Hz, 01 -> 4.096kHz, 10 -> 8.192kHz, 11 -> 32.768kHz
0146++ F5C9             RTC_REG_TRIM            .EQU    008h    ; Trim, initially 0. B7: Sign, 1=Add, 0=Subtract clock cycles.  
0147++ F5C9                                                     ;   B6-0: Trim amount/2. Applied 1 every minute in fine trim, 128 times a second in coarse trim mode. 0 = disable trim
0148++ F5C9             
0149++ F5C9             RTC_64HZ_ENABLED        .EQU    044h    ; Value for RTC_REG_CTRL to enable 64Hz interrupt output
0150++ F5C9             
0151++ F5C9             RTC_WEEKDAY_RUNNING     .EQU    008h    ; Value for RTC_REG_WKDAY for normall running of clock1364+  F5C9             
1365+  F5C9                                 .INCLUDE "../io.asm"
0001++ F5C9             ;
0002++ F5C9             ; I/O routines.. specifically keyboard and serial
0003++ F5C9             ;
0004++ F5C9             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F5C9             ;
0006++ F5C9             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F5C9             ;
0008++ F5C9             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F5C9             ; of this software and associated documentation files (the "Software"), to deal
0010++ F5C9             ; in the Software without restriction, including without limitation the rights
0011++ F5C9             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F5C9             ; copies of the Software, and to permit persons to whom the Software is
0013++ F5C9             ; furnished to do so, subject to the following conditions:
0014++ F5C9             ; 
0015++ F5C9             ; The above copyright notice and this permission notice shall be included in all
0016++ F5C9             ; copies or substantial portions of the Software.
0017++ F5C9             ; 
0018++ F5C9             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F5C9             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F5C9             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F5C9             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F5C9             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F5C9             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F5C9             ; SOFTWARE.
0025++ F5C9             ;
0026++ F5C9             
0027++ F5C9             
0028++ F5C9 21 08 FF    keyboard_init       LD      HL, keyboard_state
0029++ F5CC 06 20                           LD      B, io_data_end - keyboard_state
0030++ F5CE AF                              XOR     A
0031++ F5CF 77          _init_loop          LD      (HL),A
0032++ F5D0 23                              INC     HL
0033++ F5D1 05                              DEC     B
0034++ F5D2 20 FB                           JR      NZ, _init_loop
0035++ F5D4 AF                              XOR     A
0036++ F5D5 32 28 FF                        LD      (input_size),A
0037++ F5D8 32 27 FF                        LD      (input_free),A
0038++ F5DB 32 26 FF                        LD      (input_pos),A
0039++ F5DE C9                              RET
0040++ F5DF             
0041++ F5DF             ; Poll the keyboard, adding raw codes to the keyboard_state buffer, and decoded characters to the input_buffer
0042++ F5DF             ;
0043++ F5DF 01 00 FD    keyboard_poll       LD      BC, 0FD00h          ; Check shift key
0044++ F5E2 3A 12 FF                        LD      A, (key_shift_state)
0045++ F5E5 E6 FC                           AND     ~(KEY_SHIFT_BIT | KEY_CTRL_BIT)
0046++ F5E7 57                              LD      D, A
0047++ F5E8             
0048++ F5E8 ED 78                           IN      A, (C)
0049++ F5EA E6 20                           AND     020h
0050++ F5EC 20 04                           JR      NZ, _check_ctrl_key
0051++ F5EE 3E 01                           LD      A, KEY_SHIFT_BIT
0052++ F5F0 B2                              OR      D
0053++ F5F1 57                              LD      D, A
0054++ F5F2             
0055++ F5F2 01 00 FE    _check_ctrl_key     LD      BC, 0FE00h          ; Keyboard row 0
0056++ F5F5 ED 78                           IN      A, (C)
0057++ F5F7 E6 10                           AND     010h
0058++ F5F9 20 04                           JR      NZ, _store_modifiers
0059++ F5FB 3E 02                           LD      A, KEY_CTRL_BIT
0060++ F5FD B2                              OR      D
0061++ F5FE 57                              LD      D, A
0062++ F5FF             
0063++ F5FF 7A          _store_modifiers    LD      A, D
0064++ F600 32 12 FF                        LD      (key_shift_state), A
0065++ F603             
0066++ F603             
0067++ F603 21 6D F7                        LD      HL, keyboard
0068++ F606 ED 78       _poll_loop          IN      A, (C)              ; BC -> Keyboard row port..
0069++ F608 16 01                           LD      D, 1                ; D -> Current Bit
0070++ F60A 5F                              LD      E, A                ; E -> Key row bit set
0071++ F60B 22 10 FF    _next_key           LD      (keyboard_pos), HL
0072++ F60E A2                              AND     D
0073++ F60F 20 3F                           JR      NZ, _released
0074++ F611                                                             ; Key is pressed... add it to state buffer
0075++ F611 C5                              PUSH    BC
0076++ F612 7E                              LD      A, (HL)             ; Raw key code in A
0077++ F613             
0078++ F613 21 08 FF                        LD      HL, keyboard_state
0079++ F616 06 08                           LD      B, _key_state_size
0080++ F618 BE          _check_pressed      CP      (HL)
0081++ F619 CA 69 F6                        JP      Z, _do_nothing      ; Key already in state table - nothing to do..
0082++ F61C 23                              INC     HL
0083++ F61D 05                              DEC     B
0084++ F61E 20 F8                           JR      NZ, _check_pressed
0085++ F620                                                             ; Key wasn't pressed, so add it to the first free slot
0086++ F620 21 08 FF                        LD      HL, keyboard_state
0087++ F623 06 08                           LD      B, _key_state_size
0088++ F625 4F                              LD      C, A
0089++ F626 AF                              XOR     A
0090++ F627 BE          _find_free          CP      (HL)
0091++ F628 28 07                           JR      Z, _key_pressed
0092++ F62A 23                              INC     HL
0093++ F62B 05                              DEC     B
0094++ F62C 20 F9                           JR      NZ, _find_free
0095++ F62E C3 69 F6                        JP      _do_nothing         ; No free slots, so ignore the key
0096++ F631             
0097++ F631 71          _key_pressed        LD      (HL), C             ; Found free slot, store the raw key code
0098++ F632             
0099++ F632                                 ; Reset repeat counter       
0100++ F632             
0101++ F632 2A 10 FF                        LD      HL, (keyboard_pos)  ; Get the current keyboard character location
0102++ F635 01 30 00                        LD      BC, _keyboard_size
0103++ F638 3A 12 FF                        LD      A, (key_shift_state)
0104++ F63B A7                              AND     A
0105++ F63C 28 04                           JR      Z, _got_keycode
0106++ F63E 09          _modifier_offset    ADD     HL, BC
0107++ F63F 3D                              DEC     A
0108++ F640 20 FC                           JR      NZ, _modifier_offset
0109++ F642             
0110++ F642 7E          _got_keycode        LD      A, (HL) 
0111++ F643 32 14 FF                        LD      (last_keycode), A
0112++ F646 CD 99 F6                        CALL    _store_key
0113++ F649 AF                              XOR     A
0114++ F64A 32 15 FF                        LD      (key_repeat_time), A
0115++ F64D             
0116++ F64D C1                              POP     BC
0117++ F64E 18 1A                           JR      _poll_next
0118++ F650             
0119++ F650                                                             ; Key is not pressed... remove it from the state buffer if it was pressed (key up event)
0120++ F650                                                             ; TODO: This is rather inefficient...
0121++ F650 C5          _released           PUSH    BC
0122++ F651 7E                              LD      A, (HL)             ; Raw key code in A
0123++ F652 A7                              AND     A
0124++ F653 28 14                           JR      Z, _do_nothing      ; Ignore character zero
0125++ F655             
0126++ F655 21 08 FF                        LD      HL, keyboard_state
0127++ F658 06 08                           LD      B, _key_state_size
0128++ F65A BE          _check_released     CP      (HL)
0129++ F65B 28 06                           JR      Z, _handle_release
0130++ F65D 23                              INC     HL
0131++ F65E 05                              DEC     B
0132++ F65F 20 F9                           JR      NZ, _check_released
0133++ F661 18 06                           JR      _do_nothing         ; Code not in state buffer, not released
0134++ F663             
0135++ F663 4F          _handle_release     LD      C, A
0136++ F664 AF                              XOR     A
0137++ F665 77                              LD      (HL), A             ; Remove it from the buffer 
0138++ F666 32 14 FF                        LD      (last_keycode), A
0139++ F669                                                             ; TODO: We should probably tell someone about this...
0140++ F669 C1          _do_nothing         POP     BC
0141++ F66A             
0142++ F66A 2A 10 FF    _poll_next          LD      HL, (keyboard_pos)
0143++ F66D 7B                              LD      A, E                ; Get the bitmask back
0144++ F66E 23                              INC     HL
0145++ F66F CB 22                           SLA     D
0146++ F671 CB 72                           BIT     6, D
0147++ F673 CA 0B F6                        JP      Z, _next_key
0148++ F676             
0149++ F676 CB 00                           RLC     B                   ; Move to the next key row
0150++ F678 3E FE                           LD      A, 0FEh
0151++ F67A B8                              CP      B
0152++ F67B C2 06 F6                        JP      NZ, _poll_loop
0153++ F67E             
0154++ F67E 3A 14 FF                        LD      A, (last_keycode)
0155++ F681 A7                              AND     A
0156++ F682 C8                              RET     Z
0157++ F683 3A 15 FF                        LD      A, (key_repeat_time)
0158++ F686 3C                              INC     A
0159++ F687 32 15 FF                        LD      (key_repeat_time), A
0160++ F68A FE 28                           CP      KEY_REPEAT_DELAY
0161++ F68C 28 08                           JR      Z, _do_repeat
0162++ F68E FE 2F                           CP      KEY_REPEAT_AFTER
0163++ F690 C0                              RET     NZ
0164++ F691 3E 28                           LD      A, KEY_REPEAT_DELAY
0165++ F693 32 15 FF                        LD      (key_repeat_time),A
0166++ F696 3A 14 FF    _do_repeat          LD      A, (last_keycode)
0167++ F699             
0168++ F699             
0169++ F699             ; Store the decoded keycode in A to the relevant buffer...
0170++ F699 4F          _store_key          LD      C, A
0171++ F69A E6 F8                           AND     CTRL_KEY_MASK       ; Check for special control characters 
0172++ F69C FE 90                           CP      CTRL_KEY_CHECK
0173++ F69E 20 05                           JR      NZ, _get_key
0174++ F6A0             
0175++ F6A0 79                              LD      A, C                ; Store them in a separate location
0176++ F6A1 32 13 FF                        LD      (control_key_pressed), A
0177++ F6A4 C9                              RET
0178++ F6A5                                                             ; Write the character to the input buffer
0179++ F6A5 79          _get_key            LD      A, C                ; Get the actual character...
0180++ F6A6 A7                              AND     A                   ; Skip blank character codes
0181++ F6A7 C8                              RET     Z
0182++ F6A8             
0183++ F6A8 6F                              LD      L, A                ; Store it in L
0184++ F6A9             
0185++ F6A9 3A 28 FF                        LD      A, (input_size)     ; Now check we have space
0186++ F6AC FE 10                           CP      _input_buffer_size
0187++ F6AE C8                              RET     Z
0188++ F6AF             
0189++ F6AF 3C                              INC     A
0190++ F6B0 32 28 FF                        LD      (input_size), A
0191++ F6B3             
0192++ F6B3 06 00                           LD      B, 0
0193++ F6B5 3A 27 FF                        LD      A, (input_free)
0194++ F6B8 4F                              LD      C, A
0195++ F6B9 7D                              LD      A, L                ; Get the character from L
0196++ F6BA 21 16 FF                        LD      HL, input_buffer
0197++ F6BD 09                              ADD     HL, BC
0198++ F6BE 77                              LD      (HL), A             ; Store the character
0199++ F6BF             
0200++ F6BF 0C                              INC     C                   ; Point to next byte in input
0201++ F6C0 3E 0F                           LD      A, 0Fh
0202++ F6C2 A1                              AND     C
0203++ F6C3 32 27 FF                        LD      (input_free), A
0204++ F6C6 C9                              RET
0205++ F6C7             
0206++ F6C7             ;
0207++ F6C7             ; Reads the next available character in A, returning that or 0 if none are available
0208++ F6C7             ; Z flag is set if no character
0209++ F6C7             ; Uses HL, BC, A
0210++ F6C7 3A 28 FF    read_character      LD      A, (input_size)
0211++ F6CA A7                              AND     A
0212++ F6CB C8                              RET     Z
0213++ F6CC             
0214++ F6CC F3                              DI                          ; Make sure we don't get into a race condition..
0215++ F6CD 3A 28 FF                        LD      A, (input_size)
0216++ F6D0 3D                              DEC     A
0217++ F6D1 32 28 FF                        LD      (input_size),A
0218++ F6D4 3A 26 FF                        LD      A, (input_pos)
0219++ F6D7 4F                              LD      C, A
0220++ F6D8 3C                              INC     A
0221++ F6D9 E6 0F                           AND     0Fh
0222++ F6DB 32 26 FF                        LD      (input_pos),A
0223++ F6DE 06 00                           LD      B, 0
0224++ F6E0 21 16 FF                        LD      HL, input_buffer
0225++ F6E3 09                              ADD     HL, BC
0226++ F6E4 7E                              LD      A, (HL)
0227++ F6E5 B7                              OR      A
0228++ F6E6 FB                              EI
0229++ F6E7 C9                              RET
0230++ F6E8                                 
0231++ F6E8             ;;
0232++ F6E8             ; D = Octave 2-6
0233++ F6E8             ; E = Note 0-11
0234++ F6E8             ; C = 1-15 duration, ~tenths of a second
0235++ F6E8             ;
0236++ F6E8 3E 07       play_note           LD      A, 7
0237++ F6EA 92                              SUB     D
0238++ F6EB 16 00                           LD      D, 0
0239++ F6ED 21 2F F7                        LD      HL, _note_table
0240++ F6F0 19                              ADD     HL, DE
0241++ F6F1 19                              ADD     HL, DE
0242++ F6F2             
0243++ F6F2 5E                              LD      E, (HL)
0244++ F6F3 23                              INC     HL
0245++ F6F4 56                              LD      D, (HL)
0246++ F6F5             
0247++ F6F5 A7          _note_octave        AND     A
0248++ F6F6 28 07                           JR      Z, _note_shifted
0249++ F6F8             
0250++ F6F8 CB 3A                           SRL     D
0251++ F6FA CB 1B                           RR      E
0252++ F6FC 3D                              DEC     A
0253++ F6FD 18 F6                           JR      _note_octave
0254++ F6FF             
0255++ F6FF 41          _note_shifted       LD      B, C
0256++ F700 4F                              LD      C, A        ; A is zero from previous octave calc
0257++ F701 CB 20                           SLA     B    
0258++ F703 CB 20                           SLA     B    
0259++ F705 CB 20                           SLA     B    
0260++ F707 CB 20                           SLA     B           ; Now BC = 4096 * C
0261++ F709             
0262++ F709 DB 24                           IN      A, (AUDIO_PORT)
0263++ F70B 32 1C F7                        LD      (_tone_val+1), A
0264++ F70E F3                              DI
0265++ F70F             
0266++ F70F             _tone_loop          ; 186 T-states          
0267++ F70F 19                              ADD     HL, DE              ; 11
0268++ F710 1F                              RRA                         ; 4   Carry into bit 7
0269++ F711 CB 2F                           SRA     A                   ; 8   Copy to bit 6
0270++ F713 CB 2F                           SRA     A                   ; 8   ..5
0271++ F715 CB 2F                           SRA     A                   ; 8   ..4
0272++ F717 CB 2F                           SRA     A                   ; 8   ..3
0273++ F719             
0274++ F719 E6 08                           AND     AUDIO_MASK          ; 7
0275++ F71B EE 00       _tone_val           XOR     0                   ; 7
0276++ F71D 32 1C F7                        LD      (_tone_val+1), A    ; 13
0277++ F720             
0278++ F720 D3 24                           OUT     (AUDIO_PORT),A      ; 12
0279++ F722             
0280++ F722 78                              LD      A, B                ; 4
0281++ F723 06 05                           LD      B, 5                ; 7
0282++ F725 10 FE                           DJNZ    $                   ; 4 * 13 + 7 = 59
0283++ F727 47                              LD      B, A                ; 4
0284++ F728             
0285++ F728 0B                              DEC     BC                  ; 6
0286++ F729 78                              LD      A, B                ; 4
0287++ F72A B1                              OR      C                   ; 4
0288++ F72B 20 E2                           JR      NZ, _tone_loop      ; 12
0289++ F72D             
0290++ F72D FB                              EI
0291++ F72E C9                              RET
0292++ F72F             
0293++ F72F EB 18       _note_table         .DW 6379
0294++ F731 65 1A                           .DW 6757
0295++ F733 F6 1B                           .DW 7158
0296++ F735 A1 1D                           .DW 7585
0297++ F737 63 1F                           .DW 8035
0298++ F739 40 21                           .DW 8512
0299++ F73B 3F 23                           .DW 9023
0300++ F73D 51 25                           .DW 9553
0301++ F73F 8C 27                           .DW 10124
0302++ F741 EA 29                           .DW 10730
0303++ F743 60 2C                           .DW 11360
0304++ F745 0D 2F                           .DW 12045
0305++ F747 00 00                           .DW 0
0306++ F749             
0307++ F749             ;
0308++ F749             ; Get the next key press
0309++ F749             ;
0310++ F749 CD C7 F6    get_key             CALL    read_character
0311++ F74C 06 00                           LD      B, 0
0312++ F74E 10 FE                           DJNZ    $
0313++ F750 28 F7                           JR      Z, get_key
0314++ F752 C9                              RET
0315++ F753             ;
0316++ F753             ; Wait for a key to be pressed and released
0317++ F753             ;
0318++ F753             ;
0319++ F753 CD C7 F6    wait_for_key        CALL    read_character
0320++ F756 06 00                           LD      B, 0
0321++ F758 10 FE                           DJNZ    $
0322++ F75A 28 F7                           JR      Z, wait_for_key
0323++ F75C             
0324++ F75C             ;
0325++ F75C             ; wait until there are no keys being pressed
0326++ F75C             ;
0327++ F75C             ;
0328++ F75C CD C7 F6    wait_no_keys        CALL    read_character
0329++ F75F 20 FB                           JR      NZ, wait_no_keys
0330++ F761 01 00 00                        LD      BC, 0h              ; Make sure key is released
0331++ F764 ED 78                           IN      A, (C)
0332++ F766 E6 3F                           AND     03Fh
0333++ F768 FE 3F                           CP      03Fh
0334++ F76A 20 F0                           JR      NZ, wait_no_keys
0335++ F76C C9                              RET
0336++ F76D             
0337++ F76D             ; Non-printing key codes
0338++ F76D             ;
0339++ F76D             KEY_ENTER       .EQU    13
0340++ F76D             KEY_DELETE      .EQU    127
0341++ F76D             KEY_CTRL_C      .EQU    03h
0342++ F76D             KEY_CTRL_E      .EQU    05h
0343++ F76D             
0344++ F76D             KEY_CTRL_P      .EQU    10h
0345++ F76D             KEY_CTRL_R      .EQU    12h
0346++ F76D             KEY_CTRL_S      .EQU    13h
0347++ F76D             KEY_CTRL_U      .EQU    15h
0348++ F76D             KEY_CTRL_X      .EQU    18h
0349++ F76D             KEY_CTRL_Z      .EQU    1Ah
0350++ F76D             
0351++ F76D             KEY_BACKSPACE   .EQU    08h
0352++ F76D             
0353++ F76D             ; Modifier and special keys have key codes with the top bit set..
0354++ F76D             ;
0355++ F76D             KEY_UP          .EQU    128
0356++ F76D             KEY_DOWN        .EQU    129
0357++ F76D             KEY_LEFT        .EQU    130
0358++ F76D             KEY_RIGHT       .EQU    131
0359++ F76D             KEY_SHIFT       .EQU    132
0360++ F76D             KEY_CTRL        .EQU    134
0361++ F76D             
0362++ F76D             ; 144 = 90h
0363++ F76D             ;
0364++ F76D             CTRL_KEY_MASK   .EQU    0F8h
0365++ F76D             CTRL_KEY_CHECK  .EQU    090h
0366++ F76D             
0367++ F76D             KEY_CTRL_UP     .EQU    144             ; These characters start on an exact multiple of 8 so they 
0368++ F76D             KEY_CTRL_DOWN   .EQU    145             ; Can easily be detected
0369++ F76D             KEY_CTRL_LEFT   .EQU    146
0370++ F76D             KEY_CTRL_RIGHT  .EQU    147
0371++ F76D             KEY_CTRL_ENTER  .EQU    148
0372++ F76D             KEY_CTRL_SPACE  .EQU    149 
0373++ F76D             
0374++ F76D             _keyboard_size  .EQU    48
0375++ F76D             
0376++ F76D             KEY_SHIFT_BIT   .EQU    1
0377++ F76D             KEY_CTRL_BIT    .EQU    2
0378++ F76D             
0379++ F76D             KEY_REPEAT_DELAY .EQU   40
0380++ F76D             KEY_REPEAT_AFTER .EQU   KEY_REPEAT_DELAY+7
0381++ F76D             
0382++ F76D 76 63 78 7A keyboard        .DB    "vcxz", 0, 0
0382++ F771 00 00 
0383++ F773 67 66 64 73                 .DB    "gfdsa", 0
0383++ F777 61 00 
0384++ F779 74 72 65 77                 .DB    "trewq", KEY_DOWN
0384++ F77D 71 81 
0385++ F77F 35 34 33 32                 .DB    "54321", KEY_UP  
0385++ F783 31 80 
0386++ F785 36 37 38 39                 .DB    "67890", KEY_BACKSPACE
0386++ F789 30 08 
0387++ F78B 79 75 69 6F                 .DB    "yuiop:"
0387++ F78F 70 3A 
0388++ F791 68 6A 6B 6C                 .DB    "hjkl.", KEY_ENTER
0388++ F795 2E 0D 
0389++ F797 62 6E 6D 20                 .DB    "bnm ", KEY_LEFT, KEY_RIGHT
0389++ F79B 82 83 
0390++ F79D             
0391++ F79D 56 43 58 5A _shifted        .DB     "VCXZ", 0, 0
0391++ F7A1 00 00 
0392++ F7A3 47 46 44 53                 .DB     "GFDSA", 0
0392++ F7A7 41 00 
0393++ F7A9 54 52 45 57                 .DB     "TREWQ", 0              ; Shift + down?
0393++ F7AD 51 00 
0394++ F7AF 25 24 23 22                 .DB     "%$", 35, 34, "!", 0    ; Shift + up
0394++ F7B3 21 00 
0395++ F7B5 5E 26 2A 28                 .DB     "^&*()", 0              ; Shift + delete
0395++ F7B9 29 00 
0396++ F7BB 59 55 49 4F                 .DB     "YUIOP;"
0396++ F7BF 50 3B 
0397++ F7C1 48 4A 4B 4C                 .DB     "HJKL,", 0              ; Shift + enter
0397++ F7C5 2C 00 
0398++ F7C7 42 4E 4D 00                 .DB     "BNM", 0,0,0            ; Shift left + right
0398++ F7CB 00 00 
0399++ F7CD             
0400++ F7CD 00 03 18 1A _ctrl           .DB    0,KEY_CTRL_C,KEY_CTRL_X,KEY_CTRL_Z,0,0
0400++ F7D1 00 00 
0401++ F7D3 00 00 00 13                 .DB    0,0,0,KEY_CTRL_S,0,0
0401++ F7D7 00 00 
0402++ F7D9 00 12 05 00                 .DB    0,KEY_CTRL_R,KEY_CTRL_E,0,0,KEY_CTRL_DOWN
0402++ F7DD 00 91 
0403++ F7DF 00 00 00 27                 .DB    0,0,0,27h,7Ch,KEY_CTRL_UP ; Vertical bar, single quote
0403++ F7E3 7C 90 
0404++ F7E5 7B 7D 60 5B                 .DB    "{}`[]",KEY_DELETE
0404++ F7E9 5D 7F 
0405++ F7EB 00 15 2B 3D                 .DB    0,KEY_CTRL_U, "+=-", 0
0405++ F7EF 2D 00 
0406++ F7F1 00 3C 40 3E                 .DB    0, "<@>_", KEY_CTRL_ENTER
0406++ F7F5 5F 94 
0407++ F7F7 5C 3F 2F 95                 .DB    "\\?/", KEY_CTRL_SPACE,KEY_CTRL_LEFT,KEY_CTRL_RIGHT
0407++ F7FB 92 93 
0408++ F7FD             
0409++ F7FD 00 00 00 00 _shift_ctrl     .DB    0,0,0,0,0,0
0409++ F801 00 00 
0410++ F803 00 00 00 00                 .DB    0,0,0,0,0,0
0410++ F807 00 00 
0411++ F809 00 00 00 00                 .DB    0,0,0,0,0,0
0411++ F80D 00 00 
0412++ F80F 00 00 00 00                 .DB    0,0,0,0,0,0
0412++ F813 00 00 
0413++ F815 00 00 00 00                 .DB    0,0,0,0,0,0
0413++ F819 00 00 
0414++ F81B 00 00 00 00                 .DB    0,0,0,0,KEY_CTRL_P,0
0414++ F81F 10 00 
0415++ F821 00 00 00 00                 .DB    0,0,0,0,0,0
0415++ F825 00 00 
0416++ F827 00 00 00 00                 .DB    0,0,0,0,0,0
0416++ F82B 00 00 
1366+  F82D                                 .INCLUDE "../uart.asm"
0001++ F82D             ;
0002++ F82D             ; UART routines..
0003++ F82D             ;
0004++ F82D             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F82D             ;
0006++ F82D             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F82D             ;
0008++ F82D             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F82D             ; of this software and associated documentation files (the "Software"), to deal
0010++ F82D             ; in the Software without restriction, including without limitation the rights
0011++ F82D             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F82D             ; copies of the Software, and to permit persons to whom the Software is
0013++ F82D             ; furnished to do so, subject to the following conditions:
0014++ F82D             ; 
0015++ F82D             ; The above copyright notice and this permission notice shall be included in all
0016++ F82D             ; copies or substantial portions of the Software.
0017++ F82D             ; 
0018++ F82D             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F82D             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F82D             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F82D             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F82D             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F82D             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F82D             ; SOFTWARE.
0025++ F82D             ;
0026++ F82D                                 .MODULE     uart
0027++ F82D             
0028++ F82D             ;
0029++ F82D             ; Baud rates, assuming 1.8432Mhz crystal
0030++ F82D             ;
0031++ F82D             UART_9600           .EQU    12
0032++ F82D             UART_19200          .EQU    6
0033++ F82D             UART_38400          .EQU    3
0034++ F82D             
0035++ F82D             UART_MODE_AUTO      .EQU    022h   ; Auto flow mode
0036++ F82D             UART_MODE_NO_FLOW   .EQU    000h   ; Auto RTS and CTS disabled
0037++ F82D             UART_MODE_DIAG      .EQU    030h   ; Loopback mode
0038++ F82D             
0039++ F82D             ;
0040++ F82D             ; Various constants
0041++ F82D             ;
0042++ F82D             UART_8N1            .EQU    003h
0043++ F82D             UART_TIMEOUT        .EQU    50000
0044++ F82D             
0045++ F82D             _CTS_STATUS_MASK    .EQU    010h
0046++ F82D             
0047++ F82D             ;
0048++ F82D             ; Set up the UART. Assume it has had time to settle after reset...
0049++ F82D             ;
0050++ F82D             ;
0051++ F82D 01 06 00    uart_init           LD      BC, UART_19200              ; B is flow control, 0 -> No auto flow control
0052++ F830             
0053++ F830 DB 26                           IN      A,(UART_MODEM_STATUS)       ; If CTS is enabled, assume we can use flow control
0054++ F832 E6 10                           AND     _CTS_STATUS_MASK
0055++ F834 28 02                           JR      Z, _no_listener
0056++ F836             
0057++ F836 06 22                           LD      B, UART_MODE_AUTO
0058++ F838                                     
0059++ F838 3E 80       _no_listener        LD      A, 80h                      ; Divisor Latch Setting Mode
0060++ F83A D3 23                           OUT     (UART_LINE_CTRL), A         ;  - entered by writing 1 to bit 7 of LCR
0061++ F83C 00                              NOP
0062++ F83D 00                              NOP
0063++ F83E 79                              LD      A, C
0064++ F83F D3 20                           OUT     (UART_TX_RX), A
0065++ F841 00                              NOP
0066++ F842 00                              NOP
0067++ F843 AF                              XOR     A
0068++ F844 D3 21                           OUT     (UART_INT_ENABLE), A
0069++ F846 00                              NOP
0070++ F847 00                              NOP
0071++ F848             
0072++ F848 3E 03                           LD      A, UART_8N1                 ; Set 8N1 and exit divisor latch setting mode
0073++ F84A D3 23                           OUT     (UART_LINE_CTRL), A
0074++ F84C             
0075++ F84C 3E 07                           LD      A, 07h                      ; Enable and clear FIFO registers
0076++ F84E D3 22                           OUT     (UART_FIFO_CTRL), A
0077++ F850             
0078++ F850 78                              LD      A, B
0079++ F851 A7                              AND     A
0080++ F852 28 02                           JR      Z, _no_flowcontrol
0081++ F854             
0082++ F854 D3 24                           OUT     (UART_MODEM_CTRL), A
0083++ F856             
0084++ F856 00          _no_flowcontrol     NOP
0085++ F857 00                              NOP
0086++ F858 C9                              RET
0087++ F859             
0088++ F859             ;
0089++ F859             ; Send character in A to UART
0090++ F859             ; Preserves all registers
0091++ F859             ;
0092++ F859             ; Carry flag is set on return if the UART send succeeded, clear if it timed out
0093++ F859             ;
0094++ F859 C5          uart_send           PUSH    BC
0095++ F85A F5                              PUSH    AF
0096++ F85B 01 50 C3                        LD      BC, UART_TIMEOUT
0097++ F85E DB 25       _check_ready        IN      A, (UART_LINE_STATUS)
0098++ F860 CB 6F                           BIT     5, A
0099++ F862 C2 70 F8                        JP      NZ, _uart_ready             ; Bit 5 is set when the UART is ready
0100++ F865 0B                              DEC     BC
0101++ F866 78                              LD      A, B
0102++ F867 B1                              OR      C
0103++ F868 C2 5E F8                        JP      NZ, _check_ready
0104++ F86B             
0105++ F86B F1                              POP     AF
0106++ F86C C1                              POP     BC
0107++ F86D 37                              SCF
0108++ F86E 3F                              CCF
0109++ F86F C9                              RET
0110++ F870             
0111++ F870 F1          _uart_ready         POP     AF
0112++ F871 C1                              POP     BC
0113++ F872 D3 20                           OUT     (UART_TX_RX), A
0114++ F874 37                              SCF
0115++ F875 C9                              RET
0116++ F876             
0117++ F876             ;
0118++ F876             ; Check to see if there are any characters to receive
0119++ F876             ; Preserves all registers
0120++ F876             ;
0121++ F876             ; Returns with carry set if there are characters ready, clear if not
0122++ F876             ;
0123++ F876 F5          uart_ready          PUSH    AF
0124++ F877 DB 25                           IN      A, (UART_LINE_STATUS)
0125++ F879 CB 47                           BIT     0, A
0126++ F87B CA 81 F8                        JP      Z, _not_ready
0127++ F87E F1                              POP     AF
0128++ F87F 37                              SCF
0129++ F880 C9                              RET
0130++ F881             
0131++ F881 F1          _not_ready          POP     AF
0132++ F882 37                              SCF
0133++ F883 3F                              CCF
0134++ F884 C9                              RET
0135++ F885             
0136++ F885             ;
0137++ F885             ; Receive a character from the UART in A
0138++ F885             ; 
0139++ F885             ; Returns with a character in A and the carry flag set. If no characters
0140++ F885             ; are available, returns with the carry flag clear.
0141++ F885             ;
0142++ F885 DB 25       uart_receive        IN      A, (UART_LINE_STATUS)
0143++ F887 CB 47                           BIT     0, A
0144++ F889 CA 90 F8                        JP      Z, _no_character
0145++ F88C DB 20                           IN      A, (UART_TX_RX)
0146++ F88E 37                              SCF
0147++ F88F C9                              RET
0148++ F890             
0149++ F890 37          _no_character       SCF
0150++ F891 3F                              CCF
0151++ F892 C9                              RET
0152++ F893             
0153++ F893             ;
0154++ F893             ; Write A as a hex byte
0155++ F893             ; Overwrites A...
0156++ F893             ;
0157++ F893 F5          uart_hex            PUSH    AF
0158++ F894 CB 2F                           SRA     A
0159++ F896 CB 2F                           SRA     A
0160++ F898 CB 2F                           SRA     A
0161++ F89A CB 2F                           SRA     A
0162++ F89C CD A9 F8                        CALL    to_hex
0163++ F89F CD 59 F8                        CALL    uart_send
0164++ F8A2 F1                              POP     AF
0165++ F8A3 CD A9 F8                        CALL    to_hex
0166++ F8A6 C3 59 F8                        JP      uart_send
0167++ F8A9             ;
0168++ F8A9             ; Returns the low nibble of A as a hex digit
0169++ F8A9             ;
0170++ F8A9 E6 0F       to_hex              AND $0F      ;LOW NIBBLE ONLY
0171++ F8AB C6 90                           ADD A,$90
0172++ F8AD 27                              DAA 
0173++ F8AE CE 40                           ADC A,$40
0174++ F8B0 27                              DAA 
0175++ F8B1 C9                              RET 
0176++ F8B2             ;
0177++ F8B2             ; Inline send. Sends the zero terminated string immediately following the call to this function to the UART.
0178++ F8B2             ;  e.g.             CALL    uart_inline
0179++ F8B2             ;                   .DB     "My text to send", 0
0180++ F8B2             ;                   <code continues after message...>
0181++ F8B2             ; Returns with Carry set if the string was successfully sent, otherwise, carry is clear.
0182++ F8B2             ;
0183++ F8B2             ; Uses A 
0184++ F8B2             ;
0185++ F8B2 E3          uart_inline         EX      (SP), HL
0186++ F8B3 CD C1 F8                        CALL    uart_string
0187++ F8B6 DA BF F8                        JP      C, _inline_end      
0188++ F8B9 7E          _find_end           LD      A, (HL)             ; Get the current character  (Carry preserved)
0189++ F8BA 23                              INC     HL                  ; Point to next character    (Carry preserved)
0190++ F8BB A7                              AND     A                   ; Test if the current character was zero (Clears carry)
0191++ F8BC C2 B9 F8                        JP      NZ, _find_end       ; If it was, we're done, otherwise repeat
0192++ F8BF E3          _inline_end         EX      (SP), HL
0193++ F8C0 C9                              RET
0194++ F8C1             ;
0195++ F8C1             ; Send a zero terminated string pointed to by HL to the UART
0196++ F8C1             ;
0197++ F8C1             ; Returns with Carry Set if the string was sent sucessfully, clear otherwise
0198++ F8C1             ;                    
0199++ F8C1 7E          uart_string         LD      A,(HL)
0200++ F8C2 23                              INC     HL
0201++ F8C3 A7                              AND     A
0202++ F8C4 CA CE F8                        JP      Z, _string_end
0203++ F8C7 CD 59 F8                        CALL    uart_send
0204++ F8CA DA C1 F8                        JP      C, uart_string
0205++ F8CD C9                              RET
0206++ F8CE 37          _string_end         SCF
0207++ F8CF C9                              RET
0208++ F8D0             
0209++ F8D0                                 .MODULE main1367+  F8D0                                 .INCLUDE "../i2c.asm"
0001++ F8D0             ; ============================================ I2C Routines =================================================
0002++ F8D0             ; Software driven I2C for Z80 PIO
0003++ F8D0             ;
0004++ F8D0             ; Assume I2C clock is on Port B bit 6
0005++ F8D0             ;            data is on Port B bit 7
0006++ F8D0             ;
0007++ F8D0             ;
0008++ F8D0             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F8D0             ;
0010++ F8D0             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F8D0             ;
0012++ F8D0             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F8D0             ; of this software and associated documentation files (the "Software"), to deal
0014++ F8D0             ; in the Software without restriction, including without limitation the rights
0015++ F8D0             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F8D0             ; copies of the Software, and to permit persons to whom the Software is
0017++ F8D0             ; furnished to do so, subject to the following conditions:
0018++ F8D0             ; 
0019++ F8D0             ; The above copyright notice and this permission notice shall be included in all
0020++ F8D0             ; copies or substantial portions of the Software.
0021++ F8D0             ; 
0022++ F8D0             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F8D0             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F8D0             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F8D0             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F8D0             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F8D0             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F8D0             ; SOFTWARE.
0029++ F8D0             ;
0030++ F8D0                                 .MODULE i2c
0031++ F8D0             
0032++ F8D0 3E CF       init_portb          LD      A, PIO_MODE_3           ; Port B mode 3
0033++ F8D2 32 00 FF                        LD      (port_b_mode), A
0034++ F8D5 D3 13                           OUT     (PIO_B_CTRL), A
0035++ F8D7             
0036++ F8D7 3E FF                           LD      A, PORT_B_IOMASK        ;
0037++ F8D9 32 01 FF                        LD      (port_b_dir), A
0038++ F8DC D3 13                           OUT     (PIO_B_CTRL), A
0039++ F8DE             
0040++ F8DE 3E 3F                           LD      A, 03Fh                 ; All bits high apart from D7, D6
0041++ F8E0 32 02 FF                        LD      (port_b_data),A
0042++ F8E3 D3 11                           OUT     (PIO_B_DATA), A         ; Changing D7 or D6 to an output will drive the lines low
0043++ F8E5 C9                              RET
0044++ F8E6             
0045++ F8E6             ; Reset the bus
0046++ F8E6             ;
0047++ F8E6             ; Uses A, B, D
0048++ F8E6 06 0A       i2c_bus_reset       LD      B, 0ah          ; ten cycles
0049++ F8E8 CD FB F9    _loop_b             CALL    i2c_scl_cycle
0050++ F8EB 10 FB                           DJNZ    _loop_b
0051++ F8ED CD EB F9                        CALL    i2c_scl_high
0052++ F8F0 06 F0                           LD      B, 0F0h
0053++ F8F2 10 FE                           DJNZ    $
0054++ F8F4 C9                              RET
0055++ F8F5             
0056++ F8F5             ;
0057++ F8F5             ; Uses A
0058++ F8F5 CD CB F9    i2c_start           CALL    i2c_sda_high
0059++ F8F8 CD EB F9                        CALL    i2c_scl_high
0060++ F8FB CD DB F9                        CALL    i2c_sda_low     ; Drive data low
0061++ F8FE C3 BB F9                        JP      i2c_scl_low     ; Drive clock low
0062++ F901             
0063++ F901             
0064++ F901             ;
0065++ F901             ; Read a byte from Device address H, Register L into A
0066++ F901             ; Calls i2c_start, sets address, reads byte and then calls i2c_stop
0067++ F901             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0068++ F901             ; Uses A, B, C, D, H, L
0069++ F901             ; Preserves H, L
0070++ F901 CD 1B F9    i2c_read_byte       CALL    i2c_read_from
0071++ F904                                 ; Fall through into stop
0072++ F904                             
0073++ F904             ;
0074++ F904             ; Uses A
0075++ F904 CD DB F9    i2c_stop            CALL    i2c_sda_low     ; Drive data low
0076++ F907 CD EB F9                        CALL    i2c_scl_high
0077++ F90A C3 CB F9                        JP      i2c_sda_high
0078++ F90D             
0079++ F90D             ; Write a byte in C to Device address H, register L
0080++ F90D             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0081++ F90D             ; Calls i2c_stop when done..
0082++ F90D             ;
0083++ F90D             ; Preserves H, L
0084++ F90D C5          i2c_write_byte      PUSH    BC
0085++ F90E CD 3C F9                        CALL    i2c_write_to
0086++ F911 C1                              POP     BC
0087++ F912 D2 04 F9                        JP      NC, i2c_stop
0088++ F915 79                              LD      A, C
0089++ F916 CD 50 F9                        CALL    i2c_write
0090++ F919 18 E9                           JR      i2c_stop
0091++ F91B                                 
0092++ F91B             ;
0093++ F91B             ; Read a byte from Device address H, Register L
0094++ F91B             ; Calls i2c_start, but does NOT call i2c_stop
0095++ F91B             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0096++ F91B             ; Uses A, B, C, D, H, L
0097++ F91B             ; Preserves H, L
0098++ F91B CD F5 F8    i2c_read_from       CALL    i2c_start
0099++ F91E 7C                              LD      A, H
0100++ F91F CD 4E F9                        CALL    i2c_address_w
0101++ F922 30 17                           JR      NC, _read_end
0102++ F924 7D                              LD      A, L
0103++ F925 CD 50 F9                        CALL    i2c_write
0104++ F928 30 11                           JR      NC, _read_end
0105++ F92A 06 32                           LD      B, 50
0106++ F92C 10 FE       _read_pause         DJNZ    _read_pause
0107++ F92E CD F5 F8                        CALL    i2c_start
0108++ F931 7C                              LD      A, H
0109++ F932 CD 48 F9                        CALL    i2c_address_r
0110++ F935 30 04                           JR      NC, _read_end
0111++ F937 CD 5D F9                        CALL    i2c_read
0112++ F93A 37                              SCF
0113++ F93B C9          _read_end           RET
0114++ F93C             
0115++ F93C             
0116++ F93C             ;
0117++ F93C             ; Prepare to write to Device address H, Register L
0118++ F93C             ; Calls i2c_start, but does NOT call i2c_stop
0119++ F93C             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0120++ F93C             ;
0121++ F93C             ; Preserves H, L
0122++ F93C CD F5 F8    i2c_write_to        CALL    i2c_start
0123++ F93F 7C                              LD      A, H
0124++ F940 CD 4E F9                        CALL    i2c_address_w
0125++ F943 D0                              RET     NC
0126++ F944 7D                              LD      A, L
0127++ F945 C3 50 F9                        JP      i2c_write
0128++ F948             
0129++ F948             ; Start reading from device address held in A
0130++ F948             ;
0131++ F948             ; Uses A, B, C, D
0132++ F948 CB 27       i2c_address_r       SLA     A
0133++ F94A F6 01                           OR      1
0134++ F94C 18 02                           JR      i2c_write
0135++ F94E             
0136++ F94E             ; Start writing to device address held in A
0137++ F94E             ;
0138++ F94E             ; Uses A, B, C, D
0139++ F94E CB 27       i2c_address_w       SLA     A
0140++ F950             
0141++ F950             ; Write A as a byte to i2c bus
0142++ F950             ; Returns Carry CLEAR if no acknowledge
0143++ F950             ;
0144++ F950             ; Uses A, B, C, D
0145++ F950 CD 78 F9    i2c_write           CALL    i2c_send_byte
0146++ F953 CB 7A                           BIT     I2C_DATA_BIT, D     ; D contains acknowledge bit
0147++ F955 37                              SCF
0148++ F956 C8                              RET     Z               ; Return with carry set if acknowledge bit is low
0149++ F957             
0150++ F957 CD 04 F9                        CALL    i2c_stop        ; Stop bus if error
0151++ F95A 37                              SCF
0152++ F95B 3F                              CCF
0153++ F95C C9                              RET                     ; Clear carry if acknowledge is high
0154++ F95D             
0155++ F95D             ; Read byte from i2C into A, without ACK
0156++ F95D             ;
0157++ F95D             ; Uses A, B, C, D
0158++ F95D 06 08       i2c_read            LD      B, 8h
0159++ F95F DB 11       _loop_r             IN      A, (PIO_B_DATA)
0160++ F961 37                              SCF
0161++ F962 CB 7F                           BIT     I2C_DATA_BIT, A
0162++ F964 20 01                           JR      NZ, _data_high
0163++ F966 3F                              CCF
0164++ F967 CB 11       _data_high          RL      C
0165++ F969 CD FB F9                        CALL    i2c_scl_cycle
0166++ F96C 10 F1                           DJNZ    _loop_r
0167++ F96E                                 ; CALL    i2c_scl_cycle
0168++ F96E             
0169++ F96E 79                              LD      A, C
0170++ F96F C9                              RET
0171++ F970             
0172++ F970             ;
0173++ F970             ; Send an ACK..
0174++ F970             ;
0175++ F970 CD DB F9    i2c_ack             CALL    i2c_sda_low
0176++ F973 CD FB F9                        CALL    i2c_scl_cycle
0177++ F976 18 53                           JR      i2c_sda_high
0178++ F978             
0179++ F978             ;
0180++ F978             ; Send a byte in A, returning the ACK state in D
0181++ F978             ; Uses A, B, C,
0182++ F978             ;
0183++ F978 E5          i2c_send_byte       PUSH    HL
0184++ F979 D5                              PUSH    DE
0185++ F97A 2A 00 FF                        LD      HL, (port_b_mode)           ; L = port_b_mode, H = port_b_dir
0186++ F97D 57                              LD      D, A
0187++ F97E                                 
0188++ F97E 3E 3F                           LD      A, ~(I2C_DATA_MASK|I2C_CLK_MASK)           ; Set SDA and SCL (port_b_dir bit) LOW
0189++ F980 A4                              AND     H
0190++ F981 CB 27                           SLA     A
0191++ F983 67                              LD      H, A
0192++ F984             
0193++ F984 0E 13                           LD      C, PIO_B_CTRL
0194++ F986 06 08                           LD      B, 8
0195++ F988             
0196++ F988 1E 40                           LD      E, I2C_CLK_MASK
0197++ F98A             
0198++ F98A 7C          _fast_loop          LD      A, H
0199++ F98B CB 22                           SLA     D
0200++ F98D CB 1F                           RR      A
0201++ F98F ED 69                           OUT     (C),L
0202++ F991 D3 13                           OUT     (PIO_B_CTRL), A
0203++ F993             
0204++ F993 B3                              OR      E
0205++ F994 ED 69                           OUT     (C), L
0206++ F996 D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0207++ F998             
0208++ F998 AB                              XOR     E
0209++ F999 ED 69                           OUT     (C), L
0210++ F99B D3 13                           OUT     (PIO_B_CTRL),A                  ; Clock low
0211++ F99D 10 EB                           DJNZ    _fast_loop
0212++ F99F             
0213++ F99F 7C                              LD      A, H
0214++ F9A0 37                              SCF
0215++ F9A1 CB 1F                           RR      A
0216++ F9A3 ED 69                           OUT     (C),L                           ; Release SDA
0217++ F9A5 D3 13                           OUT     (PIO_B_CTRL), A
0218++ F9A7             
0219++ F9A7 B3                              OR      E
0220++ F9A8 ED 69                           OUT     (C), L
0221++ F9AA D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0222++ F9AC             
0223++ F9AC ED 69                           OUT     (C), L
0224++ F9AE AB                              XOR     E
0225++ F9AF 6F                              LD      L, A
0226++ F9B0 32 01 FF                        LD      (port_b_dir), A
0227++ F9B3             
0228++ F9B3 DB 11                           IN      A, (PIO_B_DATA)                 ; Read ACK
0229++ F9B5 ED 69                           OUT     (C),L                           ; Clock low
0230++ F9B7             
0231++ F9B7 D1                              POP     DE
0232++ F9B8 E1                              POP     HL
0233++ F9B9 57                              LD      D, A
0234++ F9BA C9                              RET
0235++ F9BB             
0236++ F9BB             ; SCL/SDA toggle routines
0237++ F9BB             ;
0238++ F9BB             ; All use A
0239++ F9BB 3A 00 FF    i2c_scl_low         LD      A, (port_b_mode)
0240++ F9BE D3 13                           OUT     (PIO_B_CTRL), A
0241++ F9C0             
0242++ F9C0 3A 01 FF                        LD      A, (port_b_dir)
0243++ F9C3 CB B7                           RES     I2C_CLK_BIT, A
0244++ F9C5 D3 13                           OUT     (PIO_B_CTRL), A
0245++ F9C7 32 01 FF                        LD      (port_b_dir), A
0246++ F9CA C9                              RET
0247++ F9CB             
0248++ F9CB 3A 00 FF    i2c_sda_high        LD      A, (port_b_mode)
0249++ F9CE D3 13                           OUT     (PIO_B_CTRL), A
0250++ F9D0             
0251++ F9D0 3A 01 FF                        LD      A, (port_b_dir)
0252++ F9D3 CB FF                           SET     I2C_DATA_BIT, A
0253++ F9D5 D3 13                           OUT     (PIO_B_CTRL), A
0254++ F9D7 32 01 FF                        LD      (port_b_dir), A
0255++ F9DA C9                              RET
0256++ F9DB             
0257++ F9DB 3A 00 FF    i2c_sda_low         LD      A, (port_b_mode)
0258++ F9DE D3 13                           OUT     (PIO_B_CTRL), A
0259++ F9E0             
0260++ F9E0 3A 01 FF                        LD      A, (port_b_dir)
0261++ F9E3 CB BF                           RES     I2C_DATA_BIT, A
0262++ F9E5 D3 13                           OUT     (PIO_B_CTRL), A
0263++ F9E7 32 01 FF                        LD      (port_b_dir), A
0264++ F9EA C9                              RET
0265++ F9EB             
0266++ F9EB 3A 00 FF    i2c_scl_high        LD      A, (port_b_mode)
0267++ F9EE D3 13                           OUT     (PIO_B_CTRL), A
0268++ F9F0             
0269++ F9F0 3A 01 FF                        LD      A, (port_b_dir)
0270++ F9F3 CB F7                           SET     I2C_CLK_BIT, A
0271++ F9F5 D3 13                           OUT     (PIO_B_CTRL), A
0272++ F9F7 32 01 FF                        LD      (port_b_dir), A
0273++ F9FA C9                              RET
0274++ F9FB             
0275++ F9FB C5          i2c_scl_cycle       PUSH   BC
0276++ F9FC 01 13 00                        LD     BC, PIO_B_CTRL
0277++ F9FF 3A 00 FF                        LD     A, (port_b_mode)
0278++ FA02 57                              LD     D, A
0279++ FA03 3A 01 FF                        LD     A, (port_b_dir)
0280++ FA06             
0281++ FA06 CB B7                           RES    I2C_CLK_BIT, A
0282++ FA08 32 01 FF                        LD     (port_b_dir), A
0283++ FA0B ED 51                           OUT    (C), D
0284++ FA0D D3 13                           OUT    (PIO_B_CTRL), A
0285++ FA0F                                 
0286++ FA0F CB F7                           SET    I2C_CLK_BIT, A
0287++ FA11 ED 51                           OUT    (C), D
0288++ FA13 D3 13                           OUT    (PIO_B_CTRL), A
0289++ FA15                                 
0290++ FA15 DB 11                           IN     A, (PIO_B_DATA)
0291++ FA17 ED 51                           OUT    (C), D
0292++ FA19 57                              LD     D, A
0293++ FA1A 3A 01 FF                        LD     A, (port_b_dir)
0294++ FA1D D3 13                           OUT    (PIO_B_CTRL), A
0295++ FA1F C1                              POP    BC
0296++ FA20 C9                              RET
0297++ FA21             
0298++ FA21                                 .MODULE main
1368+  FA21             
1369+  FA21                                 .INCLUDE "../disp.asm"
0001++ FA21             ; ========================================== Display Routines ===============================================
0002++ FA21             ;
0003++ FA21             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0004++ FA21             ;
0005++ FA21             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0006++ FA21             ;
0007++ FA21             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0008++ FA21             ; of this software and associated documentation files (the "Software"), to deal
0009++ FA21             ; in the Software without restriction, including without limitation the rights
0010++ FA21             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0011++ FA21             ; copies of the Software, and to permit persons to whom the Software is
0012++ FA21             ; furnished to do so, subject to the following conditions:
0013++ FA21             ; 
0014++ FA21             ; The above copyright notice and this permission notice shall be included in all
0015++ FA21             ; copies or substantial portions of the Software.
0016++ FA21             ; 
0017++ FA21             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0018++ FA21             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0019++ FA21             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0020++ FA21             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0021++ FA21             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0022++ FA21             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0023++ FA21             ; SOFTWARE.
0024++ FA21             ;
0025++ FA21                                 .MODULE disp
0026++ FA21             
0027++ FA21             CONFIG_PAGE         .EQU    3
0028++ FA21             BRIGHT_PAGE         .EQU    1
0029++ FA21             LED_PAGE            .EQU    0 
0030++ FA21             
0031++ FA21 CD 6E FB    display_init        CALL    disp_clear
0032++ FA24 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0033++ FA26 CD 61 FA                        CALL    disp_brightness
0034++ FA29             
0035++ FA29 CD 35 FA                        CALL    disp_select_l
0036++ FA2C CD 41 FA                        CALL    disp_config
0037++ FA2F             
0038++ FA2F CD 3B FA                        CALL    disp_select_r
0039++ FA32 CD 41 FA                        CALL    disp_config
0040++ FA35             
0041++ FA35 3E 50       disp_select_l       LD      A, DL_ADDRESS
0042++ FA37 32 03 FF                        LD      (display_address), A
0043++ FA3A C9                              RET
0044++ FA3B             
0045++ FA3B 3E 53       disp_select_r       LD      A, DR_ADDRESS
0046++ FA3D 32 03 FF                        LD      (display_address), A
0047++ FA40 C9                              RET
0048++ FA41             
0049++ FA41 2E 03       disp_config         LD      L, CONFIG_PAGE
0050++ FA43 CD 9C FA                        CALL    disp_page
0051++ FA46 CD F5 F8                        CALL    i2c_start
0052++ FA49 3A 03 FF                        LD      A, (display_address)
0053++ FA4C CD 4E F9                        CALL    i2c_address_w
0054++ FA4F 3E 00                           LD      A, 000h
0055++ FA51 CD 50 F9                        CALL    i2c_write
0056++ FA54 3E 01                           LD      A, 001h         ; Turn display on
0057++ FA56 CD 50 F9                        CALL    i2c_write
0058++ FA59 3E 78                           LD      A, 078h         ; 0.020mA
0059++ FA5B CD 50 F9                        CALL    i2c_write
0060++ FA5E C3 04 F9                        JP      i2c_stop
0061++ FA61             
0062++ FA61             ;
0063++ FA61             ; Sets the brightness for the display
0064++ FA61             ; Enter with E set to the desired brightness for all segments
0065++ FA61             ;
0066++ FA61 CD 35 FA    disp_brightness     CALL    disp_select_l
0067++ FA64 CD 6A FA                        CALL    _set_bright
0068++ FA67 CD 3B FA                        CALL    disp_select_r
0069++ FA6A 2E 01       _set_bright         LD      L, BRIGHT_PAGE
0070++ FA6C CD 9C FA                        CALL    disp_page
0071++ FA6F 2E 0C                           LD      L, 12
0072++ FA71 CD F5 F8    _bright_loop        CALL    i2c_start
0073++ FA74 3A 03 FF                        LD      A, (display_address)
0074++ FA77 CD 4E F9                        CALL    i2c_address_w
0075++ FA7A 7D                              LD      A, L
0076++ FA7B 3D                              DEC     A
0077++ FA7C CB 27                           SLA     A
0078++ FA7E CB 27                           SLA     A
0079++ FA80 CB 27                           SLA     A
0080++ FA82 CB 27                           SLA     A
0081++ FA84 CD 50 F9                        CALL    i2c_write
0082++ FA87 26 10                           LD      H, 010h
0083++ FA89 7B          _bright_byte        LD      A, E
0084++ FA8A CD 50 F9                        CALL    i2c_write
0085++ FA8D 25                              DEC     H
0086++ FA8E 20 F9                           JR      NZ, _bright_byte
0087++ FA90 CD 04 F9                        CALL    i2c_stop
0088++ FA93 2D                              DEC     L
0089++ FA94 20 DB                           JR      NZ, _bright_loop
0090++ FA96 2E 00                           LD      L, LED_PAGE
0091++ FA98 CD 9C FA                        CALL    disp_page
0092++ FA9B C9                              RET
0093++ FA9C             
0094++ FA9C             ; Set the Page number
0095++ FA9C             ; Call with page number in L
0096++ FA9C             ;
0097++ FA9C             ; Uses A, B, C, D
0098++ FA9C CD B4 FA    disp_page           CALL    disp_unlock
0099++ FA9F CD F5 F8                        CALL    i2c_start
0100++ FAA2 3A 03 FF                        LD      A, (display_address)
0101++ FAA5 CD 4E F9                        CALL    i2c_address_w
0102++ FAA8 3E FD                           LD      A, 0FDh
0103++ FAAA CD 50 F9                        CALL    i2c_write
0104++ FAAD 7D                              LD      A, L
0105++ FAAE CD 50 F9                        CALL    i2c_write
0106++ FAB1 C3 04 F9                        JP      i2c_stop
0107++ FAB4             
0108++ FAB4 CD F5 F8    disp_unlock         CALL    i2c_start           ; Must be called before switching pages
0109++ FAB7 3A 03 FF                        LD      A, (display_address)
0110++ FABA CD 4E F9                        CALL    i2c_address_w
0111++ FABD 3E FE                           LD      A, DISP_REG_CRWL
0112++ FABF CD 50 F9                        CALL    i2c_write
0113++ FAC2 3E C5                           LD      A, DISP_UNLOCK
0114++ FAC4 CD 50 F9                        CALL    i2c_write
0115++ FAC7 C3 04 F9                        JP      i2c_stop
0116++ FACA             
0117++ FACA             ; Set the character at column A to brightness C
0118++ FACA             ;
0119++ FACA             ;
0120++ FACA C5          disp_char_bright    PUSH    BC
0121++ FACB 06 50                           LD      B, DL_ADDRESS
0122++ FACD FE 0C                           CP      12
0123++ FACF DA D6 FA                        JP      C, _bright_left
0124++ FAD2 06 53                           LD      B, DR_ADDRESS
0125++ FAD4 D6 0C                           SUB     12
0126++ FAD6 5F          _bright_left        LD      E, A
0127++ FAD7 78                              LD      A, B
0128++ FAD8 32 03 FF                        LD      (display_address), A
0129++ FADB 2E 01                           LD      L, BRIGHT_PAGE
0130++ FADD CD 9C FA                        CALL    disp_page
0131++ FAE0             
0132++ FAE0 CD F5 F8                        CALL    i2c_start
0133++ FAE3 3A 03 FF                        LD      A, (display_address)
0134++ FAE6 CD 4E F9                        CALL    i2c_address_w
0135++ FAE9 7B                              LD      A, E
0136++ FAEA CB 27                           SLA     A
0137++ FAEC CB 27                           SLA     A
0138++ FAEE CB 27                           SLA     A
0139++ FAF0 CB 27                           SLA     A
0140++ FAF2 CD 50 F9                        CALL    i2c_write
0141++ FAF5 E1                              POP     HL
0142++ FAF6 26 10                           LD      H, 010h
0143++ FAF8 7D          _bright_char_loop   LD      A, L
0144++ FAF9 CD 50 F9                        CALL    i2c_write
0145++ FAFC 25                              DEC     H
0146++ FAFD 20 F9                           JR      NZ, _bright_char_loop
0147++ FAFF CD 04 F9                        CALL    i2c_stop
0148++ FB02             
0149++ FB02 2E 00                           LD      L, LED_PAGE
0150++ FB04 CD 9C FA                        CALL    disp_page
0151++ FB07 C9                              RET
0152++ FB08                                 
0153++ FB08             ; Display a single character A at column C
0154++ FB08             ;
0155++ FB08             ; Returns with A pointing to next column
0156++ FB08             ;
0157++ FB08 FE 20       disp_character      CP      32
0158++ FB0A F2 14 FB                        JP      P, _not_control
0159++ FB0D             
0160++ FB0D 21 61 48    _invalid_char       LD      HL, INVALID_CHAR_BITMASK
0161++ FB10 79                              LD      A, C
0162++ FB11 C3 29 FB                        JP      disp_bitmask
0163++ FB14             
0164++ FB14 CB 7F       _not_control        BIT     7, A
0165++ FB16 C2 0D FB                        JP      NZ, _invalid_char
0166++ FB19 D6 20                           SUB     32
0167++ FB1B             
0168++ FB1B 16 00                           LD      D, 0
0169++ FB1D 5F                              LD      E, A
0170++ FB1E CB 23                           SLA     E                   ; Don't need to shift into D, since bit 7 is zero
0171++ FB20 21 7C FB                        LD      HL, font  
0172++ FB23 19                              ADD     HL, DE
0173++ FB24 56                              LD      D, (HL)
0174++ FB25 23                              INC     HL
0175++ FB26 66                              LD      H, (HL)
0176++ FB27 6A                              LD      L, D
0177++ FB28 79                              LD      A, C
0178++ FB29                                 ; Fall into disp_bitmask
0179++ FB29             
0180++ FB29             ; Display a bitmask in HL at column A (0 - 23)
0181++ FB29             ;
0182++ FB29             ; Returns with A pointing to next column
0183++ FB29             ;
0184++ FB29             ; Uses A, B, C, D, E
0185++ FB29 F5          disp_bitmask        PUSH    AF
0186++ FB2A 06 50                           LD      B, DL_ADDRESS
0187++ FB2C FE 0C                           CP      12
0188++ FB2E DA 35 FB                        JP      C, _disp_left
0189++ FB31 06 53                           LD      B, DR_ADDRESS
0190++ FB33 D6 0C                           SUB     12
0191++ FB35 5F          _disp_left          LD      E, A
0192++ FB36 CD F5 F8                        CALL    i2c_start
0193++ FB39 78                              LD      A, B
0194++ FB3A CD 4E F9                        CALL    i2c_address_w
0195++ FB3D 7B                              LD      A, E
0196++ FB3E CB 27                           SLA     A
0197++ FB40 CD 50 F9                        CALL    i2c_write
0198++ FB43 7D                              LD      A, L
0199++ FB44 CD 50 F9                        CALL    i2c_write
0200++ FB47 7C                              LD      A, H
0201++ FB48 CD 50 F9                        CALL    i2c_write
0202++ FB4B CD 04 F9                        CALL    i2c_stop
0203++ FB4E F1                              POP     AF
0204++ FB4F 3C                              INC     A
0205++ FB50 C9                              RET
0206++ FB51             
0207++ FB51             
0208++ FB51 C3 29 FB                        JP      disp_bitmask
0209++ FB54             ;
0210++ FB54             ; Clear the display and show an inline string from column 0
0211++ FB54             ;
0212++ FB54 CD 6E FB    disp_clear_inline   CALL    disp_clear
0213++ FB57 AF                              XOR     A
0214++ FB58             ;
0215++ FB58             ; Display an inline string to column A->
0216++ FB58             ;
0217++ FB58 E3          disp_inline         EX      (SP), HL
0218++ FB59 CD 5F FB                        CALL    disp_string
0219++ FB5C 23                              INC     HL
0220++ FB5D E3                              EX      (SP), HL
0221++ FB5E C9                              RET
0222++ FB5F             
0223++ FB5F             ; Display a string pointed to by HL to column A->
0224++ FB5F             ; Note string should be zero terminated...
0225++ FB5F             ; Returns with HL pointing to the 0 terminator
0226++ FB5F             ;
0227++ FB5F 4F          disp_string         LD      C, A
0228++ FB60 7E                              LD      A, (HL)
0229++ FB61 B7                              OR      A
0230++ FB62 C2 66 FB                        JP      NZ, _char_ok
0231++ FB65 C9                              RET
0232++ FB66             
0233++ FB66 E5          _char_ok            PUSH    HL
0234++ FB67 CD 08 FB                        CALL    disp_character
0235++ FB6A E1                              POP     HL
0236++ FB6B 23                              INC     HL
0237++ FB6C 18 F1                           JR      disp_string
0238++ FB6E             
0239++ FB6E             ; Clear the display
0240++ FB6E             ;
0241++ FB6E 3E 00       disp_clear          LD      A, 0
0242++ FB70 21 00 00                        LD      HL, 0
0243++ FB73 CD 29 FB    _clear_loop         CALL    disp_bitmask
0244++ FB76 FE 18                           CP      24
0245++ FB78 C2 73 FB                        JP      NZ, _clear_loop
0246++ FB7B C9                              RET
0247++ FB7C             
0248++ FB7C                                 .MODULE main1370+  FB7C                                 .INCLUDE "../font.asm"
0001++ FB7C             ;
0002++ FB7C             ; Font definition
0003++ FB7C             ;
0004++ FB7C             ;
0005++ FB7C             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ FB7C             ;
0007++ FB7C             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ FB7C             ;
0009++ FB7C             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ FB7C             ; of this software and associated documentation files (the "Software"), to deal
0011++ FB7C             ; in the Software without restriction, including without limitation the rights
0012++ FB7C             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ FB7C             ; copies of the Software, and to permit persons to whom the Software is
0014++ FB7C             ; furnished to do so, subject to the following conditions:
0015++ FB7C             ; 
0016++ FB7C             ; The above copyright notice and this permission notice shall be included in all
0017++ FB7C             ; copies or substantial portions of the Software.
0018++ FB7C             ; 
0019++ FB7C             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ FB7C             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ FB7C             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ FB7C             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ FB7C             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ FB7C             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ FB7C             ; SOFTWARE.
0026++ FB7C             ;
0027++ FB7C             
0028++ FB7C             INVALID_CHAR_BITMASK    .EQU 04861h
0029++ FB7C             
0030++ FB7C             font
0031++ FB7C 00 00                           .dw     0000h
0032++ FB7E 00 49                           .dw     4900h   ; !
0033++ FB80 02 02                           .dw     0202h   ; "
0034++ FB82 CE 12                           .dw     12ceh   ; #
0035++ FB84 ED 12                           .dw     12edh   ; $
0036++ FB86 E4 2D                           .dw     2de4h   ; %
0037++ FB88 59 0B                           .dw     0b59h   ; &
0038++ FB8A 00 02                           .dw     0200h   ; '
0039++ FB8C 00 0C                           .dw     0c00h   ; (
0040++ FB8E 00 21                           .dw     2100h   ; )
0041++ FB90 C0 3F                           .dw     3fc0h   ; *
0042++ FB92 C0 12                           .dw     12c0h   ; +
0043++ FB94 00 20                           .dw     2000h   ; ,
0044++ FB96 C0 00                           .dw     00c0h   ; -
0045++ FB98 00 40                           .dw     4000h   ; .
0046++ FB9A 00 24                           .dw     2400h   ; /
0047++ FB9C             
0048++ FB9C 3F 24                           .dw     243fh   ; 0
0049++ FB9E 06 04                           .dw     0406h   ; 1
0050++ FBA0 DB 00                           .dw     00dbh   ; 2
0051++ FBA2 8F 00                           .dw     008fh   ; 3
0052++ FBA4 E6 00                           .dw     00e6h   ; 4
0053++ FBA6 69 08                           .dw     0869h   ; 5
0054++ FBA8 FD 00                           .dw     00fdh   ; 6
0055++ FBAA 01 14                           .dw     1401h   ; 7
0056++ FBAC FF 00                           .dw     00ffh   ; 8
0057++ FBAE EF 00                           .dw     00efh   ; 9
0058++ FBB0 40 00                           .dw     0040h   ; :
0059++ FBB2 00 22                           .dw     2200h   ; ;
0060++ FBB4 40 0C                           .dw     0c40h   ; <
0061++ FBB6 C8 00                           .dw     00c8h   ; = 
0062++ FBB8 80 21                           .dw     2180h   ; >
0063++ FBBA 83 50                           .dw     5083h   ; ?
0064++ FBBC             
0065++ FBBC BB 02                           .dw     02bbh   ; @
0066++ FBBE F7 00                           .dw     00f7h   ; A
0067++ FBC0 8F 12                           .dw     128fh   ; B
0068++ FBC2 39 00                           .dw     0039h   ; C
0069++ FBC4 0F 12                           .dw     120fh   ; D
0070++ FBC6 79 00                           .dw     0079h   ; E
0071++ FBC8 71 00                           .dw     0071h   ; F
0072++ FBCA BD 00                           .dw     00bdh   ; G
0073++ FBCC F6 00                           .dw     00f6h   ; H
0074++ FBCE 09 12                           .dw     1209h   ; I
0075++ FBD0 1E 00                           .dw     001eh   ; J
0076++ FBD2 70 0C                           .dw     0c70h   ; K
0077++ FBD4 38 00                           .dw     0038h   ; L
0078++ FBD6 36 05                           .dw     0536h   ; M
0079++ FBD8 36 09                           .dw     0936h   ; N
0080++ FBDA 3F 00                           .dw     003fh   ; O
0081++ FBDC             
0082++ FBDC F3 00                           .dw     00f3h   ; P
0083++ FBDE 3F 08                           .dw     083fh   ; Q
0084++ FBE0 F3 08                           .dw     08f3h   ; R
0085++ FBE2 ED 00                           .dw     00edh   ; S
0086++ FBE4 01 12                           .dw     1201h   ; T
0087++ FBE6 3E 00                           .dw     003eh   ; U
0088++ FBE8 30 24                           .dw     2430h   ; V
0089++ FBEA 36 28                           .dw     2836h   ; W
0090++ FBEC 00 2D                           .dw     2d00h   ; X
0091++ FBEE EE 00                           .dw     00eeh   ; Y
0092++ FBF0 09 24                           .dw     2409h   ; Z
0093++ FBF2 39 00                           .dw     0039h   ; [
0094++ FBF4 00 09                           .dw     0900h   ; \
0095++ FBF6 0F 00                           .dw     000fh   ; ]
0096++ FBF8 00 28                           .dw     2800h   ; ^
0097++ FBFA 08 00                           .dw     0008h   ; _
0098++ FBFC             
0099++ FBFC 00 01                           .dw     0100h   ; `
0100++ FBFE 8C 20                           .dw     208ch   ; a
0101++ FC00 78 08                           .dw     0878h   ; b
0102++ FC02 D8 00                           .dw     00d8h   ; c
0103++ FC04 8E 20                           .dw     208eh   ; d 
0104++ FC06 58 20                           .dw     2058h   ; e 
0105++ FC08 C0 14                           .dw     14c0h   ; f
0106++ FC0A 8E 04                           .dw     048eh   ; g
0107++ FC0C 70 10                           .dw     1070h   ; h
0108++ FC0E 00 10                           .dw     1000h   ; i
0109++ FC10 10 22                           .dw     2210h   ; j
0110++ FC12 00 1E                           .dw     1e00h   ; k
0111++ FC14 00 12                           .dw     1200h   ; l
0112++ FC16 D4 10                           .dw     10d4h   ; m
0113++ FC18 50 10                           .dw     1050h   ; n
0114++ FC1A DC 00                           .dw     00dch   ; o
0115++ FC1C             
0116++ FC1C 70 01                           .dw     0170h   ; p
0117++ FC1E 86 04                           .dw     0486h   ; q
0118++ FC20 50 00                           .dw     0050h   ; r
0119++ FC22 88 08                           .dw     0888h   ; s
0120++ FC24 78 00                           .dw     0078h   ; t
0121++ FC26 1C 00                           .dw     001ch   ; u
0122++ FC28 10 20                           .dw     2010h   ; v
0123++ FC2A 14 28                           .dw     2814h   ; w
0124++ FC2C 00 2D                           .dw     2d00h   ; x
0125++ FC2E 8E 02                           .dw     028eh   ; y
0126++ FC30 48 20                           .dw     2048h   ; z
0127++ FC32 49 21                           .dw     2149h   ; {
0128++ FC34 00 12                           .dw     1200h   ; |
0129++ FC36 89 0C                           .dw     0c89h   ; }
0130++ FC38 C0 24                           .dw     24c0h   ; ~
0131++ FC3A 00 00                           .dw     0000h   ; 1371+  FC3C                                 .INCLUDE "bios_rtc.asm"
0001++ FC3C             ; RTC Routines
0002++ FC3C             ;
0003++ FC3C             ;
0004++ FC3C             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ FC3C             ;
0006++ FC3C             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ FC3C             ;
0008++ FC3C             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ FC3C             ; of this software and associated documentation files (the "Software"), to deal
0010++ FC3C             ; in the Software without restriction, including without limitation the rights
0011++ FC3C             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ FC3C             ; copies of the Software, and to permit persons to whom the Software is
0013++ FC3C             ; furnished to do so, subject to the following conditions:
0014++ FC3C             ; 
0015++ FC3C             ; The above copyright notice and this permission notice shall be included in all
0016++ FC3C             ; copies or substantial portions of the Software.
0017++ FC3C             ; 
0018++ FC3C             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ FC3C             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ FC3C             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ FC3C             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ FC3C             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ FC3C             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ FC3C             ; SOFTWARE.
0025++ FC3C             ;
0026++ FC3C             ;
0027++ FC3C                                     .MODULE rtc
0028++ FC3C             
0029++ FC3C             ; Set the initial time and start the clock
0030++ FC3C             ;
0031++ FC3C             ;
0032++ FC3C CD C9 F3    rtc_init                CALL    m_print_inline
0033++ FC3F 0A 0D 43 68                         .DB     "\n\rCheck RTC",0
0033++ FC43 65 63 6B 20 
0033++ FC47 52 54 43 00 
0034++ FC4B             
0035++ FC4B CD C0 FC                            CALL    _read_seconds
0036++ FC4E CD BB FC                            CALL    _pause
0037++ FC51 CB 7B                               BIT     7, E                ; Check to see if the clock is running
0038++ FC53 C0                                  RET     NZ                  ; Return if it is..
0039++ FC54             
0040++ FC54 CD C9 F3    _do_reset               CALL    m_print_inline
0041++ FC57 0A 0D 52 65                         .DB     "\n\rReset RTC",0
0041++ FC5B 73 65 74 20 
0041++ FC5F 52 54 43 00 
0042++ FC63             
0043++ FC63 26 6F                               LD      H, RTC_ADDRESS      ; Clock isn't running, reset to default time
0044++ FC65 2E 00                               LD      L, RTC_REG_SEC
0045++ FC67 CD 3C F9                            CALL    i2c_write_to
0046++ FC6A D2 CE FC                            JP      NC, rtc_ack_error
0047++ FC6D             
0048++ FC6D 21 E1 FC                            LD      HL, time_scratch
0049++ FC70 7E          _reset_loop             LD      A, (HL)
0050++ FC71 23                                  INC     HL
0051++ FC72 FE FF                               CP      0ffh
0052++ FC74 CA 7F FC                            JP      Z, _start_clock
0053++ FC77 CD 50 F9                            CALL    i2c_write
0054++ FC7A D2 CE FC                            JP      NC, rtc_ack_error
0055++ FC7D 18 F1                               JR      _reset_loop
0056++ FC7F             
0057++ FC7F CD 04 F9    _start_clock            CALL    i2c_stop            ; Enable VBAT and start the clock
0058++ FC82             
0059++ FC82 26 6F                               LD      H, RTC_ADDRESS      ; Enable VBAT
0060++ FC84 2E 03                               LD      L, RTC_REG_WKDAY
0061++ FC86 CD 1B F9                            CALL    i2c_read_from
0062++ FC89 D2 CE FC                            JP      NC, rtc_ack_error
0063++ FC8C 5F                                  LD      E, A
0064++ FC8D CD 04 F9                            CALL    i2c_stop
0065++ FC90 CB DB                               SET     3, E
0066++ FC92 CD BB FC                            CALL    _pause
0067++ FC95             
0068++ FC95 CD 3C F9                            CALL    i2c_write_to
0069++ FC98 D2 CE FC                            JP      NC, rtc_ack_error
0070++ FC9B 7B                                  LD      A, E
0071++ FC9C CD 50 F9                            CALL    i2c_write
0072++ FC9F D2 CE FC                            JP      NC, rtc_ack_error
0073++ FCA2 CD 04 F9                            CALL    i2c_stop
0074++ FCA5             
0075++ FCA5 CD C0 FC                            CALL    _read_seconds
0076++ FCA8 CB FB                               SET     7, E                ; Set bit 7 to enable clock
0077++ FCAA                                     
0078++ FCAA CD 3C F9                            CALL    i2c_write_to
0079++ FCAD D2 CE FC                            JP      NC, rtc_ack_error
0080++ FCB0 7B                                  LD      A, E
0081++ FCB1 CD 50 F9                            CALL    i2c_write
0082++ FCB4 D2 CE FC                            JP      NC, rtc_ack_error
0083++ FCB7 CD 04 F9                            CALL    i2c_stop
0084++ FCBA C9                                  RET
0085++ FCBB             
0086++ FCBB 06 00       _pause                  LD      B, 0
0087++ FCBD 10 FE                               DJNZ    $
0088++ FCBF C9                                  RET
0089++ FCC0             
0090++ FCC0             ;
0091++ FCC0             ; Read seconds register in E
0092++ FCC0             ;
0093++ FCC0 26 6F       _read_seconds           LD      H, RTC_ADDRESS      
0094++ FCC2 2E 00                               LD      L, RTC_REG_SEC      
0095++ FCC4 CD 1B F9                            CALL    i2c_read_from
0096++ FCC7 D2 CE FC                            JP      NC, rtc_ack_error
0097++ FCCA 5F                                  LD      E, A
0098++ FCCB C3 04 F9                            JP     i2c_stop
0099++ FCCE             
0100++ FCCE CD 04 F9    rtc_ack_error           CALL    i2c_stop
0101++ FCD1                                     
0102++ FCD1 CD C9 F3                            CALL    m_print_inline
0103++ FCD4 0A 0D 52 54                         .DB     "\n\rRTC Panic",0
0103++ FCD8 43 20 50 61 
0103++ FCDC 6E 69 63 00 
0104++ FCE0 C9                                  RET
0105++ FCE1             
0106++ FCE1                                     ;  Initial time on power up..
0107++ FCE1 23          time_scratch            .db  23h            ; Seconds
0108++ FCE2 59                                  .db  59h            ; Minutes
0109++ FCE3 08                                  .db  08h            ; Hours    (24 hr clock)
0110++ FCE4 06                                  .db  06h            ; Weekday  (1-7. Monday=1)
0111++ FCE5 05                                  .db  05h            ; Date
0112++ FCE6 11                                  .db  11h            ; Month
0113++ FCE7 22                                  .db  22h            ; Year 
0114++ FCE8 FF                                  .db  0ffh           ; 0ffh end marker
0115++ FCE9             
0116++ FCE9                                     .MODULE main1372+  FCE9                                 .INCLUDE "../flash.asm"
0001++ FCE9             ;
0002++ FCE9             ; Flash update routines
0003++ FCE9             ;
0004++ FCE9             ; Note that any memory write operations *at all* during flash updates will cancel the current operation.
0005++ FCE9             ; That means no data can be stored to memory, no stack operations (call, push), no interrupts.
0006++ FCE9             ; 
0007++ FCE9             ;
0008++ FCE9             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ FCE9             ;
0010++ FCE9             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ FCE9             ;
0012++ FCE9             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ FCE9             ; of this software and associated documentation files (the "Software"), to deal
0014++ FCE9             ; in the Software without restriction, including without limitation the rights
0015++ FCE9             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ FCE9             ; copies of the Software, and to permit persons to whom the Software is
0017++ FCE9             ; furnished to do so, subject to the following conditions:
0018++ FCE9             ; 
0019++ FCE9             ; The above copyright notice and this permission notice shall be included in all
0020++ FCE9             ; copies or substantial portions of the Software.
0021++ FCE9             ; 
0022++ FCE9             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ FCE9             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ FCE9             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ FCE9             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ FCE9             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ FCE9             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ FCE9             ; SOFTWARE.
0029++ FCE9             ;
0030++ FCE9                                 .MODULE     flash
0031++ FCE9             
0032++ FCE9             _cmd_1_addr         .EQU  05555h
0033++ FCE9             _cmd_2_addr         .EQU  02AAAh
0034++ FCE9             
0035++ FCE9             _bank_mask          .EQU  03FFFh                ; One memory bank is 14 bits -> 16Kb
0036++ FCE9             _sector_mask        .EQU  00FFFh                ; A sector is 12 bits -> 4Kb
0037++ FCE9             
0038++ FCE9             _cmd_1_addr_bank    .EQU  _cmd_1_addr >> 14
0039++ FCE9             _cmd_2_addr_bank    .EQU  _cmd_2_addr >> 14
0040++ FCE9             _cmd_3_addr_bank    .EQU  _cmd_1_addr_bank
0041++ FCE9             _cmd_4_addr_bank    .EQU  _cmd_1_addr_bank
0042++ FCE9             _cmd_5_addr_bank    .EQU  _cmd_2_addr_bank
0043++ FCE9             
0044++ FCE9             _cmd_1_logical_addr .EQU  _cmd_1_addr & _bank_mask
0045++ FCE9             _cmd_2_logical_addr .EQU  _cmd_2_addr & _bank_mask
0046++ FCE9             _cmd_3_logical_addr .EQU  _cmd_1_logical_addr
0047++ FCE9             _cmd_4_logical_addr .EQU  _cmd_1_logical_addr
0048++ FCE9             _cmd_5_logical_addr .EQU  _cmd_2_logical_addr
0049++ FCE9             
0050++ FCE9             _cmd_1_data         .EQU  0AAh
0051++ FCE9             _cmd_2_data         .EQU  055h
0052++ FCE9             _cmd_3_data_write   .EQU  0A0h
0053++ FCE9             _cmd_3_data_erase   .EQU  080h
0054++ FCE9             _cmd_4_data         .EQU  0AAh
0055++ FCE9             _cmd_5_data         .EQU  055h
0056++ FCE9             
0057++ FCE9             _cmd_6_data_erase   .EQU  030h
0058++ FCE9             
0059++ FCE9             ;
0060++ FCE9             ; Enter with A -> 7 bit index of 4K sector to be erased.
0061++ FCE9             ;
0062++ FCE9             ; Preserves BC, DE, HL
0063++ FCE9             ;
0064++ FCE9             ; Note this uses bank 0, and leaves it configured for the page containing the erased sector
0065++ FCE9             ;
0066++ FCE9             ; Typical time to erase sector ~18ms
0067++ FCE9             ;
0068++ FCE9 F3          flash_sector_erase  DI                          ; Disable interrupts
0069++ FCEA E5                              PUSH    HL
0070++ FCEB C5                              PUSH    BC
0071++ FCEC D5                              PUSH    DE
0072++ FCED             
0073++ FCED E6 7F                           AND     07fh
0074++ FCEF 57                              LD      D, A
0075++ FCF0 CB 3A                           SRL     D
0076++ FCF2 CB 3A                           SRL     D                   ; D is now the bank number
0077++ FCF4             
0078++ FCF4 CB 27                           SLA     A
0079++ FCF6 CB 27                           SLA     A
0080++ FCF8 CB 27                           SLA     A
0081++ FCFA CB 27                           SLA     A
0082++ FCFC E6 30                           AND     030h
0083++ FCFE 5F                              LD      E, A                ; E is the sector within the bank shifted into bits 13 & 12
0084++ FCFF             
0085++ FCFF 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0086++ FD01 3E 01                           LD      A, _cmd_1_addr_bank
0087++ FD03 ED 79                           OUT     (C), A
0088++ FD05 21 55 15                        LD      HL, _cmd_1_logical_addr
0089++ FD08 36 AA                           LD      (HL), _cmd_1_data
0090++ FD0A             
0091++ FD0A 3E 00                           LD      A, _cmd_2_addr_bank
0092++ FD0C ED 79                           OUT     (C), A
0093++ FD0E 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0094++ FD11 36 55                           LD      (HL), _cmd_2_data
0095++ FD13             
0096++ FD13 3E 01                           LD      A, _cmd_3_addr_bank
0097++ FD15 ED 79                           OUT     (C), A
0098++ FD17 21 55 15                        LD      HL, _cmd_3_logical_addr
0099++ FD1A 36 80                           LD      (HL), _cmd_3_data_erase
0100++ FD1C             
0101++ FD1C 3E 01                           LD      A, _cmd_4_addr_bank
0102++ FD1E ED 79                           OUT     (C), A
0103++ FD20 21 55 15                        LD      HL, _cmd_4_logical_addr
0104++ FD23 36 AA                           LD      (HL), _cmd_4_data
0105++ FD25             
0106++ FD25 3E 00                           LD      A, _cmd_5_addr_bank
0107++ FD27 ED 79                           OUT     (C), A
0108++ FD29 21 AA 2A                        LD      HL, _cmd_5_logical_addr
0109++ FD2C 36 55                           LD      (HL), _cmd_5_data
0110++ FD2E             
0111++ FD2E ED 51                           OUT     (C), D                  ; Switch to the bank containing our sector
0112++ FD30 63                              LD      H, E                    ; And write the sector bits as an address (bits 0-11 are ignored)
0113++ FD31 36 30                           LD      (HL), _cmd_6_data_erase
0114++ FD33             
0115++ FD33 7E          _wait_erase         LD      A,(HL)
0116++ FD34 CB 07                           RLC     A
0117++ FD36 30 FB                           JR      NC, _wait_erase
0118++ FD38             
0119++ FD38 D1                              POP     DE
0120++ FD39 C1                              POP     BC
0121++ FD3A E1                              POP     HL
0122++ FD3B FB                              EI
0123++ FD3C C9                              RET
0124++ FD3D             
0125++ FD3D             ;
0126++ FD3D             ; Enter with A -> Byte to write
0127++ FD3D             ;            D -> 7 bit index of 4K sector being written
0128++ FD3D             ;            HL -> 12 bit address of byte within sector
0129++ FD3D             ;
0130++ FD3D             ; Preserves D, HL
0131++ FD3D             ; Uses A, BC, E
0132++ FD3D             ;
0133++ FD3D             ; Typical time to erase byte ~14us
0134++ FD3D             ;
0135++ FD3D F3          flash_write_byte    DI
0136++ FD3E 5F                              LD      E, A                ; Preserve our byte
0137++ FD3F                                 
0138++ FD3F 7C                              LD      A, H                ; Make sure HL is within our sector
0139++ FD40 E6 0F                           AND     _sector_mask >> 8
0140++ FD42 67                              LD      H, A
0141++ FD43             
0142++ FD43 7A                              LD      A, D                ; Make sure D is a valid sector index
0143++ FD44 E6 7F                           AND     07fh
0144++ FD46 57                              LD      D, A
0145++ FD47 47                              LD      B, A
0146++ FD48             
0147++ FD48 7A                              LD      A, D                ; Get the bottom 2 bits of our sector index..
0148++ FD49 E6 03                           AND     03h
0149++ FD4B CB 27                           SLA     A
0150++ FD4D CB 27                           SLA     A
0151++ FD4F CB 27                           SLA     A
0152++ FD51 CB 27                           SLA     A
0153++ FD53 B4                              OR      H
0154++ FD54 67                              LD      H, A                ; ..and OR them into H to get a 14 bit address within our bank
0155++ FD55             
0156++ FD55 CB 3A                           SRL     D
0157++ FD57 CB 3A                           SRL     D                   ; D is now our bank number
0158++ FD59             
0159++ FD59 E5                              PUSH    HL
0160++ FD5A             
0161++ FD5A 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0162++ FD5C 3E 01                           LD      A, _cmd_1_addr_bank
0163++ FD5E ED 79                           OUT     (C), A
0164++ FD60 21 55 15                        LD      HL, _cmd_1_logical_addr
0165++ FD63 36 AA                           LD      (HL), _cmd_1_data
0166++ FD65             
0167++ FD65 3E 00                           LD      A, _cmd_2_addr_bank
0168++ FD67 ED 79                           OUT     (C), A
0169++ FD69 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0170++ FD6C 36 55                           LD      (HL), _cmd_2_data
0171++ FD6E             
0172++ FD6E 3E 01                           LD      A, _cmd_3_addr_bank
0173++ FD70 ED 79                           OUT     (C), A
0174++ FD72 21 55 15                        LD      HL, _cmd_3_logical_addr
0175++ FD75 36 A0                           LD      (HL), _cmd_3_data_write
0176++ FD77             
0177++ FD77 ED 51                           OUT     (C), D
0178++ FD79 E1                              POP     HL
0179++ FD7A 73                              LD      (HL), E
0180++ FD7B             
0181++ FD7B 7E          _wait_byte          LD      A, (HL)
0182++ FD7C AB                              XOR     E
0183++ FD7D CB 07                           RLC     A
0184++ FD7F 30 FA                           JR      NC, _wait_byte
0185++ FD81             
0186++ FD81 7C                              LD      A, H                ; Clear bits 13 & 12 to restore HL to sector address..
0187++ FD82 E6 0F                           AND     _sector_mask >> 8
0188++ FD84 67                              LD      H, A
0189++ FD85                            
0190++ FD85 50                              LD      D, B                ; And restore D
0191++ FD86 FB                              EI
0192++ FD87 C9                              RET
0193++ FD88             
0194++ FD88             ;
0195++ FD88             ; Write a flash data block. This uses Page 0 to write the data, so the source must be above 4000h
0196++ FD88             ;
0197++ FD88             ;       D -> 7 bit index of 4K sector being written
0198++ FD88             ;       HL -> Address of source data
0199++ FD88             ;       BC -> bytes to write
0200++ FD88             ;
0201++ FD88             ; Returns D pointing to last sector written
0202++ FD88             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
0203++ FD88             
0204++ FD88 DD E5       flash_write         PUSH    IX
0205++ FD8A E5                              PUSH    HL
0206++ FD8B DD E1                           POP     IX
0207++ FD8D 21 00 00                        LD      HL, 0           ; Address in sector..
0208++ FD90             
0209++ FD90             _erase_sector       ; Lower 12 bits of HL are zero, erase sector before writing bytes
0210++ FD90 7A                              LD      A, D
0211++ FD91 CD E9 FC                        CALL    flash_sector_erase
0212++ FD94 DD 7E 00    _write_loop         LD      A, (IX+0)
0213++ FD97 C5                              PUSH    BC
0214++ FD98 CD 3D FD                        CALL    flash_write_byte
0215++ FD9B C1                              POP     BC
0216++ FD9C             
0217++ FD9C DD 23                           INC     IX
0218++ FD9E 0B                              DEC     BC
0219++ FD9F 78                              LD      A, B
0220++ FDA0 B1                              OR      C
0221++ FDA1 28 0E                           JR      Z, _success
0222++ FDA3             
0223++ FDA3 23                              INC     HL
0224++ FDA4 7D                              LD      A, L
0225++ FDA5 A7                              AND     A
0226++ FDA6 20 EC                           JR      NZ, _write_loop
0227++ FDA8 7C                              LD      A, H
0228++ FDA9 E6 0F                           AND     _sector_mask >> 8
0229++ FDAB 67                              LD      H, A
0230++ FDAC 20 E6                           JR      NZ, _write_loop
0231++ FDAE             
0232++ FDAE 14                              INC     D
0233++ FDAF 18 DF                           JR      _erase_sector
0234++ FDB1             
0235++ FDB1 DD E1       _success            POP     IX
0236++ FDB3 C9                              RET
0237++ FDB4             
0238++ FDB4                                 .MODULE main1373+  FDB4             
1374+  FDB4             ;
1375+  FDB4             ;
1376+  FDB4             ; Page mapping - since the BIOS uses other pages to manage disk and screen, it must also manage the expected page for the user 
1377+  FDB4             ; programs, to prevent them from being unexpectedly changed (eg. after interrupts).
1378+  FDB4             ;
1379+  FDB4             
1380+  FDB4             ; Set the User page mapping. Sets page A (0-2) to the physical (RAM/ROM) page in E
1381+  FDB4             ; Returns with carry SET if successful. The given logical page will now point to the physical page in RAM or ROM
1382+  FDB4             ;
1383+  FDB4 FE 03       set_page_mapping    CP      3
1384+  FDB6 D0                              RET     NC
1385+  FDB7 4F                              LD      C, A
1386+  FDB8 06 00                           LD      B, 0
1387+  FDBA 21 39 FF                        LD      HL, page_0_mapping
1388+  FDBD 09                              ADD     HL, BC
1389+  FDBE 73                              LD      (HL), E 
1390+  FDBF             
1391+  FDBF C6 70                           ADD     A, IO_MEM_0             ; NOTE: Order is important here. Interrupts may occur after the page is stored (above)
1392+  FDC1 4F                              LD      C, A                    ; This may result in the page being prematurely mapped, but that's OK.
1393+  FDC2 ED 59                           OUT     (C), E                  ; If we tried to set the page before storing the new default we'd have to disable interrupts
1394+  FDC4 37                              SCF                             ; To avoid a race condition
1395+  FDC5 C9                              RET
1396+  FDC6             
1397+  FDC6 3E 16       get_version         LD      A, 016h
1398+  FDC8 C9                              RET
1399+  FDC9             
1400+  FDC9             JUMP_TABLE_SIZE     .EQU    11
1401+  FDC9             
1402+  FDC9~            .IF $ > (BIOS_TOP - (3*JUMP_TABLE_SIZE))
1403+  FDC9~                .ECHO "BIOS No room for Jump Table ("
1404+  FDC9~                .ECHO $
1405+  FDC9~                .ECHO " > "
1406+  FDC9~                .ECHO (BIOS_TOP-(3*JUMP_TABLE_SIZE))
1407+  FDC9~                .ECHO ") \n\n"
1408+  FDC9~                .STOP
1409+  FDC9             .ENDIF
1410+  FDC9             
1411+  FDC9             BIOS_SPARE          .EQU    BIOS_TOP - $ - (3*JUMP_TABLE_SIZE)
1412+  FDC9 00 00 00 00                     .FILL   BIOS_SPARE, 0
1412+  FDCD 00 00 00 00 
1412+  FDD1 00 00 00 00 
1412+  FDD5 00 00 00 00 
1412+  FDD9 00 00 00 
1413+  FDDC             
1414+  FDDC C3 C9 F3                        JP          m_print_inline      ; 11 (0FDDCh) - Print the characters following the call instruction
1415+  FDDF C3 B4 FD                        JP          set_page_mapping    ; 10 (0FDDFh) - Set the logical (cpu) page in A (0-2) to the physical (RAM/ROM) page in E
1416+  FDE2 C3 F5 F8                        JP          i2c_start           ; 9  (0FDE2h) - Sends I2C start sequence
1417+  FDE5 C3 04 F9                        JP          i2c_stop            ; 8  (0FDE5h) - Sends I2C stop sequence
1418+  FDE8 C3 50 F9                        JP          i2c_write           ; 7  (0FDE8h) - Write A as a byte to i2c bus. Carry SET if success. i2c_stop is not called.
1419+  FDEB C3 5D F9                        JP          i2c_read            ; 6  (0FDEBh) - Read byte from i2C into A, without ACK
1420+  FDEE C3 3C F9                        JP          i2c_write_to        ; 5  (0FDEEh) - Prepare to write to Device address H, Register L. Carry SET if success. i2c_stop is not called.
1421+  FDF1 C3 1B F9                        JP          i2c_read_from       ; 4  (0FDF1h) - Read a byte int A from Device address H, Register L. Carry SET if success. i2c_stop is not called.
1422+  FDF4 C3 53 F7                        JP          wait_for_key        ; 3  (0FDF4h) - Waits for until a key is pressed and released
1423+  FDF7 C3 E8 F6                        JP          play_note           ; 2  (0FDF7h) - Plays the note defined by DE (octave, note) and C (duration, tenths)
1424+  FDFA C3 C6 FD                        JP          get_version         ; 1  (0FDFAh) - Returns the Bios version in A
1425+  FDFD             
1426+  FDFD             
1427+  FDFD~            .IF $ > BIOS_TOP
1428+  FDFD~                .ECHO "End of BIOS is too high ("
1429+  FDFD~                .ECHO $
1430+  FDFD~                .ECHO " > "
1431+  FDFD~                .ECHO BIOS_TOP
1432+  FDFD~                .ECHO ") \n\n"
1433+  FDFD~                .STOP
1434+  FDFD             .ENDIF
1435+  FDFD             
1436+  FDFD             .ECHO "Bios Size is "
1437+  FDFD             .ECHO BIOS_TOP-BIOS_START-BIOS_SPARE
1438+  FDFD             .ECHO ". Limit is "
1439+  FDFD             .ECHO BIOS_TOP-BIOS_START
1440+  FDFD             .ECHO ". Spare "
1441+  FDFD             .ECHO BIOS_SPARE
1442+  FDFD             .ECHO "\n\n"
1443+  FDFD             
1444+  FDFD                                 .INCLUDE shared_data.asm
0001++ FDFD             ;
0002++ FDFD             ; Shared data - common state data for routines
0003++ FDFD             ;
0004++ FDFD             ; [] show default/initial values stored at the location
0005++ FDFD             ;
0006++ FDFD             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007++ FDFD             ;
0008++ FDFD             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009++ FDFD             ;
0010++ FDFD             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011++ FDFD             ; of this software and associated documentation files (the "Software"), to deal
0012++ FDFD             ; in the Software without restriction, including without limitation the rights
0013++ FDFD             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014++ FDFD             ; copies of the Software, and to permit persons to whom the Software is
0015++ FDFD             ; furnished to do so, subject to the following conditions:
0016++ FDFD             ; 
0017++ FDFD             ; The above copyright notice and this permission notice shall be included in all
0018++ FDFD             ; copies or substantial portions of the Software.
0019++ FDFD             ; 
0020++ FDFD             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021++ FDFD             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022++ FDFD             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023++ FDFD             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024++ FDFD             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025++ FDFD             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026++ FDFD             ; SOFTWARE.
0027++ FDFD             ;
0028++ FDFD             
0029++ FF00                                 .ORG    0FF00h
0030++ FF00             
0031++ FF00             ; I2C/Port B routines
0032++ FF00             port_b_mode         .BLOCK  1
0033++ FF01             port_b_dir          .BLOCK  1
0034++ FF02             port_b_data         .BLOCK  1
0035++ FF03             
0036++ FF03             ; Display functions
0037++ FF03             display_address     .BLOCK  1              ; byte - I/O address of the display driver (right or left) being written to
0038++ FF04             
0039++ FF04             ;
0040++ FF04             ; Stuff
0041++ FF04             timer               .BLOCK  4              ; 2 Words - counts up by 1 every 64th of a second. Rollover ~2 years.
0042++ FF08                                     
0043++ FF08             ; General I/O
0044++ FF08             ;
0045++ FF08             ; This MUST start with keyboard_state, and will all be reset to zero when io_init is called
0046++ FF08             ;
0047++ FF08             _key_state_size     .EQU    8               ; 8 key rollover
0048++ FF08             
0049++ FF08             keyboard_state      .BLOCK  _key_state_size ; state buffer - 8 bytes containing raw key codes for keys currently pressed
0050++ FF10             keyboard_pos        .BLOCK  2               ; Internal state
0051++ FF12             key_shift_state     .BLOCK  1               ; Holds state of shift and control keys in bits 0 and 1 respectively
0052++ FF13             control_key_pressed .BLOCK  1               ; If special control keys are pressed, they are stored here..
0053++ FF14             last_keycode        .BLOCK  1               ; The last keycode that was pressed, for repeats..
0054++ FF15             key_repeat_time     .BLOCK  1               ; How many poll events since the key state last changed
0055++ FF16             
0056++ FF16             _input_buffer_size  .EQU    16
0057++ FF16             input_buffer        .BLOCK _input_buffer_size          ; 16 byte input buffer. Note wraparound is handled by bitmasks, so don't change this length
0058++ FF26             input_pos           .BLOCK  1               ; Next read position in input buffer
0059++ FF27             input_free          .BLOCK  1               ; Next write position in input buffer
0060++ FF28             input_size          .BLOCK  1               ; Bytes occupied in the input buffer
0061++ FF29             
0062++ FF29             io_data_end         .EQU  input_size        ; Byte after IO data block, used to reset values to zero
0063++ FF29             
0064++ FF29             ;------------------------------- Console output and screen data ------------------------------------------------
0065++ FF29             screen_page         .BLOCK  1               ; [30?]  1 Byte, screen buffer page address
0066++ FF2A             screen_offset       .BLOCK  1               ; [0]    1 Byte, row offset (0-63) of virtual screen in screen buffer (high byte of screen address).
0067++ FF2B             
0068++ FF2B             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0069++ FF2B             display_row         .BLOCK  1               ; [0]    1 Byte, current row being shown by the LED display
0070++ FF2C             display_col         .BLOCK  1               ; [0]    1 Byte, current column being shown by the LED display - Note, 0 based
0071++ FF2D             
0072++ FF2D             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0073++ FF2D             cursor_row          .BLOCK  1               ; [1]    1 Byte, cursor row on virtual console. Top of page is row 1.   
0074++ FF2E             cursor_col          .BLOCK  1               ; [1]    1 Byte, cursor column on virtual console. Left of page is column 1.
0075++ FF2F             
0076++ FF2F             console_height      .BLOCK  1               ; [24]   1 Byte, virtual console height (rows)
0077++ FF30             console_width       .BLOCK  1               ; [40]   1 byte, virtual console width (columns)
0078++ FF31             
0079++ FF31             console_colour      .BLOCK  1               ; [0x0F] 1 Byte, current colour. Top 4 bits [7:4] are background, bottom 4 [3:0] are foreground
0080++ FF32             console_flags       .BLOCK  1               ;        1 Byte, bit flags for console
0081++ FF33             
0082++ FF33             console_timer       .BLOCK  1               ;        1 Byte, used to blink cursor, clear movement indicator etc.
0083++ FF34             console_escape      .BLOCK  1               ;        1 Byte, escape value (0 if not received yet)
0084++ FF35             console_param1      .BLOCK  1               ;        1 Byte, first character after escape (0 if not recieved yet)
0085++ FF36             
0086++ FF36             console_identify    .BLOCK  1               ; [0]    1 Byte, indicates console identifier sequence to be returned..
0087++ FF37             
0088++ FF37             CFLAGS_SHOW_CURSOR  .EQU    1               ; Awaiting input - show (blink) the cursor
0089++ FF37             CFLAGS_TRACK_CURSOR .EQU    2               ; LED display is tracking cursor position
0090++ FF37             CFLAGS_SHOW_MOVED   .EQU    4               ; Show display as being moved by user
0091++ FF37             CFLAGS_ESCAPE       .EQU    8               ; Escape sequence started
0092++ FF37             CFLAGS_CURSOR_ON    .EQU    16              ; Cursor is currently displayed
0093++ FF37             
0094++ FF37             SHOW_MOVE_DELAY     .EQU    60              ; How long to show the display has been moved
0095++ FF37             
0096++ FF37             ;------------------------------- BIOS customisation  ------------------------------------------------
0097++ FF37             
0098++ FF37             drive_a_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive A image
0099++ FF38             drive_b_mem_page    .BLOCK  1               ; First page in RAM/ROM for the Drive B image
0100++ FF39             
0101++ FF39             page_0_mapping      .BLOCK  1               ; Stores the user mapping for these pages, so they can be correctly restored after interrupts
0102++ FF3A             page_1_mapping      .BLOCK  1
0103++ FF3B             page_2_mapping      .BLOCK  1
0104++ FF3C             
0105++ FF3C             ;------------------------------- BDOS variables ------------------------------------------------
0106++ FF3C             ; *** TRACK AND SECTOR MUST BE IN THIS ORDER - READ BY _get_memdisc_addr ***
0107++ FF3C             sys_track           .BLOCK  1               ; 1 Byte, Current disk track 
0108++ FF3D             sys_sector          .BLOCK  2               ; Word, current disk sector
0109++ FF3F             sys_dmaaddr         .BLOCK  2               ; Word, DMA address - Disc will read data to this address, or write from this address
0110++ FF41             sys_disk_dph        .BLOCK  2               ; Word, points to current disk parameter header (DPH) 
0111++ FF43             sys_seldsk          .BLOCK  1               ; Byte, current selected disk drive (A=0, B=1..)
0112++ FF44             
0113++ FF44             sys_alv0            .BLOCK  32              ; 32 bytes, allocation vector 0 (max 255 blocks)
0114++ FF64             sys_alv1            .BLOCK  32              ; 32 bytes, allocation vector 1 (max 255 blocks)
0115++ FF84             
0116++ FF84             display_buffer      .BLOCK  24*2            ; 48 byte scratch area used for composing display output (eg. rtc time display etc.)
0117++ FFB4             
0118++ FFB4             intr_stackarea      .BLOCK  32              ; Interrupt handler stack
0119++ FFD4             intr_stack          .BLOCK  2
0120++ FFD6             
0121++ FFD6             ; Panic codes
0122++ FFD6             ;
0123++ FFD6             PANIC_0001          .EQU    0F001h
0124++ FFD6             PANIC_0002          .EQU    0F002h
0125++ FFD6             PANIC_0003          .EQU    0F003h
0126++ FFD6             PANIC_0004          .EQU    0F004h
0127++ FFD6             
1445+  FFD6                                 .END1136   FFD6                                 .END
tasm: Number of errors = 0
